<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="kotlin in Action-Kotlin实战, TheCara">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>kotlin in Action-Kotlin实战 | TheCara</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">TheCara</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">TheCara</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/TheCara" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/TheCara" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200831160049.png')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">kotlin in Action-Kotlin实战</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Android/">
                                <span class="chip bg-color">Android</span>
                            </a>
                        
                            <a href="/tags/Kotlin/">
                                <span class="chip bg-color">Kotlin</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Kotlin/" class="post-category">
                                Kotlin
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-07-26
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="2-Kotlin-基础"><a href="#2-Kotlin-基础" class="headerlink" title="2 Kotlin 基础"></a>2 Kotlin 基础</h1><h3 id="2-1-基本要素-函数变量"><a href="#2-1-基本要素-函数变量" class="headerlink" title="2.1 基本要素: 函数变量"></a>2.1 基本要素: 函数变量</h3><h4 id="2-1-3-变量"><a href="#2-1-3-变量" class="headerlink" title="2.1.3 变量"></a>2.1.3 变量</h4><p><strong>可变变量和不可变变量</strong></p>
<ul>
<li>val–不可变引用。使用val声明的变量不能在初始化之后再次赋值。它对应的是java中的final变量</li>
<li>var–可变引用。这种变量的值可以被改变。这种声明对应的是普通(非final)变量</li>
</ul>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595899792330.png" alt=""></p>
<p>👆在定义了val变量的代码块期间,<strong>val变量只能进行唯一一次初始化</strong>。但是,如果编译器能确保只有唯一一次初始化语句会被执行,可以根据条件使用不同的值来初始化它。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595899976491.png" alt=""></p>
<p>自身不可变(只可以执行一次,初始化一次)</p>
<p>注意,尽管val引用自身是不可变的,但是它指向的对象<strong>`可能</strong>`是可变的。列如</p>
<pre><code>val languages = arrayListOf(&quot;Java&quot;)
lenguages.add(&quot;Kotlin&quot;)</code></pre><h3 id="2-3-表示和处理选择：枚举和“when”"><a href="#2-3-表示和处理选择：枚举和“when”" class="headerlink" title="2.3 表示和处理选择：枚举和“when”"></a>2.3 表示和处理选择：枚举和“when”</h3><h4 id="2-3-1-声明枚举类"><a href="#2-3-1-声明枚举类" class="headerlink" title="2.3.1 声明枚举类"></a>2.3.1 声明枚举类</h4><p><strong>什么是枚举</strong></p>
<p>为了让编译器能够自动检查某个值在枚举的集合中，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用 <strong>enum</strong> 来定义枚举类。</p>
<pre><code class="kotlin">enum class Color{
    RED,ORANGE,YELLOW,GREEN,BLUE,INDIGO,VIOLET
}</code></pre>
<p>kotlin 中 enum 是一个所谓的软关键词：只有当它出现在class前面时才会有特殊的意义，在其他地方可以把它当作普通的名称使用。</p>
<h4 id="2-3-5-智能转换：合并类型检查和转换"><a href="#2-3-5-智能转换：合并类型检查和转换" class="headerlink" title="2.3.5 智能转换：合并类型检查和转换"></a>2.3.5 智能转换：合并类型检查和转换</h4><h5 id="kotlin智能转换的案例"><a href="#kotlin智能转换的案例" class="headerlink" title="kotlin智能转换的案例"></a>kotlin智能转换的案例</h5><h6 id="表达式类型层次"><a href="#表达式类型层次" class="headerlink" title="表达式类型层次"></a>表达式类型层次</h6><pre><code class="kotlin">interface Expr
class Num(val value: Int) : Expr    // 简单的值对象类，只有一个属性value，实现了Expr接口
class Sum(val left: Expr, val right: Expr) : Expr   // Sum运算的实参可以是任何Expr:Num 或者 Sum</code></pre>
<h6 id="对表达式求值"><a href="#对表达式求值" class="headerlink" title="对表达式求值"></a>对表达式求值</h6><pre><code class="kotlin">fun eval(e: Expr): Int {
    if (e is Num) {
//        val n = e.value as Num //显示的转换为Num类型多余的
        return e.value
    }
    if (e is Sum) {
        return eval(e.left) + eval(e.right) // 变量 e 被智能的转换了类型
    }
    throw IllegalArgumentException(&quot;test&quot;)
}</code></pre>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200831171911.png" alt=""></p>
<p>结果</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200831171248.png" alt=""></p>
<h5 id="“is”-修饰符"><a href="#“is”-修饰符" class="headerlink" title="“is” 修饰符"></a>“is” 修饰符</h5><p>在 kotlin 中，你要使用 is 检查来判断一个变量是否是某个类型。</p>
<h5 id="什么时候进行智能转换？"><a href="#什么时候进行智能转换？" class="headerlink" title="什么时候进行智能转换？"></a>什么时候进行智能转换？</h5><p>如果你检查过一个变量是某种类型，后面就不再需要转换它了，可以就把它当作你检查过的类型使用。事实上编译器为你执行了类型转换，我们把这种行为称为 <strong>智能转换。</strong></p>
<h1 id="3-函数的订阅和调用"><a href="#3-函数的订阅和调用" class="headerlink" title="3 函数的订阅和调用"></a>3 函数的订阅和调用</h1><h2 id="3-3-给别人的类添加方法：扩展函数和属性"><a href="#3-3-给别人的类添加方法：扩展函数和属性" class="headerlink" title="3.3 给别人的类添加方法：扩展函数和属性"></a>3.3 给别人的类添加方法：扩展函数和属性</h2><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><blockquote>
<p>扩展函数非常简单，作为一个类的成员函数，不过它定义在类的外边。</p>
</blockquote>
<h1 id="4-类、对象和接口"><a href="#4-类、对象和接口" class="headerlink" title="4 类、对象和接口"></a>4 类、对象和接口</h1><h3 id="4-1-定义类继承结构"><a href="#4-1-定义类继承结构" class="headerlink" title="4.1 定义类继承结构"></a>4.1 定义类继承结构</h3><h4 id="4-1-1-Kotlin-中的接口"><a href="#4-1-1-Kotlin-中的接口" class="headerlink" title="4.1.1 Kotlin 中的接口"></a>4.1.1 Kotlin 中的接口</h4><h5 id="声明接口"><a href="#声明接口" class="headerlink" title="声明接口"></a>声明接口</h5><pre><code class="kotlin">interface Clickable{
    fun click()
}</code></pre>
<h5 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h5><pre><code>class Button : Clickble {
    override fun click() {
        println(&quot;I was clicked&quot;)
    }
}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200826205307.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200826205356.png" alt=""></p>
<h5 id="Kotlin实现接口与-Java-有那些不同"><a href="#Kotlin实现接口与-Java-有那些不同" class="headerlink" title="Kotlin实现接口与 Java 有那些不同"></a>Kotlin实现接口与 Java 有那些不同</h5><p>Kotlin 在类后面使用冒号来代替 <strong>Java</strong> 中的 extends 和 implements 关键词。 和 Java 一样，<strong>一个类可以实现任意多个接口</strong>，但<strong>只能继承一个类型</strong>。</p>
<h5 id="override-修饰符的作用"><a href="#override-修饰符的作用" class="headerlink" title="override 修饰符的作用"></a>override 修饰符的作用</h5><ul>
<li>相同</li>
</ul>
<p>与 Java 中的 @Override 注解类似，<strong>override 修饰符用来标注被重写的父类或者接口的方法和属性</strong>。</p>
<ul>
<li>不同</li>
</ul>
<p>在 Kotlin 中使用 override 修饰符是强制要求的。<strong>这会避免先写出实现方法再添加抽象方法造成的意外重写：</strong>你的代码将不能编译，除非你显式地将这个方法标注为 Override 或者重命名它。</p>
<h5 id="如何给接口添加一个默认实现的方法"><a href="#如何给接口添加一个默认实现的方法" class="headerlink" title="如何给接口添加一个默认实现的方法"></a>如何给接口添加一个默认实现的方法</h5><p>接口的方法可以有一个默认实现的方法。</p>
<pre><code class="kotlin">interface Clickable{
    fun click() // 普通的方法声明
    fun showOff() = println(&quot;I&#39;m clickable!&quot;) // 带默认实现的方法
}</code></pre>
<h5 id="实现一个带有默认实现的方法的接口要注意什么"><a href="#实现一个带有默认实现的方法的接口要注意什么" class="headerlink" title="实现一个带有默认实现的方法的接口要注意什么"></a>实现一个带有默认实现的方法的接口要注意什么</h5><p>如果你实现了这个接口，你需要为 click 提供一个实现。可以重新定义 showOff() 方法的行为，或者如果你对默认行为感到满意也可以直接省略它。（默认实现的方法也可以被重写）</p>
<h5 id="定义实现了同样方法的接口"><a href="#定义实现了同样方法的接口" class="headerlink" title="定义实现了同样方法的接口"></a>定义实现了同样方法的接口</h5><pre><code class="kotlin">interface Focusable {
    fun setFocus(b: Boolean) = println(&quot;I ${if (b) &quot;got&quot; else &quot;lost&quot;} focus.&quot;)
    fun showOff() = println(&quot;I&#39;m focusable!&quot;)
}</code></pre>
<h5 id="在类中实现两个有相同默认实现方法的接口会发生什么"><a href="#在类中实现两个有相同默认实现方法的接口会发生什么" class="headerlink" title="在类中实现两个有相同默认实现方法的接口会发生什么"></a>在类中实现两个有相同默认实现方法的接口会发生什么</h5><p>在这两个接口中都带有默认实现的 showOff() 方法：在没有显示的实现 showOff() ,会得到编译错误信息。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827000446.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827000526.png" alt=""></p>
<h6 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h6><p>必须显式的实现相同方法。</p>
<h5 id="调用继承-接口-的默认实现方法"><a href="#调用继承-接口-的默认实现方法" class="headerlink" title="调用继承(接口)的默认实现方法"></a>调用继承(接口)的默认实现方法</h5><pre><code class="kotlin">class Button : Clickable, Focusable {
    override fun click() {
        TODO(&quot;Not yet implemented&quot;)
    }

    //如果同样的继承成员不止一个实现，必须提供一个显示的实现。
    override fun showOff() {
        // 使用尖括号加上父类名字的“super”表明了你想要调用哪一个父类的方法
        super&lt;Clickable&gt;.showOff()
        super&lt;Focusable&gt;.showOff()
    }

}</code></pre>
<p>通过调用继承的两个父类型中的实现来实现 showOff() 。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827005257.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827005432.png" alt=""></p>
<h4 id="4-1-2-open、final-和-abstract-修饰符：默认为-final"><a href="#4-1-2-open、final-和-abstract-修饰符：默认为-final" class="headerlink" title="4.1.2 open、final 和 abstract 修饰符：默认为 final"></a>4.1.2 open、final 和 abstract 修饰符：默认为 final</h4><h5 id="kotlin-中如何继承一个类"><a href="#kotlin-中如何继承一个类" class="headerlink" title="kotlin 中如何继承一个类"></a>kotlin 中如何继承一个类</h5><p>如果你想要创建一个类的子类，需要使用 open 修饰符来标示这个类。此外<strong>需要给每个可以被重写的属性或者方法添加 open 属性</strong>。</p>
<h5 id="声明一个带open-方法的-open-类"><a href="#声明一个带open-方法的-open-类" class="headerlink" title="声明一个带open 方法的 open 类"></a>声明一个带open 方法的 open 类</h5><pre><code class="kotlin">open class RichButton : Clickable {
    fun disable() {}    // 这个函数是 final 的： 不能在子类中重写它。
    open fun animate() {} // 这个函数是 open 的： 可以在子类中重写它

    // 这个函数重写了 open 函数并且它本身同样是 open 的
    override fun click() {
        TODO(&quot;Not yet implemented&quot;)
    }

}</code></pre>
<h5 id="默认-final-的好处"><a href="#默认-final-的好处" class="headerlink" title="默认 final 的好处"></a>默认 final 的好处</h5><p>类默认 final 带来了一个重要的好处就是这使得在大量的场景中的只能转换成为可能。</p>
<h5 id="智能转换的前提"><a href="#智能转换的前提" class="headerlink" title="智能转换的前提"></a>智能转换的前提</h5><p><strong>智能转换只能在进行类型检查后没有改变过的变量上起的作用。</strong>对于一个类来说，这意味着<strong>智能转换在val类型并且没有自定义访问器的类属性上使用</strong>。 这个前提意味着属性必须是 final 的，否则如果一个子类可以重写属性并且定义一个自定义的访问器将会打破智能转换的关键前提。</p>
<h5 id="抽象类的默认修饰符"><a href="#抽象类的默认修饰符" class="headerlink" title="抽象类的默认修饰符"></a>抽象类的默认修饰符</h5><p>抽象成员始终是open的，所以不需要显式地使用open修饰符。</p>
<h5 id="声明一个抽象类"><a href="#声明一个抽象类" class="headerlink" title="声明一个抽象类"></a>声明一个抽象类</h5><pre><code class="kotlin">abstract class Animated {
    abstract fun animate()  // 这个函数是抽象的：它没有实现必须被子类重写

    // 抽象类中的非抽象函数 并不是默认 open 的，但是可以标注为 open的
    open fun stopAnimating() {

    }

    fun animateTwice() {}
}</code></pre>
<h4 id="4-1-4-内部类和嵌套类：默认嵌套类"><a href="#4-1-4-内部类和嵌套类：默认嵌套类" class="headerlink" title="4.1.4 内部类和嵌套类：默认嵌套类"></a>4.1.4 内部类和嵌套类：默认嵌套类</h4><p>内部类：非静态嵌套类，也被成为内部类。</p>
<p>嵌套类：静态嵌套类，嵌套类多称为：静态嵌套类。</p>
<h5 id="Kotlin中嵌套类和Java中的不同"><a href="#Kotlin中嵌套类和Java中的不同" class="headerlink" title="Kotlin中嵌套类和Java中的不同"></a>Kotlin中嵌套类和Java中的不同</h5><p>在Kotlin中的嵌套类不能访问外部类的实例，除非你特别的做出要求。 </p>
<h5 id="在序列化时使用内部类"><a href="#在序列化时使用内部类" class="headerlink" title="在序列化时使用内部类"></a>在序列化时使用内部类</h5><p>在你定义一个 View 元素，它的状态时可序列化的。<strong>想要序列化一个视图可能并不容易，但是可以把所有需要的数据复制到另一个辅助类中去。</strong></p>
<pre><code class="kotlin">interface State : Serializable
interface View {
    fun getCurrentState(): State
    fun restoreState(state: State) {}
}</code></pre>
<p>声明State接口去实现Serializable。View接口声明了可以用来保存视图状态的getCurrentState和restoreState方法。</p>
<h5 id="用内部类的java代码来实现View"><a href="#用内部类的java代码来实现View" class="headerlink" title="用内部类的java代码来实现View"></a>用内部类的java代码来实现View</h5><pre><code class="java">public class Button implements View{
    @Override
    public State getCurrentState(){
        return new ButtonState();
    }
    @Override
    public voiew restoreState(State state){
        /**/
    }
    public class ButtonState implements State{
        /**/
    }
}</code></pre>
<p>问题：在运行时你会得到 java.io.NotSerializable.Exception:Button 异常，在你序列化声明的按钮状态时。这个可能看起来会很奇怪：你序列化的变量是ButtonState类型，为什么会有Button异常呢？</p>
<h5 id="无法序列化的原因"><a href="#无法序列化的原因" class="headerlink" title="无法序列化的原因"></a>无法序列化的原因</h5><p>在java中，当你在另一个类中声明一个类时，它会默认变成内部类。案例中：ButtonState类隐示的存储了它的外部Button类的应用。从而解释了为什么ButtonState不能被序列化。</p>
<h5 id="修复无法序列化"><a href="#修复无法序列化" class="headerlink" title="修复无法序列化"></a>修复无法序列化</h5><p><strong>需要声明ButtonState类是static的</strong>。将嵌套类声明为static会冲这个类中删除包围它的类的隐式引用。</p>
<h5 id="在kotlin中使用嵌套类来实现-View"><a href="#在kotlin中使用嵌套类来实现-View" class="headerlink" title="在kotlin中使用嵌套类来实现 View"></a>在kotlin中使用嵌套类来实现 View</h5><pre><code class="kotlin">class Button : View {
    override fun getCurrentState(): State {
        TODO(&quot;Not yet implemented&quot;)
    }

    override fun restoreState(state: State) {
        TODO(&quot;Not yet implemented&quot;)
    }

    // 这个类与Java中的静态潜逃类类似
    class ButtonState : State {

    }

}</code></pre>
<p><strong>kotlin中默认行为是嵌套类。</strong></p>
<h5 id="如何让默认嵌套类的类型变为内部类！"><a href="#如何让默认嵌套类的类型变为内部类！" class="headerlink" title="如何让默认嵌套类的类型变为内部类！"></a>如何让默认嵌套类的类型变为内部类！</h5><p>要把它（嵌套类）变成为一个内部类来持有一个外部类的引用的话需要使用 <strong>inner</strong> 修饰符。</p>
<h5 id="kotlin中内部类访问外部类"><a href="#kotlin中内部类访问外部类" class="headerlink" title="kotlin中内部类访问外部类"></a>kotlin中内部类访问外部类</h5><p>在kotlin中引用外部类实例的语法与java不同。需要使用this@Outer从Inner类去访问Outer类。</p>
<h4 id="4-1-5-密封类：定义受限的类继承结构"><a href="#4-1-5-密封类：定义受限的类继承结构" class="headerlink" title="4.1.5 密封类：定义受限的类继承结构"></a>4.1.5 密封类：定义受限的类继承结构</h4><h5 id="什么是密封类”sealed“"><a href="#什么是密封类”sealed“" class="headerlink" title="什么是密封类”sealed“"></a>什么是密封类”sealed“</h5><p>sealed 类。为父类添加了一个新的 sealed 修饰符，可对创建的子类做出严格的限制。<strong>所有的子类必须嵌套在父类中。</strong></p>
<h5 id="为什么要使用密封类（定义受限的类继承结构）"><a href="#为什么要使用密封类（定义受限的类继承结构）" class="headerlink" title="为什么要使用密封类（定义受限的类继承结构）"></a>为什么要使用密封类（定义受限的类继承结构）</h5><p><strong>作为接口实现的表达式 👇</strong></p>
<pre><code class="kotlin">interface Expr
class Num(val value: Int) : Expr
class Sum(val left: Expr, val right: Expr):Expr

fun eval(e: Expr): Int =
    when (e) {
        is Num -&gt; e.value
        is Sum -&gt; eval(e.left) + eval(e.right)
        else -&gt; // 必须检查 else 分支
            throw  IllegalArgumentException(&quot;Unknown expression!&quot;)
    }
</code></pre>
<p><strong>当使用 when 结构来执行表达式的时候，Kotlin 编译器会强制检查默认选项</strong>。在这个例子中，<strong>不能返回一个有意义的值，所以直接返回异常状态。</strong></p>
<p>更重要的是，如果你添加了一个新的子类，编译器并不能发现你修改了。<strong>如果你忘记添加一个新的分支，就会选择默认选项，这又可能导致潜在的 bug。</strong></p>
<h5 id="如何使用密封类-“sealed”"><a href="#如何使用密封类-“sealed”" class="headerlink" title="如何使用密封类 “sealed”"></a>如何使用密封类 “sealed”</h5><pre><code class="kotlin">sealed class Expr { //将基类标记为封闭的
    class Num(val value: Int) : Expr()
    class Sum(val left: Expr, val right: Expr) : Expr() // 将所有可能的类作为嵌套类列出
}

fun eval(expr: Expr): Int =
    // “when”表达式覆盖了所有的可能情况，所以不再需要 else 分支
    when (expr) {
        is Expr.Num -&gt; expr.value
        is Expr.Sum -&gt; eval(expr.left) + eval(expr.right)
    }</code></pre>
<p><strong>如果你在 when 表达式中处理了所有的 sealed 类的子类，你就不再需要提供默认分支。</strong>注意，sealed 修饰符隐含的这个类是一个 open 类，你不再需要显式地添加 open 修饰符。</p>
<h3 id="4-2-声明一个带默认构造方法或属性的类"><a href="#4-2-声明一个带默认构造方法或属性的类" class="headerlink" title="4.2 声明一个带默认构造方法或属性的类"></a>4.2 声明一个带默认构造方法或属性的类</h3><p><strong>kotlin中构造方法和java中有那些不同</strong></p>
<p>与java中一个类可以声明一个或多个构造方法。kotlin也是类似的，只是做出了一些修改：区分了主构造方法（通常是主要而简洁的初始化类的方法，并且在类体外部声明）和从构造方法。</p>
<h4 id="4-2-1-初始化类：主构造方法和初始化代码块"><a href="#4-2-1-初始化类：主构造方法和初始化代码块" class="headerlink" title="4.2.1 初始化类：主构造方法和初始化代码块"></a>4.2.1 初始化类：主构造方法和初始化代码块</h4><h5 id="什么是主构造方法。"><a href="#什么是主构造方法。" class="headerlink" title="什么是主构造方法。"></a>什么是主构造方法。</h5><pre><code class="kotlin">class User(val nickname:String)</code></pre>
<p>这段被括号围起来的代码块就叫<strong>做主构造方法</strong>。它有两个目的：表明构造方法的<strong>参数</strong>，以及定义使用这个<strong>参数</strong>的属性。</p>
<h5 id="明确的主构造方法声明"><a href="#明确的主构造方法声明" class="headerlink" title="明确的主构造方法声明"></a>明确的主构造方法声明</h5><pre><code class="kotlin">class User constructor(_nickname: String) {   // 带一个参数的主构造方法
    val nickname: String

    init {  // 初始化代码块
        nickname = _nickname
    }
}</code></pre>
<p>现在来看看完成同样功能的代码具体是什么样子。</p>
<blockquote>
<p>两个关键词 <strong>construtor</strong> 和 <strong>init</strong>。 constructor 关键词用来开始一个<strong>构造方法</strong>或者<strong>从构造方法</strong>的声明。init 关键词用来引入初始化代码块。这种代码块包含了类在创建时执行的代码，并且会和主构造方法一起使用。<strong>因为主构造方法有语法限制，不能包含初始化代码，这就是需要初始化代码块（init）的原因。</strong>同时可以创建多个初始化代码块。</p>
</blockquote>
<h5 id="用参数来初始化属性"><a href="#用参数来初始化属性" class="headerlink" title="用参数来初始化属性"></a>用参数来初始化属性</h5><pre><code class="kotlin">class User(_nickname: String) { // 带一个参数的构造方法
    val nickname: String = _nickname    // 用参数来初始化属性

}</code></pre>
<blockquote>
<p>在例子中，不需要把初始化代码放在初始化代码块中，因为它可以与nickname属性声明结合。如果主构造方法没有注解或可见性修饰符，同样可以去除 constructor 关键词。</p>
</blockquote>
<h5 id="用最简洁的方法再次初始化类"><a href="#用最简洁的方法再次初始化类" class="headerlink" title="用最简洁的方法再次初始化类"></a>用最简洁的方法再次初始化类</h5><pre><code class="kotlin">class User(val nickname:String)    // “val” 意味相对应的属性会用构造方法的参数来初始化。</code></pre>
<p>前几个案例用 val 关键词声明了属性。如果属性用相对应的构造方法参数来初始化，<strong>代码可以通过把 val 关键词加载参数前的方法来简化它</strong>。可以用来代替类中的属性定义了。</p>
<h5 id="为构造方法提供默认值"><a href="#为构造方法提供默认值" class="headerlink" title="为构造方法提供默认值"></a>为构造方法提供默认值</h5><pre><code class="kotlin">class User(val nickname: String, val isSubscribed: Boolean = true) // 为构造方法提供一个默认值    </code></pre>
<p>可以像函数参数一样为构造方法声明默认值。</p>
<h5 id="如何让一个类不被其他代码实例化"><a href="#如何让一个类不被其他代码实例化" class="headerlink" title="如何让一个类不被其他代码实例化"></a>如何让一个类不被其他代码实例化</h5><p>如果想要你的类不被其他代码实例化，必须把构造方法标记为 private。</p>
<pre><code class="kotlin">class Secretive private constructor()   // 这个类有 private 构造方法</code></pre>
<h4 id="4-2-2-构造方法：用不同的方法来初始化方法"><a href="#4-2-2-构造方法：用不同的方法来初始化方法" class="headerlink" title="4.2.2 构造方法：用不同的方法来初始化方法"></a>4.2.2 构造方法：用不同的方法来初始化方法</h4><h5 id="为什么要使用多种方法初始化父类"><a href="#为什么要使用多种方法初始化父类" class="headerlink" title="为什么要使用多种方法初始化父类"></a><strong>为什么要使用多种方法初始化父类</strong></h5><p>最常见的一种就是当你需要扩展一个框架类来提供多个构造方法，以便于通过不同的方法来初始化类的时候。</p>
<h5 id="父类使用从构造方法"><a href="#父类使用从构造方法" class="headerlink" title="父类使用从构造方法"></a><strong>父类使用从构造方法</strong></h5><pre><code class="kotlin">open class View {
    constructor(ctx: Context) { // 从构造方法
        //some code
    }

    constructor(ctx: Context, attr: AttributeSet) { // 从构造方法
        //some code
    }
}</code></pre>
<h5 id="扩展父类"><a href="#扩展父类" class="headerlink" title="扩展父类"></a>扩展父类</h5><pre><code class="kotlin">class MyButton : View {
    constructor(ctx: Context) : super(ctx) {
        // 调用父类构造方法
    }

    constructor(ctx: Context, attr: AttributeSet) : super(ctx, attr) {

    }
}</code></pre>
<h5 id="调用父类的另一个构造方法"><a href="#调用父类的另一个构造方法" class="headerlink" title="调用父类的另一个构造方法"></a>调用父类的另一个构造方法</h5><pre><code class="kotlin">class MyButton : View {
    constructor(ctx: Context) : this(ctx, My_SYTLE) {
        // 委托给这个类的另一个构造方法
    }

    constructor(ctx: Context, attr: AttributeSet) : super(ctx, attr) {

    }
}</code></pre>
<p>从<strong>构造方法</strong>中调用你自己类的另一个<strong>构造方法</strong>。</p>
<p>可以修改 MyButton类 <strong>使得一个构造方法委托给同一个类的另一个构造方法</strong>，为参数传入默认值，图下👇。第二个方法继续调用super()。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200906113216.png" alt=""></p>
<h4 id="4-2-3-实现在接口中声明的属性"><a href="#4-2-3-实现在接口中声明的属性" class="headerlink" title="4.2.3 实现在接口中声明的属性"></a>4.2.3 实现在接口中声明的属性</h4><h5 id="在接口中声明一个属性"><a href="#在接口中声明一个属性" class="headerlink" title="在接口中声明一个属性"></a>在接口中声明一个属性</h5><pre><code class="kotlin">interface User {
    val nickname: String
}</code></pre>
<p>接口可以包含抽象属性声明。</p>
<p>这意味这<strong>实现User接口的类需要</strong>提供一个取得nickname值的方式。</p>
<h5 id="实现接口中的属性-三种"><a href="#实现接口中的属性-三种" class="headerlink" title="实现接口中的属性 三种"></a>实现接口中的属性 三种</h5><p>第一种</p>
<pre><code class="kotlin">// 主构造方法属性
class PrivateUser(override val nickname: String) : User {

}</code></pre>
<p>对于 PrivateUser 来说，<strong>你是用了间接的语法直接在主构造方法中声明了一个属性</strong>。这个属性实现了来自于User的抽象属性，所以你将其标记为 override。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908100413.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908095819.png" alt=""></p>
<p>运行结果</p>
<p>第二种</p>
<pre><code class="kotlin">class SubscribingUser(val email: String) : User {
    override val nickname: String get() = email.substringBefore(&#39;@&#39;)  // 自定义getter
}</code></pre>
<p>对于 SubscribeingUser 来说，nikename属性通过一个自定义 getter 实现。<strong>这个属性没有一个支持字段来存储它的值，它只有一个 getter 在每次调用时从 email 中得到昵称。</strong></p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908100342.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908100257.png" alt=""></p>
<p>运行结果</p>
<p>第三种</p>
<pre><code class="kotlin">class FacebookUser(val accoundId: Int) : User {
    override val nickname = getFacebookName(accoundId)  // 属性初始化
    fun getFacebookName(text: String): String {
        return text
    }
}</code></pre>
<p>nickname在SubscribingUser和FackbookUser中的不同实现。即使它们看起来很相似，第一个属性有一个自定义getter在每次访问时计算 subscringBefore，然后 FackbookUser中的属性有一个<strong>支持字段来存储在类初始化时计算得到数据</strong>。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908104646.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908111027.png" alt=""></p>
<p>运行结果</p>
<h3 id="4-3-编译器生成的方法-数据类和委托"><a href="#4-3-编译器生成的方法-数据类和委托" class="headerlink" title="4.3 编译器生成的方法:数据类和委托"></a>4.3 编译器生成的方法:数据类和委托</h3><h4 id="4-3-2-数据类-自动生成通用方法的实现"><a href="#4-3-2-数据类-自动生成通用方法的实现" class="headerlink" title="4.3.2 数据类:自动生成通用方法的实现."></a>4.3.2 数据类:自动生成通用方法的实现.</h4><p>实现一个数据类需要重写方法:toString、equals和hashcode。</p>
<p><strong>数据类</strong></p>
<pre><code class="kotlin">data class Client(val name:String,val postalCode:Int)</code></pre>
<p>这是一个数据类,重写了所有标准的Java方法:</p>
<ul>
<li>equals 用来比较实例</li>
<li>hashCode用来作为例如HashMap这种基于哈希容器的键</li>
<li>toString用来为类生成按声明顺序排列的所有字段的字符串表达形式</li>
</ul>
<h3 id="4-4-“object”-关键字：-将声明一个类与创建一个实例结合起来"><a href="#4-4-“object”-关键字：-将声明一个类与创建一个实例结合起来" class="headerlink" title="4.4 “object” 关键字： 将声明一个类与创建一个实例结合起来"></a>4.4 “object” 关键字： 将声明一个类与创建一个实例结合起来</h3><p>这个关键词定义一个类并同时创建一个实例（换句话说就是一个对象）。</p>
<ul>
<li><strong>对象声明</strong>是定义一个单例的一种方式。</li>
<li><strong>伴生对象</strong>可以持有<strong>工场方法</strong>和其他与这个类的相关，但是在调用时并不依赖类实例方法。<strong>它们的成员可以通过类名来访问</strong>。</li>
<li><strong>对象表达式用来代替Java的匿名内部类</strong></li>
</ul>
<h4 id="4-4-1-对象声明：创建单例易如反掌"><a href="#4-4-1-对象声明：创建单例易如反掌" class="headerlink" title="4.4.1 对象声明：创建单例易如反掌"></a>4.4.1 对象声明：创建单例易如反掌</h4><h5 id="为什么使用对象声明？"><a href="#为什么使用对象声明？" class="headerlink" title="为什么使用对象声明？"></a>为什么使用对象声明？</h5><p>在面向对象系统中一个相当常见的情形就是只需要一个实例的类。例如，可以使用一个对象声明来表示一个组织的工资单。</p>
<h5 id="在Java中是如何实现单例模式？"><a href="#在Java中是如何实现单例模式？" class="headerlink" title="在Java中是如何实现单例模式？"></a>在Java中是如何实现单例模式？</h5><p>定义一个使用private构造方法并且用静态字段来持有这个类仅有的实例。</p>
<h5 id="什么是对象声明"><a href="#什么是对象声明" class="headerlink" title="什么是对象声明"></a>什么是对象声明</h5><p>Kotlin通过使用对象声明功能为这一切提供了最高级的语言支持。<strong>对象声明将类声明与该类的单一实例声明结合到了一起。</strong></p>
<h5 id="对象声明使用"><a href="#对象声明使用" class="headerlink" title="对象声明使用"></a>对象声明使用</h5><pre><code>object Payroll {
    val allEmployees = arrayListOf&lt;Person&gt;()
    fun calculateSalary() {
        for (person in allEmployees){

        }
    }
}</code></pre><p>对象声明通过 object 关键词引入。与类一样，一个对象声明也可以包含属性、方法、初始化语句块等的声明，唯一不允许的是构造方法。对象声明在定义时就创建了构造对象，不需要在代码的其他地方调用构造方法。对象声明同样可以继承类和接口。</p>
<h1 id="5-Lambda-编程"><a href="#5-Lambda-编程" class="headerlink" title="5 Lambda 编程"></a>5 Lambda 编程</h1><h2 id="5-5-带接收者的lambda：“with”与“apply”"><a href="#5-5-带接收者的lambda：“with”与“apply”" class="headerlink" title="5.5 带接收者的lambda：“with”与“apply”"></a>5.5 带接收者的lambda：“with”与“apply”</h2><h5 id="什么是带接收者的-lambda？"><a href="#什么是带接收者的-lambda？" class="headerlink" title="什么是带接收者的 lambda？"></a>什么是带接收者的 lambda？</h5><blockquote>
<p>Kotlin 中独特的 lambda 功能：在lambda函数体内可以调用一个不同的对象方法，而且无需借助任何额外的限定符。</p>
</blockquote>
<p><strong>接收者：</strong>调用者</p>
<h3 id="5-5-1-“with”-函数"><a href="#5-5-1-“with”-函数" class="headerlink" title="5.5.1 “with” 函数"></a>5.5.1 “with” 函数</h3><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><blockquote>
<p>对同一个对象执行很多次操作，不需要反复把对象名称写出来。</p>
</blockquote>
<h5 id="构建字母表"><a href="#构建字母表" class="headerlink" title="构建字母表"></a>构建字母表</h5><pre><code class="kotlin">fun alphabet(): String {
    val result = StringBuilder()
    for (letter in &#39;A&#39;..&#39;Z&#39;) {
        result.append(letter)
    }
    result.append(&quot;\n Now I know the alphbet!&quot;)
    return result.toString()
}</code></pre>
<pre><code class="kotlin">fun main() {
    println(alphabet())
}</code></pre>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201022214803.png" alt=""></p>
<h5 id="使用场景（为什么要用”with“）"><a href="#使用场景（为什么要用”with“）" class="headerlink" title="使用场景（为什么要用”with“）"></a><strong>使用场景</strong>（为什么要用”with“）</h5><p>案例中多次调用到 “<strong>result</strong>“实例。使用”<strong>with</strong>“减少对实例的调用。</p>
<h5 id="如何使用-”with“？"><a href="#如何使用-”with“？" class="headerlink" title="如何使用 ”with“？"></a>如何使用 ”with“？</h5><pre><code class="kotlin">fun alphabet(): String {
    val result = StringBuilder()
    return with(result) {// 指定接收者的值
        for (letter in &#39;A&#39;..&#39;Z&#39;) {
            this.append(letter) // 显式的使用‘this’来调用接收者值的方法（result.appned()方法）
        }
        append(&quot;\n Now I know the alphabet!&quot;)   // 隐藏 ‘this’ 同样可以使用
        this.toString()
    }
}</code></pre>
<pre><code class="kotlin">fun main() {
    println(alphabet())
}</code></pre>
<h5 id="”with“的结构"><a href="#”with“的结构" class="headerlink" title="”with“的结构"></a>”with“的结构</h5><blockquote>
<p>with 结构看上去像是一种特殊的语法结构，但它实际上是一个接收两个参数的函数：这个例子中两个参数分别是 stringBuilder 和 lambda 。</p>
</blockquote>
<p>with 函数把第一个参数转换为第二个参数传递给 lambda 的接收者。</p>
<h5 id="在普通函数中与扩展函数中带接收者的-lambda-有那些不同"><a href="#在普通函数中与扩展函数中带接收者的-lambda-有那些不同" class="headerlink" title="在普通函数中与扩展函数中带接收者的 lambda 有那些不同"></a>在普通函数中与扩展函数中带接收者的 lambda 有那些不同</h5><blockquote>
<p>在扩展函数体内部，this 指向了这个函数扩展的那个类型实例，而且也可以被省略掉，让你直接访问接收者的成员。</p>
</blockquote>
<h3 id="5-5-2-“apply”-函数"><a href="#5-5-2-“apply”-函数" class="headerlink" title="5.5.2 “apply” 函数"></a>5.5.2 “apply” 函数</h3><h5 id="apply-和-with-的不同"><a href="#apply-和-with-的不同" class="headerlink" title="apply 和 with 的不同"></a>apply 和 with 的不同</h5><blockquote>
<p>apply 函数同with 函数功能相同，区别在于 apply 始终会返回作为实参传递给它的对象。（返回本身作为实例）</p>
</blockquote>
<pre><code class="kotlin">fun alphabet() = StringBuilder().apply {
    for (letter in &#39;A&#39;..&#39;Z&#39;) {
        append(letter)
    }
    append(&quot;\n Now I know the alphbet!&quot;)
}.toString()</code></pre>
<p>apply 被声明成一个扩展函数。它的<strong>接收者</strong>变成了作为实参的 lambda 的接收者。执行 apply 的结果是StringBuilder,所以接下来里可以调用 toString 把它转换成 String。</p>
<p><strong>使用apply初始化一个TextView</strong></p>
<pre><code class="kotlin">fun createViewWithCustomAttributes(context : Context) = {
    TextView(context).apply{
        text = &quot;Sample Text&quot;
        textSize = 20.0
        setPadding(10,0,0,0)
    }
}</code></pre>
<p><strong>apply函数允许里使用紧凑的表达式函数体风格</strong>。新的<strong>TextView</strong>实例<strong>创建</strong>之后立即被传给了<strong>apply</strong>。</p>
<p><strong>那个是接收者?</strong></p>
<p>TextView实例变成了 (lambda 的) 接收者，你可以调用它的属性和方法。</p>
<p>with 函数和 apply 函数是最基本和最通用的使用带接收者的 lambda 的例子。更多的函数也可以使用这种模式。例如，使用<strong>标准库函数buildString进一步简化alphbet函数</strong>，它会负责<strong>创建StringBuilder</strong>并<strong>调用toString</strong>。<strong>building实际是带接收者的lambda</strong>，<strong>接收者</strong>就是<strong>StringBuilder</strong>。</p>
<p><strong>使用buildString创建字母表</strong></p>
<h2 id="5-6-小结"><a href="#5-6-小结" class="headerlink" title="5.6 小结"></a>5.6 小结</h2><h1 id="6-Kotlin的类型系统"><a href="#6-Kotlin的类型系统" class="headerlink" title="6  Kotlin的类型系统"></a>6  Kotlin的类型系统</h1><h2 id="6-1-可空性"><a href="#6-1-可空性" class="headerlink" title="6.1 可空性"></a>6.1 可空性</h2><h3 id="6-17-“let”-函数"><a href="#6-17-“let”-函数" class="headerlink" title="6.17 “let” 函数"></a>6.17 “let” 函数</h3><p>用来处理可空表达式。和安全调用运算符一起使用，允许你对表达式求值，检查求值结果是否null，并把结果保存为一个变量。</p>
<pre><code class="kotlin">fun sendEmailTo(email : String){
    println(&quot;Sending emaill to $emaill&quot;)
}

&gt;&gt;&gt; var email:String ? = &quot;yole@example.com&quot;
&gt;&gt;&gt; email?.let{sendEmailTo(it)}
&gt;&gt;&gt; emaill = null
&gt;&gt;&gt; emaill?.let{    sendEmailTo(it)        }</code></pre>
<blockquote>
<p>所以说只有这段表达式不为空时才会执行代码块里的代码</p>
</blockquote>
<h3 id="6-18-延迟初始化的属性"><a href="#6-18-延迟初始化的属性" class="headerlink" title="6.18 延迟初始化的属性"></a>6.18 延迟初始化的属性</h3><h4 id="使用-延迟初始化属性的原因"><a href="#使用-延迟初始化属性的原因" class="headerlink" title="使用 延迟初始化属性的原因"></a>使用 延迟初始化属性的原因</h4><blockquote>
<p>Kotlin 通常要求你在构造方法中初始化所有属性，如果某个属性是可空类型，你就必须提供一个非空的初始化值。否则，你就必须使用可空类型。如果你这样做，该属性的每一次访问都需要null检查或者！！运算符</p>
</blockquote>
<p><strong>使用非空断言访问可控属性</strong></p>
<pre><code class="kotlin">class MyService{
    fun performAction():String = &quot;foo&quot;
}
class MyText{
    private var myService : MyService ?= null    // 声明了一个可空类型初始化为 null
    @Before fun setUp(){    // 在 setUp方法中提供真正的初始化器
        myService = MyService()
    }
    @Test fun testAction(){
        Assert.assertEquals(&quot;foo&quot;,myService!!.performAction())    // 必须注意可空性：要么用&quot;!!&quot;，要么用&quot;?.&quot;
    }
}</code></pre>
<p><strong>使用延迟初始化</strong></p>
<pre><code class="kotlin">class MyService{
    fun performAction():String = &quot;foo&quot;
}
class MyText{
    private lateinit var myService : MyService    // 声明了一个不需要初始化器的非空类型属性
    @Before fun setUp(){    // 在 setUp 方法中初始化 myService
        myService = MyService()
    }
    @Test fun testAction(){
        Assert.assertEquals(&quot;foo&quot;,myService.performAction())    // 不需要 null 检查直接访问属性
    }
}</code></pre>
<p>注意</p>
<blockquote>
<p>初始化的属性必须为var，因为需要在构造方法外修改它的值，使用val属性被编译时必须在构造方法中初始化final片段。</p>
<p>尽管 myService 属性是非空的，你不需要在构造方法中初始化它。在属性没有被初始化之前调用会得到异常 “lateinit property myService has not been initialized”。</p>
<p>lateinit 属性常见的一种用法是在依赖注入。在某种情况下，lateinit 属性的值是被依赖注入框架从外部设置的。为了保证和各种依赖注入框架的兼容性</p>
<p>，Kotlin 会自动生成一个和 lateinit 属性具有相同可见性的字段。如果属性的可见性是public，生成的字段意思public</p>
</blockquote>
<h1 id="8-高阶函数：Lambda作为形参和返回值"><a href="#8-高阶函数：Lambda作为形参和返回值" class="headerlink" title="8 高阶函数：Lambda作为形参和返回值"></a>8 高阶函数：Lambda作为形参和返回值</h1><p><strong>内联函数作用</strong></p>
<p>能够消除lambda带来的性能开销，还能够使lambda内的控制流更加灵活。</p>
<h2 id="8-1-声明高阶函数"><a href="#8-1-声明高阶函数" class="headerlink" title="8.1 声明高阶函数"></a>8.1 声明高阶函数</h2><p>定义</p>
<blockquote>
<p>高阶函数就是以另一个函数作为参数或者返回值的函数。</p>
</blockquote>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h3 id="字段和属性"><a href="#字段和属性" class="headerlink" title="字段和属性"></a>字段和属性</h3><p><a href="https://blog.csdn.net/chenchunlin526/article/details/71424844" target="_blank" rel="noopener">深入理解Java中的字段与属性的区别</a></p>
<h4 id="属性和字段的区别"><a href="#属性和字段的区别" class="headerlink" title="属性和字段的区别"></a>属性和字段的区别</h4><p>属性（property），通常可以理解为get 和 set 方法。</p>
<p>字段（field），通常叫做 <strong>类成员</strong>，或者 <strong>类变量</strong> ，有时也叫 域 ，理解为 数据成员，用来承担数据的。</p>
<h4 id="属性和字段详解"><a href="#属性和字段详解" class="headerlink" title="属性和字段详解"></a>属性和字段详解</h4><p><strong>字段（field）</strong></p>
<p>类成员（字段field），通常在类中定义成员变量例如：</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200909213136.png" alt=""></p>
<p>解释为：<strong>FacebookUser类拥有成员变量nickname，有一个字段 nickname。</strong></p>
<p>字段一般用于承担数据，所以为了数据的安全性，一般设置为私有的。</p>
<p>字段和常量描述的类的数据（域），当这些数据的某些部分不运行外界访问时，<strong>根据”对象封装“原则，应该尽量避免将类的字段以公有方式提供给外部</strong>。除啦final修饰的常量。</p>
<p><strong>属性（property）</strong></p>
<p><strong>属性只局限于类中方法的声明，并不与类中其它成员相关</strong>，数据JavaBean范畴：</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200909220317.png" alt=""></p>
<p>这是一个属性，一个字段。</p>
<p>总结：属性是对字段的封装，供外部访问。通常<strong>属性</strong>将对应的<strong>私有字段</strong>通过封装成公共属性，以便于外界访问和修改。</p>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>是指可以被求值的代码。</p>
<p>例如</p>
<pre><code class="c">int result = add(x + 1,y)</code></pre>
<blockquote>
<p>x + 1 作为表达式传递了数值</p>
</blockquote>
<pre><code class="c">int result = add（if(x==1),y）</code></pre>
<blockquote>
<p>这段语句在 c 中是没有办法作为表达式的。</p>
</blockquote>
<h3 id="Kotlin-this表达式"><a href="#Kotlin-this表达式" class="headerlink" title="Kotlin this表达式"></a>Kotlin this表达式</h3><p>为了表示当前的 <strong>接收者</strong> 使用 this{:.keyword} 表达式：</p>
<ul>
<li>在类的成员中，this{:.keyword}指的是当前对象</li>
<li>在扩展函数或者带接受者的函数字面值中，this{:.keyword}表示在点左侧的接收者参数。</li>
</ul>
<h3 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h3><p>函数引用 是kotlin引入的一个功能。使用(::)表示对函数的引用</p>
<p>代码</p>
<pre><code class="kotlin">val sum:(Int,Int) -&gt; Int = {x,y -&gt; x +y}</code></pre>
<blockquote>
<p>sum 是一个函数类型的变量，lambda表达式执行了相加的操作。</p>
</blockquote>
<pre><code class="kotlin">fun applyOp(x: Int, y: Int, op: (Int, Int) -&gt; Int): Int = op(x, y)</code></pre>
<p>applyOp 是一个接受三个参数的函数，第三个参数是lambda类型。可以用下面的返回调用这个函数：</p>
<pre><code class="kotlin">applyOp(2,3,sum)</code></pre>
<p>即高阶函数可以作为一个类型赋值给变量，也可以作为另一个函数的参数。</p>
<h4 id="函数引用：函数可以是一个-lambda"><a href="#函数引用：函数可以是一个-lambda" class="headerlink" title="函数引用：函数可以是一个 lambda"></a>函数引用：函数可以是一个 lambda</h4><p>上述的lambda表达式，可以用纯函数的形式：</p>
<pre><code class="kotlin">fun sum(x: Int, y: Int) = x + y</code></pre>
<p>实现效果是一样的，区别在于不再需要使用变量来保持对函数的引用，但是这样需要对applOp函数要做一些修改，原来的</p>
<p><strong>applOp(2,3,sum)</strong>写法会报类型不匹配的语法错误。需要修改为使用<strong>函数引用</strong>代码如下：</p>
<pre><code class="kotlin">applOp(2,3,::sum)</code></pre>
<p>这些算是 函数引用 的大致概念。同时<strong>函数引用</strong>也是可以赋值给变量的。</p>
<pre><code class="kotlin">val sumLambda: (Int, Int) -&gt; Int = ::sum
applyOp(2, 3, sumLambda)</code></pre>
<p><strong>引用：</strong></p>
<p><a href="https://www.web3.xin/code/2606.html" target="_blank" rel="noopener">Kotlin this表达式</a></p>
<p><a href="https://www.jianshu.com/p/10358883455c" target="_blank" rel="noopener">kotlin中的函数引用详解</a>    </p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-8-3-1.gif" alt="如果有些方法没有详细说明你可以自行搜索查看"></p>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://thecara.github.io" rel="external nofollow noreferrer">TheCara</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://thecara.github.io/2020/07/26/kotlin-in-Action-Kotlin%E5%AE%9E%E6%88%98/">https://thecara.github.io/2020/07/26/kotlin-in-Action-Kotlin%E5%AE%9E%E6%88%98/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by-nc/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY-NC 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://thecara.github.io" target="_blank">TheCara</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Android/">
                                    <span class="chip bg-color">Android</span>
                                </a>
                            
                                <a href="/tags/Kotlin/">
                                    <span class="chip bg-color">Kotlin</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/07/26/choco%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%89%E8%A3%85/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/18.jpg" class="responsive-img" alt="Chocolatey的配置与应用的安装">
                        
                        <span class="card-title">Chocolatey的配置与应用的安装</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            使用 Chocolatey安装7zip全程使用科学上网
choco install 7zip如何安装Chocolatey在桌面下载
使用管理员打开cmd访问到下载的目录中
输入👇.安装的同时要使用科学上网
@powershell -NoP
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-07-26
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Chocolatey/" class="post-category">
                                    Chocolatey
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Chocolatey/">
                        <span class="chip bg-color">Chocolatey</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/07/26/RecyclerView%E5%9C%A8Kotlin%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/21.jpg" class="responsive-img" alt="RecyclerView在Kotlin中的使用">
                        
                        <span class="card-title">RecyclerView在Kotlin中的使用</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            创建项目RecyclerExample项目需要引入依赖
需要子项布局在 “RecyclerViewExample\app\src\main\res\layout”下创建 “example_item.xml” 👇
&lt;?xml vers
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-07-26
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Android/" class="post-category">
                                    Android
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Android/">
                        <span class="chip bg-color">Android</span>
                    </a>
                    
                    <a href="/tags/Kotlin/">
                        <span class="chip bg-color">Kotlin</span>
                    </a>
                    
                    <a href="/tags/RecyclerView/">
                        <span class="chip bg-color">RecyclerView</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('h1'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="/about" target="_blank">TheCara</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/TheCara" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:qyx2013@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1099178659" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1099178659" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
