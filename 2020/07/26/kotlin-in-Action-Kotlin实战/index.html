<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="kotlin, TheCara">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>kotlin | TheCara</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">TheCara</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">TheCara</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/TheCara" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/TheCara" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200831160049.png')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">kotlin</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Kotlin/" class="post-category">
                                Kotlin
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-07-26
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="2-Kotlin-基础"><a href="#2-Kotlin-基础" class="headerlink" title="2 Kotlin 基础"></a>2 Kotlin 基础</h1><h2 id="2-1-基本要素-函数变量"><a href="#2-1-基本要素-函数变量" class="headerlink" title="2.1 基本要素: 函数变量"></a>2.1 基本要素: 函数变量</h2><h3 id="2-1-3-变量"><a href="#2-1-3-变量" class="headerlink" title="2.1.3 变量"></a>2.1.3 变量</h3><p><strong>可变变量和不可变变量</strong></p>
<ul>
<li>val–不可变引用。使用val声明的变量不能在初始化之后再次赋值。它对应的是java中的final变量</li>
<li>var–可变引用。这种变量的值可以被改变。这种声明对应的是普通(非final)变量</li>
</ul>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595899792330.png" alt=""></p>
<p>👆在定义了val变量的代码块期间,<strong>val变量只能进行唯一一次初始化</strong>。但是,如果编译器能确保只有唯一一次初始化语句会被执行,可以根据条件使用不同的值来初始化它。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595899976491.png" alt=""></p>
<p>自身不可变(只可以执行一次,初始化一次)</p>
<p>注意,尽管val引用自身是不可变的,但是它指向的对象<strong>`可能</strong>`是可变的。列如</p>
<pre><code class="kotlin">val languages = arrayListOf(&quot;Java&quot;)
lenguages.add(&quot;Kotlin&quot;)</code></pre>
<h2 id="2-3-表示和处理选择：枚举和“when”"><a href="#2-3-表示和处理选择：枚举和“when”" class="headerlink" title="2.3 表示和处理选择：枚举和“when”"></a>2.3 表示和处理选择：枚举和“when”</h2><h3 id="2-3-1-声明枚举类"><a href="#2-3-1-声明枚举类" class="headerlink" title="2.3.1 声明枚举类"></a>2.3.1 声明枚举类</h3><p><strong>什么是枚举</strong></p>
<p>为了让编译器能够自动检查某个值在枚举的集合中，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用 <strong>enum</strong> 来定义枚举类。</p>
<pre><code class="kotlin">enum class Color{
    RED,ORANGE,YELLOW,GREEN,BLUE,INDIGO,VIOLET
}</code></pre>
<p>kotlin 中 enum 是一个所谓的软关键词：只有当它出现在class前面时才会有特殊的意义，在其他地方可以把它当作普通的名称使用。</p>
<h3 id="2-3-5-智能转换：合并类型检查和转换"><a href="#2-3-5-智能转换：合并类型检查和转换" class="headerlink" title="2.3.5 智能转换：合并类型检查和转换"></a>2.3.5 智能转换：合并类型检查和转换</h3><p><strong>kotlin智能转换的案例</strong> </p>
<p><strong>表达式类型层次</strong></p>
<pre><code class="kotlin">interface Expr
class Num(val value: Int) : Expr    // 简单的值对象类，只有一个属性value，实现了Expr接口
class Sum(val left: Expr, val right: Expr) : Expr   // Sum运算的实参可以是任何Expr:Num 或者 Sum</code></pre>
<p><strong>对表达式求值</strong></p>
<pre><code class="kotlin">fun eval(e: Expr): Int {
    if (e is Num) {
//        val n = e.value as Num //显示的转换为Num类型多余的
        return e.value
    }
    if (e is Sum) {
        return eval(e.left) + eval(e.right) // 变量 e 被智能的转换了类型
    }
    throw IllegalArgumentException(&quot;test&quot;)
}</code></pre>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200831171911.png" alt=""></p>
<p>结果</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200831171248.png" alt=""></p>
<p><strong>“is” 修饰符</strong></p>
<p>在 kotlin 中，你要使用 is 检查来判断一个变量是否是某个类型。</p>
<p><strong>什么时候进行智能转换？</strong></p>
<p>如果你检查过一个变量是某种类型，后面就不再需要转换它了，可以就把它当作你检查过的类型使用。事实上编译器为你执行了类型转换，我们把这种行为称为 <strong>智能转换。</strong></p>
<h1 id="3-函数的订阅和调用"><a href="#3-函数的订阅和调用" class="headerlink" title="3 函数的订阅和调用"></a>3 函数的订阅和调用</h1><h2 id="3-3-给别人的类添加方法：扩展函数和属性"><a href="#3-3-给别人的类添加方法：扩展函数和属性" class="headerlink" title="3.3 给别人的类添加方法：扩展函数和属性"></a>3.3 给别人的类添加方法：扩展函数和属性</h2><p><strong>介绍</strong></p>
<blockquote>
<p>扩展函数非常简单，作为一个类的成员函数，不过它定义在类的外边。</p>
</blockquote>
<h1 id="4-类、对象和接口"><a href="#4-类、对象和接口" class="headerlink" title="4 类、对象和接口"></a>4 类、对象和接口</h1><h2 id="4-1-定义类继承结构"><a href="#4-1-定义类继承结构" class="headerlink" title="4.1 定义类继承结构"></a>4.1 定义类继承结构</h2><h3 id="4-1-1-Kotlin-中的接口"><a href="#4-1-1-Kotlin-中的接口" class="headerlink" title="4.1.1 Kotlin 中的接口"></a>4.1.1 Kotlin 中的接口</h3><p><strong>声明接口</strong></p>
<pre><code class="kotlin">interface Clickable{
    fun click()
}</code></pre>
<p><strong>实现接口</strong></p>
<pre><code>class Button : Clickble {
    override fun click() {
        println(&quot;I was clicked&quot;)
    }
}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200826205307.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200826205356.png" alt=""></p>
<p><strong>Kotlin实现接口与 Java 有那些不同</strong></p>
<p>Kotlin 在类后面使用冒号来代替 <strong>Java</strong> 中的 extends 和 implements 关键词。 和 Java 一样，<strong>一个类可以实现任意多个接口</strong>，但<strong>只能继承一个类型</strong>。</p>
<p><strong>override 修饰符的作用</strong></p>
<ul>
<li>相同</li>
</ul>
<p>与 Java 中的 @Override 注解类似，<strong>override 修饰符用来标注被重写的父类或者接口的方法和属性</strong>。</p>
<ul>
<li>不同</li>
</ul>
<p>在 Kotlin 中使用 override 修饰符是强制要求的。<strong>这会避免先写出实现方法再添加抽象方法造成的意外重写：</strong>你的代码将不能编译，除非你显式地将这个方法标注为 Override 或者重命名它。</p>
<p><strong>如何给接口添加一个默认实现的方法</strong></p>
<p>接口的方法可以有一个默认实现的方法。</p>
<pre><code class="kotlin">interface Clickable{
    fun click() // 普通的方法声明
    fun showOff() = println(&quot;I&#39;m clickable!&quot;) // 带默认实现的方法
}</code></pre>
<p><strong>实现一个带有默认实现的方法的接口要注意什么</strong></p>
<p>如果你实现了这个接口，你需要为 click 提供一个实现。可以重新定义 showOff() 方法的行为，或者如果你对默认行为感到满意也可以直接省略它。（默认实现的方法也可以被重写）</p>
<p><strong>定义实现了同样方法的接口</strong></p>
<pre><code class="kotlin">interface Focusable {
    fun setFocus(b: Boolean) = println(&quot;I ${if (b) &quot;got&quot; else &quot;lost&quot;} focus.&quot;)
    fun showOff() = println(&quot;I&#39;m focusable!&quot;)
}</code></pre>
<p><strong>在类中实现两个有相同默认实现方法的接口会发生什么</strong></p>
<p>在这两个接口中都带有默认实现的 showOff() 方法：在没有显示的实现 showOff() ,会得到编译错误信息。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827000446.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827000526.png" alt=""></p>
<p><strong>解决办法</strong></p>
<p>必须显式的实现相同方法。</p>
<p><strong>调用继承(接口)的默认实现方法</strong></p>
<pre><code class="kotlin">class Button : Clickable, Focusable {
    override fun click() {
        TODO(&quot;Not yet implemented&quot;)
    }

    //如果同样的继承成员不止一个实现，必须提供一个显示的实现。
    override fun showOff() {
        // 使用尖括号加上父类名字的“super”表明了你想要调用哪一个父类的方法
        super&lt;Clickable&gt;.showOff()
        super&lt;Focusable&gt;.showOff()
    }

}</code></pre>
<p>通过调用继承的两个父类型中的实现来实现 showOff() 。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827005257.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827005432.png" alt=""></p>
<h3 id="4-1-2-open、final-和-abstract-修饰符：默认为-final"><a href="#4-1-2-open、final-和-abstract-修饰符：默认为-final" class="headerlink" title="4.1.2 open、final 和 abstract 修饰符：默认为 final"></a>4.1.2 open、final 和 abstract 修饰符：默认为 final</h3><p><strong>kotlin 中如何继承一个类</strong></p>
<p>如果你想要创建一个类的子类，需要使用 open 修饰符来标示这个类。此外<strong>需要给每个可以被重写的属性或者方法添加 open 属性</strong>。</p>
<p><strong>声明一个带open 方法的 open 类</strong></p>
<pre><code class="kotlin">open class RichButton : Clickable {
    fun disable() {}    // 这个函数是 final 的： 不能在子类中重写它。
    open fun animate() {} // 这个函数是 open 的： 可以在子类中重写它

    // 这个函数重写了 open 函数并且它本身同样是 open 的
    override fun click() {
        TODO(&quot;Not yet implemented&quot;)
    }

}</code></pre>
<p><strong>默认 final 的好处</strong></p>
<p>类默认 final 带来了一个重要的好处就是这使得在大量的场景中的只能转换成为可能。</p>
<p><strong>智能转换的前提</strong></p>
<p><strong>智能转换只能在进行类型检查后没有改变过的变量上起的作用。</strong>对于一个类来说，这意味着<strong>智能转换在val类型并且没有自定义访问器的类属性上使用</strong>。 这个前提意味着属性必须是 final 的，否则如果一个子类可以重写属性并且定义一个自定义的访问器将会打破智能转换的关键前提。</p>
<p><strong>抽象类的默认修饰符</strong></p>
<p>抽象成员始终是open的，所以不需要显式地使用open修饰符。</p>
<p><strong>声明一个抽象类</strong></p>
<pre><code class="kotlin">abstract class Animated {
    abstract fun animate()  // 这个函数是抽象的：它没有实现必须被子类重写

    // 抽象类中的非抽象函数 并不是默认 open 的，但是可以标注为 open的
    open fun stopAnimating() {

    }

    fun animateTwice() {}
}</code></pre>
<h3 id="4-1-4-内部类和嵌套类：默认嵌套类"><a href="#4-1-4-内部类和嵌套类：默认嵌套类" class="headerlink" title="4.1.4 内部类和嵌套类：默认嵌套类"></a>4.1.4 内部类和嵌套类：默认嵌套类</h3><p>内部类：非静态嵌套类，也被成为内部类。</p>
<p>嵌套类：静态嵌套类，嵌套类多称为：静态嵌套类。</p>
<p><strong>Kotlin中嵌套类和Java中的不同</strong></p>
<p>在Kotlin中的嵌套类不能访问外部类的实例，除非你特别的做出要求。 </p>
<p><strong>在序列化时使用内部类</strong></p>
<p>在你定义一个 View 元素，它的状态时可序列化的。<strong>想要序列化一个视图可能并不容易，但是可以把所有需要的数据复制到另一个辅助类中去。</strong></p>
<pre><code class="kotlin">interface State : Serializable
interface View {
    fun getCurrentState(): State
    fun restoreState(state: State) {}
}</code></pre>
<p>声明State接口去实现Serializable。View接口声明了可以用来保存视图状态的getCurrentState和restoreState方法。</p>
<p><strong>用内部类的java代码来实现View</strong></p>
<pre><code class="java">public class Button implements View{
    @Override
    public State getCurrentState(){
        return new ButtonState();
    }
    @Override
    public voiew restoreState(State state){
        /**/
    }
    public class ButtonState implements State{
        /**/
    }
}</code></pre>
<p>问题：在运行时你会得到 java.io.NotSerializable.Exception:Button 异常，在你序列化声明的按钮状态时。这个可能看起来会很奇怪：你序列化的变量是ButtonState类型，为什么会有Button异常呢？</p>
<p><strong>无法序列化的原因</strong></p>
<p>在java中，当你在另一个类中声明一个类时，它会默认变成内部类。案例中：ButtonState类隐示的存储了它的外部Button类的应用。从而解释了为什么ButtonState不能被序列化。</p>
<p><strong>修复无法序列化</strong></p>
<p><strong>需要声明ButtonState类是static的</strong>。将嵌套类声明为static会冲这个类中删除包围它的类的隐式引用。</p>
<p><strong>在kotlin中使用嵌套类来实现 View</strong></p>
<pre><code class="kotlin">class Button : View {
    override fun getCurrentState(): State {
        TODO(&quot;Not yet implemented&quot;)
    }

    override fun restoreState(state: State) {
        TODO(&quot;Not yet implemented&quot;)
    }

    // 这个类与Java中的静态潜逃类类似
    class ButtonState : State {

    }

}</code></pre>
<p><strong>kotlin中默认行为是嵌套类。</strong></p>
<p><strong>如何让默认嵌套类的类型变为内部类！</strong></p>
<p>要把它（嵌套类）变成为一个内部类来持有一个外部类的引用的话需要使用 <strong>inner</strong> 修饰符。</p>
<p><strong>kotlin中内部类访问外部类</strong></p>
<p>在kotlin中引用外部类实例的语法与java不同。需要使用this@Outer从Inner类去访问Outer类。</p>
<h3 id="4-1-5-密封类：定义受限的类继承结构"><a href="#4-1-5-密封类：定义受限的类继承结构" class="headerlink" title="4.1.5 密封类：定义受限的类继承结构"></a>4.1.5 密封类：定义受限的类继承结构</h3><p><strong>什么是密封类”sealed“</strong></p>
<p>sealed 类。为父类添加了一个新的 sealed 修饰符，可对创建的子类做出严格的限制。<strong>所有的子类必须嵌套在父类中。</strong></p>
<p><strong>为什么要使用密封类（定义受限的类继承结构）</strong></p>
<p><strong>作为接口实现的表达式 👇</strong></p>
<pre><code class="kotlin">interface Expr
class Num(val value: Int) : Expr
class Sum(val left: Expr, val right: Expr):Expr

fun eval(e: Expr): Int =
    when (e) {
        is Num -&gt; e.value
        is Sum -&gt; eval(e.left) + eval(e.right)
        else -&gt; // 必须检查 else 分支
            throw  IllegalArgumentException(&quot;Unknown expression!&quot;)
    }
</code></pre>
<p><strong>当使用 when 结构来执行表达式的时候，Kotlin 编译器会强制检查默认选项</strong>。在这个例子中，<strong>不能返回一个有意义的值，所以直接返回异常状态。</strong></p>
<p>更重要的是，如果你添加了一个新的子类，编译器并不能发现你修改了。<strong>如果你忘记添加一个新的分支，就会选择默认选项，这又可能导致潜在的 bug。</strong></p>
<p><strong>如何使用密封类 “sealed”</strong></p>
<pre><code class="kotlin">sealed class Expr { //将基类标记为封闭的
    class Num(val value: Int) : Expr()
    class Sum(val left: Expr, val right: Expr) : Expr() // 将所有可能的类作为嵌套类列出
}

fun eval(expr: Expr): Int =
    // “when”表达式覆盖了所有的可能情况，所以不再需要 else 分支
    when (expr) {
        is Expr.Num -&gt; expr.value
        is Expr.Sum -&gt; eval(expr.left) + eval(expr.right)
    }</code></pre>
<p><strong>如果你在 when 表达式中处理了所有的 sealed 类的子类，你就不再需要提供默认分支。</strong>注意，sealed 修饰符隐含的这个类是一个 open 类，你不再需要显式地添加 open 修饰符。</p>
<h2 id="4-2-声明一个带默认构造方法或属性的类"><a href="#4-2-声明一个带默认构造方法或属性的类" class="headerlink" title="4.2 声明一个带默认构造方法或属性的类"></a>4.2 声明一个带默认构造方法或属性的类</h2><p><strong>kotlin中构造方法和java中有那些不同</strong></p>
<p>与java中一个类可以声明一个或多个构造方法。kotlin也是类似的，只是做出了一些修改：区分了主构造方法（通常是主要而简洁的初始化类的方法，并且在类体外部声明）和从构造方法。</p>
<h3 id="4-2-1-初始化类：主构造方法和初始化代码块"><a href="#4-2-1-初始化类：主构造方法和初始化代码块" class="headerlink" title="4.2.1 初始化类：主构造方法和初始化代码块"></a>4.2.1 初始化类：主构造方法和初始化代码块</h3><p><strong>什么是主构造方法。</strong></p>
<pre><code class="kotlin">class User(val nickname:String)</code></pre>
<p>这段被括号围起来的代码块就叫<strong>做主构造方法</strong>。它有两个目的：表明构造方法的<strong>参数</strong>，以及定义使用这个<strong>参数</strong>的属性。</p>
<p><strong>明确的主构造方法声明</strong></p>
<pre><code class="kotlin">class User constructor(_nickname: String) {   // 带一个参数的主构造方法
    val nickname: String

    init {  // 初始化代码块
        nickname = _nickname
    }
}</code></pre>
<p>现在来看看完成同样功能的代码具体是什么样子。</p>
<blockquote>
<p>两个关键词 <strong>construtor</strong> 和 <strong>init</strong>。 constructor 关键词用来开始一个<strong>构造方法</strong>或者<strong>从构造方法</strong>的声明。init 关键词用来引入初始化代码块。这种代码块包含了类在创建时执行的代码，并且会和主构造方法一起使用。<strong>因为主构造方法有语法限制，不能包含初始化代码，这就是需要初始化代码块（init）的原因。</strong>同时可以创建多个初始化代码块。</p>
</blockquote>
<p><strong>用参数来初始化属性</strong></p>
<pre><code class="kotlin">class User(_nickname: String) { // 带一个参数的构造方法
    val nickname: String = _nickname    // 用参数来初始化属性

}</code></pre>
<blockquote>
<p>在例子中，不需要把初始化代码放在初始化代码块中，因为它可以与nickname属性声明结合。如果主构造方法没有注解或可见性修饰符，同样可以去除 constructor 关键词。</p>
</blockquote>
<p><strong>用最简洁的方法再次初始化类</strong></p>
<pre><code class="kotlin">class User(val nickname:String)    // “val” 意味相对应的属性会用构造方法的参数来初始化。</code></pre>
<p>前几个案例用 val 关键词声明了属性。如果属性用相对应的构造方法参数来初始化，<strong>代码可以通过把 val 关键词加载参数前的方法来简化它</strong>。可以用来代替类中的属性定义了。</p>
<p><strong>为构造方法提供默认值</strong></p>
<pre><code class="kotlin">class User(val nickname: String, val isSubscribed: Boolean = true) // 为构造方法提供一个默认值    </code></pre>
<p>可以像函数参数一样为构造方法声明默认值。</p>
<p><strong>如何让一个类不被其他代码实例化</strong></p>
<p>如果想要你的类不被其他代码实例化，必须把构造方法标记为 private。</p>
<pre><code class="kotlin">class Secretive private constructor()   // 这个类有 private 构造方法</code></pre>
<h3 id="4-2-2-构造方法：用不同的方法来初始化方法"><a href="#4-2-2-构造方法：用不同的方法来初始化方法" class="headerlink" title="4.2.2 构造方法：用不同的方法来初始化方法"></a>4.2.2 构造方法：用不同的方法来初始化方法</h3><p><strong>为什么要使用多种方法初始化父类</strong></p>
<p>最常见的一种就是当你需要扩展一个框架类来提供多个构造方法，以便于通过不同的方法来初始化类的时候。</p>
<p><strong>父类使用从构造方法</strong></p>
<pre><code class="kotlin">open class View {
    constructor(ctx: Context) { // 从构造方法
        //some code
    }

    constructor(ctx: Context, attr: AttributeSet) { // 从构造方法
        //some code
    }
}</code></pre>
<p><strong>扩展父类</strong></p>
<pre><code class="kotlin">class MyButton : View {
    constructor(ctx: Context) : super(ctx) {
        // 调用父类构造方法
    }

    constructor(ctx: Context, attr: AttributeSet) : super(ctx, attr) {

    }
}</code></pre>
<p><strong>调用父类的另一个构造方法</strong></p>
<pre><code class="kotlin">class MyButton : View {
    constructor(ctx: Context) : this(ctx, My_SYTLE) {
        // 委托给这个类的另一个构造方法
    }

    constructor(ctx: Context, attr: AttributeSet) : super(ctx, attr) {

    }
}</code></pre>
<p>从<strong>构造方法</strong>中调用你自己类的另一个<strong>构造方法</strong>。</p>
<p>可以修改 MyButton类 <strong>使得一个构造方法委托给同一个类的另一个构造方法</strong>，为参数传入默认值，图下👇。第二个方法继续调用super()。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200906113216.png" alt=""></p>
<h3 id="4-2-3-实现在接口中声明的属性"><a href="#4-2-3-实现在接口中声明的属性" class="headerlink" title="4.2.3 实现在接口中声明的属性"></a>4.2.3 实现在接口中声明的属性</h3><p><strong>在接口中声明一个属性</strong></p>
<pre><code class="kotlin">interface User {
    val nickname: String
}</code></pre>
<p>接口可以包含抽象属性声明。</p>
<p>这意味这<strong>实现User接口的类需要</strong>提供一个取得nickname值的方式。</p>
<p><strong>实现接口中的属性 三种</strong></p>
<p>第一种</p>
<pre><code class="kotlin">// 主构造方法属性
class PrivateUser(override val nickname: String) : User {

}</code></pre>
<p>对于 PrivateUser 来说，<strong>你是用了间接的语法直接在主构造方法中声明了一个属性</strong>。这个属性实现了来自于User的抽象属性，所以你将其标记为 override。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908100413.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908095819.png" alt=""></p>
<p>运行结果</p>
<p>第二种</p>
<pre><code class="kotlin">class SubscribingUser(val email: String) : User {
    override val nickname: String get() = email.substringBefore(&#39;@&#39;)  // 自定义getter
}</code></pre>
<p>对于 SubscribeingUser 来说，nikename属性通过一个自定义 getter 实现。<strong>这个属性没有一个支持字段来存储它的值，它只有一个 getter 在每次调用时从 email 中得到昵称。</strong></p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908100342.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908100257.png" alt=""></p>
<p>运行结果</p>
<p>第三种</p>
<pre><code class="kotlin">class FacebookUser(val accoundId: Int) : User {
    override val nickname = getFacebookName(accoundId)  // 属性初始化
    fun getFacebookName(text: String): String {
        return text
    }
}</code></pre>
<p>nickname在SubscribingUser和FackbookUser中的不同实现。即使它们看起来很相似，第一个属性有一个自定义getter在每次访问时计算 subscringBefore，然后 FackbookUser中的属性有一个<strong>支持字段来存储在类初始化时计算得到数据</strong>。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908104646.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908111027.png" alt=""></p>
<p>运行结果</p>
<h3 id="4-2-4-通过-getter或setter访问支持字段"><a href="#4-2-4-通过-getter或setter访问支持字段" class="headerlink" title="4.2.4 通过 getter或setter访问支持字段"></a>4.2.4 通过 getter或setter访问支持字段</h3><p>关于两种属性的例子：存储值的属性和具有自定义访问器在每次访问时的属性。<strong>现在让我们来看看怎么结合这两种来实现一个既可以存储值又可以被值访问和修改时提供额外逻辑的属性。</strong>要支持这种情况，需要能够从属性的访问器中访问它的支持字段。</p>
<p>假设在任何适合对存储的属性中的数据进行修改时输出日志，你声明了一个可变属性并且在每次 setter 访问时执行额外的代码。</p>
<pre><code class="kotlin">/*    在 setter 中访问支持字段    */
class User(val name:String) {
    var address: String = &quot;unspecified&quot;
        set(value: String){
            println(&quot;&quot;&quot;
                Address was changed for $name:&quot;$field&quot; -&gt; &quot;$value&quot;.&quot;&quot;&quot;.trinmIndent())    //读取支持字段的值
                field = value    // 更新支持字段的值
        }
}</code></pre>
<pre><code class="kotlin">&gt;&gt;&gt; val user = User(&quot;Alice&quot;)
&gt;&gt;&gt; user.address = &quot;Elasenheimerstrasse 47, 80687 Muenchen&quot;
Address was changed for Alice:
&quot;unspecified&quot; -&gt; &quot;Elsenheimerstrasse 47, 80687 Muenchen&quot;</code></pre>
<blockquote>
<p>可以像平常一样通过使用 user.address = “new value” 来修改一个属性的值，这其实在底层调用了setter。在这个例子中，setter 被重新定义了，所以额外的输出日志的代码被执行了（简单起见，这里直接将其打印出来）。</p>
<p>在 setter 的函数体中，使用了特殊的标识符 field来访问支持字段的值。在 getter 中，只能读取值：而在 setter 中，既能读取它也能修改它。</p>
</blockquote>
<h2 id="4-3-编译器生成的方法-数据类和委托"><a href="#4-3-编译器生成的方法-数据类和委托" class="headerlink" title="4.3 编译器生成的方法:数据类和委托"></a>4.3 编译器生成的方法:数据类和委托</h2><h3 id="4-3-2-数据类-自动生成通用方法的实现"><a href="#4-3-2-数据类-自动生成通用方法的实现" class="headerlink" title="4.3.2 数据类:自动生成通用方法的实现."></a>4.3.2 数据类:自动生成通用方法的实现.</h3><p>实现一个数据类需要重写方法:toString、equals和hashcode。</p>
<p><strong>数据类</strong></p>
<pre><code class="kotlin">data class Client(val name:String,val postalCode:Int)</code></pre>
<p>这是一个数据类,重写了所有标准的Java方法:</p>
<ul>
<li>equals 用来比较实例</li>
<li>hashCode用来作为例如HashMap这种基于哈希容器的键</li>
<li>toString用来为类生成按声明顺序排列的所有字段的字符串表达形式</li>
</ul>
<h2 id="4-4-“object”-关键字：-将声明一个类与创建一个实例结合起来"><a href="#4-4-“object”-关键字：-将声明一个类与创建一个实例结合起来" class="headerlink" title="4.4 “object” 关键字： 将声明一个类与创建一个实例结合起来"></a>4.4 “object” 关键字： 将声明一个类与创建一个实例结合起来</h2><p>这个关键词定义一个类并同时创建一个实例（换句话说就是一个对象）。</p>
<ul>
<li><strong>对象声明</strong>是定义一个单例的一种方式。</li>
<li><strong>伴生对象</strong>可以持有<strong>工场方法</strong>和其他与这个类的相关，但是在调用时并不依赖类实例方法。<strong>它们的成员可以通过类名来访问</strong>。</li>
<li><strong>对象表达式用来代替Java的匿名内部类</strong></li>
</ul>
<h3 id="4-4-1-对象声明：创建单例易如反掌"><a href="#4-4-1-对象声明：创建单例易如反掌" class="headerlink" title="4.4.1 对象声明：创建单例易如反掌"></a>4.4.1 对象声明：创建单例易如反掌</h3><p><strong>为什么使用对象声明？</strong></p>
<p>在面向对象系统中一个相当常见的情形就是只需要一个实例的类。例如，可以使用一个对象声明来表示一个组织的工资单。</p>
<p><strong>在Java中是如何实现单例模式？</strong></p>
<p>定义一个使用private构造方法并且用静态字段来持有这个类仅有的实例。</p>
<p><strong>什么是对象声明</strong></p>
<p>Kotlin通过使用对象声明功能为这一切提供了最高级的语言支持。<strong>对象声明将类声明与该类的单一实例声明结合到了一起。</strong></p>
<p><strong>对象声明使用</strong></p>
<pre><code>object Payroll {
    val allEmployees = arrayListOf&lt;Person&gt;()
    fun calculateSalary() {
        for (person in allEmployees){

        }
    }
}</code></pre><p>对象声明通过 object 关键词引入。与类一样，一个对象声明也可以包含属性、方法、初始化语句块等的声明，唯一不允许的是构造方法。对象声明在定义时就创建了构造对象，不需要在代码的其他地方调用构造方法。对象声明同样可以继承类和接口。</p>
<h1 id="5-Lambda-编程"><a href="#5-Lambda-编程" class="headerlink" title="5 Lambda 编程"></a>5 Lambda 编程</h1><h2 id="5-1-Lambda表达式和成员引用"><a href="#5-1-Lambda表达式和成员引用" class="headerlink" title="5.1 Lambda表达式和成员引用"></a>5.1 Lambda表达式和成员引用</h2><h3 id="5-1-1-Lambda-简介：作为函数参数的代码块"><a href="#5-1-1-Lambda-简介：作为函数参数的代码块" class="headerlink" title="5.1.1 Lambda 简介：作为函数参数的代码块"></a>5.1.1 Lambda 简介：作为函数参数的代码块</h3><p>在代码中存储和传递一小段行为是常有的任务。例如，“当一个事件发生的时候运行这个事件处理器”又或是“把这个操作应用到这个数据结构的所有元素上”。在老版本的Java中可以使用匿名函数。</p>
<blockquote>
<p>使用函数式编程 提供了另外一种解决问题的方法：</p>
<p>把函数当作值来对待。可以直接传递函数，而不需要先声明一个类再传递一个类的实例。使用 lambda 表达式后代码会变的更加简洁。</p>
</blockquote>
<p>例子。假设你要定义一个点击按钮的行为，添加一个处理点击的监听器。监听器实现了想对应的接口 OnClickListener 和它的一个方法 onClick。</p>
<pre><code class="java">/*    用匿名内部类实现监听器    */
button.setOnClickListener(new OnClickListener(){
    @Override
    public void onClick(View view){
        /*点击之后执行的动作*/
    }
})</code></pre>
<p>使用匿名内部类的写法，更加冗余。接下来使用 lambda 写法</p>
<pre><code class="kotlin">/*    用 lambda 实现监听器    */
button.setOnClickListener{    /*    点击后执行操作    */    }</code></pre>
<h3 id="5-1-2-Lamda-和-集合"><a href="#5-1-2-Lamda-和-集合" class="headerlink" title="5.1.2 Lamda 和 集合"></a>5.1.2 Lamda 和 集合</h3><p>良好的编程风格原则之一是避免代码的重复。我们对集合执行大部分任务都遵循这几个通用的模式，所以要实现这几个模式的代码应该放在一个库里。在没有 lambda 的帮助，很难为集合提供一个好用方便的库。</p>
<p>看个例子。</p>
<p>创建一个 Person 类，它包含了这个了的名字和年龄信息。</p>
<pre><code class="kotlin">data class Person(val name:String, val age :Int)</code></pre>
<p>假设你现在要在列表中找到年龄最大的那个人。</p>
<pre><code class="kotlin">/*    手动在集合中搜索    */
fun findTheOldest(people:List&lt;Person&gt;){
    var maxAge = 0    //存储最大年龄
    var theOldest:Person ?= null //存储年龄最大的人
    for (person in people){
        if(person.age &gt; maxAge){    //如果下一个比现在年龄最大的人还要大，改变最大值
            maxAge = person.age
            theOldest = person
        }
    }
    println(theOldest)
}
&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31))
&gt;&gt;&gt; findTheOldest(people)
Person(name = Bob,age = 31)</code></pre>
<pre><code class="kotlin">/*    用 lambda 在集合中搜索    */
&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31))
&gt;&gt;&gt; println(people.maxBy{it.age})    // 比较年龄最大的元素
Person(name = Bob, age = 31)</code></pre>
<p>maxBy函数可以在任何集合上调用，且只需要一个参数：函数指定比较哪个值来找到最大元素。</p>
<p>花括号中的代码 <strong>{it.age}</strong>就是实现了这个逻辑的lmabda。 它接收一个集合中的元素作为实参(作用 it 引用它)并且返回用来比较的值。在这个例子中，集合元素是Person对象，用来比较的是存储在其age属性中的年龄。</p>
<pre><code class="kotlin">/*    用成员引用    */
people.maxBy(Person:age)</code></pre>
<h3 id="5-1-3-Lambda-表达式的语法"><a href="#5-1-3-Lambda-表达式的语法" class="headerlink" title="5.1.3 Lambda 表达式的语法"></a>5.1.3 Lambda 表达式的语法</h3><p>概述 lambda</p>
<blockquote>
<p>一个 lambda 把一小段行为进行编码，你能把它当作值到处传递。它可以被独立地声明并储存一个变量。</p>
</blockquote>
<pre><code class="kotlin">/*    lambda 表达式的语法    */
{x:Int,y:Int -&gt; x+y}
/*    参数 -&gt; 函数体    */</code></pre>
<blockquote>
<p>Kotlin 的lambda 表达式始终用花括号包围。实参并没有用括号括起来。箭头把实参列表和lambda 函数体隔开了。</p>
</blockquote>
<p>可以把 lambda表达式存储在一个变量中，把这个变量当作普通函数对待（即通过相应实参调用它）</p>
<pre><code class="kotlin">&gt;&gt;&gt; val sum = {x:Int,y:int -&gt; x+y}
&gt;&gt;&gt; println(sum(1,2))    // 调用保存在变量中的lambda
3</code></pre>
<blockquote>
<p>Kotlin 中的语法约定，如果 lambda 表达式是函数调用的最后一个实参，它可以放到括号外边。在这个例子中lambda是唯一的实参，所以可以放到括号外边</p>
<pre><code class="kotlin">people.maxBy(){p:Person -&gt; p.age}</code></pre>
<p>当 lamdba 是函数的唯一实参时，还可以去除调用代码中的空括号。</p>
<pre><code class="kotlin">people.maxBy{p:Person -&gt; p.age}</code></pre>
<p>三种语法形式的含义都是一样的，但最后都是易读的。如果lambda是唯一的实参，你当然愿意在写代码的时候省掉这个括号。而当你有多个实参时，既可以把lambda留在括号内来强调它是一个实参，也可以把它放在括号外面，两种选择都是可行的。如果你想传递两个或多个lamdba，不能把超过一个的lamdba放在外面。这时使用常规语法来传递它们通常是更好的选择。</p>
</blockquote>
<p>回顾 joinToString 函数 （对元素添加分隔符）。 Kotlin 标准库中也有定义它，标准库中的这个版本的不同之处在于它可以接收一个附加的函数参数。这个函数可以使用 toString函数以外的方法把一个元素转换成字符串。</p>
<p><strong>打印出人的名字</strong></p>
<pre><code class="kotlin">/*    把 lambda 作为命名实参传递    */
&gt;&gt;&gt;val people = listOf(Person(&quot;Alice&quot;,31),Person(&quot;Bob&quot;,29))
&gt;&gt;&gt;val names = people.joinToString(separator = &quot;&quot;,transform = {p:Person -&gt; p.name})

&gt;&gt;&gt;println(names)
Alices Bob</code></pre>
<p><strong>用更简单的方法</strong></p>
<pre><code class="kotlin">/*    把 lambda 放在括号外传递    */
people.joinToString(&quot; &quot;){p:Person -&gt; p.name}</code></pre>
<p><strong>简化语法，移除参数类型</strong></p>
<pre><code class="kotlin">/*    省略 lambda 参数类型    */
people.maxBy{p:Person -&gt; p.age}    // 显式地写出参数类型
people.maxBY{p-&gt;p.age}    // 推导出参数类型</code></pre>
<p>和局部变量一样，如果 lambda 参数的类型可以被推导出来，你就不需要显式地指定它。以这里的 maxBy 为例子，其参数类型始终和集合的元素类型相同。编译器知道你是对一个Person对象的集合调用maxBy函数，所以它能推断出 lambda参数也会是Person类型。<strong>也存在不能推断出的情况，先遵循：先不声明类型，等编译器报错后再指定它。</strong></p>
<p><strong>最后的简化是使用默认参数名称 it 代替命名参数</strong></p>
<pre><code class="kotlin">/*    使用默认参数名称    */
people.maxBy(it.age)    //&quot;it&quot;是自动生成的参数名称</code></pre>
<p>仅在参数名称没有显式地指定时这个默认的名称才会生成。</p>
<p><strong>可以用变量存储 lambda 表达式</strong></p>
<pre><code class="kotlin">&gt;&gt;&gt; val getAge = {p:Person -&gt; p.age}
&gt;&gt;&gt; people.maxBy(getAge)</code></pre>
<blockquote>
<p>lambda 并没有被限制在这样小的规模，它可以包含更多的语句。</p>
</blockquote>
<pre><code class="kotlin">&gt;&gt;&gt; val sum = {x:Int,y:Int -&gt;
    println(&quot;Computing the sum of $x and $y...&quot;)
    x + y}
&gt;&gt;&gt; println(sum(1,2))
Computing the sum of 1 and 2...
3</code></pre>
<h3 id="5-1-4-在作用域中访问变量"><a href="#5-1-4-在作用域中访问变量" class="headerlink" title="5.1.4 在作用域中访问变量"></a>5.1.4 在作用域中访问变量</h3><blockquote>
<p>在声明一个匿名内部类的时候，能够在这个匿名类内部引用这个函数的参数和局部变量。</p>
<p>而在使用 lambda 声明的时候，也可以做同样的事情。如果在函数内部使用 lambda 也可以访问这个函数的参数，还有在 lambda 之前定义的局部变量。</p>
</blockquote>
<p><strong>forEach 函数</strong></p>
<p> 用 forEach 函数展示 上述行为。</p>
<p>它是最基本集合操作函数之一；它所作的全部事情就是在集合中的每个元素上都调用给定的 lambda。forEach 函数比普通for 函数循环更简洁，除此之外没有其它优势，所以并不急于把所有的循环更改为  lambda。</p>
<pre><code class="kotlin">/*    在 lambda 中使用函数参数    */
fun printMessageWithPrefix(message : Collection&lt;String&gt;,prefix:String){
    messages.forEach{    // 接受 lambda 作为实参指定对每个元素操作
        println(&quot;$prefix $it&quot;)    // 在 lambda 中访问 “prefix”
    }
}

&gt;&gt;&gt; val errors = listOf(&quot;433 Forbidden&quot;,&quot;404 Not Found&quot;)
&gt;&gt;&gt; printMessagesWithPrefix(errors,&quot;Error:&quot;)
Error:403 Forbidden
Error:404 Not Found</code></pre>
<blockquote>
<p>Kotlin 和 Java的一个显著区别就是，在 Kotlin 中不会仅限于访问 final 变量，在 lambda 内部也可以修改变量。</p>
</blockquote>
<pre><code class="kotlin">/*    在lambda中改变局部变量    */
fun printProblemCounts(responeses:Collection&lt;String&gt;){
    var clientErrors = 0
    var serverErrors = 0
    responeses.forEach{
        if(it.startsWith(&quot;4&quot;)){
            clientErrors ++
        }else if(it.startsWith(&quot;5&quot;)){
            serverErrors++
        }
    }
    println(&quot;$clientErrors client error,$serverErrors server errors&quot;)
}
&gt;&gt;&gt; val responses = listOf(&quot;200 OK&quot;,&quot;418 I&#39;m a teapot&quot;,&quot;500 Internal Server Error&quot;)
...
&gt;&gt;&gt; printProblemCounts(responses)
1 client errors,1 server errors</code></pre>
<blockquote>
<p>于 Java 不同，Kotlin 允许在 lambda 内部访问非 final 变量甚至修改它们。从 lambda 内访问外部变量，我们称这个变量被 <strong>lambda捕捉</strong>，如同上述的案例中的 prefix，clientErrors，serverErrors一样。</p>
</blockquote>
<p><strong>默认情况下，局部变量的声明期被限制在声明这个变量的函数中。但是如果它被lambda捕捉了，使用这个变量的代码可以被存储并稍后执行。</strong></p>
<p><strong>如果 lambda 被用作 <em>事件处理器</em> 或者用在其他 <em>异步执行</em> 的情况下，对局部变量的修改只会在 lambda 执行的时候发生。</strong></p>
<blockquote>
<p>反面案例</p>
<pre><code class="kotlin">fun tryToCountButtonClicks(button:Button):Int{
    var clicks = 0
    button.onClick{clicks++}
    return clicks
}</code></pre>
<p>这个函数始终返回0。尽管 onClick 处理器可以修改clicks的值，你并不能观察到值发生了变化，因为onClick处理器是在函数返回之后调用的。<strong>这个函数正确的实现方法需要把点击次数存储在函数外依然可以访问到的地方–例如类的属性，而不是存储在函数的局部变量中。</strong></p>
</blockquote>
<h3 id="5-1-5-成员引用"><a href="#5-1-5-成员引用" class="headerlink" title="5.1.5 成员引用"></a>5.1.5 成员引用</h3><p>​    如果把函数转换成一个值，你就可以传递它。</p>
<pre><code class="kotlin">val getAge = Person::age    //引用 age</code></pre>
<blockquote>
<p>这种表达式称为 <strong>成员引用</strong>，它提供了简明语法，来创建一个调用单个方法或者访问单个属性的函数值。 <strong>双冒号把类名称与你要引用的成员（一个方法或者一个属性）名称隔开</strong></p>
<pre><code class="kotlin">Person::age //类::成员</code></pre>
</blockquote>
<p>等价于 </p>
<pre><code class="kotlin">val getAge = {person:Person -&gt;person.age}</code></pre>
<blockquote>
<p>注意，不管你引用的是函数还是属性，都不要在成员引用的名称后面添加括号。</p>
</blockquote>
<blockquote>
<p>成员引用和调用该函数的lambda具有一样的类型，所以可以互换使用：</p>
<pre><code class="kotlin">people.maxBy(Person::age)</code></pre>
<p>还可以引用顶层函数</p>
<pre><code class="kotlin">fun salute() = println(&quot;Salute!&quot;)
&gt;&gt;&gt; run(::salute)    // 引用顶层函数
Salute!</code></pre>
<p>这种情况下，你省略了类名称，直接以::开头。成员引用::salute被当作实参传递给库函数run，它会调用想对应的函数。</p>
<p>如果 lambda 要委托给一个接收多个参数的函数，提供成员引用代替它将会非常方便</p>
<pre><code class="kotlin">val action = {person:Person,message:String -&gt;
    sendEmail(person,massage)    //这个lambda委托sendEmail函数
    }
val nextAction = :: sendEmail    //用成员引用代替</code></pre>
<pre><code class="kotlin">/*    用构造方法引用存储或者延期执行创建类实例的动作。 构造方法引用的形式在双冒号后指定类的名称：    */
data class Person(val name:String,val age:Int)
&gt;&gt;&gt; val createPerson = :：Person    //创建Person实例的动作被保存成了值
&gt;&gt;&gt; val p = createPerson(&quot;Alice&quot;,29)
&gt;&gt;&gt; println(p)
Person(name = Alice,age = 29)</code></pre>
<p><strong>可以用同样的方法引用扩展函数</strong></p>
<pre><code class="kotlin">fun Person.isAdult() = age &gt;= 21
val predicate = Person::isAdult</code></pre>
<p>尽管 isAdult 不同类的成员，还是可以通过引用访问它，这个访问的成员没有两样：person.isAdult()。</p>
</blockquote>
<p><strong>绑定引用</strong></p>
<blockquote>
<p>在 kotlin 1.0 中 ，当接受一个类的方法或者属性引用时，你始终需要提供一个该类的实例来调用这个引用。Kotlin1.1计划支持绑定成员引用，它允许你使用成员引用语法捕捉特定实例对象的方法引用。</p>
<pre><code class="kotlin">&gt;&gt;&gt; val p = Person(&quot;Dmitry&quot;,34)
&gt;&gt;&gt; val personAgeFunction = Person::age
&gt;&gt;&gt; println(personsAgeFunction(p))
34 
&gt;&gt;&gt; val dmitrysAgeFunction = p::age
&gt;&gt;&gt; println(dmitryAgeFunction())
34</code></pre>
<p>注意，personsAgeFunction是一个当参数函数（返回给定了的年龄），而dmitryAgeFunction是一个零参数的函数（返回已经指定好的人的年龄）。</p>
<p>在 Kotlin1.1之前，你需要显式地写出 lambda{p.age},而不是使用绑定成员引用p::age。</p>
</blockquote>
<h2 id="5-2-集合的函数式API"><a href="#5-2-集合的函数式API" class="headerlink" title="5.2 集合的函数式API"></a>5.2 集合的函数式API</h2><p>我们先从filter和map这类函数及它们背后的概念开始。</p>
<h3 id="5-2-1-基础：filter和map"><a href="#5-2-1-基础：filter和map" class="headerlink" title="5.2.1 基础：filter和map"></a>5.2.1 基础：filter和map</h3><p>filter和map函数形成了集合操作的基础，很多集合操作都是借助它们来表达的。</p>
<p>通过两种样子的例子帮助你来理解，一个纯数字形式一个使用<strong>自定义</strong>的Person类来实现。</p>
<pre><code class="kotlin">data class Person(val name:String,val age:Int)</code></pre>
<p><strong>filter函数</strong></p>
<blockquote>
<p>遍历集合并选出引用给定 lambda 条件 后会返回true的那些元素</p>
<pre><code class="kotlin">&gt;&gt;&gt; val list = listOf(1,2,3,4)
&gt;&gt;&gt; println(list.filter{it%2==0})
[2,4]</code></pre>
</blockquote>
<p><strong>map函数</strong></p>
<blockquote>
<p>对集合中每个元素应用给定的函数并把结果收集到一个新的集合中。</p>
<p>根据lambda参数作为判断生成新的集合。</p>
<pre><code class="kotlin">&gt;&gt;&gt; val list = listOf(1,2,3,4)
&gt;&gt;&gt; println(list.map{it*it})
[1,4,9,16]</code></pre>
</blockquote>
<blockquote>
<p>如果直想打印名字列表，而不是完整信息，可以用map变换列表：</p>
<pre><code class="kotlin">&gt;&gt;&gt; val people=listOf(Person(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31))
&gt;&gt;&gt; println(people.map{it.name})
[Alice,Bob]</code></pre>
<p>使用 <strong>成员引用</strong> 同样可以</p>
<pre><code class="kotlin">people.map(Person::name)</code></pre>
</blockquote>
<blockquote>
<p>当需要获得分组中最大人的名字时。</p>
<pre><code class="kotlin"> val maxAge = people.maxBy(Person::age).age
 people.filter{it.age == maxAge}</code></pre>
<p><strong>map 应用过滤和变换函数</strong></p>
<pre><code class="kotlin">&gt;&gt;&gt; val numbers = mapOf(0 to &quot;zero&quot;,1 to &quot;one&quot;)
&gt;&gt;&gt; println(numbers.mapValues{it.value.toUppterCase()})    // 对map集合的值进行操作
[0=ZERO,1=ONE]</code></pre>
<p>键和值分别由各自的函数来处理。<strong>filterKeys和mapKeys过滤和变换map的键，而另外的filterValues和mapValues过滤和变换对应的值。</strong></p>
</blockquote>
<h3 id="5-2-2-“all”“any”“count”和“find”：对集合引用判断式"><a href="#5-2-2-“all”“any”“count”和“find”：对集合引用判断式" class="headerlink" title="5.2.2 “all”“any”“count”和“find”：对集合引用判断式"></a>5.2.2 “all”“any”“count”和“find”：对集合引用判断式</h3><blockquote>
<p>这些方法作用</p>
<p>Kotlin中，它们是通过 all 和 any 函数表达式的（检查集合中的所有元素是否都符合某个条件）。count 函数检查由多少元素满足判断式，而find函数返回第一个符合条件的元素。</p>
<p>案例：</p>
<p>检查一个人是否还没有到28岁。</p>
<pre><code class="kotlin">val canBeInClub27 = {p:Person -&gt; p.age &lt;=27}</code></pre>
<p>如果是<strong>所有元素都满足判断式条件</strong>的应该使用 all 函数。（）</p>
<pre><code class="kotlin">&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,27),Person(&quot;Bob&quot;,31))
&gt;&gt;&gt; println(people.all(canBeInClub27))
false</code></pre>
<p>如果你<strong>检查集合中至少存在一个匹配的元素</strong>，则使用 any 函数</p>
<pre><code class="kotlin">&gt;&gt;&gt; println(people.any(canBeInClub27))</code></pre>
<p>true</p>
<p>如果<strong>你想知道有多少元素满足判断式</strong>，使用count：</p>
<pre><code class="kotlin">&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,27),Person(&quot;Bob&quot;,31))
&gt;&gt;&gt; println(people.count(canBeInClub27))
1</code></pre>
</blockquote>
<p><strong>使用正确的函数完成工作：”count” VS. “size”</strong></p>
<p>count 方法容易被遗忘，然后通过过滤集合之后再取大小来实现它：</p>
<pre><code class="kotlin">&gt;&gt;&gt; println(people.filter(canBeInClub27).size)
1</code></pre>
<p>再这种情况下，一个集合中间会被创建并用来存储所有满足判断式的元素。</p>
<p>而另一方面，count 方法只是最终匹配元素的数量，不关心元素本身，所以更高效。</p>
<blockquote>
<p><strong>要找到一个满足判断式的元素，使用 find 函数</strong></p>
<pre><code class="kotlin">&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,27),Person(&quot;Bob&quot;,31))
&gt;&gt;&gt; println(people.find(canBeInClub27))
Person[name = Alice,age = 27]</code></pre>
<p>存在多个能够匹配的元素就返回其中第一个元素：或者返回 null，如果没有一个元素能满足判断式。find还有一个同义方法 firstOrNull，可以使用这个方法更加清楚的表达你的意图。</p>
</blockquote>
<h3 id="5-2-3-groupBy：把列表转换成分组的map"><a href="#5-2-3-groupBy：把列表转换成分组的map" class="headerlink" title="5.2.3 groupBy：把列表转换成分组的map"></a>5.2.3 groupBy：把列表转换成分组的map</h3><blockquote>
<p><strong>当你想把人按照年龄分组，相同年龄的人放在一组。</strong></p>
<p>groupBy: 按照表达式将几个进行分组并返回一个 map 集合</p>
<pre><code class="kotlin">&gt;&gt;&gt; val people = listOf(Perosn(&quot;Alice&quot;,31),Perosn(&quot;Bob&quot;,29),Person(&quot;Carol&quot;,31))
&gt;&gt;&gt; println(people.groupBy{it.age})</code></pre>
<p>返回结果 map，是元素分组依据的键（这个例子中是age）和元素分组（persons）之间映射</p>
<pre><code class="kotlin">{
29 = [Person(name = Bob,age = 29)],
31 = [Person(name = Alice,age = 31),
        Person(name = Carol,age = 31)]
        }</code></pre>
<p>每个分组都是存储在一个列表中，<strong>结果的类型就是Map&lt;Int,List<Person>&gt;</strong>。</p>
<p>可以使用像 mapKeys 和 mapValues 这也的函数对这个map做进一步的修改。</p>
</blockquote>
<blockquote>
<p><strong>使用成员引用把字符串按照首字母分组：</strong></p>
<pre><code class="kotlin">&gt;&gt;&gt; val list = listOf(&quot;a&quot;,&quot;ab&quot;,b)
&gt;&gt;&gt; println(list.groupBy(String::first))
{a = [a,ab],
 b = [b]}</code></pre>
<p>first并不是String类的成员，而是一个扩展。然而，可以把它当作成员引用访问。</p>
</blockquote>
<h3 id="5-2-4-flatMap-和-flatten：处理嵌套集合和元素"><a href="#5-2-4-flatMap-和-flatten：处理嵌套集合和元素" class="headerlink" title="5.2.4 flatMap 和 flatten：处理嵌套集合和元素"></a>5.2.4 flatMap 和 flatten：处理嵌套集合和元素</h3><p><strong>例子</strong></p>
<blockquote>
<p>假设你有一堆藏书，使用Book表示：</p>
<pre><code class="kotlin">class Book(val title:String,val authors:List&lt;String&gt;)</code></pre>
<p>authors ：保存书的所有作者。</p>
<p>统计出图书馆中所有作者的set；</p>
<pre><code class="kotlin">books.flatMap{it.authros}.toSet()    //包含撰写 “books” 集合中书籍的所有作者 set</code></pre>
<p>flatMap:作用，1.首先根据作为实参给定的函数对集合中的每个元素做转换（或者说映射），然后把多个列表合并（或者说平铺）成一个列表。</p>
</blockquote>
<blockquote>
<p>说明：</p>
<pre><code class="kotlin">&gt;&gt;&gt; val strings = listOf(&quot;abc&quot;,&quot;def&quot;)
&gt;&gt;&gt; pritnln(strings.flatMap{it.toList()})
[a,b,c,d,e,f]</code></pre>
<p>字符串上的toList函数把它转换成字符列表。</p>
<p>使用 map 函数，你会得到一个字符列表的列表。</p>
<p>flatMap 函数：执行后面操作，并返回一个包含所有元素（字符）的列表</p>
<p>回到例子中：</p>
<pre><code class="kotlin">&gt;&gt;&gt; val books = listOf(Book(&quot;Thursday Next&quot;,listOf(&quot;Jasper Fforde&quot;)),
                        Book(&quot;Mort&quot;,listOf(&quot;Terry Pratchett&quot;)),
                        Book(&quot;Good Omens&quot;,listOf(&quot;Terry Pratchett&quot;,
                                                &quot;Neil Gaiman&quot;)))
&gt;&gt;&gt; println(books.flatMap{it.authors}.toSet)                                                
[Jasper Fforde,Terry Pratchett,Neil Gaiman]</code></pre>
<p>book.authors 是存储了多个作者的集合。flatMap 函数把所有书籍的作者合并成变频的列表。</p>
<p><strong>toSet调用移除了结果集合中的所有重复元素。</strong></p>
<p>所以 Terry Pratchett 在输出中只出现了一次。</p>
<p><strong>如果你只需要平铺一个集合，可以使用 flatten 函数：listOfLists.flatten</strong></p>
</blockquote>
<h2 id="5-3-惰性集合操作：序列"><a href="#5-3-惰性集合操作：序列" class="headerlink" title="5.3 惰性集合操作：序列"></a>5.3 惰性集合操作：序列</h2><blockquote>
<p>你看到了关于许多链式调用的例子，例如 map 和 filter。这些函数会及早的创建中间集合，也就是说每一步的中间结果都被存储在一个临时列表。</p>
<pre><code class="kotlin">people.map(Person::name).filter{it.startsWith(&quot;A&quot;)}</code></pre>
<p>Kotlin 标准库参考文档说明，filter 和 map 都会返回一个列表。这意味这上面的例子中的链式调用会创建两个列表：一个保存filter函数的结果，另一个保存 map函数的结果。如果源列表只有两个元素，这不是什么问题，但是如果有一百万个元素，（链式）调用就会变得十分低效。</p>
<p>为了提高效率可以将操作变换成序列，而不是使用集合：</p>
<pre><code class="kotlin">people.asSequence()    //把初始集合转换成序列
      .map(Person::name)    
      .filter{it.startsWith(&quot;A&quot;)}    //系列支持和集合一样的API
      .toList()    // 把结果序列转换会列表</code></pre>
<p>这个例子没有创建任何一个存储元素的，所以元素数量巨大的情况下性能显著提升。</p>
<p>Kotlin 惰性集合操作的入口就是 Sequence 接口。这个接口表示可以诸葛列举的元素序列。Sequence 只提供了一个方法，iterator，用来从序列中获取值</p>
</blockquote>
<p>优势</p>
<blockquote>
<p>Sequence接口的强大之处在于其操作的实现方式。序列中的元素求值是惰性的，因此可以使用序列更高效地对集合元素执行链式操作，而不需要创建额外的集合来保存过程中产生的总结结果。</p>
</blockquote>
<p>为什么需要把序列转换回集合？把序列代替集合不是更方便吗？特别是它的这些优点。</p>
<blockquote>
<p>大多数是这样的。如果你需要迭代序列中的元素，可以直接使用。而要使用其他API方法，例如下标访问元素，那么你需要将序列转换成列表。</p>
</blockquote>
<blockquote>
<p>通常，对一个大型集合执行链式操作时要使用序列。在后面的章节中继续讨论Kotlin常规集合的及早操作高效的原因，尽管它会创建中间集合。当集合拥有数量巨大的元素，元素为中间结果进行重新分配开销巨大，所以惰性求值是更好的选择。</p>
</blockquote>
<h3 id="5-3-1-执行序列操作：中间和末端操作"><a href="#5-3-1-执行序列操作：中间和末端操作" class="headerlink" title="5.3.1 执行序列操作：中间和末端操作"></a>5.3.1 执行序列操作：中间和末端操作</h3><p><strong>序列操作共分两种</strong>：</p>
<blockquote>
<p>中间和末端。</p>
<p>一次中间操作返回的是另一个序列，这个序列知道如何变换原始序列中的元素。</p>
<p>而末端操作返回的是一个结果，这个结果可能是集合、元素、数字，或者其他的初始集合的变换序列中获得的任意对象。</p>
<pre><code class="kotlin">sequence.map{...}.filter{...}//中间操作
        .toList()//末端操作</code></pre>
</blockquote>
<p><strong>没有末端操作的例子：</strong></p>
<pre><code class="kotlin">&gt;&gt;&gt; listOf(1,2,3,4).asSequence()    //序列化
...        .map{print(&quot;map($it)&quot;);it*it}    // 转换成map集合并操作它
...        .filter{ print(&quot;filter($it)&quot;);it%2==0}    //调用对象，然后根据条件过滤</code></pre>
<blockquote>
<p>执行这段代码并不会在控制台上输出任何内容。这意味着map和filter变换被延期了，它们只有在获取结果的是否才会被应用(即末端操作被调用的时候)：</p>
<pre><code class="kotlin">&gt;&gt;&gt;listOf(1,2,3,4).asSequence()
...                .map{print(&quot;map($it);it*it&quot;)}
...                .filter{print(filter(&quot;$it&quot;);it%2 == 0)}
...                .toList()
map(1) filter(1) map(2) filter(4) map(3) filter(9) map(4) filter(16)</code></pre>
<p>末端操作触发执行了所有的延期计算。</p>
</blockquote>
<p><strong>计算执行的顺序。</strong></p>
<blockquote>
<p>一个笨办法实在每个元素上调用map函数，然后再结果序列的每个元素上再调用filter函数。</p>
<p>map和filter对集合就是这样做的，而序列不一样。对序列来说，所有操作是按序列应用再每个元素上：处理完第一个元素（先映射再过滤），然后完成第二个元素的处理，以此类推。</p>
<p><strong>这种方法意味着部分元素根本不会发生任何转换</strong></p>
<p>如果在轮到它们之前就已经取得了结果。我们来看一个map和find的例子。首先一个数字映射成它的平方，然后找到第一个比数字3大的条目：</p>
<pre><code class="kotlin">&gt;&gt;&gt; println(listOf(1,2,3,4).asSequence()
                           .map{it*it}
                           .find{it &gt; 3}
                           )
4</code></pre>
<p>如果同样的操作被应用在集合而不是序列上时，那么 map 的结果首先被求出来。即变换初始集合中的所有元素。第二步，中间集合中满足判断式的一个元素会被找出来。而对于序列来说，惰性方法意味这你可以跳过处理部分元素。图 5.8 阐明了 这段代码两种求值方法之间的区别，一种是及早求值（使用集合），一种是惰性求值（使用序列）。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210402111938.png" alt="及早求值在整个集合上执行每个操作；惰性求值则逐个处理元素"></p>
<p><strong>在集合上执行操作的顺序也会影响性能。</strong></p>
<p>假设你有一个人的集合，想要打印集合中那些长度小于某个限制的人名。</p>
<p>这时你需要做两件事：把每个人映射成他们的名字，然后过滤掉其中那些不够短的名字。</p>
<p><strong>这种情况可以用任何顺序应用map和filter操作。两种顺序得到的结果是一样的如下</strong></p>
<pre><code class="kotlin">&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31),Person(&quot;Charles&quot;,31),Person(&quot;Dan&quot;,21))
&gt;&gt;&gt; println(people.asSequence().map(Person::name).filter{it.length &lt; 4}.toList()) // 先 “map” 后 “filter”
[Bob,Dan]
&gt;&gt;&gt; println(people.asSequence().filter{it.name.length &lt; 4}
...            .map(Person::name).tolist())    // 先“filter”后 map
[Bob,Dan]</code></pre>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210402103856.png" alt="先应用filter有助于减少变换的总次数"></p>
<blockquote>
<p>如果 filter 在强，不适合的元素会被尽早地过滤掉且不会发生变换。</p>
</blockquote>
<h3 id="5-3-2-创建序列"><a href="#5-3-2-创建序列" class="headerlink" title="5.3.2 创建序列"></a>5.3.2 创建序列</h3><blockquote>
<p>asSequence()：函数用来在集合中创建序列</p>
<p>generateSequence()函数：给定序列中的前一个元素，这个函数会计算出下一个元素。</p>
<p><strong>案例 使用 generateSequence 计算 100 以内所有的自然数之和。</strong></p>
<pre><code>&gt;&gt;&gt; val naturalNumbers = generateSequence(0) {it +1}
&gt;&gt;&gt; val numbersTo100 = naturalNumbers.takeWhile{it &lt;= 100}
&gt;&gt;&gt; println(numbersTo100.sum())    //当获得结果 “sum” 时，所有被推迟的操作都被执行
5050</code></pre><p>例子中 naturalNumbers 和 numbersTo100都有延期操作序列。这些序列中的实际数字知道你调用末端操作的时候才会求值。（sum）</p>
</blockquote>
<p><strong>创建父目录的序列</strong></p>
<blockquote>
<p>如果元素的父元素和它的类型相同（比如人类或者java文件），你可能会对它的所有祖先组成的序列的特质感兴趣。下列这个例子可以查询是否放在隐藏目录中，通过创建一个其父目录的序列并检查每个目录的属性来实现。</p>
<pre><code class="kotlin">/*    创建并使用父目录的序列    */
fun File.isInsideHiddenDirectory() = 
        generateSequence(this){it.parentFile}.any{it.isHidden}    // 查询文件是否放在隐藏目录中。

&gt;&gt;&gt; val file = File(&quot;/Users/svtk/.HiddenDir/a.txt&quot;)        
&gt;&gt;&gt; println(file.IsInsideHiddenDirectory())
true</code></pre>
<p>你生成了一个序列，通过提供第一个元素和获取每个后续元素的方式来实现。如果把any换成find，你还可以得到你想要的那个目录（对象）。注意，使用序列允许你找到需要的目录之后立即停止遍历父目录。</p>
</blockquote>
<h2 id="5-4-使用-Java-函数式接口"><a href="#5-4-使用-Java-函数式接口" class="headerlink" title="5.4  使用 Java 函数式接口"></a>5.4  使用 Java 函数式接口</h2><p>Kotlin 的 lambda 可以和 Java API 互操作。</p>
<p>在本章节开头处，有看过一个把 lambda 传递给 Java 方法的例子：</p>
<pre><code class="kotlin">button.setOnClickListener{/*    点击之后的动作     */}    //复习 作为方法的最后一个参数可以省略()。把lambda作为实参传递。</code></pre>
<p>Botton 通过接收类型为OnClickListener的实参的setOnClickListener方法给按钮设置一个新的监听器：</p>
<pre><code class="java">/*    Java    */
public class Button{
    public void setOnClickListener(OnClickListener l){...}
}</code></pre>
<p>OnClickListener 接口声明了一个方法，onClick：</p>
<blockquote>
<p><em>接口可以被实现，但不能被实例化。</em></p>
</blockquote>
<pre><code class="java">public interface OnClickListener{
    void onClick(View v)
}</code></pre>
<p>在Java 8 之前你不得不创建一个匿名类的实例来作为实参传递给 setOnClickListener方法：</p>
<pre><code class="java">button.setOnClickListener(new OnClickListener(){
    @Override
    public void onClick(View v){
        ...
    }
})</code></pre>
<p>在 kotlin 中 可以传递一个 lambda，代替这个实例：</p>
<pre><code class="kotlin">button.setOnClickListener{view -&gt; ...}</code></pre>
<p>lambda 用来实现 OnClickListener，它有一个类型为View的参数，和onClick一样。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210402121803.png" alt="Lmabda的参数和方法参数对应"></p>
<blockquote>
<p>这个方法可以工作的原因是OnClickListener接口只有一个方法。<strong>这种方法被称为函数式接口，或者 SAM 接口，SAM 代表单抽象方法。Java API随处可见像Runnable和Callable这样的函数式接口，以及支持它的方法。</strong>Kotlin允许你在调用接口函数式接口作为参数的方法时使用lambda，来保证你的Kotlin代码即整洁又符合习惯。</p>
</blockquote>
<p>​             </p>
<h3 id="5-4-1-把lambda-当作参数传递给Java方法"><a href="#5-4-1-把lambda-当作参数传递给Java方法" class="headerlink" title="5.4.1 把lambda 当作参数传递给Java方法"></a>5.4.1 把lambda 当作参数传递给Java方法</h3><p>可以把lambda传递给任何期望函数式接口的方法。</p>
<blockquote>
<p>例如，如下的方法 Runable类型的参数：</p>
<pre><code class="Java">/*    Java    */
void postponeComputation(int delay,Runnable computation);</code></pre>
<p>在 Kotlin 中，可以调用它并把一个lambda作为实参传给它。编译器会<strong>自动</strong>把它转换成一个Runnable的实例：</p>
<p>postponeComputation(1000){ println(42) }</p>
<p>当我们说“一个Runnnable的实例”时，指的是“一个实现了Runnable接口的匿名类的实例”。编译器会帮你创建它，并使用lambda作为单抽象方法–这个例子中式run方法–的方法体。</p>
<p>如下：显式的创建一个Runnable的匿名对象也能达到同样的效果：</p>
<pre><code class="kotlin">postponeComputation(1000,object:Runnable{    //把对象表达式作为函数式接口的实现传递。
    override fun run(){
        println(42)
    }
})</code></pre>
<p>但是这里有点不一样。当你显式地声明对象时，每次调用都会创建一个新的实例。使用lambda的情况不同：如果lambda没有访问任何来自定义它的函数变量，相应的匿名类实例可以在多次调用之间重（chóng）用：</p>
<pre><code class="kotlin">postponeComputation(1000){println(42)}    //整个程序只会创建一个Runnable的实例</code></pre>
<p>想要完全等价的实现应该是下面这段代码中的显式object声明，它把Runnable实例存储在一个变量中，并且每次调用的时候都使用这个变量：</p>
<pre><code class="kotlin">val runnable = Runnable{println(42)}    //编译成全局变量：程序中仅此一个实例
fun handleComputation(){
    postponeComputation(1000,runnable)    //每次postponeComputation调用时用的是一个对象
}</code></pre>
<p>如果lambda在包围它的作用域中捕捉到了变量，那么每次调用就不再可能重用同一个实例了。</p>
<p>这时，每次调用编译器都要创建一个新对象，其中存储着被捕捉的变量的值。</p>
<p>如下：每次调用都会使用一个新的Runnable实例，把id值存储在它的字段中：</p>
<pre><code class="kotlin">fun handleComputation(id:String){    //lambda会捕捉“id”这个变量
    postponeComputation(1000){println(id)}    //每次handleComputation调用都创建一个Runnable的新实例。
}</code></pre>
</blockquote>
<p>Lmabda的实现细节</p>
<blockquote>
<p>从 Kotlin1.0起，每次lambda表达式都会被编译成一个匿名类，除非它是内联lambda。（内联函数不会创建匿名类）。在后续版本支持生成java8字节码后，编译器就可以避免为每一个lambda表达式都生成一个独立的.class文件。如果lambda捕捉了变量，每个被捕捉的变量会在匿名类中有对应的字段，而且每次（对lambda）的调用都会创建一个这个匿名类的新实例。</p>
<p><em>否则，一个单例就会被创建。类的名称由lambda声明所在的函数名字称加上后缀衍生出来：这个例子中就是 HandleComputation$1。如果你反编译之前lambda表达式的代码，就会看到：</em> </p>
<pre><code class="kotlin">class HandleComputation$1(val id:String):Runnable{
    override fun run(){
        println(id)
    }
}
fun handleComputation(id:String){
    postponeComputation(1000,HandleComputation$1(id))    //底层创建一个特殊的实例，而不是lambda
}</code></pre>
<p>编译器给每个被捕捉的变量生成了一个字段和一个构造方法参数。</p>
</blockquote>
<p><strong>把lambda传给标记成 inline 的Kotlin函数，是不会创建任何匿名类的。</strong></p>
<h3 id="5-4-2-SAM构造方法：显式地把lambda转换成函数式接口"><a href="#5-4-2-SAM构造方法：显式地把lambda转换成函数式接口" class="headerlink" title="5.4.2 SAM构造方法：显式地把lambda转换成函数式接口"></a>5.4.2 SAM构造方法：显式地把lambda转换成函数式接口</h3><blockquote>
<p>SAM<strong>构造方法</strong>是<strong>编译器生成的函数</strong>。用来让你执行从lambda到函数式接口实例的显式转换。</p>
<p>可以用在编译器不会自动应用转换的上下文中使用它。</p>
<p><strong>例如：如果有一个方法返回一个函数式接口（只有一个抽象方法的实例）的实例，不能直接返回一个lambda，要用SAM构造方法把它包装起来。</strong></p>
<p><strong>如下例子：</strong></p>
<pre><code class="kotlin">/*    使用SAM构造方法来返回值    */
fun createAllDoneRunnable():Runnable{
    return Runnable {println(&quot;All done!&quot;)}
}
&gt;&gt;&gt; createAllDoneRunnable().run()
All done!</code></pre>
<p><strong>SAM（函数式接口）构造返回的名称和底层函数式接口的名称一样。</strong>SAM构造方法只接收一个参数— 一个被用作函数式接口单抽象方法的lambda – 并返回实现了这个接口类的一个实例。</p>
</blockquote>
<blockquote>
<p>除开返回值外，SAM构造方法还可以用在需要<strong>把从lambda生成的函数式接口实例存储在一个变量中的情况。**</strong>假设你要在多个按钮上重用同一个监听器**，就像下面的代码清单一样（在Android应用中，这段代码可以作为Activity.onCreate方法的一部分）</p>
<pre><code class="kotlin">/*    使用SAM构造方法来重用listener实例    */
val listener =OnClickListener{    view -&gt;
    val text = when (view.id){
        R.id.button1 -&gt; &quot;First button&quot;
        R.id.button2 -&gt; &quot;Second button&quot;
        else -&gt; &quot;Unknown button&quot;
    }
    toast(text)
}
button1.setOnClickListener(listener)
button2.setOnClickListener(listener)</code></pre>
<p>listener 会检查那个按钮是点击的事件源并作出对应的行为。可以使用实现了OnClickListener的对象声明来定义监听器，但是SAM构造方法提供了更简洁的方法。</p>
</blockquote>
<blockquote>
<p><strong>Lambda 和 添加/移除监听器</strong></p>
<p>lambda 内部类有匿名对象那样的this：没有办法应用lambda转换成的匿名类实例。<strong>从编译器的角度来看，lambda是一个代码块，而不是一个对象，而且也不能当作一个对象来引用</strong>。<strong>Lambda中的this引用指向的是包围它的类。</strong></p>
<ul>
<li><input disabled="" type="checkbox"> 如果你的事件监听器在处理事件时需要取消它自己，不能使用lambda这样做。<strong>这种情况使用实现了接口的匿名对象</strong>。<strong>在匿名对象内，this关键词指向该对象实例，可以把它传递给移除监听器的API</strong></li>
</ul>
</blockquote>
<p>尽管方法调用中的SAM转换一般都会自动发生，<strong>但是当把lambda作为参数传给一个重载方法</strong>，<strong>也有编译器不能选择正确的重载情况</strong>。这时显式的SAM构造方法时解决错误的好方法。</p>
<h2 id="5-5-带接收器的lambda：”with“-与-”apply“"><a href="#5-5-带接收器的lambda：”with“-与-”apply“" class="headerlink" title="5.5 带接收器的lambda：”with“ 与 ”apply“"></a>5.5 带接收器的lambda：”with“ 与 ”apply“</h2><p><strong>带接收者的lambda：</strong></p>
<p>此节将办理逐步熟悉Kotlin的lambda的独特功能：<strong>在lambda函数体类可以调用一个不同对象的方法，而却无需借助任何限定符</strong>；此方法在java中是不存在的。这样的lambda叫做带接收者的lambda</p>
<p><strong>什么是带接收者的 lambda？</strong></p>
<blockquote>
<p>Kotlin 中独特的 lambda 功能：在lambda函数体内可以调用一个不同的对象方法，而且无需借助任何额外的限定符。</p>
</blockquote>
<p><strong>接收者：</strong>调用者</p>
<h3 id="5-5-1-“with”-函数"><a href="#5-5-1-“with”-函数" class="headerlink" title="5.5.1 “with” 函数"></a>5.5.1 “with” 函数</h3><p>从 with 函数开始它用到了带接收者lambda。</p>
<p>with的库函数：</p>
<blockquote>
<p>它对同一个对象执行多次操作，而不需要反复把对象的名称写出来。</p>
</blockquote>
<p><strong>构建字母表</strong></p>
<pre><code class="kotlin">fun alphabet(): String {
    val result = StringBuilder()
    for (letter in &#39;A&#39;..&#39;Z&#39;) {
        result.append(letter)
    }
    result.append(&quot;\n Now I know the alphbet!&quot;)
    return result.toString()
}</code></pre>
<pre><code class="kotlin">fun main() {
    println(alphabet())
}</code></pre>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201022214803.png" alt=""></p>
<p><strong>使用场景（为什么要用”with“）</strong></p>
<p>案例中多次调用到 “<strong>result</strong>“实例。使用”<strong>with</strong>“减少对实例的调用。</p>
<p><strong>如何使用 ”with“？</strong></p>
<pre><code class="kotlin">fun alphabet(): String {
    val result = StringBuilder()
    return with(result) {// 指定接收者的值
        for (letter in &#39;A&#39;..&#39;Z&#39;) {
            this.append(letter) // 显式的使用‘this’来调用接收者值的方法（result.appned()方法）
        }
        append(&quot;\n Now I know the alphabet!&quot;)   // 隐藏 ‘this’ 同样可以使用
        this.toString()
    }
}</code></pre>
<pre><code class="kotlin">fun main() {
    println(alphabet())
}</code></pre>
<p><strong>”with“的结构</strong></p>
<blockquote>
<p>with 结构看上去像是一种特殊的语法结构，但它实际上是一个接收两个参数的函数：这个例子中两个参数分别是 stringBuilder 和 lambda 。</p>
</blockquote>
<p>with 函数把第一个参数转换为第二个参数传递给 lambda 的接收者。</p>
<p><strong>在普通函数中与扩展函数中带接收者的 lambda 有那些不同</strong></p>
<blockquote>
<p>在扩展函数体内部，this 指向了这个函数扩展的那个类型实例，而且也可以被省略掉，让你直接访问接收者的成员。</p>
</blockquote>
<blockquote>
<p>上面的代码中，this 指定了stringBuilder，这时传给with的第一个参数。可以通过显式的this引用来访问stringBuilder的方法，就像this，append(latter)这样：也可以像append（”\nNow…”)</p>
</blockquote>
<p><strong>重构初始的alphabet函数，去除stringBuilder变量。</strong></p>
<blockquote>
<pre><code class="kotlin">/*    使用with和一个表达式函数体来构造字母表    */
fun alphabet() = with(StringBuilder){
    for(letter in &#39;A&#39;...&#39;Z&#39;){
        append(letter)
    }
    append(&quot;\n Now I know the alphabet!&quot;)
    toString()
}</code></pre>
<p>现在此函数只返回一个表达式，所有表达式函数体语法重写了它。</p>
<p>可以创建一个新的StringBuilder实例直接当作实例传递给这个函数，然后 lambda中不需要显式的this就可以引用到这个实例。</p>
</blockquote>
<h3 id="5-5-2-“apply”-函数"><a href="#5-5-2-“apply”-函数" class="headerlink" title="5.5.2 “apply” 函数"></a>5.5.2 “apply” 函数</h3><p><strong>apply 和 with 的不同</strong></p>
<blockquote>
<p>apply 函数同with 函数功能相同，区别在于 apply 始终会返回作为实参传递给它的对象。（返回本身作为实例）</p>
</blockquote>
<pre><code class="kotlin">fun alphabet() = StringBuilder().apply {
    for (letter in &#39;A&#39;..&#39;Z&#39;) {
        append(letter)
    }
    append(&quot;\n Now I know the alphbet!&quot;)
}.toString()</code></pre>
<p>apply 被声明成一个扩展函数。它的<strong>接收者</strong>变成了作为实参的 lambda 的接收者。执行 apply 的结果是StringBuilder,所以接下来里可以调用 toString 把它转换成 String。</p>
<p><strong>使用apply初始化一个TextView</strong></p>
<pre><code class="kotlin">fun createViewWithCustomAttributes(context : Context) = {
    TextView(context).apply{
        text = &quot;Sample Text&quot;
        textSize = 20.0
        setPadding(10,0,0,0)
    }
}</code></pre>
<p><strong>apply函数允许里使用紧凑的表达式函数体风格</strong>。新的<strong>TextView</strong>实例<strong>创建</strong>之后立即被传给了<strong>apply</strong>。</p>
<p><strong>那个是接收者?</strong></p>
<p>TextView实例变成了 (lambda 的) 接收者，你可以调用它的属性和方法。</p>
<p>with 函数和 apply 函数是最基本和最通用的使用带接收者的 lambda 的例子。更多的函数也可以使用这种模式。例如，使用<strong>标准库函数buildString进一步简化alphbet函数</strong>，它会负责<strong>创建StringBuilder</strong>并<strong>调用toString</strong>。<strong>building实际是带接收者的lambda</strong>，<strong>接收者</strong>就是<strong>StringBuilder</strong>。</p>
<p><strong>使用buildString创建字母表</strong></p>
<pre><code class="kotlin">/*    使用bulderString创建字母表    */
fun alphabet()=builderString{
    for (letter in &#39;A&#39;...&#39;Z&#39;){
        append(latter)
    }
    append(&quot;\n Now I know tha alphabet!&quot;)
}</code></pre>
<p>buildString 函数完成了借助StringBuilder创建String的任务。</p>
<h2 id="5-6-小结"><a href="#5-6-小结" class="headerlink" title="5.6 小结"></a>5.6 小结</h2><ul>
<li><strong>Lambda 允许你将代码块当作参数传递给函数。</strong></li>
<li><strong>Kotlin可以把lambda放在括号括号外穿的给函数，而且可以使用it引用单个lambda参数</strong></li>
<li><strong>lambda中的代码可以访问和修改包括这个lambda调用的函数的变量（访问修改调用者的变量）</strong></li>
<li><strong>通过在函数名称前加上前戳::，可以创建方法、可以创建方法及属性的引用，并用这些引用代替lambda传递给函数。</strong></li>
<li><strong>使用像filter、map、all、any、等函数，大多数公共的集合操作不需要手动迭代元素就可以完成。</strong></li>
<li><strong>序列允许你合并一个集合上的多个操作，而不需要创建新的集合来保存中间结果。</strong></li>
<li><strong>可以把lambda作为实参传递给接收Java函数式接口（带单抽象方法的接口，也叫SAM接口）作为形参的方法。</strong></li>
<li><strong>with标准库函数允许你调用同一个对象的多个方法，而不需要反复写出这个对象的引用。apply函数让你使用构造者风格的API创建和初始化任何对象。</strong></li>
</ul>
<h1 id="6-Kotlin的类型系统"><a href="#6-Kotlin的类型系统" class="headerlink" title="6  Kotlin的类型系统"></a>6  Kotlin的类型系统</h1><h2 id="6-1-可空性"><a href="#6-1-可空性" class="headerlink" title="6.1 可空性"></a>6.1 可空性</h2><p><strong>可空性是Kotlin类型系统中帮助你避免NullPointerException错误的特性。</strong></p>
<p>现代编程语言包括Kotlin解决这类问题的方法是把运行时的错误转变成编译期的错误。通过支持作为类型系统的一部分的可空性，编译器就能在编译器发现很多潜在的错误，从而减少运行时抛出异常的可能性。</p>
<p>我们会讨论Kotlin中的可空类型：Kotlin怎样表示允许null的值，以及Kotlin提供的处理这些值的工具。除此之外，我们还要讨论混合使用Kotlin和Java代码时关于可空类型的细节。</p>
<h3 id="6-1-1-可空类型"><a href="#6-1-1-可空类型" class="headerlink" title="6.1.1 可空类型"></a>6.1.1 可空类型</h3><p>Kotlin  和 Java 的类型系统之间第一条也可能是最重要的一条区别是，Kotlin对可空类型的显式的支持。</p>
<blockquote>
<p>这意味着，这是一种指出你程序中那些变量和属性允许为null的方式。如果一个变量可以为null，对变量的方法的调用就是不安全的，因为这样会导致NullPointerException。Kotlin不允许这样的调用因而可以阻止许多可能的异常。</p>
</blockquote>
<p><strong>在实践时它是如果工作的</strong></p>
<pre><code class="kotlin">int strLen(String s){
    return s.length();
}</code></pre>
<blockquote>
<p>这个函数被调用的时候，传给它的是一个null实参，它会抛出NullPointerException。是否需要在方法中增加对null的检查，这取决于使用该函数的意图。</p>
</blockquote>
<p><strong>用Kotlin重写这个函数</strong></p>
<blockquote>
<p>不希望在调用时传递一个 null 进来</p>
<pre><code class="kotlin">fun strLen(s:String) = s.length</code></pre>
<p>使用可能为null的参数调用strLen是不允许的，在编译期就会被标记成错误：</p>
<pre><code class="kotlin">&gt;&gt;&gt; strLen(null)
ERROR:Null can not be a value of a non-null type String</code></pre>
<p>这个函数中的参数被声明成String类型，在Kotlin中这个表示它必须包含一个String实例。这一边由编译器强制实施，所以你不能传递一个包含null的参数。</p>
<blockquote>
<p>如果你允许调用这个方法的时候传递给它可能所有的实参，包含那些可以为null的实参，需要显式地在类型名称后面加上问号来标记它：</p>
<pre><code class="kotlin">fun strLenSafe(s:String?) = ... //允许为空</code></pre>
<p>问号可以加载任何类型的后面来表示这个类型的变量可以存储null引用：String?、Int?、MyCustomType?等等</p>
</blockquote>
</blockquote>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210404144208.png" alt="可空类型的变量可以存储null引用"></p>
<p><strong>所有类型在没有问号的类型声明的情况下是不能存储null引用的，也就是说常见类型默认都是非空的。</strong></p>
<blockquote>
<p><strong>在拥有一个可空类型的值，能对它进行操作也是有限制的。</strong></p>
<p>例如，不能再调用它的方法：</p>
<pre><code class="kotlin">&gt;&gt;&gt; fun strLenSafe(s:String?) = s.length()
ERROR:only safe(?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type kotlin.String?</code></pre>
<p>也不能再把它赋值给非空类型的变量：</p>
<pre><code class="kotlin">&gt;&gt;&gt; val x:String ?= null
&gt;&gt;&gt; var y:String =x
ERROR:Type mismatch:inferred type is String? but String was expected</code></pre>
<p>也不能把可空类型的值传递给拥有非空类型参数的函数：</p>
<pre><code class="kotlin">&gt;&gt;&gt; strLen(x)
ERROR:Type mismatch:inferred type is String? but String was expected</code></pre>
<p><strong>可以进行的操作</strong></p>
<p>最重要的操作就是和null进行比较。而且一旦你进行了比较操作，编译器就会记住，并且在这次比较发生的作用域内把这个值当作非空来对待。</p>
<p>例如，下列代码是合法的：</p>
<pre><code class="kotlin">/*    使用 if 检查处理null    */
fun strLenSafe(s:String?):Int = 
    if (s != null) s.length else 0    // 增加了null 检查后，这段代码就可以编译了
&gt;&gt;&gt; val x:String?= null
&gt;&gt;&gt; println(strLenSafe(x))
0
&gt;&gt;&gt; println(strLenSafe(&quot;abc&quot;))
3</code></pre>
<p>if 检查并不是唯一处理可空性的工具，稍后会有其他工具来帮助我们处理可空值。</p>
</blockquote>
<h3 id="6-1-2-类型的含义"><a href="#6-1-2-类型的含义" class="headerlink" title="6.1.2 类型的含义"></a>6.1.2 类型的含义</h3><p><strong>什么是类型，为什么变量拥有类型？</strong></p>
<blockquote>
<p>类型就是数据的分类，决定了该类型可能的值，以及该类型的值上可能完成的操作（维基百科）。</p>
</blockquote>
<p>试试在Java的一些类型上套用如上的定义，从double类型开始。double类型是64位的双精度浮点数。可以对double类型的值进行标准的算术运算，所有的功能都可以一视同仁的运用到所有double类型的值上。因此如果你有一个类型为double的变量，那么你就能确定编译器允许在该值上进行任意操作，都可以被成功的执行。</p>
<p>现在我们把它和String类型的变量对比一下。在Java中，这样的变量可以持有两种值，分别是String实例和null。这两种完全不一样：就连Java自己的instanceof运算符都会告诉你null不是String。这两种值的操作也完全不一样：真实的String实例允许你调用它的任何方法，而null值只允许非常有限的操作。</p>
<p>上述表明在Java中类型系统不能很好的工作。<strong>即使变量拥有声明类型String你依然无法知道能对该变量的值做些什么，除非做额外的检查。你往往跳过这些检查，因为你觉得你了解程序中大概的数据流动，并确定在某个点上的值不可能为null。有时候你想错了，而你的程序就会因为NullPointerException而崩溃。</strong></p>
<p>Kotlin的可空类型为这类问题提供了全面的解决方案。区分开可空类型和非空类型使事情变得明朗：那些对值的操作使允许的，哪些操作有会导致运行时异常并因此被禁止。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<p>可空的和非空的对象在运行时没有什么区别；可空类型并不是非空类型的包装。所有的检查都发生在编译期。这意味Kotlin的可空类型并不会在运行时带来额外的开销。</p>
</blockquote>
<h3 id="6-1-3-安全调用运算符：“-”"><a href="#6-1-3-安全调用运算符：“-”" class="headerlink" title="6.1.3 安全调用运算符：“?.”"></a>6.1.3 安全调用运算符：“?.”</h3><p><strong>安全调用运算符</strong>：“?.”，它允许你把null检查和一次方法复用合并成一次操作。</p>
<p>例如：表达式 s?.toUpperCase() 等用于下面这种繁琐的写法： if (s!=null) s.toUpperCase() else null。</p>
<blockquote>
<p>也就是说在你调用一个非空值的方法，这次方法调用会被正常的调用。如果是null值的话，这次调用不会发生，而整个表达式的值为null。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210409163831.png" alt="安全调用运算符只会调用非空值的方法"></p>
<p>注意，这次调用的结果类型也是可空的。尽管String.toUppferCase()会返回String类型的值，但s是可空的时候，表达式s?.toUpperCase()的结果类型是String?:</p>
<pre><code class="kotlin">fun printAllCaps(s:String?){
    val allCaps:String? = s?.toUppperCase()    // allCaps可能是null
    println(allCaps)
}
&gt;&gt;&gt; printAllCaps(&quot;abc&quot;)
ABC
&gt;&gt;&gt; printAllCaps(null)
null</code></pre>
<p><strong>安全调用不光可以调用方法，可能用来访问属性。</strong></p>
<pre><code class="kotlin">/*    使用安全调用处理可控属性    */
class Employee(val name:String,val manager:Employee?)

fun managerName(employee:Employee):String?= employee.maneger?.name

&gt;&gt;&gt; val ceo = Employee(&quot;Da Boss&quot;,null)
&gt;&gt;&gt; val developer = Employee(&quot;Bob Smith&quot;,ceo)
&gt;&gt;&gt; println(managerName(developer))
Da Boss
&gt;&gt;&gt; println(managerName(ceo))</code></pre>
<p>如果你的对象途中又多个可空类型的属性，通常可以在同一表达式中方便地使用多个安全调用。加入你要使用不同的类型来保存关于个人的信息、他们的公司，以及公司的地址，而公司和地址都可以省略。使用?.运算符，不需要任何额外的检查，就可以在以放代码中访问到Person的country属性。</p>
<pre><code class="kotlin">/*    链接多个安全调用    */
class Address(val streetAddress:String,val zipCode:Int,val city:String,val country:String)

class Company(val name:String, val address:Address?)

class Person(val name:String,val company:Company?)
fun Person.countryName():String{
    val country = this.company?.address?.country    // 多个安全调用链接在一起
    return if (country!=null) contry else &quot;Unknown&quot;
}
&gt;&gt;&gt; val person = Person(&quot;Dmitry&quot;,null)
&gt;&gt;&gt; println(person.countryName())
Unknown</code></pre>
<h3 id="6-1-4-Elvis-运算符：“-”"><a href="#6-1-4-Elvis-运算符：“-”" class="headerlink" title="6.1.4 Elvis 运算符：“?:”"></a>6.1.4 Elvis 运算符：“?:”</h3><p>Kotlin有方便的运算符来提供代替null的默认值。它被称为Elvis运算符。（或者null合并运算符）</p>
<pre><code class="kotlin">fun foo(s:String?){
    val t:String = s?:&quot;&quot;    //如果“s”为null，结果为空字符串
}</code></pre>
<blockquote>
<p>Elvis运算符接收两个运算数，如果第一个运算数不为null，或者结果就是第一个运算数；如果第一个运算数为null，运算结果就是第二个运算数。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210411235620.png" alt="Elvis运算符用其他值代替null"></p>
<blockquote>
<p>Elvis 运算符经常和安全调用运算符一起使用，<strong>用一个值代替null对象调用返回时返回null。</strong></p>
<pre><code class="kotlin">fun strLenSafe(s:String?):Int = s?.length?:0
&gt;&gt;&gt; println(strLenSafe(&quot;abc&quot;))
3
&gt;&gt;&gt; pritnln(strLenSafe(null))
0</code></pre>
</blockquote>
<blockquote>
<p>在 6.1.3 “链接多个安全调用” 的函数 countryName现在也可以使用一行代码来完成。</p>
<pre><code class="kotlin">fun Person.countryName()=conpany?.address?.country?:=&quot;Unknown&quot;**</code></pre>
</blockquote>
<p><strong>在Kotlin中有种场景下Elvis运算符会特别顺手，想return和throw这样的操作其实是表达式，因此可以把它们写在Elvis运算符的右边。这种情况下，如果Elvis运算符左边的值为null，函数就会立即返回一个值或者抛出一个异常，如果函数中需要检查先决条件，这个方式会很有用。</strong></p>
<p><strong>实现一个打印包含个人公司地址的出货标签函数。</strong></p>
<pre><code class="kotlin">/*    同时使用throw和Elvis运算符    */
class Address(val streetAddress:String,val zipCOde:Int,val city:String,val country:String)

class Company(val name:String,val address:Address?)

class Person(val name:String,val company:Company?)

fun pritnlnShippingLabel(person:Person){
    val address = person.company?.address
                ?: throw IllegalArgumentException(&quot;No address&quot;)    //如果缺少addres就抛出异常
    with(address){    //address 不为空
        println(streetAddress
        println(&quot;$zipCode $city,$country&quot;)
    }
}
&gt;&gt;&gt; val address = Address(&quot;Elsestr. 47&quot;,80687,&quot;Munich&quot;,&quot;Germany&quot;)               
&gt;&gt;&gt; val jetbrains = Company(&quot;JetBrains&quot;,address)                
&gt;&gt;&gt; val person = Person(&quot;Dmitry&quot;,jetbrains)                

&gt;&gt;&gt; printShippingLabel(person)
Elsestr.47
80687 Munich.Germany

&gt;&gt;&gt; printShippingLable(Person(&quot;Alexey&quot;,null))
java.lang.IllegalArgumentException:No address</code></pre>
<p><strong>如果一切正常，函数printShippingLable会打印出标签。如果地址不存在，它不会只是抛出一个带行号的NullPointerException，相反，它会报告一个有意义的错误。</strong>如果地址存在，标签会包含街道地址、邮编、城市和国家。留意之前说过的with函数是如何被用来避免在一行中重复四次address的。</p>
<h3 id="6-1-5-安全转换-“as-”"><a href="#6-1-5-安全转换-“as-”" class="headerlink" title="6.1.5 安全转换 “as?”"></a>6.1.5 安全转换 “as?”</h3><p>“as”用来转换类型的常规Kotlin运算符，<strong>和常规的Java类型转换一样，如果被转换的值不是你试图转换的类型，就会抛出ClassCastException异常。</strong></p>
<p><strong>“as?”运算符尝试把值转换成指定的类型，如果值不是合适的类型就返回null</strong></p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210414230332.png" alt="安全转换运算符尝试把值转换成给定的类型。如果类型不合适就返回null"></p>
<p><strong>一种常见的模式是把安全转换和Elvis运算符结合使用。</strong></p>
<pre><code class="kotlin">/*    使用安全转换实现equals    */
class Person(val firstName:String,val lastName:String){
    override fun equals(o:Any?):Boolean{
        val otherPerson = o as? Person ?: return false    // 检查类型，如果不匹配就返回false
        return otherPerson.firstName == firstName &amp;&amp; otherPerson.lastName == lastName    //在安全转换之后，变量otherPerson被智能地转换为 Person 类型
    }
    override fun hashCode():Int = firstName.hashCode() * 37 + lastName.hashCode()
}
&gt;&gt;&gt; val p1 = Person(&quot;Dmitry&quot;,&quot;Jemerov&quot;)
&gt;&gt;&gt; val p2 = Person(&quot;Dmitry&quot;,&quot;Jemerov&quot;)
&gt;&gt;&gt; println(p1 == p2)
true
&gt;&gt;&gt; println(p1.equals(42))
false</code></pre>
<p><strong>使用这种模式，可以非常容易地检查实参是否是适当的类型，转换它，并在它的类型不能确定是返回false，而且这些操作全部在同一个表达式中。</strong>当然，这种场景下智能转换也会生效：当你检查过类型并拒绝了null值，编译器就确定了变量otherPerson值的类型是Person并当你能够相应的使用它。</p>
<h3 id="6-1-6-非空断言：“-”"><a href="#6-1-6-非空断言：“-”" class="headerlink" title="6.1.6 非空断言：“!!”"></a>6.1.6 非空断言：“!!”</h3><p>非空断言：</p>
<p><strong>它使用双感叹号表示，可以把任何值转换成非空类型。如果对null值做非空断言，则会抛出异常。</strong></p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210414234748.png" alt="通过使用非空断言，如果值为null，可以显式地抛出异常"></p>
<p><strong>使用非空断言来吧可空的实参转换成非空。</strong></p>
<pre><code class="kotlin">/*    使用非空断言    */
fun ignoreNulls(s:String?){
    val sNotNull:String = s!!    // 异常指向这一行
    println(sNotNull.length)
}
&gt;&gt;&gt; igoreNulls(null)
Exceptin in thread &quot;main&quot; kotlin.KotlinNullPointerException
    at &lt;...&gt;.ignoreNulls(07_NotnullAssertions.kt:2)</code></pre>
<blockquote>
<p>如果上面函数中s为null会发生什么？Kotlin没有其他选择，它会在运行时抛出一个异常（一种特殊的NullPointerException）。但是注意异常抛出的位置是非空断言所在的哪一行，而不是接下来试图使用那个值的一行。本质上，你在告诉编译器：“我知道这个字不为null，如果我错了我准备好啦接收这个异常。”</p>
<blockquote>
<p>注意：Kotlin的设计者试图说服你思考更好的解决方案，这些方案不会使用断言这种编译器无法验证的方法。</p>
</blockquote>
<p>但是确实存在这种情况，某些问题适合使用非空断言来解决。当你在一个函数中检测一个值是否为null，而在另一个函数中使用这个值时，这种情况下编译器无法识别这种用法是否安全。（也就是使用前检查他是否为null）</p>
</blockquote>
<h3 id="6-1-7-“let”-函数"><a href="#6-1-7-“let”-函数" class="headerlink" title="6.1.7 “let” 函数"></a>6.1.7 “let” 函数</h3><p><strong>用来处理可空表达式。和安全调用运算符一起使用，允许你对表达式求值，检查求值结果是否null，并把结果保存为一个变量。</strong></p>
<pre><code class="kotlin">
/*    使用let调用一个接收非空参数的函数    */
fun sendEmailTo(email : String){
    println(&quot;Sending emaill to $emaill&quot;)
}

&gt;&gt;&gt; var email:String ? = &quot;yole@example.com&quot;
&gt;&gt;&gt; email?.let{sendEmailTo(it)}
Sending email to yole@example.com
&gt;&gt;&gt; emaill = null
&gt;&gt;&gt; emaill?.let{    sendEmailTo(it)        }</code></pre>
<blockquote>
<p>所以说只有这段表达式不为空时才会执行代码块里的代码</p>
</blockquote>
<h3 id="6-1-8-延迟初始化的属性"><a href="#6-1-8-延迟初始化的属性" class="headerlink" title="6.1.8 延迟初始化的属性"></a>6.1.8 延迟初始化的属性</h3><p><strong>使用延迟初始化属性的原因</strong></p>
<blockquote>
<p>Kotlin 通常要求你在构造方法中初始化所有属性，如果某个属性是可空类型，你就必须提供一个非空的初始化值。否则，你就必须使用可空类型。如果你这样做，该属性的每一次访问都需要null检查或者”!!”运算符</p>
</blockquote>
<p><strong>使用非空断言访问可控属性</strong></p>
<pre><code class="kotlin">/*    使用非空断言访问可空属性    */
class MyService{
    fun performAction():String = &quot;foo&quot;
}
class MyText{
    private var myService : MyService ?= null    // 声明了一个可空类型初始化为 null
    @Before fun setUp(){    // 在 setUp方法中提供真正的初始化器
        myService = MyService()
    }
    @Test fun testAction(){
        Assert.assertEquals(&quot;foo&quot;,myService!!.performAction())    // 必须注意可空性：要么用&quot;!!&quot;，要么用&quot;?.&quot;
    }
}</code></pre>
<pre><code class="kotlin">/*    使用延迟初始化属性    */
class MyService{
    fun performAction():String = &quot;foo&quot;
}
class MyText{
    private lateinit var myService : MyService    // 声明了一个不需要初始化器的非空类型属性
    @Before fun setUp(){    // 在 setUp 方法中初始化 myService
        myService = MyService()
    }
    @Test fun testAction(){
        Assert.assertEquals(&quot;foo&quot;,myService.performAction())    // 不需要 null 检查直接访问属性
    }
}</code></pre>
<p>注意</p>
<blockquote>
<p>初始化的属性必须为var，因为需要在构造方法外修改它的值，使用val属性被编译时必须在构造方法中初始化final片段。</p>
<p>尽管 myService 属性是非空的，你不需要在构造方法中初始化它。在属性没有被初始化之前调用会得到异常 “lateinit property myService has not been initialized”。</p>
<blockquote>
<p>lateinit 属性常见的一种用法是在依赖注入。在某种情况下，lateinit 属性的值是被依赖注入框架从外部设置的。为了保证和各种依赖注入框架的兼容性</p>
<p>，Kotlin 会自动生成一个和 lateinit 属性具有相同可见性的字段。如果属性的可见性是public，生成字段也是可见性public</p>
</blockquote>
</blockquote>
<h3 id="6-1-9可空类型的扩展"><a href="#6-1-9可空类型的扩展" class="headerlink" title="6.1.9可空类型的扩展"></a>6.1.9可空类型的扩展</h3><blockquote>
<p>为可空类型定义扩展函数。可以允许接收者（调用者）为空null 的（扩展函数）调用，并在该函数中处理null，而不是在确保变量不为null之后再调用它的方法。</p>
<p><strong>只有扩展函数才能做到这一点，普通成员方法的调用是通过对象实例来分发的，因此实例为null时（成员方法）永远不能被执行。</strong></p>
</blockquote>
<p>Kotlin标准库中定义的String的两个扩展函数isEmpty和isBlanck就是这样的例子。第一个函数判断字符串是否是一个空的字符串“”。第二个函数则判断它是否是空的或者它只包含空白字符。通常用这些函数来检查字符串中是否有价值的，以确保对它的操作是由意义的。</p>
<p><strong>像这种无意义的空字符串和空白字符串这样处理null也很有用。事实上，你的确可以这样做：函数isEmptyOrNull和isNullOrBlank就可以由String?类型的接收者调用（用于可空类型接收者调用）。</strong></p>
<pre><code class="kotlin">/*    用可空接收者调用扩展函数    */
fun verifyUserInput(input:String?){
    if (input.isNullOrBlank()){    //不需要安全调用
        println(&quot;Please fill in the requied fileds&quot;)
    }
}

&gt;&gt;&gt; verifyUserInput(&quot; &quot;)    //可空类型的扩展函数在接收者为空时也可以调用
Please fill in the required fields
&gt;&gt;&gt; verifyUserInput(null)
Please fill in the required fields</code></pre>
<p>不需要安全访问，就可以直接为可控接收者声明扩展函数</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210417170332.png" alt="不需要安全调用就可以访问可空类型的扩展"></p>
<p><strong>函数isNullOrBlank显式地检查了null，这种情况下返回true，然后调用isBlank，它只能在非空String上调用：</strong></p>
<pre><code class="kotlin">fun String?.isNullOrBlank():Boolean =    //可空字符串的扩展
        this == null || this.isBlank    //第二个“this”使用了智能转换</code></pre>
<blockquote>
<p>当你为一个可空类型（以?结尾）定义扩展函数时，这意味着你可以对可空的值调用这个函数；并且函数体中的this可能为null，所以你必须显式地价差。在Java中，this永远是非空的，因为它引用的时当前你所在这个类的实例。而在Kotlin中，这并不永远成立：在可空类型的扩展函数中，this可以是null的。</p>
<p>let函数也能被可空的接收者调用，但它并不检查值是否为null。如果你在一个可空类型上调用let函数，而没有使用安全调用运算符，lambda的实参将会是可空的：</p>
<p>（let检查是否为null，并把结果保存为一个变量）</p>
<pre><code class="kotlin">&gt;&gt;&gt; val person:Person?=...    // 可空类型的非空属性
&gt;&gt;&gt; person.let{ sendEmailTo(it) }    // 没有安全调用，所以“it”是可空类型
ERROR:Type mismatch:inferred type is Person? but Person was expected</code></pre>
<p><strong>使用let来检查非空的实参，必须使用安全调用运算符“?.”，就像代码：person?.let{ sendEmailTo(it) }。</strong></p>
<blockquote>
<p>当你定义自己的扩展函数时，需要考虑该扩展是否需要为可空类型定义。默认情况下，应该把它定义成会空类型的扩展函数。在发现大部分情况下需要在可空类型上使用这个函数，再安全的修改它。</p>
</blockquote>
</blockquote>
<h3 id="6-1-10-类型参数的可空性"><a href="#6-1-10-类型参数的可空性" class="headerlink" title="6.1.10 类型参数的可空性"></a>6.1.10 类型参数的可空性</h3><p>Kotlin 中<strong>所有泛型类和泛型函数的类型参数默认</strong>都是可空的。</p>
<p>任何类型，包括可空类型在内，都可以替换类型参数。这种情况下，使用类型参数作为类型的声明都允许为null，尽管类型参数T并没有用问号结尾。</p>
<p>例子：</p>
<pre><code class="kotlin">/*    处理可空的类型参数    */
fun &lt;T&gt; printHashCode(t:T){
    println(t?.hashCode())    //因为”T“ 可能为null，所以必须使用安全调用
}
&gt;&gt;&gt; printHashCode(null)    //”T“被推导为”Any?“
null</code></pre>
<p>在printHashCode调用中，类型参数T推导出的类型是可空类型Any?。    因此，尽管没有用问号结尾，实参t依然允许持有null。</p>
<p><strong>要使类型参数非空（不为空）必须要为它指定一个非空的上界，那样泛型就会拒绝可空值作为实参。</strong></p>
<pre><code class="kotlin">/*    为类型参数声明非空三界    */
fun &lt;T:Any&gt; printHashCode(t:T){    //现在”T“就不是可空的
    println(t.hashCode())
}
&gt;&gt;&gt; printHashCode(null)    //这段代码是无法编译的：你不能传递null，因为期望值是非空值。
Error:Type paramater bound for &#39;T&#39; is not asthisfied
&gt;&gt;&gt; printHashCode(42)
42</code></pre>
<p>注意必须使用问号结尾来标记类型为可空的，没有问号就是非空的。类型参数是这个规则唯一的例外。（在使用三界后，想使用可空类型就要加问号来标记可空。）</p>
<h3 id="6-1-11-可空性和Java"><a href="#6-1-11-可空性和Java" class="headerlink" title="6.1.11 可空性和Java"></a>6.1.11 可空性和Java</h3><p>Kotlin 引以为傲的是和Java的互操作性，而你知道Java类型系统是不支持可空性的。在你混合使用Kotlin和Java时会发生什么？会不会失去所有的安全性？或者每个值都必须检查是否为null？</p>
<blockquote>
<p>有些时候Java代码包含了可空性的信息，这些信息用注解来表达。</p>
<p><strong>当代码中出现了这些信息时，Kotlin就会使用。因此Java中@Nullable string 被Kotlin当作String?(可空类型)，而@NotNull String就是String(不为空类型)</strong></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210419170543.png" alt="根据Java类型识别的注解，Java类型回在Kotlin中表示为可空类型和非空类型"></p>
<p>Kotlin 可以识别多种不同风格的可空性注解，包括JSR-305标准的注解（在javax.annotation包之中）、Android的注解（android.support.annotation包之中）和JetBrains工具支持的注解（org.jetbrains.annotation）。</p>
<p><strong>如果这些注解不存在会发生什么？</strong></p>
<p><strong>Java 类型会变成Kotlin中的平台类型</strong></p>
<p><strong>平台类型</strong></p>
<blockquote>
<p><strong>平台类型本质上就是Kotlin不知道可空性信息的类型</strong>。<strong>即可以把它当作可空类型处理，也可以当作会空类型处理</strong>。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210420145256.png" alt="Java类型在Kotlin中表示为平台类型，既可以把它当作可空类型也可以当作会空类型来处理"></p>
<blockquote>
<p>这意味着，你要像在Java中意义，对你在这个类型上做的操作负全部责任。编译器将会允许所有的操作，它不会把对这些字的空安全操作高亮多余的，但它平时确实这样对待会空类型值上的空安全操作。<strong>如果你认为这个字为null，在使用它之前可以用它和null进行比较。如果你认位它不为null，就直接使用它。就像在Java中一样，如果你错误地理解了这个值，使用的时候就会遇到NullPointerException。</strong></p>
</blockquote>
<p><strong>例子</strong></p>
<pre><code class="java">/*    没有可空性注解的Java类    */
public class Person{
    private final String name;
    public Person(String name){
        this.name = name
    }
    public String getName(){
        return name
    }
}</code></pre>
<blockquote>
<p>getName能不能返回null?这种情况下Kotlin编译器完全不知道String类型的可空性，所以你必须处理它。<strong>如果你确定name不为null，就可以像Java中一样按照通常的方式对它解引用，不需要额外的检查。但是这种情况下请准备好接受异常。</strong></p>
</blockquote>
<pre><code class="kotlin">/*    不使用null检查访问Java类    */
fun yellAt(person:Person){
    println(person.name.toUpperCase()+ &quot;!!!&quot; )    //toUpperCase()调用的函数接收者person.name为null，所以这里会抛出异常
}
&gt;&gt;&gt; yellAt(Person(null))
java.lang.IllegalArgumentException:Paramater specified as non-null is null: method toUpperCase, parameter $receiver</code></pre>
<blockquote>
<p>注意，这里你看到的不是一个NullPointerException，而是一条更详细的错误信息，告诉你方法toUpperCase不能在null的接收者上调用。</p>
<p><strong>对于公有的Kotlin函数，编译器生成对每个非空类型的参数（和接收者）的检查和，所以使用不正确的参数的调用尝试都立即被报告为异常。（在使用参数前会检查非空的参数。）</strong></p>
<p>这种值检查在函数调用的时候就执行，而不是等到这些参数被使用的时候。这确保了不正确的调用会被尽早的发现，那些由于null值被传给代码不同层次的多个函数之后，并被这些函数访问时而产生的难以理解的异常就能被避免。</p>
</blockquote>
<p>把getName()的返回类型解释为可空的并安全的访问它。</p>
<pre><code>/*    使用null检查来访问的Java类    */
fun yellAtSafe(person:Person){
    println((person.name?:&quot;Anyone&quot;).toUpperCase()+&quot;!!!&quot;)
}

&gt;&gt;&gt; yellAtSafe(null)
ANYONE!!!</code></pre><blockquote>
<p>Java API 中大部分库没有（可空性）注解，所以可以把所有类型都解释为非空，但是会导致错误。为了避免错误，你应该阅读Java方法的文档（必要时还要查看它的实现），并知道它上面时候返回null，并给那些返回加上检查。</p>
<blockquote>
<p>为什么需要平台类型？</p>
<p>对 Kotlin 来说，把来自Java的所有值都当成可空的是不是更安全？这种设计也许可行，但是这需要对永远不为空的值做大量冗余的null检查，因为Kotlin编译器无法了解到这样的信息。</p>
<p>涉及泛型的话这种新款就更加糟糕了。例如，在Kotlin中，每次来自Java的ArrayList<String>都被当作ArrayList&lt;String?&gt;?，每次访问或者转换类型都需要检查这些值是否为null，这样抵消掉安全性带来的好处。编写这样的检查非常令人厌烦，所以Kotlin的设计者做出了更实用的选择，让开发者负责正确处理来自Java的值</p>
</blockquote>
</blockquote>
<p>在<strong>Kotiln中不能声明一个平台类型（不知道可空信息的）的变量</strong>，这些信息只能来自Java代码，但你可能会在IDE的错误信息中见到它们。</p>
<pre><code class="kotlin">&gt;&gt;&gt; val i:Ine = person.name
ERROR:Type mismatch: inferred type is String! but Int was expected</code></pre>
<blockquote>
<p>String! 表示法被Kotlin编译器用来表示来自<strong>Java代码的平台类型</strong>。你不能在自己的代码中使用这种语法。而且感叹号通常与问题的来源无关，所以通常可以忽略它。<strong>这只是在强调类型的可空性是未知的。</strong></p>
</blockquote>
<p><strong>你可以用你喜欢的方式来解释平台类型，既可以是可控的也可以是非空的。</strong></p>
<pre><code class="kotlin">&gt;&gt;&gt; val s:String?=person.name    //可空
&gt;&gt;&gt; val s1:String = person.name    //非空</code></pre>
<p><strong>如果你用来自Java的null值给一个非空的Kotlin变量赋值，在赋值的瞬间你就会得到异常。</strong>你需要正确的理解可空性。</p>
<p><strong>继承</strong></p>
<p>Kotlin 重写Java的方法时，<strong>可以选择把参数和返回类型定义成可空的，也可以选择把它们定义成非空的。</strong></p>
<p><strong>例子</strong></p>
<pre><code class="java">/*    Java中的StringProcessor接口    */
interfece StringProcessor{
    void process(String value);
}</code></pre>
<p>Kotlin 中下面的两种实现编译器都可以接收。</p>
<pre><code class="kotlin">/*    实现Java接口时使用不同的参数可空性    */
class StringPrinter:StringProcessor{
    override fun process(value:String){
        pritlin(value)
    }
}
class NullableStringPrinter:StringProcessor{
    override fun process(value:String?){    // 参数可空
        if(value != null){
            println(value)
        }

    }
}</code></pre>
<blockquote>
<p>在实现Java类或者接口的方法时一定要搞清楚它的可空性。<strong>因为方法实现可在非Kotlin的代码中被调用，Kotlin编译器会为你声明的每个非空的参数生成非空断言。</strong>如果Java代码传给这个方法一个null值，断言就会触发，你就会得到一个异常，即便你从来没有在你的实现中访问过这个参数的值。</p>
</blockquote>
<h2 id="6-2-基本数据类型和其他基本类型"><a href="#6-2-基本数据类型和其他基本类型" class="headerlink" title="6.2 基本数据类型和其他基本类型"></a>6.2 基本数据类型和其他基本类型</h2><p>描述程序中的基本数据类型，例如Int、Boolean和Any。</p>
<p>与Java不同，Kotlin并不区分基本数据类型和它们的包装类。</p>
<h3 id="6-2-1-基本数据类型：Int、Boolean及其他"><a href="#6-2-1-基本数据类型：Int、Boolean及其他" class="headerlink" title="6.2.1 基本数据类型：Int、Boolean及其他"></a>6.2.1 基本数据类型：Int、Boolean及其他</h3><blockquote>
<p><strong>Java把基本数据类型和引用类型做了区分。</strong></p>
<p>一个基本数据类型（如int）的变量直接存储了它的值，而一个引用类型（如String）的变量存储的时指向包含该对象的内存地址的引用。</p>
</blockquote>
<blockquote>
<p>基本数据类型的只能够更高效地存储和传递，但你不能对这些值调用方法，或是它们存放在集合中。</p>
<p><strong>Java提供了特殊的包装类型（比如java.lang.Integer),在你需要对象的是否对基本数据类型进行封装。因此，你不能用Collection<int>来定义一个整数的集合，而必须用Collection<integer>来定义。</strong></p>
</blockquote>
<blockquote>
<p><strong>Kotlin 并不区分基本数据类型和包装类型，</strong>永远是同一个类型（比如int）</p>
<pre><code class="kotlin">val i:Int = 1
val list:List&lt;Int&gt; = listOf(1,2,3)</code></pre>
<p>同时还能对数字类型的值调用方法。</p>
<pre><code class="kotlin">/*    使用标准库的函数coerceIn来把值限制在特定范围内    */
fun showProgress(progress:Int){
    val percent = progress.coerceIn(0,100)
    println(&quot;We&#39;re ${percent}% done!&quot;)
}
&gt;&gt;&gt; showProgress(146)
We&#39;re 100% done!</code></pre>
<p>虽然没有区分基本数据类型和包装类型，但是这不意味着Kotlin使用对象来表示所有数组！</p>
<p><strong>在运行时，数字类型会尽可能地使用最高效的方式来表示。大多数形况下——对于变量、属性、参数和返回类型——Kotlin的Int类型会被编译成Java基本类型int。唯一不可行的例外是泛型类，例如集合。用作泛型参数的基本数据类型会被编译成对应的包装类。例如，Int类被用作集合类型的类型参数时，集合类将会保存对应包换类型java.lang.Integer的实例。</strong></p>
</blockquote>
<p><strong>Java基本数据类型完整列表</strong></p>
<ul>
<li>整数类型——Byte、Short、Int、Long</li>
<li>浮点整数类型——Float、Double</li>
<li>字符类型——Char</li>
<li>布尔类型——Boolean</li>
</ul>
<p><strong>就像Int 这样的Kotlin类型在底层可以轻易的编译成对应的Java基本类型，因为两种类型都不能存储null引用。当你在Kotlin中使用Java声明时，Java基本数据类型就会变成非空类型（而不是平台类型），因为它们不能持有null值。</strong></p>
<h3 id="6-2-2-可空基本数据类型：Int-、Boolean？及其他"><a href="#6-2-2-可空基本数据类型：Int-、Boolean？及其他" class="headerlink" title="6.2.2 可空基本数据类型：Int?、Boolean？及其他"></a>6.2.2 可空基本数据类型：Int?、Boolean？及其他</h3><blockquote>
<p>Kotlin中的可空类型不能用Java的基本数据类型表示，因为null只能被存储在Java的引用类型的变量中。这意味着任何时候使用了基本数据类型的可空版本，它就会被编译成对应的包装类。</p>
</blockquote>
<pre><code class="kotlin">/*    名字永远已知的Person类，但是年龄可能未知或者未指定。添加函数检查一个人是否比另一个人年长    */
class Person(val name:String,val age:Int ?= null){
        fun isOlderThan(other:Person):Boolean?{
            if(age == null ||other.age == null)
                return null
            return age &gt; other.age
        }
}

&gt;&gt;&gt; println(Person(&quot;Sam&quot;,35).isOlderThan(Person(&quot;Amy&quot;,42)))
false
&gt;&gt;&gt; println(Person(&quot;Sam&quot;,34).isOlderThan(Person(&quot;Jane&quot;)))
null</code></pre>
<p><strong>注意，普通的可空性规则如何在这里引用。</strong>你不能就这样比较两个值，因为它们当中任何一个都可能为null。你必须检查两个值都不为null。</p>
<p>Person类声明的age属性的值被当作java.lang.Integer存储（包装类）。但是只有在你使用来自Java的类时这些细节才有意义。为了在Kotlin中选出正确的类型，你只需要考虑对变量或者属性来说，null是否是它们可能的值。</p>
<p><strong>泛型类（ArrayList<Integer>)是包装类型应用的另一种情况。如果你用基本数据类型作为泛型类的参数类型，那么Kotlin会使用该类型的包装形式（Int ==&gt; Integer）</strong></p>
<p>创建一个Integer包装类的列表，<strong>尽管没有指定过可空类型或者用过null值</strong></p>
<pre><code class="kotlin">val listOfInts = listOf(1,2,3)</code></pre>
<p>这是由Java虚拟机实现泛型的方式决定的。JVM不支持用基本数据类型作为类型参数，所以泛型类（Java和Kotlin一样）必须始终使用类型的包装表示。<strong>因此，你要高效的存储基本数据类型元素的大型集合，要么使用支持这种集合的第三方库（如Trove4J）要么使用数组来存储。</strong></p>
<h3 id="6-2-3-数字转换"><a href="#6-2-3-数字转换" class="headerlink" title="6.2.3 数字转换"></a>6.2.3 数字转换</h3><p>Kotlin和Java<strong>之间一条重要的区别就是处理数字转换的方式。</strong>Kotlin不会自动的把数字从一种类型转换成另一种，即便是转换范围更大的类型。</p>
<pre><code class="kotlin">val i = 1
val i : Long = i    //错误：类型不匹配</code></pre>
<p>正确的转换</p>
<pre><code class="kotlin">val i = 1
val l:Long = i.toLang()</code></pre>
<blockquote>
<p>基本数据类型类型（Boolean除外）都定义有转换函数：toByte()、toShort()、toChar()等。这些函数支持双向转换：既可以把 小范围的类型扩展到大范围，比如Int.toLong(),也可以把大范围的类型截取到小范围，比如Long.toInt()。</p>
<p>Kotlin 要求转换必须是显式的，尤其是在比较<strong>装箱值</strong>的时候。比较两个装箱值的equals方法不仅会检查它们存储的值，还会比较装箱类型。所以，在Java中new Integer(42).equals(new Long(42)) 会返回false。</p>
<blockquote>
<p>Java中的装箱和拆箱</p>
<p><strong>装箱和拆箱是从Java1.5开始引入的，它的目的是将原始类型值自动地转换成对应的对象。</strong>自动装箱机制可以让我们在Java的变量赋值或者其他方法调用等情况下使用原始类型或者对象类型更加简单直接。</p>
</blockquote>
</blockquote>
<p>假如 Kotlin 支持隐式转换，</p>
<pre><code class="kotlin">val x = 1    // Int变量
val list = listOf(1L,2L,3L)    //Long值列表
x in list //假如支持隐式转换它仍然是 false</code></pre>
<blockquote>
<p>因此，上列中 x in list 根本不会编译。Kotlin要求你显式的转换类型，这样只有类型相同的值才比较：</p>
<pre><code class="kotlin">&gt;&gt;&gt; val x = 1
&gt;&gt;&gt; println(x.toLong() in listOf(1L,2L,3L))
true</code></pre>
<p>在代码中用到不同的数据类型，你必须显式的转换这些变量，来避免意想不到的结果。</p>
</blockquote>
<blockquote>
<p><strong>基本数据类型字面值</strong></p>
<ul>
<li>使用后戳L表示Long类型(长整型)字面值:123L.</li>
<li>使用标准浮点数表示Double(双浮点精度)字面值:0.12、2.0、1.2e10、1.2e-10。</li>
<li>使用F表示Float类型（浮点数）字面值：123.4f、.345F、1e3f。</li>
<li>使用前戳0x或者0X表示十六进制字面值：0xCAFEBABE或者0xbcdL。</li>
<li>使用前戳0b或者0B表示二进制字面值：0b000000101.</li>
</ul>
<p>在Kotlin1.1才开始支持数字字面值中的下划线。对字符字面值来说，可以使用和Java几乎一样的语法。把字符卸载单引号中，必要时还可以使用转义序列。有效的Kotlin字符字面值：‘1’、‘/t’（制表符）、‘\u0009’（使用Unicode转义序列表示的制表符）。</p>
</blockquote>
<blockquote>
<p>当你在书写数字字面值的时候，一般不需要使用转换函数。这种（字面值）特殊的语法来显示地标记常量类型，例如42L或者42.0f。即使你没有使用这种语法，数字字面值去初始化一个类型已知的变量是（Ine 类型已知，初始化为Long），又或是把字面值当作实参传递给函数时，必要的转换会自动发生。  算数运算符也会被重载，它们可以接收所有适当的数字类型。</p>
<pre><code class="kotlin">/*    如下的代码并没有任何显式的转换却可以正常工作过    */
fun foo(l:Long) = println(l)

&gt;&gt;&gt; val b:Byte = 1    //常量有正确的类型
&gt;&gt;&gt; val l = b+1L    //+可以进行直接类型和长整型参数的计算
&gt;&gt;&gt; foo(42)    // 编译器认为42是一个长整型
42</code></pre>
<blockquote>
<p>Koylin算术运算符关于数值范围溢出的行为和Java完全一直；Kotlin并没有引入由溢出检查带来的额外开销。</p>
</blockquote>
</blockquote>
<p><strong>字符串转换</strong></p>
<blockquote>
<p>Kotlin 标准库提供了一套相似的扩展方法，用来把字符串转换成基本数据类型（toInt、toByte、toBoolean、等）。</p>
<pre><code class="kotlin">&gt;&gt;&gt; println(&quot;42&quot;.toInt())
42</code></pre>
<p>函数会尝试把字符串的内容解析成对应的函数，如果解析失败抛出NumberFormatException。</p>
</blockquote>
<h3 id="6-2-4-“Any”和“Ant？”：根类型"><a href="#6-2-4-“Any”和“Ant？”：根类型" class="headerlink" title="6.2.4 “Any”和“Ant？”：根类型"></a>6.2.4 “Any”和“Ant？”：根类型</h3><blockquote>
<p><strong>和Ojbect作为Java类层级结构的根差不多，Any类型是Kotlin所有非空类型的超类型（非空类型的根）。</strong>而在Java中，Object只是所有应用类型的超类型（引用类型的的根），而基本数据类型并不是类层级结构的一部分。这意味着当你需要Object的时候，不得不使用java.long.Integer这样的包装类型来表示基本数据类型的值。<strong>而在Kotlin中，Any是所有类型的超类型（所有类型的根），包括像Int这样的基本数据类型。</strong></p>
</blockquote>
<p>基本数据类型的值赋给Any类型的变量时会自动装箱：</p>
<pre><code class="kotlin">val answer:Any = 42    \\Any是引用类型，所以值42会被装箱</code></pre>
<p><strong>Any是非空类型，所以Any类型的变量不可以持有null值。Kotlin中想要持有任何可能的变量，包括null在内，必须使用Any?类型。</strong></p>
<blockquote>
<p>在底层，Any类型对应java.lang.Object。Kotlin把Java方法参数和返回类型中用到的Object类型看作Any（更确切的说是当作平台类型，因为其可空性是位置的）。当Kotlin函数使用Any时，它会被编译成Java字节码中的Object。</p>
</blockquote>
<h3 id="6-2-5-Unit-类型：Kotlin的“void”"><a href="#6-2-5-Unit-类型：Kotlin的“void”" class="headerlink" title="6.2.5 Unit 类型：Kotlin的“void”"></a>6.2.5 Unit 类型：Kotlin的“void”</h3><p><strong>Kotlin中的Unit类型和Java中void是一样的功能</strong>。在函数没有什么需要返回的时候，Unit可以用作函数的返回类型：</p>
<pre><code class="kotlin">fun f(): Unit{...}
fun f(){...}    //省略Unit声明</code></pre>
<p>两个代码块的结果是相同的。</p>
<p>大多数情况下你不会留意到void和Unit之间的区别。<strong>如果你的Kotlin函数使用Unit作为返回类型并且没有重写泛型函数，在底层它会被编译成旧的void函数。如果你要在Java中重写这个函数，新的Java函数需要返回void。</strong></p>
<p><strong>Kotlin中的Unit和Java中的void到底有那些不同？</strong></p>
<blockquote>
<p>Unit是一个完整的类型，可以作为类型参数，而void却不行。只存在值是Unit类型，这个值也叫Unit，并且会被隐式地返回。当你在重写返回泛型参数的函数</p>
<p>时会非常有用只需要让方法返回Unit类型的值：</p>
<pre><code class="kotlin">interface Processor&lt;T&gt;{
    fun process():T
}
class NoResultProcessor:Processor&lt;Unit&gt;{
    override fun process(){    // 返回 Unit ，这里可以省略类型说明
        // do stuff
    }    // 这里不需要显式的return
}</code></pre>
<p>接口签名要求process函数返回一个值；而且，因为Unit类型确实有值，所以从方法中返回它并没有问题。然而你不需要在NoResultProcessor.process函数中写上显式的return语句，因为编译器会隐式地加上return Unit.</p>
</blockquote>
<p>在与Java对比中，Java中为了解决使用“没有值”作为类型参数的任何一个可能解法，都没有Kotlin好用。一种是分开接口定义来表示需要和不需要返回值的接口（如Callable和Runnable）。另一种使用特殊的java.lang.Void类型作为类型参数。即便你使用了后面这种方法，你还是需要加入return null；语句来返回唯一能匹配这个类型的值，因为只要返回类型不是void，你就必须始终有显式的return语句。</p>
<p>在函数式编程语言中，Unit这个名字习惯上被用来表示“只有一个实例”，这正是Kotlin和Java的void的区别。</p>
<h3 id="6-2-6-Nothing类型：“这个函数永不返回”"><a href="#6-2-6-Nothing类型：“这个函数永不返回”" class="headerlink" title="6.2.6 Nothing类型：“这个函数永不返回”"></a>6.2.6 Nothing类型：“这个函数永不返回”</h3><p><strong>解释了为什么要创建Nothing类型</strong></p>
<blockquote>
<p>对于某些Kotlin函数来说，“返回类型的概念没有任何意义，因为它从来不会成功地结束。例如，许多测试库都有一个叫fail的函数，它通过抛出带有特定信息的异常来让当前测试失败。一个包含无限循环的函数也永远不会成功地结束。</p>
</blockquote>
<p>分析调用函数代码时，知道函数永远不会正常结束是很有帮助的。Kotlin 使用Nothing这种特殊的返回类型来表示:</p>
<pre><code class="kotlin">fun fail(message:String):Nothing{
    throw IllegalStateException(message)
}
&gt;&gt;&gt; fail(&quot;Error occurred&quot;)
java.lang.IllegalStateException:Error occurred</code></pre>
<p>Nothing 类型没有任何值，只有被当作函数返回值使用，或者被当作泛型函数返回值的类型参数使用才会有意义。在其他情况下，声明一个不能存储任何值的变量是没有意义的。</p>
<p>Nothing函数可以放在Elvis运算符的右边来做先决条件检查：</p>
<pre><code class="kotlin">val address = company.address?:fail(&quot;No address&quot;)
println(address.city)</code></pre>
<p><strong>编译器知道这种返回类型的函数从不终止，然后在分析调用这些函数的代码时利用这个信息。</strong>上例，编译器会把address的类型推断成非空，因为它为null时的分支处理会始终抛出异常。</p>
<h2 id="6-3-集合与数组"><a href="#6-3-集合与数组" class="headerlink" title="6.3 集合与数组"></a>6.3 集合与数组</h2><p>Kotlin以Java集合库为基础构建，并通过扩展函数增加的特性来增强它。</p>
<h3 id="6-3-1-可空性和集合"><a href="#6-3-1-可空性和集合" class="headerlink" title="6.3.1 可空性和集合"></a>6.3.1 可空性和集合</h3><p>我们讨论了可空类型的概念，但仅仅简略的谈到类型参数的可空性。对前后一致的类型系统来说十分关键<strong>：知道集合是否可以持有null元素，和知道变量值是否可以为null同等重要。Kotlin完全支持类型参数的可空性。就像变量的类型可以加上？字符来表示变量可以持有null一样，类型在被当作类型参数时也可以用同样的方式标记。</strong></p>
<p>这个函数从一个文件中读取文本行的列表，并尝试把每一行文本解析成数字。</p>
<pre><code class="kotlin">/*    创建一个可以包含可空值的集合    */
fun readNumbers(reader: BufferedReader): List&lt;Int?&gt;{
    var result = ArratList&lt;Int?&gt;()    //创建包含可空Int值的列表
    for (line in reader.lineSequence()){
        try{
            val number = line.toInt()
            result.add(number)    // 向列表中添加整数（非空）
        }
        catch(e: NumberFormatException){
            result.add(null)    //向列表添加 null，因为当前行不能被解析成整数。
        }
    }
    return result
}</code></pre>
<blockquote>
<p><strong>如果这一行文本被解析，那么就向result列表中添加一个整数，否则添加null。List&lt;Int?&gt;是能持有Int?类型值的列表：换句话说，可以持有Int或者null。（集合中可以存放null值）。从Kotlin1.1中，可以使用函数String.toIntOrNull来简化例子，字符串不能被解析的时候会返回null。</strong></p>
</blockquote>
<p><strong>变量自己的可空性</strong>和用<strong>作类型参数的类型的可空性是有区别的。</strong>包含<strong>可空Int</strong>的列表和<strong>包含Int的可空列表</strong>之间是有区别的。如下：</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210426224838.png" alt="要小心决定什么是可空的：集合的元素还是集合本身？"></p>
<p>第一种情况，列表本身始终不为null，列表中的每个值都可以为null。第二种类型的变量可能包含空引用而不是列表实例，<strong>但列表中的元素始终保持非空的。</strong></p>
<p>在另一种上下文中，<strong>你可能需要声明一个持有可空的列表，并且包含可空的数字。</strong>Kotlin中的写法是List&lt;Int?&gt;?，有两个问号。在使用变量自己值的时候，<strong>以及使用列表中每个元素的时候，需要使用null检查。（因为内容可能为空，所以在使用时需要做null检查）</strong></p>
<p><strong>如何使用可空值的列表，</strong>如下函数计算列表中有效数字之和，并单独的对无效数字计数。</p>
<pre><code class="kotlin">/*    使用可空值集合    */
fun addValidNumbers(numbers:List&lt;Int?&gt;){
    var sumOfValidNumbers = 0
    var invalidNumbers = 0
    for (number in numbers){    //从列表中读取可空值
        if (number != null){    //检查值是否为null
            sumOfValidNumbers +=number
        }else {
            invalidNumbers++
        }
    }
    println(&quot;Sum of valid numbers: $sumOfValidNumbers&quot;)
    println(&quot;Invalid numbers: $invalidNumbers&quot;)
}

 &gt;&gt;&gt; val reader = BufferedReader(StringReader(&quot;1\nabc\n42&quot;))
 &gt;&gt;&gt; val numbers = readNumber(reader)
 &gt;&gt;&gt; addValidNumbers(numbers)
 Sum of valid numbers: 43
 Invalid numbers:1</code></pre>
<p>当你访问一个列表中的元素时，你得到的是一个类型为Int?的值，并且要在用它进行算数运算之前检查它是否为null。</p>
<p><strong>Kotlin 提供了标准库函数filterNotNull函数，用来遍历一个包含可空值的集合并过滤掉null的操作。</strong></p>
<pre><code class="kotlin">fun addValidNumbers(numbers:List&lt;Int?&gt;){
    val validNumbers = numbers.filterNotNull()
    println(&quot;Sum of valid numbers:${validNumbers.sum()}&quot;)
    println(&quot;Invalid numbers:${numbers.size - validNUmbers.size}&quot;)
}</code></pre>
<p>过滤影响了集合的类型。validNumbers的类型是List<Int>，因此过滤保证了集合不会再包含任何为null的元素。</p>
<h3 id="6-3-2-只读集合与可变集合"><a href="#6-3-2-只读集合与可变集合" class="headerlink" title="6.3.2 只读集合与可变集合"></a>6.3.2 只读集合与可变集合</h3><p><strong>集合分为两种：只读集合和可变集合</strong></p>
<p>Kotlin 的集合设计和Java不同的另一个重要特质是，<strong>它把访问集合数据的接口和修改集合数据的接口分开了。</strong>这种区别存在于最基础的使用集合之中：kotlin.collection.Collection。使用这个接口，可以遍历集合中的元素、获得集合的大小、判断集合中是否包含某个元素，以及执行其他从集合中读取数据的操作。<strong>但这个接口没有任何添加或移除元素的返回</strong>。</p>
<p><strong>使用kotlin.collection.MutableCollection接口可以修改接口中的数据。</strong>它继承了普通的kotlin.collections.Collection接口，并提供了方法来添加和移除、清空集合等。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210510115136.png" alt="MutableCollection继承了Collection并增加了修改集合内容的方法。"></p>
<p>通常规则是在代码的任何地方都应该使用只读接口，只在代码需要修改集合的地方使用可变接口的变体。</p>
<p>就像 val 和 var 之间的分离一样，只读集合接口和可变集合接口的分离能让程序中的数据发生的事情更容易理解。如果函数接收Collection而不是MutableCollection作为形参，你就知道它不会修改集合，而只是读取集合中的数据。如果函数要求你传递给它MutableCollection，可以认为它将会修改数据。如果你使用了集合作为组件部状态的一部分，可能需要把集合先拷贝一份传递给这个函数（这种模式通常称为 <strong>防御式拷贝</strong>）。</p>
<pre><code class="kotlin">/*    使用只读集合接口与可变集合接口    */
fun &lt;T&gt; copyElemets(source: Collection&lt;T&gt;,
                    target: MutableCollection&lt;T&gt;){
    for (item in source){    // 在source集合中的所有元素中循环
        target.add(item)    // 向可变的target集合中添加元素
    }
}
&gt;&gt;&gt; val source:Collection&lt;Int&gt; = arrayListOf(3,5,7)
&gt;&gt;&gt; val target:MutableCollection&lt;Int&gt; = arratListOf(1)
&gt;&gt;&gt; copyElements(source,target)
&gt;&gt;&gt; println(target)
[1,3,5,7]</code></pre>
<p><strong>只读集合类型不能作为可变集合的参数。</strong>不能把只读集合类型的变量作为target参数传给函数，即便它的值是一个可变集合：</p>
<pre><code class="kotlin">&gt;&gt;&gt; val source:Collection&lt;Int&gt; = arrayListOf(3,5,7)
&gt;&gt;&gt; val target:Collection&lt;Int&gt; = arratListOf(1)
&gt;&gt;&gt; copyElements(source,target)
Error: Type mismatch:inferred type is Collection&lt;Int&gt;
    but MutableCollection&lt;Int&gt; was expected</code></pre>
<p>使用集合接口时需要牢记的关键点是 <strong>只读集合是不一定可变的。</strong>如果你使用的变量只有一个只读接口类型，它可能只是同一个集合的众多引用中的一个。任何其他的引用都可能拥有一个可变接口类型。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210516151639.png" alt="两种不同的引用，一个只读，另一个可变，指向同一个集合对象"></p>
<p>如果你调用了这样的代码，它<strong>持有其他指向你集合的引用</strong>，或者并行的运行了这样的代码。你依然会遇到这种状况，你正在使用集合的时候它被其他代码修改了，则会导致concurrentModificationException错误和其他一些问题。因此，<strong>必须了解只读集合并不总是线程安全的。如果你在多线程环境下处理数据，你需要保证代码正确的同步的对数据的访问，或者使用支持并发访问的数据结构。</strong></p>
<h3 id="6-3-3-Kotlin集合和Java"><a href="#6-3-3-Kotlin集合和Java" class="headerlink" title="6.3.3 Kotlin集合和Java"></a>6.3.3 Kotlin集合和Java</h3><p><strong>Kotlin接口是Java接口的实例</strong>。每一个Kotlin接口都是其对应Java集合接口的一个实例。在Kotlin和Java之间转移并不需要转换；不需要包装器也不需要拷贝数据。但每个Kotlin中都有两种表示：一种是只读一种是可变的。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210516154303.png" alt="Kotlin集合接口的层级结构，Java类ArrayList和HashSet都继承了Kotlin可变接口"></p>
<p>Kotlin中只读接口和可变接口的基本构造与 Java.util中的Java集合接口的构造是平行的。可变接口直接对应java.util中的接口，而它们的只读版本缺少了所有产生改变的方法。</p>
<p>Kotlin中Map类（并没有继承Collection或是Interable）也被表示成了两种不同的版本：Map和MutableMap。表中展示了不同集合的函数。</p>
<table>
<thead>
<tr>
<th>集合类型</th>
<th>只读</th>
<th>可变</th>
</tr>
</thead>
<tbody><tr>
<td><strong>List</strong></td>
<td>listOf</td>
<td>mutableListOf、arrayListOf</td>
</tr>
<tr>
<td><strong>Set</strong></td>
<td>setOf</td>
<td>mutableSet、hashSetOf、linkedSetOf、sortedSetOf</td>
</tr>
<tr>
<td><strong>Map</strong></td>
<td>mapOf</td>
<td>mutableMapOf、hashMapOf、linkedMapOf、sortedMapOf</td>
</tr>
</tbody></table>
<p><strong>注意，setOf()和mapOf()返回的是Java标准库中类的实例（至少在Kotlin1.0版本中是这样），在底层它们都是可变的。但你不能完全信赖这一点：Kotlin的未来版本可能会使用真正不可变的实现类作为setOf和mapOf的返回值。</strong></p>
<p><strong>当你需要调用Java方法并把集合作为参数时。例如：使用java.util.Collection做为形参，你可以使用Collection或MutableCollection（只读集合或可变集合）的值作为实参传递给形参。</strong></p>
<p><strong>这时的操作对可变性有重要影响。因为Java并不会区分只读集合与可变集合，即使Kotlin中把集合声明成只读的，Java代码也可以修改这个集合。Kotlin编译器不能完全的分析Java代码到底对集合做了什么，因此Kotlin无法拒绝向可以修改集合的Java代码传递只读Colleciton。</strong>例如，如下代码组成了一个多语言兼容的Kotlin/Java程序：</p>
<pre><code class="java">/*    Java    */
//    ColletionUtils.Java
public class ColletionUtils{
    public static List&lt;String&gt; uppercaseAll(List&lt;String&gt; items){
        for(int i = 0 ;i &lt; items.size(); i++){
            items.set(i,items.get(i).toUpperCase());
        }
        return items
    }
}</code></pre>
<pre><code class="kotlin">/*    Kotlin    */
// collections.kt
fun printInUppercase(list:List&lt;String&gt;){    // 声明只读的参数
    println(CollectionUtils.uppercaseAll(list))    //调用可以修改集合的Java函数
    println(list.first())    //打印被修改过的集合
}
&gt;&gt;&gt; val list = listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)
&gt;&gt;&gt; printInUpppercase(list)
[A,B,C]
A</code></pre>
<p><strong>如果你写了Kotlin函数，使用集合并传递给了Java，这时你要确认使用了正确的参数类型，同时取决于你调用的Java代码是否会修改集合。</strong></p>
<p>注意，<strong>这些也适用于包含非空类型元素的集合类。</strong>如果你向Java方法传递了这样的集合，该方法就可能在其中写入null值；Kotlin没有办法再不影响性能的情况下，禁止它的发生，或者察觉到已经发生的改变。因此，当你向可以修改集合的Java代码传递集合的时，你需要采取特别的预防措施，来确保Kotlin类型正确的反映出集合上所有可能的修改。</p>
<h3 id="6-3-4-作为平台类型的集合"><a href="#6-3-4-作为平台类型的集合" class="headerlink" title="6.3.4 作为平台类型的集合"></a>6.3.4 作为平台类型的集合</h3><p><strong>Kotlin集合作为平台类型的集合</strong></p>
<p><strong>平台类型不会理会可空或者非空，所以在Kotlin重写或实现平台类型时需要选择集合是否可空。</strong></p>
<p><strong>Kotlin 把定义在java代码中的类型看成平台类型。</strong>Kotlin没有任何关于平台类型的可空性信息，所以编译器允许Kotlin代码将其视为可空或者非空的。同样，Java中声明的集合类型的变量也被视为平台类型。<strong>一个平台类型集合本质上就是可变性未知的集合——Kotlin代码将其视为只读的或者可变的。</strong>实际上你想要执行的所有操作都不受影响。</p>
<p><strong>当你重写或者实现签名中有集合类型的Java方法时这种差异才变的重要。</strong>这里像平台类型的可空性一样，你需要决定使用那种 <strong>Kotlin类型 *<em>来表示这个Java类型， *</em>它来自你要重写或实现的方法。</strong></p>
<p>在重写或者实现时，你要做出多种选择，<strong>它们都会反映在产生的Kotlin代码类型中:</strong></p>
<ul>
<li>集合是否可空？</li>
<li>集合的元素是否可空？</li>
<li>你的方法会不会修改集合？</li>
</ul>
<p>代码中直观的表示。一个Java接口表示一个能处理文件中的文本对象。</p>
<pre><code class="java">/*    使用集合参数的Java接口    */
interface FileContentProcessor{
    void processContents(File path,
        byte[] binaryContents,
        List&lt;String&gt; textContents);
}</code></pre>
<p>这个接口的Kotlin实现需要做出如下选择：</p>
<ul>
<li>列表将是可空的，因为有些文件是二进制格式，它们的内容不能被表示成文本。</li>
<li>列表中的元素将会是非空的，因为文件中每一行都永远不为null。</li>
<li>列表将是可读的，因为它表示的文本内容，而且这些内容不会被修改。</li>
</ul>
<p>实现的样子</p>
<pre><code class="kotlin">/*    FileContentProcessor 的Kotlin实现    */
class FileIndexer:FileContentProcessor{
    override fun processContents(path:File,
        binaryContents:ByteArray?,
        textContents:List&lt;String&gt;?){
            ....
        }
}</code></pre>
<p>与另一个接口对比。这里接口的实现从文本表单中解析出的数据并放大一个对象列表中，再把这些对象附加到输出列表中。当发现解析失败时，就把错误信息添加到另一个单独的列表中，作为错误日志。</p>
<pre><code class="java">/*    另一个集合参数的Java接口    Java*/
interface DataParser&lt;T&gt;{
    void parseData(String input,
        List&lt;T&gt; output,
        List&lt;String&gt; errors);
}</code></pre>
<p>这种情况下的选择：</p>
<ul>
<li>List<String> 将是非空的，因为调用者总是需要接收错误的信息。</li>
<li>列表的元素将是可空的，因为不是每个输出列表中的条目都有关联的错误信息。</li>
<li>List<String> 将是可变的，因为代码实现需要向其中添加元素。</li>
</ul>
<p>实现这个接口</p>
<pre><code class="kotlin">/*    DataParser的Kotlin实现    */
class PersonParser: DataParser&lt;Person&gt;{
    override fun parseData(input:String,
        output:MutableList&lt;Person&gt;,
        error:MutableList&lt;String?&gt;){
            //...
        }
}</code></pre>
<p>注意，同样为Java类型——List<String>——如何表示成了两种不同的Kotlin类型：一种是List<String>?（包含字符串的可空列表），另一个是MutableList&lt;String?&gt;（包含可空字符串的可变列表）。你必须知道Java接口或类必须遵守的确切契约。基于你的实现要做的事情通常很容易理解。</p>
<h3 id="6-3-5-对象和基本数据类型的数组"><a href="#6-3-5-对象和基本数据类型的数组" class="headerlink" title="6.3.5 对象和基本数据类型的数组"></a>6.3.5 对象和基本数据类型的数组</h3><p>默认情况下，你应该优先使用集合而不是数组。但是因为有大量JavaAPI仍然在使用数组，所以来介绍它们在Kotlin中如何使用。</p>
<p>Kotlin 数组的语法出现在了每个例子中， <strong>因为数组是 Java main 函数标准签名的一部分。</strong></p>
<blockquote>
<p>方法签名：</p>
<p>方法签名由方法名+形参列表组成，目的是让此方法确定为唯一的。</p>
</blockquote>
<pre><code class="kotlin">/*    使用数组    */
fun main(args:Array[String]){
    for (i in args.indices){    // 使扩展属性array.indeces在下标的访问内迭代
        pritnl(&quot;Argument $i is :${args[i]}&quot;)    //通过下标使用 array[index] 访问元素
    }
}</code></pre>
<p> Kotlin中的数组是一个带有类型参数的类，其元素类型被指定为相应的类型参数。</p>
<p><strong>要在Kotlin中创建数组，如下方法供你选择</strong></p>
<blockquote>
<ul>
<li>arrayOf函数创建数组，它包含元素是指定为该函数的实参。</li>
<li>arrayOfNulls创建一个给定大小的数组，包含为null元素。当然，它只能用来创建包含元素类型的可空数组。</li>
<li>Array构造方法接收数组大小和一个lambda表达式，使用lambda表达式来创建每一个数组元素。这就是使用元素类型来初始化数组，当不用显式地传递每个元素的方式。</li>
</ul>
</blockquote>
<p>展示如何使用Array函数来创建“a”到”z”的字符串数组。</p>
<pre><code class="kotlin">/*    创建字符数组    */
&gt;&gt;&gt; val letters = Array&lt;String&gt;(26){i-&gt;(&#39;a&#39;+i).toString()}
&gt;&gt;&gt; pritnln(letters.joinToString(&quot;&quot;))
abcdefghijklmnoprstuvwxyz</code></pre>
<p>为了清楚起见，这里显示了数组元素的类型，但在真实的代码中可以省略。因为编译器会推导出它的类型。</p>
<blockquote>
<p>Kotlin <strong>代码中最常见的创建数组的情况之一是需要调用参数为数组的Java方法</strong>，或是在调用带有vararg参数的Kotlin函数时。这种情况下，通常已经将数据存储在集合中，只需要将其转换为数组即可。可以使用toTypedArray方法来执行此操作。</p>
<pre><code class="kotlin">/*    向vararg方法传递集合    */
&gt;&gt;&gt; val string = listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)
&gt;&gt;&gt; pritnln(&quot;%s/%s/%s&quot;.format(*strings.toTypedArray()))    // 期望vararg参数时使用展开运算符(*)传递数组
a/b/c</code></pre>
</blockquote>
<blockquote>
<p>数组类型的类型参数始终会变成对象类型。<strong>因此，如果你声明了一个Array<Int>,它将会是一个包含装箱整型的数组（它的Java类型将是java.lang.Integer[])。如果你需要创建没有装箱的基本数据类型的数组，必须使用一个基本数据类型数组的特殊类。</strong></p>
</blockquote>
<p>为表示基本数据类型的数组，Kotlin提供了若干独立的类，每一个基本数据类型都对应一个。例如，Int类型值的数组叫做IntArray。</p>
<p>要创建一个基本数据类型的数组，你有如下选择：</p>
<ul>
<li><strong>该类型的构造方法接收size参数并返回一个使用对应基本数据类型默认值（通常是0）初始化好滴数组。</strong></li>
<li><strong>工厂函数（IntArray的intArrayOf，以及其他数组类型的函数）接收边长参数的值并创建存储这些的数组。</strong></li>
<li><strong>另一个构造方法，接受一个大小和一个用来初始化元素的lambda</strong></li>
</ul>
<p>例子</p>
<pre><code class="kotlin">/*    下面创建存储了5个0的整形数组的两种选择    */
&gt;&gt;&gt; val fiveZeros = IntArray(5)    //默认值 0
&gt;&gt;&gt; val fiveZerosToo = intArrayOf(0,0,0,0,0)</code></pre>
<pre><code class="kotlin">/*    下面接收lambda的构造方法的例子    */
&gt;&gt;&gt; val squares = IntArray(5){i-&gt;(i+1)*(i+1)}
&gt;&gt;&gt; println(squares.joinToString())
1,4,9,16,25</code></pre>
<blockquote>
<p><strong>假如你有一个持有基本数据类型装箱后的值的数组或者集合，</strong>可以使用对应的转换函数把它们转换成基本数据类型的数组，例如toIntArray。</p>
</blockquote>
<blockquote>
<p><strong>我们来看看你可是对数组做的事情。</strong>处理基本操作外（获得数组长度，获取或者设置元素），Kotlin标准库支持一套和集合相同的用于数组的扩展函数。其中（filter，map等）也适用于数组，包括基本数据类型的数组（注意这些返回值返回的是列表不是数组）。</p>
<pre><code class="kotlin">/*    使用forEachIndexed函数加上lambda来重写”使用数组“例子    */
fun main(args:Array&lt;String&gt;){
    atgs.forEachIndexed{index,elemnt -&gt;
        println(&quot;Argument $index is: $element&quot;)}
}</code></pre>
</blockquote>
<h3 id="6-4-小结"><a href="#6-4-小结" class="headerlink" title="6.4 小结"></a>6.4 小结</h3><ul>
<li></li>
</ul>
<h1 id="8-高阶函数：Lambda作为形参和返回值"><a href="#8-高阶函数：Lambda作为形参和返回值" class="headerlink" title="8 高阶函数：Lambda作为形参和返回值"></a>8 高阶函数：Lambda作为形参和返回值</h1><p><strong>内联函数作用</strong></p>
<p>能够消除lambda带来的性能开销，还能够使lambda内的控制流更加灵活。</p>
<h2 id="8-1-声明高阶函数"><a href="#8-1-声明高阶函数" class="headerlink" title="8.1 声明高阶函数"></a>8.1 声明高阶函数</h2><p>定义</p>
<blockquote>
<p>高阶函数就是以另一个函数作为参数或者返回值的函数。在kotlin中，函数可以用lambda或者函数引用来表示。因此，<strong>任何以lambda或者函数引用作为参数的函数，或者返回值为lambda或函数引用的函数</strong>，或者两者都有满足的函数都是高阶函数。</p>
</blockquote>
<p>标准库中的filter函数将一个判断式函数作为参数，因此它是一个高阶函数：</p>
<pre><code class="kotlin">list.filter{x&gt;0}</code></pre>
<h3 id="8-1-1-函数类型"><a href="#8-1-1-函数类型" class="headerlink" title="8.1.1 函数类型"></a>8.1.1 函数类型</h3><p>在变量中我们有<strong>Int类型</strong>，<strong>String类型</strong>等那么也有属于函数的<strong>函数类型</strong>。</p>
<p>声明一个lambda作为实参的函数，你需要知道如何声明对应形参的类型。在那之前，看接下来的例子，把 lambda 表达式保存在局部变量中。在不声明类型的情况下，这些就依赖于Kotlin的类型推导。</p>
<pre><code class="kotlin">val sum = {x:Int,y:Int -&gt; x+y}
val action = {println(42)}</code></pre>
<p>编译器推导出sum和action两个变量具有<strong>函数类型</strong>。</p>
<p>显式声明<strong>函数类型的变量</strong></p>
<pre><code class="kotlin">val sum:(Int ,Int) -&gt; Int = {x,y-&gt;x+y}    // 有两个Int类型参数和Int类型返回值
val action:() - &gt; Unit = { println(42) }    //没有参数和返回值</code></pre>
<p>声明函数类型，需要将函数参数类型放在括号中，紧接着是一个箭头和函数的返回值类型。</p>
<pre><code class="kotlin">(Int,String) -&gt; Unit
// ↑参数类型    ↑返回类型</code></pre>
<p>在声明函数类型时Unit是不能省略的，其他情况下可以。</p>
<p>函数类型的返回值标记为可空类型：</p>
<pre><code class="kotlin">val canReturnNull: (Int,Int) -&gt; Int?={null}</code></pre>
<p>定义函数类型的可空变量。</p>
<blockquote>
<p>为了明确表示是变量本身可空，而不是函数类型的返回类型可空，你需要将整个函数类型的定义包含在括号内并在括号后添加问号。</p>
<pre><code class="kotlin">val funOrNull:((Int,Int) -&gt; Int) ?= null</code></pre>
</blockquote>
<h3 id="8-1-2-调用作为参数的函数"><a href="#8-1-2-调用作为参数的函数" class="headerlink" title="8.1.2 调用作为参数的函数"></a>8.1.2 调用作为参数的函数</h3><p>实现一个高阶函数。</p>
<p>实现2，3两个数字的任意操作。</p>
<blockquote>
<p>函数类型作为参数，形参和实参更像是接口，形参是接口实参则用来具体的实现。</p>
</blockquote>
<p>定义一个简单的高阶函数</p>
<pre><code class="kotlin">//    定义一个函数类型的参数
fun twoAndThree(operation: (Int,Int) -&gt; Int){
    val result = opration(2,3)    // 调用参数（函数类型）
    println(&quot;The result is $result&quot;)
}
&gt;&gt;&gt; twoAndThree{a,b -&gt; a+b}
The result is 5
&gt;&gt;&gt; twoAndThree(a,b -&gt; a*b)
The result is 6</code></pre>
<p>实现最常用的标准库函数：filter函数。为了更让事情更简单一些，将实现基于String类型的filter函数，但和作用于泛型的版本原理是显示的。</p>
<pre><code class="kotlin">/* &quot;String&quot;:接收者类型。
    “predicate”：参数类型
    “(Char) -&gt; Boolean”：函数类型参数
    “Char”:函数类型参数的参数类型
    “Boolean”：函数类型的参数返回类型
    */
fun String.filter(predicate:(Char) -&gt; Boolean):String</code></pre>
<blockquote>
<p>filter 函数的声明，以一个判断式作为参数</p>
</blockquote>
<p>判断式的类型是一个函数，以字符作为参数并返回boolean类型的值。如果要让传递给判断式的字符出现在最终返回的字符串中，判断式需要返回ture，反之false。</p>
<pre><code class="kotlin">//    实现一个简单版本的filer函数
fun String.filter(predicate: (Char) -&gt; Boolean):String{
    val sb = StringBuilder()
    for (index in 0 until length){
        val element = get(index)
        if (predicate(element)) sb.append(element)    // 调用引用的String类型参数给predicate函数进行判断
    }
    return sb.toString()
}

&gt;&gt;&gt; println(&quot;ab1c&quot;.filter{it in &#39;a&#39;..&#39;z&#39;})    //传递 lambda 作为 &#39;predicate&#39;参数
abc</code></pre>
<blockquote>
<p>filter 函数的实现非常简单明了。它检查每个字符时候满足判断式，如果满足就将字符添加到包含结果的StringBuilder中。</p>
</blockquote>
<h3 id="8-1-3-在Java中使用函数类"><a href="#8-1-3-在Java中使用函数类" class="headerlink" title="8.1.3 在Java中使用函数类"></a>8.1.3 在Java中使用函数类</h3><p><strong>原理</strong></p>
<blockquote>
<p>函数类型被声明为普通的接口：一个函数类型的变量是<strong>FunctionN接口的实现</strong>。</p>
<p>Kotlin 标准库定义了一系列的接口，这些接口对应于不同的参数数量的函数：<strong>Function0<R>(没有参数的函数)、Function&lt;P1,R&gt;(一个参数的函数)</strong>。</p>
<p>每个接口定义了一个 invoke 方法，调用这个方法就会执行函数。</p>
<p>一个函数类型的变量就是实现了对应的Function接口的实现类的实力，实现类的invoke方法包含了lambda函数体。</p>
</blockquote>
<p><strong>在 Java 中调用使用了函数类型的 Kotlin 函数。</strong></p>
<pre><code class="kotlin">/*    kotlin声明    */
fun processTheAnswer(f:(Int) -&gt;){
    println(f(42))
}</code></pre>
<pre><code class="kotlin">/*    Java    */
&gt;&gt;&gt; processTheAnswe(number -&gt; number+1);
43</code></pre>
<p>在旧版 Java 中，可以传递一个实现了函数接口中 invoke 方法的匿名类的实例：</p>
<pre><code class="java">/*    Java    */
&gt;&gt;&gt; processTheAnswer(
...        new Function1&lt;Integer,Integer&gt;(){    // 在Java 8 以前使用函数类型
...            @Override
...            public Integer invoke(Integer number){
...                System.out.println(number);
...                return number+1;
...                }
...        });
43</code></pre>
<p>在 Java 中使用函数类型必须显示地传递一个接收者对象作为第一个参数。</p>
<p>在Java中可以很容易地使用 Kotlin 标准库中以lambda作为参数的扩展函数。</p>
<pre><code class="java">/*    Java    */
&gt;&gt;&gt; List&lt;String&gt; strings = new ArrayList()；
&gt;&gt;&gt; strings.add(&quot;42&quot;)
&gt;&gt;&gt; CollectionKt.forEach(strings, s -&gt;{    //可以在Java中使用Kotlin标准库中的函数
...        System.out.println(a);
...        return unit.INSTANCE;    // 必须显示的返回一个Unit类型的值。
...})</code></pre>
<blockquote>
<p>在 Java 中 ，函数或许lambda可以返回Unit。因为在 Kotlin 中 Unit 类型是有值的，所以需要显示的返回它。</p>
<p>一个返回 void 的lambda 不能作为返回 Unit 的函数类型的实参，就像之前的例子中的(String) -&gt;Unit.</p>
</blockquote>
<h3 id="8-1-4-函数类型的参数默认值和null值"><a href="#8-1-4-函数类型的参数默认值和null值" class="headerlink" title="8.1.4 函数类型的参数默认值和null值"></a>8.1.4 函数类型的参数默认值和null值</h3><p>声明函数类型的参数时可以指定参数的默认值。</p>
<p><strong>用来理解参数默认值的关键作用</strong></p>
<pre><code class="kotlin">/*    使用了硬编码toString转换的joinToString函数    */
fun &lt;T&gt; Collection&lt;T&gt;.joinToString(
        separator: String = &quot;,&quot;,
        prefix: String = &quot;&quot;,
        postfix: String = &quot;&quot;
): String{
        val result = StringBuilder(prefix)
        for ((index,element) in this.withIndex()){
            if(index &gt;0) result.append(separator)
            result.append(element)    // 使用默认toString方法将对象转换成字符串
        }
        result.append(postfix)
        return result.toString()
}</code></pre>
<blockquote>
<p>这里的实现很灵活但是并没有让你控制转换的关键点： 集合中的原始是如何转换成字符串的。</p>
</blockquote>
<blockquote>
<p>这里使用 StringBuilder.append(o:Any?) (result.append(element)),他总是使用toString方法将对象转换成字符串。在大多数情况下这样是可以的，但是不总是这样。</p>
</blockquote>
<blockquote>
<p>现在可以传递一个lambda去指定如何将对象转换成字符串。</p>
</blockquote>
<blockquote>
<p>但是要求所有调用者都传递lambda是比较烦人的，因为大部分调用者使用默认的行为就可以了。为了解决这个问题，可以定义一个函数类型的参数并用一个lambda作为它的默认值。</p>
</blockquote>
<pre><code class="kotlin">/*    给函数类型的参数指定默认值    */
fun &lt;T&gt; Collection&lt;T&gt;.joinToString(
        separator: String = &quot;,&quot;,
        prefix: String = &quot;&quot;,
        postfix: String = &quot;&quot;,
        transform: (T) -&gt; String = {it.toString()}    //声明一个lambda为默认值的函数类型的参数
): String {
        val result = StringBuilder(prefix)
        for ((index,element) in this.withIndex()){
            if(index &gt; 0 ) result.append(separator)
            result.append(transform(element))    // 调用作为实参的element传递给 “transform”形参的函数
        }
        result.append(postfix)
        return result.toString()
}


&gt;&gt;&gt; val letters = listOf(&quot;Alpha&quot;,&quot;Beta&quot;)
&gt;&gt;&gt;  println(letters.joinToString())    // 使用默认的转换函数
Alpha, Beta
&gt;&gt;&gt; println(letters.joinToString{it.toLowerCase()})    // 传递一个 lambda 作为参数
alpha,beta
&gt;&gt;&gt; println(letters.joinToString(separator = &quot;!&quot;,postifx = &quot;!&quot;, transform = {it.ToUpperCase()}))    // 使用命名参数参数语法几个参数，包括lambda。
ALPHA,BETA</code></pre>
<blockquote>
<p>这个带默认值的函数类型是一个泛型参数T表示集合中的元素类型。 Lambda transform 将接收这个类型的参数。</p>
</blockquote>
<blockquote>
<p>声明函数类型的默认值并不需要特殊的语法，只需要把 lambda 作为值放在 = 号后。上述例子展示了多种方式调用函数类型。</p>
</blockquote>
<p><strong>声明函数类型其参数是可空的</strong></p>
<pre><code class="kotlin">/*    案例1    一般情况*/
fun foo(callback: (() -&gt;Unit)?){
    if(callback != null){
        callback()
    }
}
</code></pre>
<blockquote>
<p>这里不能直接调用作为参数传递进行的函数：Kotlin 会因为检查到潜在的空指针异常而导致编译失败。<strong>这里可选的办法是显式地检查null</strong>。</p>
</blockquote>
<pre><code class="kotlin">/*    使用函数类型的可空参数    */
fun &lt;T&gt; Collection&lt;T&gt;.joinToString(
        separator: String = &quot;,&quot;,
        prefix: String = &quot;&quot;,
        postfix: String = &quot;&quot;,
        transform:    ((T) -&gt; String ) ?=null    // 声明一个函数类型的可空参数
): String{
    val result = StringBuilder(prefix)
    for ((index,element) in this.withIndex()){
        if (index &gt; 0) result.append(separator)
        val str = transform?.invoke(element)    // 使用安全调用语法，调用函数
            ?: element.toString()    //使用 Elvis 运算符处理回调没有被指定的情况
        result.append(str)
    }
    result.append(postfix)
    return result.toString()

}</code></pre>
<blockquote>
<p>这是一个更简单的版本，它利用了一个事实 ，函数类型是包含 invoke 方法的接口具体实现。作为一个普通方法，invoke可以通过安全调用语法被调用：callback?.invoke()方法</p>
</blockquote>
<h3 id="8-1-5-返回函数的函数"><a href="#8-1-5-返回函数的函数" class="headerlink" title="8.1.5 返回函数的函数"></a>8.1.5 返回函数的函数</h3><pre><code class="kotlin">/*    定义一个返回函数的函数    */
enum class Delivery {STANDARD, EXPEDITED}
class Order(val itemCount:Int)
fun getShippingCostCalculator(delivery:Delivery):(Order)-&gt;Double{    // 声明返回函数的函数
    if (delivery == Delivery.EXPEDITEM){    // 返回 lambda
        return {order -&gt; 6+2.1 * order.itemCount}
    }
    return {order -&gt;1.2*order.itemCount}
}
&gt;&gt;&gt; val calculator = getShippingCostCalculator(Delivery.EXPEDITEM)    // 将返回的函数保存在变量中
&gt;&gt;&gt; println(&quot;Shapping costs ${calculator(Order(3))}&quot;)    // 调用返回的函数
Shipping costs 12.3</code></pre>
<blockquote>
<p><strong>使用场景</strong></p>
<p>例如，运输费用的计算依赖于选择恰当的逻辑变体并将它作为另一个函数返回。<strong>声明一个 返回另一个函数的函数，需要指定一个函数类型作为返回类型。</strong></p>
<p>函数 getShippingCostCalculator返回一个函数，这个函数以Order最为参数并返回一个Double类型的值。</p>
<p><strong>要返回一个函数，需要写一个return表达式，跟上一个lambda、一个成员引用，或者其他的函数类型的表达式，比如一个函数的局部变量。</strong></p>
</blockquote>
<p><strong>另一个返回函数的例子</strong></p>
<blockquote>
<p>例如，你可以在 UI 上输入一个字符串，然后只显示那些名字以这个字符串开头的联系人；还可以隐藏没有电话号码的联系人。用ContactListFilters这个类来保存这个选项的状态。</p>
</blockquote>
<pre><code class="kotlin">class ContactListFilters{
    var prefix: String = &quot;&quot;
    var onlyWithPhoneNumber: Boolean = false
}</code></pre>
<blockquote>
<p>当用户输入 D 来查看姓或者名以 D 开头的联系人时，prefix的值会被更新。</p>
</blockquote>
<pre><code class="kotlin">/*    在UI代码中定义一个返回函数的函数    */
data class Persion(
    val firstName:String,
    val lastName:String,
    val phoneNumber:String?
)

class ContactListFilters{
    val prefix:String = &quot;&quot;
    val onlyWithPhoneNumber: Boolean = false
    fun getPredicate():(Person) -&gt; Boolean{    //声明一个返回函数的函数
        val    startWithPrefix  = {p:Persion -&gt; p.firstName.startsWith(prefix) || p.lastName.startsWith(prefix)
        }
        if (!onlyWithPhoneNumber){
            return startWithPrefix    // 返回一个函数类型的变量
        }
        return { startsWithPrefix(it)&amp;&amp;it.phoneNumber != null }    //从函数返回一个lambda

    }
}
&gt;&gt;&gt; val contacts = listOf(Persion(&quot;Dmitry&quot;,&quot;Jemeroy&quot;,&quot;123-4567&quot;),
...                          Persion(&quot;Svetlane&quot;,&quot;Isakova&quot;,null))
&gt;&gt;&gt; val contactListFilters = ContactListFilters()
&gt;&gt;&gt; with (contactListFilters){
&gt;&gt;&gt;        prefix = &quot;Dm&quot;
&gt;&gt;&gt;     onlyWithPhoneNumber = true
&gt;&gt;&gt; }
&gt;&gt;&gt; println(contacts.filter(
...        contactListFilters.getPredicate()))        // 将 getPredicate 返回的函数作为参数传递给 “filter” 函数
[Persion (firstName = Dmitry,lastName = Jemetov,phoneNumber = 123-4567)]</code></pre>
<blockquote>
<p>为了让展示联系人列表的逻辑代码和输入的过滤条件的UI条件解耦，可以定义一个函数来创建一个判断式，用来过滤联系人列表。判断式检查前戳，如果有需要也检查电话号码时候存在。</p>
</blockquote>
<blockquote>
<p>getPredicate 函数返回一个函数（类型）的值，这个值被传递给filter作为参数。</p>
</blockquote>
<h3 id="8-1-6-通过lambda-去除重复代码"><a href="#8-1-6-通过lambda-去除重复代码" class="headerlink" title="8.1.6 通过lambda 去除重复代码"></a>8.1.6 通过lambda 去除重复代码</h3><p>例子</p>
<blockquote>
<p>这是一个分析网站访问的例子。SiteVisit类用来保存每次访问的路径、持续时间和用户的操作系统。不同的操作系统使用枚举来表示。</p>
</blockquote>
<pre><code class="kotlin">/*    定义站点访问数据    */
data calss SiteVisit(
    val path: String,
    val dutation: Double,
    val os: OS
    )
enum class OS{ WINDOWS,LINUX,MAC,IOS,ANDROID}
val log = listOf(
    SiteVisit(&quot;/&quot;,34.0,OS.WINDOWS),
    SiteVisit(&quot;/&quot;,22.0,OS.MAC),
    SiteVisit(&quot;/login&quot;,12.0,OS.WINDOWS),
    SiteVisit(&quot;/signup&quot;,8.0,OS.IOS),
    SiteVisit(&quot;/&quot;,16.3.OS.ANDROID)
)</code></pre>
<blockquote>
<p>需要显示来自 Windows 的平均访问时间，可以使用 average 函数来完成这个任务。</p>
</blockquote>
<pre><code class="kotlin">/*    使用硬编码的过滤器分析站点访问数据    */
val averageWindowsDutation = log
    .filter {it.os == OS.WINDOWS}
    .map(SiteVisit::dutation)
    .avaerage()
&gt;&gt;&gt;println(averageWindowsDutaion)
23.0</code></pre>
<blockquote>
<p>显示来自于Windows机器的平均访问时间，用 average 函数来完成任务。</p>
</blockquote>
<pre><code class="kotlin">/*    使用普通的方法去除重复代码    */
fun List&lt;SiteVisit&gt;.averageDurationFor(os:OS) = filter{it.os == os}.map(SiteVisit::dutation).average()    // 将重复代码抽取到函数中
&gt;&gt;&gt; println(log.averageDurationFor(OS.WINDOWS))
23.0
&gt;&gt;&gt; println(log.averageDurationFor(OS.MAC))
22.0</code></pre>
<blockquote>
<p>现在你要计算一个来自MAC用户的相同数据，为了避免重复，可以将平台类型抽象成一个参数.</p>
<p>注意这个函数作为扩展函数增强了可读性。如果它值在局部的上下文中有用，你甚至可以将这个函数声明为局部的扩展函数。</p>
</blockquote>
<pre><code class="kotlin">/*    用一个重复的硬编码函数分析站点访问数据    */
val averageMobileDutation = log
    .filter{it.os == setOf(OS.IOS,OS.ANDROID)}
    .map(SiteVisit::duration)
    .average()

&gt;&gt;&gt; println(averageMobileDuration)
12.15
</code></pre>
<blockquote>
<p>如果你对移动平台的访问的平均时间感兴趣。</p>
<p>这时已经不能再再用简单的参数表示不同的平台了。可能还需要使用更加复杂的条件查询日志，比如，“来自IOS平台对注册页面的访问平均时间是多少？”</p>
<p><strong>可以使用函数类型将需要的条件抽象到一个参数中</strong></p>
</blockquote>
<pre><code class="kotlin">/*    用高阶函数去除重复代码    */
fun List&lt;SiteVisit&gt;.averageDutationFor(predicate:(SiteVisit) -&gt; Boolean) = filter(predicate).map(SiteVisit::duration).average()
&gt;&gt;&gt; println(log.averageDurationFor{
...        it.os in setOf(OS.ANDROID,OS.IOS)
})
12.15
&gt;&gt;&gt; println(log.averageDurationFor{
...        it.os == OS.IOS &amp;&amp; it.path == &quot;/signup&quot;    // 满足系统为IOS，访问地址为 注册界面的条件
})
8.0</code></pre>
<blockquote>
<p>函数类型可以帮助去除重复代码。使用lambda，不仅可以去除重复的数据，也可以去除重复的行为。</p>
</blockquote>
<h2 id="8-2-内联函数：消除lambda带来的运行时开销"><a href="#8-2-内联函数：消除lambda带来的运行时开销" class="headerlink" title="8.2 内联函数：消除lambda带来的运行时开销"></a>8.2 内联函数：消除lambda带来的运行时开销</h2><blockquote>
<p>Kotlin 中传递 lambda 作为函数参数的简明语法与普通的表达式语法很相似。</p>
<p><strong>lambda 表达式会被正常地编译成匿名类。这表示每调用一次 lambda 表达式，就会额外的创建一个类。并且如果 lambda 捕捉了某个变量，那么每次调用的时候都会创建一个新的对象。这会带来运行时的额外开销，导致使用 lambda 比使用一个直接执行相同代码的函数效率更低。</strong></p>
<p>有没有可能让编译器生成跟 Java 语句相同高效的代码，但还是能把重复的逻辑抽取到库函数中呢？（作用）</p>
<p>如果使用 <strong>inline</strong> 修饰符标记一个函数，在函数被使用的时候编译器并不会生成函数调用的代码，而是使用函数实现的真实代码替换每一次的函数调用。</p>
</blockquote>
<p><strong>内联函数简介</strong></p>
<blockquote>
<p>在<a href="https://baike.baidu.com/item/计算机科学" target="_blank" rel="noopener">计算机科学</a>中，<strong>内联函数</strong>（有时称作<strong>在线函数</strong>或<strong>编译时期展开函数</strong>）是一种<a href="https://baike.baidu.com/item/编程语言" target="_blank" rel="noopener">编程语言</a>结构，用来建议<a href="https://baike.baidu.com/item/编译器" target="_blank" rel="noopener">编译器</a>对一些特殊<a href="https://baike.baidu.com/item/函数" target="_blank" rel="noopener">函数</a>进行内联扩展（有时称作<strong>在线扩展</strong>）；也就是说建议编译器将指定的函数体插入并取代每一处调用该函数的地方（<a href="https://baike.baidu.com/item/上下文" target="_blank" rel="noopener">上下文</a>），从而节省了每次调用函数带来的额外时间开支。但在选择使用内联函数时，必须在程序占用空间和程序执行效率之间进行权衡，因为过多的比较复杂的函数进行内联扩展将带来很大的存储资源开支。另外还需要特别注意的是对<a href="https://baike.baidu.com/item/递归函数" target="_blank" rel="noopener">递归函数</a>的内联扩展可能引起部分编译器的无穷编译。</p>
</blockquote>
<h3 id="8-2-1-内联函数如何运作"><a href="#8-2-1-内联函数如何运作" class="headerlink" title="8.2.1 内联函数如何运作"></a>8.2.1 内联函数如何运作</h3><blockquote>
<p><strong>内联函数！</strong></p>
<p>当一个函数被声明为 inline 时，它的函数体是内联的–换句话说，函数体会被直接替换到函数被调用的地方，而不是被正常调用。</p>
</blockquote>
<pre><code class="kotlin">/*    定义一个内联函数    */
inline fun &lt;T&gt; sysnchronized(lock:Lock,action : () -&gt; T):T{
    lock.lock()
    try{
        return action()
    }
    finally    {
        lock.unlock()
    }
}
val l = Lock()
synchronized(1){
    //...
}</code></pre>
<blockquote>
<p>函数用于确保一个共享资源不会并发地被多个线程访问。函数锁住一个Lock对象，执行代码块。</p>
</blockquote>
<blockquote>
<p>调用这个函数的语法跟Java中使用 synchronized 语法完全一直。<strong>区别</strong>，Java 的 synchronized 语法可以用于<strong>任何对象</strong>，这个函数则要求传入一个Lock实例。</p>
<p>同时，Kotlin 标准库中定义了一个可以接受<strong>任何对象</strong>作为参数的 synchronized 函数版本。</p>
<p>这里使用同步操作时显式的对象锁能够提升代码的可读性和维护性。</p>
</blockquote>
<blockquote>
<p><strong>使用 inline 的效果！</strong></p>
<p>因为已经将 synchronized 函数声明为 inline，所以每次调用它所生成的代码跟 Java 的synchronized 语句都是一样的。</p>
</blockquote>
<p><strong>使用 synchronized 的例子。</strong></p>
<pre><code class="kotlin">fun foo(l:Lock){
    println(&quot;Before sync&quot;)
    synchronized(1){
        println(&quot;Action&quot;)    //内联函数
    }
    println(&quot;After sync&quot;)
}</code></pre>
<pre><code class="kotlin">/*    编译后的 foo 函数    */
fun _foo_(l:Lock){
    println(&quot;Before sync&quot;)    //这是调用者 foo 的代码
    l.lock()    // 这是被内联的 synchronized 函数代码
    try(
        println(&quot;Action&quot;)    //被内联的lmabda题代码
    )finally{
        l.unlock()        //这是调用者 foo 的代码
    }
    println(&quot;After sync&quot;)    //这是调用者 foo 的代码
}</code></pre>
<blockquote>
<p>展示的是作用相同的代码，将会被编译成同样的字节码。</p>
</blockquote>
<blockquote>
<p>这里 lambda 表达式 和 synchronized 函数实现了内联。</p>
<p>由于lambda 生成的字节码成为了函数调用这定义的部分，而不是被包含在一个实现了函数接口的匿名类中</p>
</blockquote>
<pre><code class="kotlin">/*    调用内联函数的时候可以传递函数类型的变量作为参数    */
class LockOwner(val lock:Lock){
    fun runUnderLock(body:() -&gt; Unit){
        synchronized(lock,body)    //作为函数类型的变量作为参数，而不是lambda
    }
}</code></pre>
<blockquote>
<p>使用函数类型的变量作为参数，不会被内联。</p>
</blockquote>
<blockquote>
<p>只有synchronized 函数体被内联了，lambda 才会被正确调用。</p>
</blockquote>
<pre><code>/*    runUnderLock 的函数字节码    */
class LockOwner(val lock:Lock){
    fun runUnderLock(body:() -&gt; Unit){    //函数类似于真正的runUnberLock被编译成的字节码
        lock.lock()
        try{
            body() // body 没有被内联，因为在调用到地方换没有 lambda
        }finally{
            lock.unlock()
        }
    }
}</code></pre><h3 id="8-2-2-内联函数的限制"><a href="#8-2-2-内联函数的限制" class="headerlink" title="8.2.2 内联函数的限制"></a>8.2.2 内联函数的限制</h3><blockquote>
<p>鉴于内联的运作方式，不是所有使用lambda的函数都可以被内联的。</p>
</blockquote>
<blockquote>
<p>当函数被内联的时候，作为参数的lambda表达式函数体会被直接替换成最终生成的代码中。这会限制函数体中对应的（lambda）参数使用。如果（lambda）参数被调用，这样的代码能被容易的内联。<strong>但是如果（lambda）参数在某个地方被保存起来，一遍后边可以继续使用，lambda表达式的代码将不能被内联，因为必须要有一个包含这些代码的对象存在。</strong></p>
</blockquote>
<blockquote>
<p>一般来说，参数如果被直接调用或者作为参数传递给另外一个inline函数，它是可以被内联的。否则，编译器会禁止参数被内联并给出错误信息“Illeal usage of inline-parameter”</p>
</blockquote>
<blockquote>
<p>例如，许多作用域序列的函数会返回一些类的实例，这些类代表对应的序列操作并接受lambda作为构造参数。 这是 Sequence.map函数的定义：</p>
</blockquote>
<pre><code class="kotlin">fun &lt;T,R&gt; Sequence&lt;T&gt;.map(transform:(T) -&gt; R):Sequence&lt;R&gt;{
    return TransformingSequence(this,transform)

}</code></pre>
<blockquote>
<p>map 函数没有直接调用作为 transform参数传递进来的函数。而是将这个函数传递给类的构造方法，构造方法将它保存在一个属性中。</p>
<p>这时为了支持这一点，作为transform参数传递的lambda需要被编译成标准的非内联的表达式，即实现了一个函数接口的匿名类。</p>
</blockquote>
<blockquote>
<p> 当函数期望两个或多个 lambda 参数，可以选择只内联其中一些参数。这是有道理的，因为一个lambda可能会包含很多代码或者不允许内联的方式使用。接受这样的非内联lambda的参数，可以用 noinline 修饰符来标记它：</p>
<pre><code class="kotlin">inline fun foo(inlined:() -&gt; Unit,noinlune notInlined:() -&gt; Unit){
    //...
}</code></pre>
</blockquote>
<h3 id="8-2-3-内联集合操作"><a href="#8-2-3-内联集合操作" class="headerlink" title="8.2.3 内联集合操作"></a>8.2.3 内联集合操作</h3><p>Kotlin 标准库中操作集合函数的性能。大部分标准库中的集合函数都带有lambda参数。<strong>不管使用标准库函数，还是直接实现这些操作效率都是一样的。</strong></p>
<p>我们来比较一下。</p>
<pre><code class="kotlin">/*    使用lambda过滤一个集合    */
data class Person(val name:String,val age:Int)
val people = listOf(Persion(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31))
&gt;&gt;&gt; println(people.filter(it.age&lt;30))
[Person(name = Alice,age = 29)]</code></pre>
<pre><code class="kotlin">/*    手动过滤一个集合 不用lambda表达式来实现*/
&gt;&gt;&gt; val result = mutableListOf&lt;Person&gt;()
&gt;&gt;&gt; for (person in people){
&gt;&gt;&gt;         if(person.age &lt; 30) result.add(person)
&gt;&gt;&gt;}
&gt;&gt;&gt; println(result)
[Person(name = &quot;Alice&quot;, age = 29)]</code></pre>
<blockquote>
<p>Kotlin 对内联函数的支持让你不必担心性能问题。</p>
</blockquote>
<blockquote>
<p>在Kotlin中，filter 函数被声明为内联函数。这意味着 filter 函数，以及传递给它的lambda的字节码会被一起内联到filter被调用的地方。最终，第一种实现所产生的字节码和第二种实现所产生的字节码大致是一样的。你可以很安全地使用符合语言习惯的集合操作。</p>
</blockquote>
<blockquote>
<p>现象你在连续使用 filter 和 map 两个操作。</p>
<pre><code class="kotlin">&gt;&gt;&gt; println(people.filter{it.age &gt; 30}
...                .map (Persion::name))
[Bob]</code></pre>
<p><strong>这个例子使用了 lambda 表达式和一个成员引用。</strong></p>
<p>这里 filter 和 map 都被声明为了 inline 函数，所以他们的函数体会被内联，因此不会产生额外的类和对象。上述的代码却创建了一个中间集合来把偶出来列表过滤的结果，由 filter 函数生成的代码会向这个集合种添加元素，而由 map 函数生成的代码会读取这个几个。</p>
<p><strong>如果有大量的元素需要处理，中间集合的运行开销将成为不可忽视的问题，这时可以在调用链后加上一个asSequence调用，用序列代替集合。</strong></p>
<p>同时如同上一节看到的一样，用于处理序列的 lambda 不能够被内联，每个中间序列被表示成lambda保存在其字段中的对象，<strong>而末端操作会导致由每个中间序列调用组成的链被执行</strong>。因此，即便序列上的操作是惰性的，你不应该总是试图在集合操作的链后<strong>asSequence</strong>。只有在处理大量数据时有用，小的集合可以用普通集合处理。</p>
</blockquote>
<h3 id="8-2-4-决定何时将函数声明成内联"><a href="#8-2-4-决定何时将函数声明成内联" class="headerlink" title="8.2.4 决定何时将函数声明成内联"></a>8.2.4 决定何时将函数声明成内联</h3><p>使用 inline 关键词只能提高 lambda 参数的函数性能，其他情况需要额外的度量和研究。</p>
<p><strong>将带有 lambda 参数的函数内联能够带来什么好处。</strong></p>
<blockquote>
<p>首先， 通过内联避免运行时开销更加明显了。毕竟节约了函数运行时的开销，而且节约了 lambda 创建匿名类，以及创建 lambda 实例对象的开销。其次，JVM 还没有聪明到总是能将函数调用内联。内联可以使用一些不可能被普通 lambda 使用的特征，比如非局部返回。</p>
</blockquote>
<p><strong>注意</strong></p>
<blockquote>
<p><strong>在使用 inline 关键字的时候，你还是应该注意代码的长度。如果你要内联的函数不大，将它的字节码拷贝到每一个调用点将会极大地增加字节码的长度。在这种情况下，你应该将那些与 lambda 参数无关的代码抽取到一个独立的非内联函数中。在 Kotlin 中内联函数总是很小的。</strong></p>
</blockquote>
<h3 id="8-2-5-使用-内联-lambda-管理资源"><a href="#8-2-5-使用-内联-lambda-管理资源" class="headerlink" title="8.2.5  使用 内联 lambda 管理资源"></a>8.2.5  使用 内联 lambda 管理资源</h3><p><strong>Lambda 可以去除重复代码的一个常见模式是资源模式</strong></p>
<blockquote>
<p>先获取资源，完成一个操作，释放资源。</p>
<p>这里资源表示多种不同的东西：一个文件、一个锁、一个数据库事务等。</p>
<p>实现这个模式的标准做法是使用 try/finally 语句。资源在 try 代码块之前被获取，在 finally 代码块中释放。</p>
</blockquote>
<p><strong>synchronization</strong></p>
<blockquote>
<p>前部分讲到将 try/finally的逻辑封装在一个函数中，然后将使用资源的代码作为 lambda 传递给这个方法。</p>
<p>synchronization将一个锁对象作为参数。</p>
</blockquote>
<p>代替 <strong>synchronization</strong></p>
<blockquote>
<p>Kotlin 标准库定义了一个叫 withLock的函数，它提供了实现同样功能的更符合语言习惯的API：它是 Lock 接口的扩展函数。</p>
<p>如何使用。</p>
<pre><code class="kotlin">val l:Lock = ...
l.withLock{
    // access the resource protected by this lock 在加锁的情况下执行指定的操作。
}
/*    在Kotlin标准库中的定义    */
fun &lt;T&gt; Lock.withLock(action : () -&gt; T):T{    //需要加锁的代码被抽取到一个独立的方法中
    lock()
    try{
        return action()
    } finally{
        unlock()
    }

}</code></pre>
</blockquote>
<p><strong>文件是另一种可以使用这种模式的常见资源类型。（文件使用 资源模式）</strong></p>
<blockquote>
<p>Java 7 为这种模式引入了特殊的语法：try-with-resource 语句。</p>
<pre><code class="kotlin">/*    下述代码来读取文件的第一行Java方法    */
/*    在Java中使用try-with-resource语句    */
static String readFirstLineFromFile(String path) throws IOException{
    try(BufferedReader br = new BufferedReader(new FileReader(path))){
        return br.readLine();
    }
}</code></pre>
<p>Kotlin 中并没有等价的语法，因为通过使用一个带有函数类型参数的函数可以无缝地完成相同的事情。这个函数叫use()</p>
<p><strong>使用 use 函数 重写上述代码</strong></p>
<pre><code class="kotlin">/*    使用use函数作为资源管理    */
fun readFirstLineFromFile (path:String):String{
    BufferedReader(FileReader(path)).use{    // 构成 BufferedReader，调用 “use” 函数，传递一个lambda执行文件操作
        br -&gt; return br.readLine()    // 从函数中返回文件的一行
    }
}</code></pre>
<p>use 函数是一个扩展函数，被用来操作可关闭的资源，它接受一个lambda作为参数。这个返回调用lambda并且确保资源被关闭，无论lambda正常执行饭是抛出了异常。当然使用use函数是内联函数，所以使用它并不会引发任何性能开销。</p>
</blockquote>
<h2 id="8-3-高阶函数中的控制流"><a href="#8-3-高阶函数中的控制流" class="headerlink" title="8.3 高阶函数中的控制流"></a>8.3 高阶函数中的控制流</h2><p>把 return 语句放在循环的中间是很简单的事情，但是如果将循环转换成一个类似于 <strong>filter （filter 是内联函数）</strong> 的函数呢？这种情况下 return 会如何工作。</p>
<h3 id="8-3-1-lambda-中的返回语句：从一个封闭的函数返回"><a href="#8-3-1-lambda-中的返回语句：从一个封闭的函数返回" class="headerlink" title="8.3.1 lambda 中的返回语句：从一个封闭的函数返回"></a>8.3.1 lambda 中的返回语句：从一个封闭的函数返回</h3><p>比较两种不同的 遍历集合的返回： 在下面的代码清单中，如果一个人的名字是 “Alice” ，就应该从函数lookForAlice 返回。</p>
<pre><code class="kotlin">/*    在一个普通循环中使用return    */
data class Person(val neme:String, val age:Int)
val people = listOf(Person (&quot;Alice&quot;,29),Person(&quot;Bob&quot;,11))
fun lookForAlice(people:List&lt;Person&gt;){
    for (person in people){
        if (person.name == &quot;Alice&quot;){
            println(&quot;Found!&quot;)
            return
        }
    }
    println(&quot;Alice is not found&quot;)     //如果“people”中没用Alice，这一行就会被打印出来
}

&gt;&gt;&gt; lookForAlice(people)
Found!</code></pre>
<blockquote>
<p>使用 forEach迭代重写这段代码安全吗？</p>
<pre><code class="kotlin">/*    在传递给 forEach 的lambda 中使用 return    */
fun lookForAlice(people:List&lt;Person&gt;){
    people.forEach{
        if (it.name == &quot;Alice&quot;){
            println(&quot;Found!&quot;)
            return
        }
    }

    println(&quot;Alice is not found&quot;)    //和上一个代码清单中的效果是一样的
}</code></pre>
<p>这是安全的</p>
</blockquote>
<blockquote>
<p>当你在 lambda 中使用 return 关键字，它会从调用 lambda 的函数中返回，并不是从 lambda 中返回。这个叫做<strong>非局部返回</strong>。<strong>因为它从一个比包含 return 的代码块更大的代码块中返回了。</strong></p>
</blockquote>
<blockquote>
<p>为了理解这条规则背后的逻辑，从Java函数中在for循环或者synchronized 代码块中使用 return 关键字。显然这会从函数中返回，而不是从循环或者代码块中返回。使用以 lambda 作为参数的函数的时候 kotlin 保留了同样的行为。</p>
</blockquote>
<blockquote>
<p>需要注意的是，<strong><em>只有在以 lambda 作为参数的函数是内联函数的时候才能从跟外层的函数返回。</em></strong>在上述代码中，forEach 的函数体和lambda的函数体一起被内联了，所以在编译的时候能很容易做到从包含它的函数中返回。在 非内联函数的lambda 中使用 return 表达式是不允许的。一个非内联函数可以把传给它的lambda保存在变量中，以便在函数返回以后可以继续使用，这个时候lambda先去影响函数的返回已经太晚了。</p>
</blockquote>
<h3 id="8-3-2-从-lambda-返回：使用标签返回"><a href="#8-3-2-从-lambda-返回：使用标签返回" class="headerlink" title="8.3.2 从 lambda 返回：使用标签返回"></a>8.3.2 从 lambda 返回：使用标签返回</h3><p><strong>标签返回</strong></p>
<blockquote>
<p>可以在lambda表达式总使用<strong>局部返回</strong>。</p>
<p>lambda 中的局部返回跟 for 循环中的 break 表达式显示。它会终止 lambda 的执行，并接着从调用 lambda 的代码处执行。</p>
</blockquote>
<p><strong>区分 局部返回和非局部返回</strong></p>
<blockquote>
<p>要区分局部返回和非局部返回，要用到<strong>标签</strong>。</p>
<p><strong>如何区分。</strong></p>
<p>想从 lambda 表达式处返回你可以标记它，然后在 return 关键字后面引用这个标签。</p>
</blockquote>
<pre><code class="kotlin">/*    用一个标签实现局部返回    */
fun lookForAlice(people:List&lt;Person&gt;){
    people.forEach lable@{    // ←给lambda表达式加上标签
        if (it.name == &quot;Alice&quot;) return@label    //← return@label 引用了这个标签
    }
    println(&quot;Alice might be somewhere&quot;)    //这里总被打印
}

&gt;&gt;&gt; lookForAlice(people)
Alice might be somewhere!</code></pre>
<blockquote>
<p><strong>如何使用标签</strong></p>
<p>要标记一个lambda表达式，在 lambda 的花括号之前放一个标签名，接着放一个 @ 符号。（标签名可以是任意的）、</p>
<p>要从一个lambda返回，在return关键词后放一个@符号，接着放标签名。</p>
<pre><code class="kotlin">// “label@” lambda标签
people.forEach label@{
    if (it.name == &quot;Alice&quot;) return@label //返回表达式标签
}
/*    用 “@” 符号标记一个标签从一个lambda返回    */</code></pre>
</blockquote>
<blockquote>
<p><strong>另一种方式，使用 lambda 作为参数的函数的函数名可以作为标签</strong></p>
<pre><code class="kotlin">/*    用函数名 return 标签    */
fun lookForAlice(people:List&lt;Person&gt;) {
    people.forEach{
        if(it.name == &quot;Alice&quot;)    return@forEach    // ←return@forEach从 lambda 表达式返回
    }
    println(&quot;Alice might be somewhere&quot;)
}</code></pre>
<p>当里显式的<strong>指定了 lambda 表达式的标签</strong>，再使用函数名作为标签没有任何效果。</p>
<p>一个 lambda 表达式的标签数量不能多于一个。</p>
</blockquote>
<blockquote>
<p><strong>带标签的 “this” 表达式</strong></p>
<p>同样的规则也适用于this表达式。在带接收者的lambda中–包含一个隐式上下文对象的lamdba也有通过一个this去访问。</p>
<p>如果你给带接收者 lambda 指定标签，就可以通过对应的带有标签的this表达式访问它的隐式接收者。</p>
<pre><code class="kotlin">&gt;&gt;&gt; println(StringBuilder().apply sb@{    // 这个 lambda 隐式接收者可以通过 this@sb 访问
...        listOf(1,2,3).apply{    // ”this”指定作用域内最近的隐式接收者
...            this@sb.append(this.toString())    // 所以隐式接收者都可以被访问，外层的接收者通过显式的标签访问
...        }
...    }) 
    [1,2,3]</code></pre>
<p>局部返回的语法相当冗长，如果一个 lambda 包含多个返回语句会变得更加笨重。所以这里可以使用 <strong>匿名函数。</strong></p>
</blockquote>
<h1 id="9-泛型"><a href="#9-泛型" class="headerlink" title="9 泛型"></a>9 泛型</h1><p><strong>Kotlin中引入了新的概念，例如实化类型参数和声明点变型。</strong></p>
<p><strong>实化类型参数允许你在运行时的内联函数调用中引用作为类型实参的具体类型（对普通的类和函数来说，这样行不通，因为类型实参在运行时会被消除）</strong></p>
<p><strong>声明点变型可以说明一个带类型参数的泛型类型，是否是另一个泛型类型的之类或者超类型，它们的基础类型相同但类型参数不同。</strong>例如它可以调节是否可以把List<Int>类型的参数传给期望List<Any>的函数。<strong>使用点变型在具体使用一个泛型时做同样的事，达到和Java通配符一样的效果。</strong></p>
<blockquote>
<p>类型参数：</p>
<p>在计算机编程语言中，TypeParameter是用于泛型编程的通用标签，用于引用未知的数据类型，数据结构或类。TypeParameter最常用于C ++模板和Java泛型。TypeParameter与元语法变量相似，但有所不同。</p>
<p>引用：维基百科</p>
</blockquote>
<h2 id="9-1-泛型类型参数"><a href="#9-1-泛型类型参数" class="headerlink" title="9.1 泛型类型参数"></a>9.1 泛型类型参数</h2><blockquote>
<p>泛型允许你定义带类型形参的类型。当这种类型的实例被创建出来的时候，类型形参被替换成称为类型实参的具体类型。</p>
<p>类型形参：声明定义时的参数，作用域仅本身。</p>
</blockquote>
<p><strong>Kotlin编译器能推导出类型实参：</strong></p>
<pre><code class="kotlin">val authors = listOf(&quot;Dmitry&quot;,&quot;Svetlane&quot;)</code></pre>
<p>因为传给listOf函数的两个值都是字符串，编译器推导出你正在创建一个List<String>。另一方面，如果你想创建一个空的列表，这样就没有任何可以推导处类型实参的线索，你就得显式指定它（类型形参）。就创建列表来说，即可以选择在变量声明中说明泛型的类型，也可以选择在创建列表的函数中说明类型实参。例子：</p>
<pre><code class="kotlin">val readers :MutableList&lt;String&gt; = mutableListOf()
val reader = mutableListOf&lt;String&gt;()</code></pre>
<h3 id="9-1-1-泛型函数和属性"><a href="#9-1-1-泛型函数和属性" class="headerlink" title="9.1.1 泛型函数和属性"></a>9.1.1 泛型函数和属性</h3><p>如果你在编写一个使用列表的函数，希望它可以在任何列表上使用，而不是某个具体类型的元素列表，那么编写一个 <strong>泛型函数</strong>。</p>
<blockquote>
<p>泛型函数有它自己的类型形参。类型形参在每次函数调用时都必须替换成具体的类型实参。</p>
</blockquote>
<p>大部分使用集合的库函数都是泛型的。下面这个函数就返回一个只包含在指定下标区间内的元素。</p>
<pre><code class="kotlin">fun &lt;T&gt; List&lt;T&gt;.slice(indeces: IntRange):List&lt;T&gt;    //接收者和返回类型使用了类型形参
// &lt;T&gt;:类型形参声明</code></pre>
<p>接收者和返回类型用到了函数的类型形参T，它们的类型都是List<T>。当你在一个具体的列表上调用这个函数时，可以显式地指定类型实参。</p>
<blockquote>
<p>多数情况下，编译器会推导出类型。</p>
</blockquote>
<pre><code class="kotlin">//调用泛型函数
&gt;&gt;&gt; val letter = (&#39;a&#39;..&#39;z&#39;).toList()
&gt;&gt;&gt; println(letter.slice&lt;Char&gt;(0..2))    //显式地指定类型实参
[a, b, c]
&gt;&gt;&gt; println(letter.slice&lt;Char&gt;(10..13))    
[k, l, m, n]</code></pre>
<p>调用的结果都是List<Char>。编译器把函数返回类型List<T>总的T替换成推导出来的类型Char</p>
<h3 id="9-1-2-声明泛型类"><a href="#9-1-2-声明泛型类" class="headerlink" title="9.1.2 声明泛型类"></a>9.1.2 声明泛型类</h3><blockquote>
<p><strong>和Java一样，Kotlin通过在内名称后加上一对尖括号，并把类型参数放在尖括号内来声明泛型类及接口。</strong></p>
<p>一旦声明以后，就可以在类的主体内像其他类型一样使用类型参数。</p>
</blockquote>
<pre><code class="kotlin">interface List&lt;T&gt;{    //List 接口顶类类型参数T
    operator fun get(index:Int):T    //在接口或类的内部，T可以当作普通类型使用。
}</code></pre>
<blockquote>
<p><strong>如果你的类继承了泛型类（或者实现了泛型接口），你就得为<em>基础类型</em>的泛型形参提供一个类型实参。它可以是具体类型或一个类型形参：</strong></p>
<pre><code class="kotlin">class StringList(override val size: Int) : List&lt;String&gt; {   //这个类实现了List，提供了具体类型实参：String
 override fun get(index: Int): String {  //注意T被String替代
     TODO(&quot;Not yet implemented&quot;)
 }
}

class ArratList&lt;T&gt; : List&lt;T&gt; {  // 现在ArrayList泛型类型形参T就是List的类型实参。
 override fun get(index: Int): T {
     TODO(&quot;Not yet implemented&quot;)
 }
}</code></pre>
<p>StringList类被声明成只能 <strong>只能包含String元素，所以它使用String作为基础类型的类型实参。</strong>之类中的任何函数都要用这个正确的类型换掉T，所以在StringList中你会得到函数签名get(Int):String ，而不是fun get(Int):T。</p>
<p><strong>而类ArrayList定义了它自己的类型参数T并把它指定为父类的类型实参。</strong>注意ArrayList<T>中的T和LIst<T>中的T不一样，它是全新的类型形参，不必保留一样的名称。</p>
<p><strong>一个类甚至可以把它自己作为类型实参应用。</strong>实现Comparable接口的类就是这种模式的经典例子。任何可以比较的元素都必须定义它如何与同样类型的对象进行比较：</p>
<pre><code class="kotlin">interface Comparable&lt;T&gt; {
 fun comparableTo(other: T): Int
}

class String : Comparable&lt;String&gt; {
 override fun comparableTo(other: String): Int {
     TODO(&quot;Not yet implemented&quot;)
 }
}
</code></pre>
<p>String 实现了Comparable接口的泛型接口，提供类型String给类型实参T。</p>
</blockquote>
<h3 id="9-1-3-类型参数约束"><a href="#9-1-3-类型参数约束" class="headerlink" title="9.1.3 类型参数约束"></a>9.1.3 类型参数约束</h3><blockquote>
<p><strong>类型参数约束可以限制作为类和函数的类型实参的类型。</strong> 以计算列表元素之和的函数为例。它们可以在List<Int>和List<Double>上，当不可以用在LIst<String>这样的列表上。可以定义一个类型参数的约束，说明sum的类型形参必须是数字，来表达这个限制。</p>
</blockquote>
<blockquote>
<p><strong>如果你把一个类型指定为泛型类型形参的上街约束</strong>，在泛型类型具体的初始化中，其对应的类型实参就必须这个具体类型或它的子类型（暂时子类型和子类的一样相同）。</p>
</blockquote>
<blockquote>
<p><strong>你是这样定义约束的，把冒号放到类型参数名称之后，作为类型形参上界的类型紧跟其后，在Java中，用的关键词extends来表达一样的概念：<T extends Number> T sum(List<T> list)。</strong></p>
<pre><code class="kotlin">// &lt;T: 类型参数
// Number&gt; ：上界
fun &lt;T:Number&gt; List&lt;T&gt;.sum():T</code></pre>
</blockquote>
<blockquote>
<p><strong>一旦指定了类型形参T的上界，你就可以把类型T的值作为它的上界（类型）的值使用。</strong></p>
<pre><code class="kotlin">fun &lt;T : Number&gt; oneHalf(value: T): Double {    //指定Number为类型形参上界
 return value.toDouble() / 2.0
}
&gt;&gt;&gt; println(oneHalf(3))
1.5</code></pre>
</blockquote>
<blockquote>
<pre><code class="kotlin">// 声明带类型参数约束的函数
fun &lt;T : Comparable&lt;T&gt;&gt; max(first: T, second: T): T {   //这个函数的实参必须是可比较元素
 return if (first &gt; second) first else second
}
&gt;&gt;&gt; println(max(&quot;kotlin&quot;, &quot;java&quot;)) // 字符串按照字母表顺序比较</code></pre>
<p><strong>T的上界是泛型类型Comparable<T> 。前面已经看到了，String累继承了Comparable<String> 这样使得String变成了max函数的有效类型实参。</strong></p>
<p>记住，first&gt;second的简写形式会根据Kotlin的运算符约定被编译成first.compareTo(second) &gt; 0。这种比较之所以可行，是因为first的类型T继承自Comparable<T>,这样你就可以比较first和另外一个类型T的元素。</p>
<p><strong>极少数情况下，需要在类型参数上指定多个约束</strong>。例如下面这个代码清单用泛型的饭是保证给定的CharSequence以句号结尾。</p>
<pre><code class="kotlin">//为一个类型参数指定多个约束
fun &lt;T&gt; ensureTrailingPeriod(seq: T) where T : CharSequence, T : Appendable {    //类型参数约束的列表
 if (!seq.endsWith(&quot;.&quot;)) {    //调用为CharSequence接口定义的扩展函数
     seq.append(&quot;.&quot;)    //调用Appendable接口的方法
 }
}
&gt;&gt;&gt; val helloWorld = StringBuilder(&quot;Hello World&quot;)
&gt;&gt;&gt; ensureTrailingPeriod(helloWorld)
&gt;&gt;&gt; println(helloWorld)</code></pre>
<p>这种情况下，可以说明作为类型实参的类型必须实现CharSequence和Appendable接口。这意味着该类型的值可以使用访问数据(endsWith)和修改数据(append) 两种操作。</p>
</blockquote>
<h3 id="9-1-4-让类型形参非空"><a href="#9-1-4-让类型形参非空" class="headerlink" title="9.1.4 让类型形参非空"></a>9.1.4 让类型形参非空</h3><blockquote>
<pre><code class="kotlin">class Processor&lt;T&gt;{
    fun process(value:T){
        value?.hashCode()    //“value“是可空的，所以要安全调用
    }
}</code></pre>
<p>如果你声明的是泛型类或者泛型函数，任何类型实参，包括哪些可空的类型实参，都可以替换它的类型形参。<strong>没有指定上界的类型形参将会使用Any?这个默认上界。</strong></p>
<p>process函数中，参数value是可空的，尽管T并没有使用问好标记。下面这种情况是因为Processor类具体初始化T能使用可空类型。</p>
</blockquote>
<blockquote>
<pre><code class="kotlin">val nullableStringProcessor = Processor&lt;String?&gt;()    //可空类型替换为String?被用来替换T
nullableStringProcessor.process(null)    //使用“null”作为“value”实参的代码可以编译</code></pre>
<p>如果你想保证替换类型形参的始终是非空类型，可以通过指定一个约定来实现。如果你除啦可空性之外没有任何限制，可以使用Any代替默认的Any?作为上界：</p>
<pre><code class="kotlin">class Processor&lt;T:Any&gt;{    //指定非空上界。
    fun process(value:T){
        value.hashCode()    //类型T的值现在是非“空”的。
    }
}</code></pre>
<p><strong>约束&lt;T:Any&gt;确保了类型T永远都是非空类型。编译器不会接收代码Processor&lt;String?&gt;,因为类型实参String?不是Any的子类型。（它是 Any? 的子类型）</strong></p>
<p>可以通过指定任意非空类型作为上界，来让类型参数非空，不光是类型Any。</p>
</blockquote>
<h2 id="9-2-运行时的泛型：擦除和实例化参数"><a href="#9-2-运行时的泛型：擦除和实例化参数" class="headerlink" title="9.2 运行时的泛型：擦除和实例化参数"></a>9.2 运行时的泛型：擦除和实例化参数</h2><p>JVM上的泛型一般是通过<strong>类型擦除</strong>实现，就是说泛型类实例的类型实参在运行时是不保留的。可以声明一个inline函数，使其类型实参不被擦除（或者，Kotlin术语称为实化）。</p>
<h3 id="9-2-1-运行时的泛型：类型检查和转换"><a href="#9-2-1-运行时的泛型：类型检查和转换" class="headerlink" title="9.2.1 运行时的泛型：类型检查和转换"></a>9.2.1 运行时的泛型：类型检查和转换</h3><p>和Java一样，Kotlin的泛型在运行时也被 <strong>擦除</strong> 了。这意味着泛型类实例不会携带用于创建它的类型实参的信息。例如，如果你创建了一个List<String>并将一堆字符串放到其中，在运行时你只能看到它是一个List，不能识别出列表本打算包含的是那种类型元素（当然，你可以获取一个元素然后检查它的类型，但即便检查通过了也不会有任何保证，因为其他元素可能拥有不同类型）。</p>
<pre><code class="kotlin">val list1:List&lt;String&gt; = listOf(&quot;a&quot;,&quot;b&quot;)
val list2:List&lt;Int&gt; = listOf(1,2,3)</code></pre>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210905153004.png" alt="在运行时，你不会知道list1和list2时候声明成字符串或者整数列表。它们每个都只是List    "></p>
<p>即使编译器看到的是两种完全不同类型的列表，在执行的时候它们看起来却完全一样。即便如此，你通常可以确信List<String>在包含字符串，而List<Int>只包含整数。因为编译器知道类型实参，并确保每个列表只存储正确的元素。</p>
<p><strong>因为类型实参没有被保留下来，你不能检查它们。</strong>例如，你不能判断一个列表是只包含字符串的列表还是包含其它对象的列表。一般而言，在is检查中不可能使用类型实参中的类型。</p>
<pre><code class="kotlin">&gt;&gt;&gt; if (value is List&lt;String&gt;){...}
ERROR:Cannot check for instance of erased type</code></pre>
<p><strong>为什么擦除了泛型类型信息？</strong></p>
<p>尽管在运行时可以完全断定这个值是一个List，但你依然无法判断它是一个含有字符串的列表，还是含有人，或者含有其他什么：这些信息被擦除了。<strong>注意擦除泛型类型信息是有好处的：应用程序使用的内存总量较小，因为要保存在内存中的类型信息更少。</strong></p>
<p><strong>检查类型是否是个列表？</strong></p>
<p>路上所述，Kotlin不允许使用没有指定类型实参的泛型类型。那么你可能想知道如何检查一个值是否是列表，而不是set或者其他对象。可以使用特殊的<strong>星号投影</strong>语法来做这种检查：</p>
<pre><code class="kotlin">if (value is List&lt;*&gt;){... ...}</code></pre>
<p>这里检查了value是否是一个List，而且并没有得到关于它的任何信息。</p>
<blockquote>
<p>注意，在as 和 as? 转换中仍然可以使用一般的泛型类型。但如果该类有正确的<strong>基础类型</strong>但<strong>类型实参</strong>是错误的，转换也不会失败，因为在运行时转换发生的时候类型实参是未知的。因此这样的转换会导致编译器发出“unchecked cast”（未受检转换）的警告。这仅仅是个警告，你仍然可以继续使用这个值，但它拥有必要的类型。</p>
<pre><code class="kotlin"> // 对泛型类型做类型转换
fun printSum(c: Collection&lt;*&gt;) {
 val initList = c as? List&lt;Int&gt;
     ?: throw IllegalArgumentException(&quot;List is expected&quot;)    //这里警告。Unchecked cast:List&lt;*&gt;to List&lt;Int&gt;
 println(initList.sum())
}

&gt;&gt;&gt; printSum(listOf(1, 2, 3))
6</code></pre>
<p>编译一切正常：编译器只是发出了一个警告，这意味着代码是合法的。如果一个整型的列表或者set上调用printSum函数，一切都会如预期发生：一种情况会打印出元素之和，而第二种情况则会IllegalArgumentException。但如果你传递了一个错误类型的值，运行时会得到一个ClassCastException：</p>
<pre><code class="kotlin">&gt;&gt;&gt; printSum(setOf(1,2,3))    //Set不是列表所以抛出了异常
IllegalArgumentException:List is expected
&gt;&gt;&gt; printSum(listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;))    //类型转换成功，但后面抛出了另外的异常
ClassCastException:String cannot be cast to Number    </code></pre>
<p>我们来讨论一下字符串列表上调用printSum函数时抛出的异常。你得到的并不是IllegalArgumentException，因为你没有办法判断实参是不是一个List<Int>。因此类型转换成功，无论如何函数sum都会在这个列表上调用。在这个函数执行期间，异常抛出了。这是因为sum函数试着从列表中读取Number值然后把它们加在一起。把String但Number用的尝试会导致运行时ClassCastException。</p>
</blockquote>
<blockquote>
<pre><code class="kotlin">/*    对已知类型实参做类型转换    */
fun printSum(c: Collection&lt;Int&gt;) {
 if (c is List&lt;Int&gt;) {
     println(c.sum())    //这次检查是合法的
 }
}

&gt;&gt;&gt; printSum(listOf(1, 2, 3))
6</code></pre>
<p>c 时候拥有类型List<Int>的检查是否可行，因为在编译期就确定了集合（不管它是列表还是其他类型的集合）包含的都是整型数字。</p>
<p>Kotlin有特殊的语法结构可以允许你在函数体中使用具体的类型实参，但是又inline函数可以。</p>
</blockquote>
<h3 id="9-2-2-声明带实化类型参数的函数"><a href="#9-2-2-声明带实化类型参数的函数" class="headerlink" title="9.2.2 声明带实化类型参数的函数"></a>9.2.2 声明带实化类型参数的函数</h3><blockquote>
<p>Kotlin泛型在运行时会被擦除，这意味着如果你有一个泛型类的实例，你无法弄清楚在这个实例创建时你究竟用的是那个类型的实参。泛型类型的类型实参也是这样。在调用泛型函数的时候，在函数体中你不能决定函数调用它用的类型实参：</p>
<pre><code class="kotlin">&gt;&gt;&gt; fun &lt;T&gt; isA(value:Any)=value is T    //表达式
Error:Cannot check for instance of erased type:T</code></pre>
<p>这种情况下只有<strong>内联函数</strong>能够使用，内联函数的类型形参能够被实化，意味着你可以在运行时应用实际的类型实参。</p>
<p><strong>如果使用inline函数标记函数，编译器会把每次函数调用都换成函数实际的代码实现。使用内联函数还可以提升性能，如果该函数使用了lambda实参：lambda的代码会被内敛，所以不会创建任何匿名类。</strong>  <strong>inline函数使用时的另一种场景：它们的类型参数可以被实化。</strong></p>
<p>把前面列子中的isA函数声明成inlie并且用reified标记类型参数，你能够用该函数检查value是不是T的实例。</p>
<pre><code class="kotlin">/*  声明带实化类型参数的函数   */
inline fun &lt;reified T&gt; isA(value: Any) = value is T
&gt;&gt;&gt; println(isA&lt;String&gt;(&quot;abc&quot;))
true
&gt;&gt;&gt; println(isA&lt;String&gt;(123))
false</code></pre>
</blockquote>
<blockquote>
<p>一个实化类型参数能够发挥作用最简单的例子就是标准库函数filterIsInstance。<strong>这个函数接收一个集合，选择其中哪些指定类的实例，然后返回这些被选中的实例。</strong></p>
<pre><code class="kotlin">/*  使用标准库函数filterIsInstance */
&gt;&gt;&gt; val items = listOf(&quot;one&quot;, 2, &quot;three&quot;)
&gt;&gt;&gt; println(items.filterIsInstance&lt;String&gt;())
[one,three]</code></pre>
<p>通过指定<String>作为函数的类型参数，你表明感兴趣的只是字符串。<strong>因此函数的返回类型时List<String>。这种情况下，<em>类型实参在运行时是已知的</em>函数filterIsInstance使用它来检查列表中的值是不是指定为该类型实参的类的实例。</strong></p>
<pre><code class="kotlin">/*  filterIsTance声明的简化版本    */
inline fun &lt;reified T&gt; Iterable&lt;*&gt;.filterIsTance(): List&lt;T&gt; {    //“reified”声明了类型参数不会在运行时被擦除
 val destination = mutableListOf&lt;T&gt;()
 for (element in this) {
     if (element is T) {        //可以检查元素是不是指定为类型实参的类的实例
         destination.add(element)
     }
 }
 return destination
}</code></pre>
</blockquote>
<p><strong>为什么实化只对内联函数有效？</strong></p>
<p>为什么在inline函数中允许这样写 element is T ，而普通的类或者函数却不行？</p>
<p>编译器把实现内联函数的字节码插入每一次调用发生的地方。每次你调用带实化类型参数的函数时，编译器都知道这次特定调用中用作实参的确切类型。因此，编译器可以生成应用作为类型实参的具体类的字节码。上述 filterIsInstance<String>调用来说，生成的代码和下面这段代码是等价的：</p>
<pre><code class="kotlin">for (element in this){
    if(element is String){    //引用具体类
        destination.add(element)
    }
}</code></pre>
<p>因为生成的字节码引用了具体类型，而不是类型参数，它不会被运行时发生的类型参数擦除影响。</p>
<p><strong>注意reified类型参数的inline函数不能在java中调用。</strong>普通的内联函数可以像常规函数那样在Java中调用–它们可以被调用而不能被内联。带实化类型参数的函数需要额外的处理，来吧类型实参的值替换到字节码中，所以它们必须永远是内联的。所以不能在java中调用。</p>
<p><strong>内联函数在什么情况下性能有势最有效？</strong></p>
<p><strong>一个内联函数可以有多个实化类型参数，也可以同时拥有飞实化类型参数和实化类型参数。注意，filterIsInstance函数虽然被标记成了inline，而他并不期望lamdba作为实参。（决定何时将函数声明为内联函数）中，我们提到函数把函数标记成内联只有在一种情况下有性能优势，即函数拥有函数类型的形参并且其对应的实参–lambda–和函数一起被内联的实化。</strong></p>
<p>为了保证良好的性能，你仍然需要追踪了解标记为inline的函数的大小。如果函数变的庞大，最好把不依赖实化类型参数的代码抽取到非内联函数中。</p>
<h3 id="9-2-3-使用实化类型参数代替类引用"><a href="#9-2-3-使用实化类型参数代替类引用" class="headerlink" title="9.2.3 使用实化类型参数代替类引用"></a>9.2.3 使用实化类型参数代替类引用</h3><p>实化类型参数的常见使用场景是为接收java.lang.Class 类型参数的API构造适配器。这个API的例子是JDK中ServiceLoader，它接收一个代表接口或抽象类的java.long.Class，并返回实现了该接口（或继承了该抽象类）java.lang.Class，并返回实现了该接口（或继承了该抽象类）的类的实例。如何利用实化类型参数更容易地调用这些API。</p>
<pre><code class="kotlin">/*    通过类引用 加载ServiceLoader    */
val serviceImpl = ServiceLoader.load(Service::class.java)</code></pre>
<p>::class.java 的语法展示了如何获取java.lang.Class对应的Kotlin类。</p>
<p>这和Java中的Service.class是完全等同的。</p>
<p><strong>使用实化类型参数的函数重写这个例子：</strong></p>
<pre><code class="kotlin">val serviceImpl = loadService&lt;Service&gt;()</code></pre>
<p>代码短了许多。</p>
<p><strong>那么如何定义实化函数？</strong></p>
<p>要加载的服务类现在被指定成了loadService函数的类型实参。把一个类要指定成类型实参要容易理解的多，因为它的代码比使用::class.java语法更短。</p>
<p>看看loadService函数是如何定义的：</p>
<pre><code class="kotlin">inline fun &lt;reified T&gt; loadService(){    //类型参数标记成了“reified”
    return ServiceLoader.load(T::Class.java)    //把T::Class当成类型形参的类访问。
}</code></pre>
<p>这种用在类型上的::Class.java语法也可以用在实化类型参数上。使用这种语法会产生对应到指定为类型参数的类的java.lang.Class,你可以正常使用它。</p>
<p><strong>简化 Android上的startActivity 函数</strong></p>
<p>如果你是Android开发者，可以使用实化类型参数简化startActivity函数。实化类型参数用来代替传递作为java.lang.Class的Activity类。</p>
<pre><code class="kotlin">inline fun &lt;reified T: Activity&gt; Context.startActivity(){    //类型参数标记为“reified”
    val intent = Intent(this,T::Class.java)    //把T::Class当成类型参数的类访问
    startActivity(intent)
}
startActivity(intent)    //调用方法显式Activity</code></pre>
<h3 id="9-2-4-实化类型参数的限制"><a href="#9-2-4-实化类型参数的限制" class="headerlink" title="9.2.4 实化类型参数的限制"></a>9.2.4 实化类型参数的限制</h3><p>实化类型参数是有一些限制的。有一些实化是与生俱来的，另一些是现有的实现决定的，而且可能在未来的Kotlin版本中放开这些限制。</p>
<p><strong>可以按下面的方式使用实化类型参数：</strong></p>
<ul>
<li>用在类型检查和类型转换中(is、!is、as、as?)</li>
<li>使用Kotlin反射API（::Class)</li>
<li>获取相应的java.lang.Class（::Class.java)</li>
<li>作为调用其他函数的类型实参</li>
</ul>
<p><strong>不能做的事情：</strong></p>
<ul>
<li>创建指定为类型参数的类的实例</li>
<li>调用类型参数类的伴生对象的方法</li>
<li>调用带实化类型参数函数的时候使用 <strong>非实化类型形参作为实参</strong></li>
<li><em>把类、属性或者非内联函数的类型参数标记</em>成reified</li>
</ul>
<p><strong>最后一条限制的后果：因为实化类型参数只能用于在内联函数上，使用实化类型参数意味着函数和所有给它的lambda都会被内联。如果内联函数使用lambda的方式导致lambda不能被内联，或者你不想lambda因为性能的关系被内联，<em>可以使用noinline修饰符把它们标记成非内联的。</em></strong></p>
<h2 id="9-3-变型：泛型和子类型化"><a href="#9-3-变型：泛型和子类型化" class="headerlink" title="9.3 变型：泛型和子类型化"></a>9.3 变型：泛型和子类型化</h2><p><strong>变型的概念描述了拥有相同基础类型和不同<em>类型实参</em>的（泛型）类型之间是如何关联的。</strong>例如：List<String>和List<Any>之间如何关联。当编写自己的泛型类或者泛型函数时，理解变型的概念十分重要：它有助于你创建出，既不会以不方便的方式限制用户，也不会破坏用户所期望的类型安全。</p>
<h3 id="9-3-1-为什么存在变型：给函数传递实参"><a href="#9-3-1-为什么存在变型：给函数传递实参" class="headerlink" title="9.3.1 为什么存在变型：给函数传递实参"></a>9.3.1 为什么存在变型：给函数传递实参</h3><p><strong>假如你有一个接收List<Any>作为实参的函数。</strong>把List<String>类型的变量传给这个函数是否安全？把一个字符串传给一个期望Any的函数是安全的，因为String类型继承自Any。<em>但是当String和Any变成List接口的类型实参后，情况就没有这么简单了。</em></p>
<p><strong>考虑一个打印出列表内容的函数。</strong></p>
<pre><code class="kotlin">fun printContents(list: List&lt;Any&gt;) {
    println(list.joinToString())
}
&gt;&gt;&gt; printContents(listOf(&quot;aaa&quot;, &quot;bbb&quot;))
aaa,bbb</code></pre>
<p>看起来这些字符串列表可以正常工作。函数把每个元素都当成Any对待，而且因为每个字符串都是Any，这完全是安全的。</p>
<p><strong>来看另一个函数它会修改列表（因此它接收一个MutableList作为参数）：</strong></p>
<pre><code class="kotlin">fun addAnswer(list: MutableList&lt;Any&gt;) {
    list.add(42)
}
&gt;&gt;&gt; val strings = mutableListOf(&quot;abc&quot;, &quot;bac&quot;)
&gt;&gt;&gt; addAnswer(strings)  //如果这一行编译通过了
&gt;&gt;&gt; println(strings.maxBy { it.length })    //运行时就会产生异常
ClassCaseException:Integer connot be cast to String</code></pre>
<p>你声明了一个类型为MutableList<String>的变量Strings，然后尝试把它传递给这个函数。假如编译器接收了，你就能在字符串中添加一个整数，这会导致你在运行时尝试访问列表中的字符串的时候出现异常。正因如此，这次调用不会通过编译。这个例子展示了当期望的是MutableList<Any>的时候把一个MutableList<String>当作实参是不安全的，Kotlin编译时阻止拉它。</p>
<blockquote>
<p>现在可以回答，把一个字符串列表传给期望Any对象列表的函数是否安全。如果<strong>函数添加或者更换了列表中的元素就是不安全的，因为这样会产生类型不一致的可能性。否则它就是安全的。</strong>可以通过是否可变选择合适的接口来轻易的控制。如果函数接收的是可读列表，可以传递具有更具体的元素类型的列表。如果列表是可变的，不能这样做。</p>
</blockquote>
<blockquote>
<p>这些问题可以推广到任何泛型类，而不仅仅是List。接下来会看到为什么两种接口List和MutableList会因为它们的类型参数产生差异。</p>
</blockquote>
<h3 id="9-3-2-类、类型和子类型"><a href="#9-3-2-类、类型和子类型" class="headerlink" title="9.3.2 类、类型和子类型"></a>9.3.2 类、类型和子类型</h3><p>变量的类型规定了该变量的可能值。有时候我们会把类型和类当成相同的概念使用，当它们不一样，现在来看看它们的区别。</p>
<blockquote>
<p>例子非泛型类，<strong>类</strong>的名称可以当作<strong>类型</strong>使用。例如，如果你这样些 var x : String，就是声明一个可以保存String类的实例的变量。但是注意，同样的类名称也可以用来声明可空类型：var x:String?。这意味着每个Kotlin类都可以用于构造至少两种类型。</p>
</blockquote>
<p>泛型类的情况就变得更加复杂了。要得到一个合法的类型，<strong>需要用一个作为类型实参的具体类型替换（泛型）类的类型形参。</strong>List不是一个类型（它是一个类），但是下面列举出所有的替代品都是合法类型：List<Int>、List<String>、List&lt;List<String>&gt;等。每个泛型类都可能生成潜在无限数量的类型。</p>
<p><strong>子类型</strong></p>
<blockquote>
<p>为了讨论类型之间的关系，需要熟悉子类型这个术语。任何时候如果需要的是类型A的值，你都能使用类型B的值（当作A的值），类型B就称为类型A的子类型。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210914222218.png" alt="如果期望A的时候可以使用B，B就是A的子类型"></p>
<p><strong>超类型</strong>是子类型的反义词。如果B是A的子类型，那A就是B的超类型。</p>
<p><strong>类型是否是另一个子类型的子类型为什么如此重要？</strong></p>
<pre><code class="kotlin">/*    检查一个类型是否是另一个的子类型    */
fun test(i: Int) {
    val n: Number = i   //编译通过，因为Int是Number的子类型
    fun f(s: String) {
        /*...*/
    }
    f(i)    //不能编译，因为Int不是String的子类型
}</code></pre>
<p><strong>只有值的类型是变量类型的子类型时，才允许变量存储该值。</strong></p>
<p><strong>简单情况下，子类型和子类本质上意味着一样的事务。</strong>例如，Int类型是Number的子类，因此Int类型是Number类型的子类型。如果一个类实现了一个接口，它的类型就是该接口类型的子类型：String是CharSequence的子类型。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210914234123.png" alt="非空类型A是可空的A?的子类型，反过来却不是"></p>
<p>这个例子说明，子类型和子类不是同一事务。</p>
<p><strong>一个非空类型是它的可空类型的子类型，当它们都对应这同一个类。</strong>你始终能在可空类型的变量中存储非空类型的值，当反过来却不行（null不是非空类型变量接收的值）：</p>
<pre><code class="kotlin">val s:String = &quot;abc&quot;
val t:String ? = s    //这次赋值是合法的，因为String是String?的子类型</code></pre>
<p><strong>泛型类</strong></p>
<p>当涉及到泛型类时，子类型和子类之间的差异显的格外重要。前面的几个问题，把List<String>类型的变量传给期望List<Any>的函数是否安全，现在可以使用子类型话术语来重新组织：List<String>是List<Any>的子类型吗？你已经了解了为什么把MutableList<String>当成MutableList<Any>的子类型对待是不安全的。显然反过来也是不成立的：MutableList<Any>肯定不是MutableList<String>的子类型。</p>
<p><strong>一个泛型类–例如，MutableList–如果对任意两种类型A和B，MutableList&lt; A &gt;既不是MutableList&lt; B &gt;的子类型也不是它的超类型，它就被称为在该类型参数上是 <em>不变型</em>。</strong>    </p>
<p><strong>什么是协变。</strong></p>
<blockquote>
<p>对于这样一个类，List，对它来说，子类型化规则不一样。Kotlin中的List接口表示的是只读集合。如果A是B的子类型，那么List&lt; A &gt;就是List&lt; B &gt;的子类型。这样的类或者接口被称为 <strong>协变</strong>。</p>
</blockquote>
<h3 id="9-3-3-协变：保留子类型化关系"><a href="#9-3-3-协变：保留子类型化关系" class="headerlink" title="9.3.3 协变：保留子类型化关系"></a>9.3.3 协变：保留子类型化关系</h3><p><strong>协变</strong></p>
<blockquote>
<p>一个协变类是泛型类，对这个类来说，下面的描述是成立的：如果A是B的子类，那么Producer&lt; A &gt;就是Producer&lt; B &gt;的子类。<strong>我们说子类型化被保留了。</strong>例如，Producer&lt; Cat &gt;是Producer&lt; Animal &gt;的子类型，因为Cat是Animal的子类型。</p>
</blockquote>
<p><strong>在声明类时如何说明某个类型参数是可以协变的！</strong></p>
<blockquote>
<p>你需要在该类型参数上加上 out 关键词：</p>
<pre><code>interface Producer&lt;out T&gt;{    //类被声明在T上的协变
    fun producer():T
}</code></pre><p>将一个类的类型参数标记为协变的，<strong>在该类型实参没有精确匹配到函数中定于的类型形参时，可以让该类的值作为这个函数的实际参数，也可以作为这个函数的返回值。</strong></p>
</blockquote>
<p><strong>不使用协变的例子会出现的问题：</strong></p>
<blockquote>
<p>函数 feedAll 用来负责喂养用类Herd代表的一群动物，Herd类的类型参数确定了畜群中动物的类。</p>
<pre><code class="kotlin">/*    定义一个不变型的类似集合的类    */
open class Animal {
 fun feed() {
     /**/
 }
}

class Herd&lt;T : Animal&gt; {   // 类型参数没有声明为协变的。
 val size: Int
     get() =
         operator

 fun get(i: Int): T {
     /*...*/
 }
}

fun feedAll(animals: Herd&lt;Animal&gt;) {
 for (i in 0 until animals.size) {
     animals[i].feed
 }
}</code></pre>
<p>现在需要添加一群猫照顾。</p>
<pre><code class="kotlin">/*  使用一个不变型的类似集合的类  */
class Cat : Animal() { //Cat是一个Animal
 fun cleanLitter() {
     ...
 }
}

fun takeCareOfCats(cats: Herd&lt;Cat&gt;) {
 for (i in 0 until cats.size) {
     cats[i].cleanLitter()   //
     //feedAll(cats
 }
}</code></pre>
<p>这时会出现问题，如果你尝试把Cat猫群类传给feedAll函数，在编译器你就会得到类型不匹配的错误。因为Herd类中的类型参数T没有用任何变形修饰符，猫群不是畜群的子类（子类型化没有被保留）。可以使用显式的类型转化来绕过这个问题，但是这种函数啰嗦，易出错，而且从来不是解决类型不匹配问题的正确方法。</p>
<p>Herd类中有一类似List的API，并且不允许它的调用者添加和修改畜群中的动物，可以把它变成协变的并相应修改带用代码。</p>
<pre><code class="kotlin">/*使用一个协变的类似集合的类*/
class Herd&lt;out T : Animal&gt; {//

}

fun takeCaraOfCats(cats: Herd&lt;Cat&gt;) {
 for (i in 0 until cats.size) {
     cats[i].cleanLitter()
 }
 feedALl(cats)   //不需要转换
}</code></pre>
</blockquote>
<p>你不能把任何类都变成协变的：这样不安全。让类在某个类型参数变为协变，限制了该类中对该类参数使用的可能性。要保证类型安全，它只能用在out位置，意味着这个类只能生产（返回）T 的值而不能消费（）</p>
<blockquote>
<p>在类成员的声明中类型参数的使用可以分为in位置和out位置。<strong>考虑怎样一个类，它声明一个类型参数T并包含了一个使用T的函数。</strong>如果函数把T当成返回类型，我们说它在out位置，这种情况下，该函数生产类型为T的值。如果T用作函数参数的类型，它就在in位置。这样的函数消费类型为T的值。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20211009171605.png" alt="函数参数的类型叫做in文字，函数返回类型叫作out位置"></p>
</blockquote>
<p><strong>约束使用T的位置</strong></p>
<p>类的类型参数前的out关键字要求所有使用T的方法只能把T放在out位置而不能放在in位置。这个关键字约束了使用T的可能性，这保证了对应子类型关系的安全性。</p>
<blockquote>
<p>例子</p>
<p>以Herd类为例，它只能在一个地方使用类型参数T:get方法的返回值。</p>
<pre><code class="kotlin">class Herd(out T: Animal) {
 val size: Int
     get() =
         operator

 fun get(i: Int): T {}//把T作为返回类型使用

}</code></pre>
<p>这是一个out位置，可以安全的把类声明成协变的。如果Herd<Animal>类的get方法返回的是Cat，任何调用该方法的代码都可以正常工作，因为Cat是Animal的子类型。</p>
<p>类型参数T上的关键字out有两层含义：</p>
<ul>
<li>子类型化会被保留（Producer<Cat>是Producer<Animal>的子类型）</li>
<li>T只能用在out位置</li>
</ul>
</blockquote>
<p><strong>类型形参可以作为另一个类的类型实参</strong></p>
<p>例</p>
<p>看这个List<Interface>接口。Kotlin中List是只读的，所以它只有一个返回类型为T的元素的方法get，而没有定义任何一个把类型为T的元素存储到列表中的方法。因此它是协变的。</p>
<pre><code class="kotlin">interface List&lt;Out T&gt;:Collection&lt;T&gt;{
    operator fun get(index: Int):T    //只读接口自定义了返回T的方法（所以T在out的位置）
}</code></pre>
<p>类型形参不光可以直接当作参数类型或者返回类型使用，<strong>还可以当作另一个类型的类型实参</strong>。例，List接口包含了一个返回List<T>的subList方法。</p>
<pre><code class="kotlin">interface List&lt;Out T&gt;:Collection&lt;T&gt;{
    fun subList(fromIndex: Int, toIndex: Int): List&lt;T&gt;   //这里的T在out的位置
}</code></pre>
<p>函数subList中的T也用在out位置。</p>
<p><strong>Mutable不能在类型参数上声明成协变的</strong></p>
<p>因为即含有接受类型为T的值作为参数的方法，也含有返回这种值的方法（因此，T出现在in和out两种位置上）。</p>
<pre><code class="kotlin">interface MutableList&lt;T&gt; : List&lt;T&gt;, MutableCollection&lt;T&gt; {  //MutableList不能在T上声明成协变的...
    override fun add(element: T): Boolean {//...因为T用在了“in”位置
        TODO(&quot;Not yet implemented&quot;)
    }
}</code></pre>
<p>编译器强制限制了这次协变。如果这个类被声明成了协变，编译器会报告错误:Type parameter T is declared as ‘out’ but occurs in ‘in’ position（类型参数T声明为“out”但出现在“in”位置）。</p>
<p><strong>构造方法</strong></p>
<p>注意，构造方法的参数既不在in位置，也不在out位置。即使类型参数声明成了out，仍然可以在构造方法参数的声明中使用它：</p>
<pre><code class="kotlin">class Herd&lt;Out T:Animal&gt;(vararg animals:T){
    ...
}</code></pre>
<p>如果 把类的实例当成一个类泛化的类型的实例使用，变型会防止该实例被误用：不能调用存在潜在危险的方法。<strong>构造方法在实例创建后不会被调用，因此就不会有危险。</strong></p>
<p>然而，如果你在构造方法的参数上使用了关键字val和var，同时就会声明一个getter和setter（如果属性是可变的）。<strong>因此对只读属性来说，类型参数用在了out位置， 可变属性在out位置的in位置都是用它：</strong></p>
<pre><code class="kotlin">class Herd&lt;T:Animal&gt;(var leadAnimal:T,vararg animals:T){...}</code></pre>
<p>这里 T不能用out标记，因为类包装属性leadAnimal的setter，它在in位置用到了T。</p>
<p><strong>关于设置修饰符</strong></p>
<p>这里位置规则只覆盖了类外部可见的（public、protected、和internal）API。私有方法的参数既不在in位置也不在out位置。变形规则只会防止外部使用者对类的误用但不会对类自己的实现起作用：</p>
<pre><code class="kotlin">class Herd&lt;out T:Animal&gt;(private var leadAnimal:T,vararg animals:T){...}</code></pre>
<p><strong>现在可以安全地让Herd在T上协变，因为属性leadAnimal变成了私有的。</strong></p>
<p>如果类型参数在in的位置使用，类和接口会怎样。这是就要有逆变关系成立。</p>
<h3 id="9-3-4-逆变：反转子类型化的关系"><a href="#9-3-4-逆变：反转子类型化的关系" class="headerlink" title="9.3.4 逆变：反转子类型化的关系"></a>9.3.4 逆变：反转子类型化的关系</h3><p><strong>概念</strong></p>
<p>逆变的概念可以被看作是协变的镜像：对一个逆变类来说，它的子类型化关系与用作类型实参的类的子类型化关系是相反的。</p>
<p><strong>逆变例子</strong></p>
<blockquote>
<p>我们从Comparator接口的例子开始，这个接口定义了一个方法compare类，用于比较两个给定的对象：</p>
<pre><code class="kotlin">interface Comparator&lt;in T&gt; {
 fun compare(e1: T, e2: T): Int {    //在in位置使用T
 }
}</code></pre>
<p>这个接口方法只是消费类型为T的值。这说明T只在in位置使用，因此它的声明之前用了in关键字。一个为特定类型的值定义的比较器显然可以比较该类型任意子类型的值。例如，如果有一个Comparator<Any>，<strong>可以用它比较任意具体类型的值。</strong></p>
<pre><code class="kotlin">&gt;&gt;&gt; val anyComparator = Comparator&lt;Any&gt; { e1, e2 -&gt;
 e1.hashCode() - e2.hashCode()
}
&gt;&gt;&gt; val strings: List&lt;String&gt;=...
&gt;&gt;&gt; strings.sortedWith(anyConparator)   // 可以用任意对象的比较器比较具体对象，比如字符串</code></pre>
<p>sortedWith函数期望一个Comparator&lt; String &gt;(一个可以比较字符串的比较器)，传给它一个能比较跟一般的类型的比较器是安全的。如果你在特定类型的对象上执行比较，<strong>可以使用能处理该类型或者它的超类型的比较器。这说明Comparator&lt; Any &gt;是Comparator&lt; String &gt;的子类型，其中Any是String的超类型。</strong>不同类型之间的子类型关系和这些类型的比较器之间的子类型化关系截然相反。</p>
</blockquote>
<p><strong>描述一个逆变类</strong></p>
<blockquote>
<p>在 <strong>类型参数</strong> 上逆变的类是这样的一个泛型类（我们以Consumber&lt; T &gt;为例），对这个类来说，下边的描述是成立的：</p>
<p><strong>如果B是A的子类型，那么Consumer&lt; A &gt;就是Consumer&lt; B &gt;的子类型。类型参数A和B交换了位置，所以我们说子类型化被反转了。例如，Consumer&lt; Animal &gt;就是Consumer&lt; Cat &gt;的子类型。</strong></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20211011233756.png" alt="对协变类型Producer&lt;T&gt;来说，子类型化保留了，但对逆变类型来说，子类型化反转了"></p>
<p>展示了类型参数上协变和逆变的类之间子类型化关系的差异。可以看到对Producer类来说，子类型化关系复制了它的类型实参的子类型化关系，而对Consumer类来说，关系反转了。</p>
<p><strong>in 关键字声明逆变</strong></p>
<p>in 关键字的意思是，对应类型的值是传递进来给这个类的方法的，并且被这些方法消费。和协变的情况类似，约束类型参数的使用将导致特定的子类型化关系。<strong>在类型参数T上的in关键字意味着子类型化被反转了，而且T只能用在in位置。</strong></p>
<table>
<thead>
<tr>
<th align="center">协变（方法名称为案例）</th>
<th>逆变</th>
<th>不变型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Producer&lt; out T&gt;</td>
<td>Consumer&lt; in T&gt;</td>
<td>MutableList&lt; T&gt;</td>
</tr>
<tr>
<td align="center">类的子类型化保留了：Producer&lt; Cat&gt;是Producer&lt; Animal&gt;的子类型</td>
<td>子类型化反转了：Consumer&lt; Animal&gt;是Consumer&lt; Cat&gt;的子类型</td>
<td>没有子类型化</td>
</tr>
<tr>
<td align="center">T只能在out位置</td>
<td>T只能在in位置</td>
<td>T可以在任何位置</td>
</tr>
</tbody></table>
<p><strong>一个类可以在一个类型参数上协变，同时在另一个类型参数上逆变。Function接口的例子。</strong></p>
<pre><code class="kotlin">interface Function1&lt;in P, out R&gt; {
    operator fun invoke(p: P): R
}</code></pre>
<p>Kotlin的表示法(P)-&gt;是表达Function&lt;P,R&gt;的另一种可读性的形式。可以发现用in关键字标记P（参数类型）只用在in位置，而用out关键字标记的R（返回类型）只用在out位置。这意味着对这个函数类型的第一个类型参数来说，子类型化反转了，而对第二个类型参数来说，子类型化保留了。</p>
<p><strong>例，你有一个高阶函数，该函数尝试对里所有的猫进行迭代，你可以把一个接收任意动物的lambda传给它。</strong></p>
<pre><code class="kotlin">fun enumerateCats(f: (Cat) -&gt; Number) {
    ...
}

fun Animal.getIndex(): Int = ...
&gt;&gt;&gt; enumerateCats(Animal::getIndex) //在Kotlin中这段代码是合法的。Animal是Cat的超类型，而Int是Number的子类型</code></pre>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20211012002918.png" alt="函数(P)-&gt;R在它的参数类型上逆变而在返回类型上协变"></p>
<h3 id="9-3-5-使用点变形：在类型出现的地方指定变型"><a href="#9-3-5-使用点变形：在类型出现的地方指定变型" class="headerlink" title="9.3.5 使用点变形：在类型出现的地方指定变型"></a>9.3.5 使用点变形：在类型出现的地方指定变型</h3><p><strong>声明点变型</strong></p>
<p>在类声明的时候就能够指定变形修饰符是很方便的，因为这些修饰符会应用到所有类被使用的地方。所以被称为<strong>声明点变型</strong></p>
<p><strong>使用点变型</strong></p>
<p>如果你熟悉Java的通配符类型（? extends 和 ? super），你会意识到Java用完全不同的方式处理类型。在Java中，每一次使用带类型参数的类型的时候，还可以指定这个类型参数是否可以用它的子类型或者超类型替换。这叫做 <strong>使用点变型</strong></p>
<p><strong>Kotlin 支持使用，使用点变型</strong></p>
<blockquote>
<p>Kotlin支持使用点变型，允许在类型参数出现的具体位置指定变型，即使在类型声明时不能被声明成协变或逆变的。</p>
</blockquote>
<p><strong>看看使用点变型是如何工作的</strong></p>
<blockquote>
<p>许多MutableList这样的接口，通常情况下既不是协变也不是逆变的，因为它同时生产和消费指定为它们类型参数的类型的值。但是对于这个类型的变量来说，在某个特定函数中只被当成其中一种角色使用的情况很常见：要么是生产者要么是消费者。例如</p>
<pre><code class="kotlin">/*    带不变型类型参数的 数据拷贝函数    */
fun &lt;T&gt; copyData(source: MutableList&lt;T&gt;, destination: MutableList&lt;T&gt;) {
for (item in source) {
  destination.add(item)
}
}</code></pre>
<p>这个函数从一个集合中把元素拷贝到另一个集合中。尽管两个集合都拥有不变型的类型，来源集合只是用于读取，而目标集合只是用于写入。这种情况下，集合元素的类型不需要精确匹配。例如，把一个字符串集合拷贝到可以包含任何集合中一点问题没有。</p>
<p>让函数支持不同类型的列表，<strong>引入第二泛型参数</strong></p>
<pre><code class="kotlin">/*    9.15 带不变型类型参数的数据拷贝函数    */
fun &lt;T : R, R&gt; copyData(source: MutableList&lt;T&gt;, destination: MutableList&lt;R&gt;) {  //来源的元素类型应该是目标元素类型的子类型
for (item in source) {
  destination.add(item)
}
}
&gt;&gt;&gt; val ints = mutableListOf(1, 2, 3)
&gt;&gt;&gt; val anyItems = mutableListOf&lt;Any&gt;()
&gt;&gt;&gt; copyData(ints,anyItems) //可以调用这个函数，因为Int是Any的子类型
&gt;&gt;&gt; println(anyItems)
[1,2,3]</code></pre>
<p>你声明了两个泛型参数代表 来源列表和目标列表中的元素类型。为了能够把一个列表中的元素拷贝到另一个列表中，来源元素类型应该是目标列表中的元素的子类型，例如 9.15中的Int是Any的子类型。</p>
<p>另一种方式支持不同列表。</p>
<p>Kotlin提供了更优雅的表达方式。当函数的实现调用了那些类型参数只出现在out位置（或只出现在in位置）的方法时，可以充分利用这一点，在函数定义中给特定用途的类型参数用上<strong>变型修饰符</strong></p>
<pre><code class="kotlin">/*    9.16 带out投影类型参数的数据拷贝函数    */
fun &lt;T&gt; copyData(
source: MutableList&lt;out T&gt;,
destination: MutableList&lt;T&gt;
) {
for (item in source) {
  destination.add(item)
}
}</code></pre>
<p>可以为类型声明中类型参数任意的用法指定变型修饰符，用法包括：形参类型、局部变量类型、函数返回类型、等。<strong>这发生的一切都叫做 类型投影：我们说source不是一个常规的MutableList，而是一个投影受限的MutableList。</strong>只能调用返回类型是泛型类型参数的那些方法。编译器禁止调用使用类型参数做实参（类型）的哪些方法（在in位置使用类型参数）：</p>
<pre><code class="kotlin">&gt;&gt;&gt; val list: MutableList&lt;out Number&gt; = ...
&gt;&gt;&gt; list.add(42)
Error:Out-projectedType &#39;MutableList&lt;out NUmber&gt;&#39; prohibits
the use of &#39;fun add(element:E):Boolean&#39;</code></pre>
<p>（在in位置使用类型参数后调用类型参数方法是不可取的。）</p>
<p><strong>不要为使用投影类型参数后不能调用某些方法而吃惊。如果需要调用那些方法，你需要的是常规类型而不是投影。</strong>这可能要求你声明第二类型参数，它依赖的是原本要进行投影的类型，例 9.15 中那样。</p>
<p>因为我们只用了声明在List中的方法，并没有用到MutableList中的方法，而且List类型参数的变型在声明时就指定了。所以实现copyData函数的正确方式应该是使用List<T>作为source实参的类型。<strong>这个例子展示这种概念依然十分重要，尤其是要记住大多数的类并没想List和MutableLIst这样分开两个接口，一个是协变的读取接口，一个是不变型的读取/写入接口。</strong></p>
<p><strong>在类型参数有out变型时投影没有意义</strong></p>
<p>如果类型阐述已经有out变型，获取它的out投影没有任何意义。就像List<out T> 这样。它和List<T>是同一个意思，因为List已经声明成了class List<out T>。Kotlin编译器会发出警告，表明这些投影是多余的。</p>
<p>同理，对类型参数的用法使用in修饰符，来表明这个特定的地方，相应的值担当的是消费者，而且类型参数可以任意使用它的子类型替换。</p>
<p>用in来重写部分代码（9.16).</p>
<pre><code class="kotlin">fun &lt;T&gt; copyData(source: MutableList&lt;T&gt;, destination: MutableList&lt;in T&gt;) {//允许目标元素的类型是来源类型的超类型
 for (item in source) {
     destination.add(item)    
 }
}</code></pre>
<blockquote>
<p>注意：Kotlin的使用点变型直接对应Java的限界通配符。Kotlin 中的MutableList<out T> 和Java 中的MutableList&lt;? extends T&gt;是一个意思。in投影是一个意思。in 投影的MutableList<in T>对应到Java的MutableList&lt;? super T&gt;。</p>
</blockquote>
</blockquote>
<p><strong>（优点）使用点变型有助于放宽可接受的类型范围。</strong>讨论另一种极端情况：这种情况下（泛型）类型使用所有可能的类型实参。（泛型要使用所有可能的类型）</p>
<h3 id="9-3-6-星号投影：-代替类型参数"><a href="#9-3-6-星号投影：-代替类型参数" class="headerlink" title="9.3.6 星号投影：* 代替类型参数"></a>9.3.6 星号投影：* 代替类型参数</h3><p>在提到类型检测和转换的时候，我们提到了一种特殊的 <strong>星号投影</strong> 语法，可以用它来表明你不知道关于泛型实参的任何信息。</p>
<p>List&lt;*&gt;表示为一个未知类型的元素的列表用这种语法表示。</p>
<p><strong>星号投影的含义</strong></p>
<p>首先 ，<strong>需要注意的是MutableList&lt;*&gt;和MutableList&lt;Any?&gt;不一样（这里MutableList<T>在T上是不变型的。）</strong>。你确信MutableList&lt;Any?&gt;这种列表包含的是 <strong>任意类型的元素。</strong>另一方面，MutableList&lt; * &gt;是包含某种 <strong>特定类型的元素的列表</strong>，但是你不知道是那个类型。这种列表被创建成一个 <strong>包含某种特定类型元素的列表</strong>， 比如String（你无法创建一个ArrayList&lt; * &gt;),而且创建它的代码期望只包含特定那种类型的元素。因为不知道是那种类型，你不能向列表中写入任何东西，因为你写入的任何值都可能会违反调用代码的期望。但是从列表中 <strong>读取元素是可行的，</strong> <strong>所有存储在列表中的值都能匹配所有Kotlin类型的超类型Any?</strong></p>
<pre><code class="kotlin">&gt;&gt;&gt; val list: MutableList&lt;Any?&gt;=mutableListOf(&#39;a&#39;, 1, &#39;qwe&#39;)
&gt;&gt;&gt; val chars = mutableListOf(&#39;a&#39;, &#39;b&#39;, c)
&gt;&gt;&gt; val unknownElements: MutableLIst&lt;*&gt; = // MutableList&lt;*&gt;和MutableList&lt;Any?&gt;不一样。
    if (Random().nextBoolean())
        list
    else
        chars

&gt;&gt;&gt; unknownElements.add(42) //编译器禁止调用这个方法
Error: Out-projected type &#39;MutableList&lt;*&gt;&#39; prohibits the use of &#39;fun add(element:E): Boolean&#39;
&gt;&gt;&gt; println(unknownElements.first())    // 读取元素是安全的：first.(）返回一个类型为Any?的元素。
3</code></pre>
<p>为什么编译器会把 MutableList&lt; * &gt; <strong>当成out投影的类型？（out-projected）</strong>。 在这个例子的上下文中， <strong>MutableList&lt;  *  &gt;投影成了MutableList&lt;Any?&gt;:</strong> 当你没有任何元素类型信息的时候，读取Any?类型的元素仍然是安全的， <strong>但是向列表中写入元素是不安全的。</strong></p>
<blockquote>
<p><strong>注意：</strong></p>
<p>对于Consumber<in T> 这样的逆变类型参数来说，星号投影等价于<in Nothing>。实际上这种星号投影无法调用任何签明中有T的方法。如果类型参数是逆变的，它就只能表现为一个消费者，你不知道它消费的到底是什么。</p>
</blockquote>
<p><strong>场景</strong></p>
<blockquote>
<p>当类型实参的信息并不重要的时候，可以使用星号投影的语法：不需要使用任何在签名中引用类型参数的方法，或者只是读取数据而不关心它的具体类型。列入，可以实现一个接收List&lt;*&gt;做参数的printFirst函数：</p>
<pre><code class="kotlin">fun printFirst(list: List&lt;*&gt;) {   // 每一种列表都可能是实参。
    if (list.isNotEmpty()) {  // isNotEmpty()没有使用泛型类型参数
        println(list.first())   // fist()现在返回的是Any?,但在这里足够了
    }
}
&gt;&gt;&gt; printFirst(listOf(&#39;Svetlana&#39;,&#39;Dmitry&#39;))
Svetlana</code></pre>
<p>使用点变型的情况下，有一个代替方案–引入一个泛型类型参数：</p>
<pre><code class="kotlin">fun &lt;T&gt; printlnFirst(list: List&lt;T&gt;) { // 每一种列表都是可能的实参
    if (list.isNotEmpty()) {
        println(list.first())   //first()现在返回的是T的值。
    }
}</code></pre>
<p>星号投影的语法很简洁，但只能用在对泛型类型实参的确切值不感兴趣的地方：只是使用生产值的方法，而且不关心那些值的类型。</p>
</blockquote>
<p><strong>场景</strong></p>
<blockquote>
<p>另一个使用星号投影的日子，以及使用这种方法时会困扰你的陷阱。</p>
<p>假如你需要验证用户的输入，并声明一个接口FieldValidator。它只包含在in位置的类型参数，所以声明成了逆变的。事实上，当期望的是字符串验证器时使用可验证任意元素的验证器也是没有问题的（这就是声明成逆变带来的效果）。同时还声明了两个验证器来分别处理String和Int。</p>
<pre><code class="kotlin">/*     9.18 输入验证的接口 */
interface FieldValidator(in T) { //接口定义成 在 T 上的逆变。
fun validete(input: T): Boolean   // T只在“in&quot;位置使用（这个方法只消费T的值）。
}

object DefaultStringValidator : FieldValidator&lt;String&gt; {
override fun validate(input: String) = input.isNotEmpty()
}

object DefaultIntValidator : FieldValidator&lt;Int&gt; {
override fun validate(input: int) = input &gt;= 0
}</code></pre>
<p>现在假设你想要把所有的验证器都存储到同一个容器中，并根据输入的类型来选出正确的验证器。首先会用到map来存储它们。你存储的是任意类型的验证器，所以你声明了KClass（代表一个Kotlin类，10章会详细介绍KClass）到FiledValidator&lt;*&gt;（可以指向任意类型的验证器）的map：</p>
<pre><code class="kotlin">&gt;&gt;&gt; validators = mutableMapOf&lt;KClass&lt;*&gt;，FieldValidator&lt;*&gt;&gt;() //key ,value
&gt;&gt;&gt; validators[String::class] = DefaultStringValidator
&gt;&gt;&gt; validators[Int::class] = DefaultIntValidator</code></pre>
<p>如果你这样做了，尝试使用验证器的时候就会遇到困难。不能用类型为FieldValidator&lt;*&gt;的验证器来验证字符串。这是不安全的，因为编译器不知道它是那种验证器：</p>
<pre><code class="kotlin">&gt;&gt;&gt; validators[String::class]!!.validate(&quot;&quot;)    //存储在map中的值的类型是FieldValidator&lt;*&gt;。
Error:Out-projected type &#39;FieldValidator&lt;*&gt;&#39; prohibits the use of &#39;fun validate(intput: T):Boolean&#39;</code></pre>
<p>（写入时会报错）在前面尝试向MutableList&lt;<em>&gt;中写入元素的时候，你已经见过这种错误了。这种情况下，这个错误的意思是把具体类型的值传给未知类型的验证器是否安全的。*</em>一种修正方法是把验证器显式地转换成需要的类型。<strong>这样做是不安全的，也是不推荐的。</strong>但我们还是把他作为让代码快速通过编译的技巧展示在这里，这样可以在后面重构它。**</p>
<pre><code class="kotlin">/*    9.19 使用显式的转换获取验证器    */
&gt;&gt;&gt; val stringValidator = validators[String::class] as FieldValidator&lt;String&gt;   //警告未受检的转换
&gt;&gt;&gt; println(stringValidator.validate(&quot;&quot;))
false
</code></pre>
<p>编译器发出了未受检转换的警告。注意，尽管如此，这段代码只有在验证时可以失败，而不是在转换时，因为运行时所有的泛型信息都被擦除了。</p>
<pre><code class="kotlin">/*   9.20 错误的获取验证器   */
&gt;&gt;&gt; val stringValidator = validators[Int::class]// 得到一个错误的验证器（可能为不小心0，但代码可以编译。(获取一个Int强制转换为String)
        as FieldValidator&lt;String&gt;  // 仅仅一个警告
&gt;&gt;&gt; stringValidator.validate(&quot;&quot;)    //直到使用验证器才发现错误。
java.lang.ClassCastException:
java.lang.String cannot be cast to java.lang.Number at DefaultIntValidator.validate</code></pre>
<p>这两段代码在两种情景下是相似的，都只会发出警告。这些强制转换导致类型不安全，也容易出错。如果想要把不同类型的验证器存储在同一个地方，我们要研究一下其他的选择。</p>
</blockquote>
<p>代码 9.21 中使用解决方法 map validators，<strong>但是把所有对它的访问封装到了两个泛型方法中，它们负责保证只有正确的验证器被注册和返回。</strong>这段代码依然会发出未受捡转换的警告（这之前的一样），但这里的Validators对象控制了所有对map的访问，保证了没有任何人会错误的改变map。</p>
<pre><code class="kotlin">/*  9.21 封装对验证器集合的访问  */
object Validators {
    private val validators = = mutableMapOf&lt;KClass&lt;*&gt;, FieldValidator&lt;*&gt;&gt;()  //使用和之前一样的map，但现在无法在外部访问他
    fun &lt;T : Any&gt; registerValidator(
        kCLass: KClass&lt;T&gt;, fieldValidator: FieldValidator&lt;T&gt;
    ) {
        validators[kClass] = fieldValidator // 只有正确的键值对被写入map，即但验证器正好对应到类的时候。
    }

    @Suppress(&quot;UNCHECKED_CAST&quot;) // 禁止关于未受检的转换到FieldValidator&lt;T&gt; 的警告
    operator fun &lt;T : Any&gt; get(kClass: KClass&lt;T&gt;): FieldValidator&lt;T&gt; =
    validators[kCLass] as? FieldValidator&lt;T&gt; ?: throw IllegalArgumentException(
    &quot;No validator for ${kClass.simpleName}&quot;
    )
}
&gt;&gt;&gt; Validators.registerValidator(String::class, DefaultStringValidator)
&gt;&gt;&gt; Validators.registerValidator(Int::class,DefaultIntValidator)
&gt;&gt;&gt; println(Validators[String::class].validate(&quot;Kotlin&quot;))
true
&gt;&gt;&gt; println(Validators[Int::class].validate(42))
true</code></pre>
<p>你拥有了一个类似安全的API。所有不安全的逻辑都被隐藏在类的主体中，通过把这些逻辑局部化，保证了它不会被错误的使用。编译器禁止使用错误的验证器，因为Validatos对象始终都会给出正确的验证器实现。</p>
<pre><code class="kotlin">&gt;&gt;&gt; println(Validators[String::class].validate(42))
Error:The integer literal does not conform to the expected type String</code></pre>
<p>通过封装验证器集合的模式可以轻松的推广到任意自定义泛型类的存储。把不安全的代码局部化到一个分开的位置预防了误用，而且让容器的使用变的安全。这个模式并不是只针对Kotlin，Java中也可以使用同样的方法。</p>
<h2 id="9-4-小结"><a href="#9-4-小结" class="headerlink" title="9.4 小结"></a>9.4 小结</h2><ul>
<li>Kotlin的泛型同Java的泛型接近它们使用同样的方式声明泛型函数和泛型类。</li>
<li>同Java一样，泛型类型的类型实参只在编译器存在。</li>
<li>不能把带类型实参的类型和is运算符一起使用，因为类型实参在运行时不被擦除。</li>
<li>内联函数的类型参数可以标记成实化的，允许你在运行时对它们使用is检查，以及获得java.lang.Class实例</li>
<li>变型是一种说明两种拥有相同基础类型和不同类型参数的泛型类型之间子类型化关系的方式，<strong>它说明了如果其中一个泛型类型的类型参数是另一个的类型参数的子类型，这个泛型类型就是另外一个泛型类型的子类型或者超类型。</strong></li>
<li>声明一个类在某个类型上是协变的，该参数只能用在out位置。</li>
<li>逆变情况相反:可以声明一个类在某个类型参数上是逆变的，如果该参数只是用在in位置。</li>
<li>Kotlin中只读接口List声明成了逆变，这意味着List&lt; String &gt; 是 List&lt; Any &gt;的子类型</li>
<li>函数接口声明成了在第一个类型参数上逆变而在第二个接口上协变，使(Animal)-&gt;Int称为(Cat)-&gt;Number的子类型。</li>
<li>在Kotlin中即可以为整个泛型类指定变型（声明点变型），也可以为泛型类型特定的使用指定变型（使用点变型）。</li>
<li>当确切的类型实参是未知的或者不重要时，可以使用星号投影语法。</li>
</ul>
<h1 id="10-注解和反射"><a href="#10-注解和反射" class="headerlink" title="10 注解和反射"></a>10 注解和反射</h1><p>要调用一个函数，你需要知道定义在哪个类中，还有它的名称和参数的类型。 <strong>注解和反射</strong>给你超越这个规则的能力，并让你编写出使用事先未知的任意类的代码。可以使用注解赋予这些类库特定的语义，而反射允许你在运行时分析这些类的结构。</p>
<p>应用注解非常直接了当。但编写你的注解尤其是编写处理它们的代码，就没有这么简单了。使用注解的语法鱼Java完全相同，而声明自己注解类的语法却略有不同。  反射API的大体结构与Java相仿，但细节存在差异。</p>
<p><strong>作为注解和反射用法的演示，我们将会带你浏览一个真实项目的实现：一个叫做JKid的库，用来序列化和反序列化JSON。这个库在运行时用反射访问任意的Kotlin对象，同时还根据JSON文件中提供的数据创建对象。注解则可以让你定制具体的类和属性是如何被这个库序列化和反序列化的。</strong></p>
<h2 id="10-1-声明并应用注解"><a href="#10-1-声明并应用注解" class="headerlink" title="10.1 声明并应用注解"></a>10.1 声明并应用注解</h2><p>Kotlin 中的核心概念是一样的。一个注解允许你把额外的元数据关联到一个声明上。然后元数据就可以被相关的源代码工具访问，同个编译好的类文件或是在运行时，取决于这个注解是如何配置的。</p>
<h3 id="10-1-1-应用注解"><a href="#10-1-1-应用注解" class="headerlink" title="10.1.1 应用注解"></a>10.1.1 应用注解</h3><p>​        在Kotlin中使用注解的方法和Java中一样。要应用一个注解，以@字符作为（注解）名字的前戳，并放在要注解的声明最前面。可以注解不同的代码元素，比如函数和类。</p>
<p>​        例如，使用框架JUnit（<a href="http://junit.org/junit4)，可以用@Test标记一个测试方法：" target="_blank" rel="noopener">http://junit.org/junit4)，可以用@Test标记一个测试方法：</a></p>
<pre><code class="kotlin">import org.junit.*

class MyTest {
    @Test
    fun testTrue() {    //@Test注解指引Junit框架把这个方法当测试调用
        Assert.assertTrue(true)
    }
}</code></pre>
<p>另一个更有趣的例子：@Deprecated注解。它在Kotlin总的含义与java一样（@Deprecated 注解含义：意思为此方法已过时，因为有了新的API代替它。）但是Kotlin用replaceWith参数增强了它，让你可以提供 一个替代者的（匹配）模式，以支持平滑的过渡到API的新版本。</p>
<p>如何给一个注解提供实参（一条 不推荐使用 的信息和一个 替代者 的模式：</p>
<pre><code class="kotlin">@Deprecated(&quot;Use removeAt(index) instead.&quot;,RepalceWith(&quot;removeAt(Index)&quot;))
fun remove(index:Int){ ... }</code></pre>
<p>实参在括号中传递，就和常规函数的调用一样。用了这个声明之后，如果有人使用了remove函数，IntelliJ IDEA 不仅会提示应该使用哪个函数来使用它（这个例子中removeAt），还会提供一个自动的快速修正。</p>
<p>注解只能拥有如下类型的参数：基本数据类型、字符串、枚举、类引用、其他的注解类，以及前面这些类型的数组。指定注解的实参与Java有微小差别：</p>
<ul>
<li>要把一个类指定为注解实参，在类名后加上 ::class :@MyAnnotation(MyClass::class) 。</li>
<li>要把另一个注解指定为一个实参，去掉注解名称前的@。例如，前面例子中的ReplaceWith是一个注解，但是你把它指定为Deprecated注解的实参时没有用@。</li>
<li>要把一个数组指定为一个实参，使用arrayOf函数：@RequestMapping（path=arrayOf(“/foo”,”/bar”))。如果注解类是在Java中声明的，命名为value的形参按需自动地被转换成可变长度的形参，所以不用arrayOf函数就可以提供多个实参。</li>
</ul>
<p><strong>注解实参</strong>需要在编译期就是已知的，所以你不能引用任意的属性作为实参。要把属性当作注解实参使用，你需要用const修饰符标记它，来告知编译器这个属性是 <strong>编译期常量</strong>。</p>
<p>下面一个JUnit@Test注解的例子，使用timeout参数测试超时时长，单位为毫秒：</p>
<pre><code class="kotlin">const val TEST_TIMEOUT = 100L
@Test(timeout = TEST_TIMEOUT) fun testMethod(){    ...    }</code></pre>
<p>在使用const标注的属性可以声明在一个文件的顶层或者一个object之中，<strong>而却必须初始化为基本数据类型或者String类型的值。</strong>如果你尝试使用普通属性作为注解实参，将会得到一个错误“Only ‘const val’ can be used in constant expressions.”（只有‘const val’才能用在常量表达式中）。</p>
<h3 id="10-1-2-注解目标"><a href="#10-1-2-注解目标" class="headerlink" title="10.1.2 注解目标"></a>10.1.2 注解目标</h3><p> 多数情况下，Kotlin源代码中的单个声明会对应多个Java声明，而且它们每个都能携带注解。例如，一个Kotlin 属性就对应了一个Java字段，getter，以及一个潜在的setter和它的参数。而一个在主构造方法中声明的属性还多拥有一个对应的元素：<strong>构造方法的参数</strong>。因此，说明这些元素中那些需要注解十分必要。</p>
<p>​    <strong>使用点目标声明</strong>被用来说明要注解的元素。<strong>使用点目标被放在@符号和注解名称之间，并用冒号和注解名分开。下列单词get导致注解@Rule被应用到了属性的getter上。</strong></p>
<pre><code class="kotlin">@get:Rule
// get（使用点目标） Rule（注解目标）</code></pre>
<p>下面看一个使用这个注解的例子。在JUnit中可以指定一个每个测试方法被执行之前都会执行的规则。例，标准的TemporaryFolder规则用来创建文件和文件夹，并在测试结束后删除它们。</p>
<p><strong>使用 ”使用点目标声明“ 以及注意事项！</strong></p>
<p>要指定一个规则，<em>在Java中需要声明一个用@Rule的注解的public字段或者方法</em>。如果在你的Kotlin测试类中只是用@Rule注解了属性folder（包含字段folder？）你会得到一个JUnit一场：“The(???)’folder’ must be public.”（(???)’folder’必须是公有的。）这是因为@Rule被应用到了字段上，而字段是默认是私有的。要把它应用到（公有的）getter上，要显式的写出来，@get:Rule 如下：</p>
<pre><code class="kotlin">class HasTempFolder {
    @get:Rule   // 注解的是getter，而不是属性
    val folder = TemporaryFolder()

    @Test
    fun testUsingTempFolder() {
        val createFile = folder.newFile(&quot;myfile.txt&quot;)
        val createFolder = folder.newFolder(&quot;subfolder&quot;)
        // ...
    }
}</code></pre>
<p>如果你使用Java中声明的注解来注解一个属性，它会被默认的应用到相应的字段上。Kotlin 也可以让你声明被直接对应到属性上的注解。</p>
<p>Kotlin支持的使用点目标的完整列表如下：</p>
<ul>
<li>property——Java的注解不能应用这种使用点目标。</li>
<li>field——为属性生成字段。</li>
<li>get——属性的getter。</li>
<li>set——属性的setter。</li>
<li>receiver——扩展函数或者扩展属性的接收者参数。</li>
<li>param——构造方法的参数。</li>
<li>setparam——属性的setter的参数。</li>
<li>delegate——为委托属性存储委托实例的字段。</li>
<li>file——包含在文件中声明的顶层函数和属性的类。</li>
</ul>
<p>任何应用到file目标的注解都必须放在文件的顶层，放在package指令之前。@JvmName是常见的应用到文件的注解之一，它改变了对应类的名称。</p>
<p>和Java不一样的是，Kotlin允许你对任意的表达式应用注解，而不仅仅是类和函数的声明以及类型。最常见的例子就是@Suppress注解，可以用它遏制被注解的表达式的上下文中的特定的编译器警告。下面就是一个注解的局部变量声明的例子，抑制了未受捡转换的警告：</p>
<pre><code class="kotlin">fun test(list: List&lt;*&gt;) {
    @Suppress(&quot;UNCHECKED_CAST&quot;)
    val string = list as List&lt;String&gt;
    // ...
}</code></pre>
<blockquote>
<p><strong>用注解控制JavaAPI</strong></p>
<p>Kotlin 提供了各种注解来控制Kotlin编写的声明如何编译成字节码并暴露给Java调用者。其中一些注解代替了Java语言中对应的关键字：比如，注解@Volatile和@Strictfp直接充当了Java的关键字volatile和strictfp的替身。其他的注解则被用来改变Kotlin声明对Java调用者的可见性：</p>
<ul>
<li>@JvmName将改变由Kotlin生成的Java方法或字段名称。</li>
<li>@JvmStatic能被用在对象声明或者伴生对象的方法上，把它们暴露成Java的静态方法。</li>
<li>@JvmOverloads，指导Kotlin编译器为带默认参数值的函数生成多个重载（函数）。</li>
<li>@JvmField可以应用于一个属性，把这个属性暴露成一个没有访问器的公有Java字段。</li>
</ul>
</blockquote>
<h3 id="10-1-3-使用注解定制JSON序列化"><a href="#10-1-3-使用注解定制JSON序列化" class="headerlink" title="10.1.3 使用注解定制JSON序列化"></a>10.1.3 使用注解定制JSON序列化</h3><p>注解的典型用法之一就是定制化对象的序列化。<strong>序列化</strong> 是一个过程，把对象转换成可以存储或者在网络上可以传输的二进制或者文本的表达式。它的逆向工程可以 <strong>反序列化</strong> ，把这种表达法转换回对象。而最常见的一种用来序列化的格式计算JSON。 有很多广泛使用的库可以把Java对象序列化成JSON，包括Jackson和GSON。这些对Kotlin完全兼容。</p>
<p>将会讨论一个满足此用途的名为JKid的纯Kotlin库。它足够小巧，可以轻松的读完它的全部源代码。</p>
<blockquote>
<p><strong>JKid 库源代码和练习</strong></p>
<p>JKid 地址：<a href="https://github.com/yole/jkid。要学习库的实现和例子，在IDE中把文件" target="_blank" rel="noopener">https://github.com/yole/jkid。要学习库的实现和例子，在IDE中把文件</a> ch10/jkid/build.gradle 作为Gradle项目打开。在项目的 src/test/kotlin/examples 目录下可以找到这些例子。它并不像GSON或者Jackson那样完善灵活，但它的性能足够使用。</p>
</blockquote>
<p>先从简单的例子开始，测试这个库：序列化和反序列化一个Person类的实例。<em>把实例传递给serialize函数，然后它就会返回一个包含该实例JSON表示法的字符串：</em></p>
<pre><code class="kotlin">data class Person(val name:String,val age:Int)

&gt;&gt;&gt; val person = Person(&quot;Alice&quot;,29)
&gt;&gt;&gt; println(serialize(person))
{&quot;age&quot;:29,&quot;name&quot;:&quot;Alice&quot;}</code></pre>
<p>一个对象的JSON表达法由键值对组成：具体实例的属性名称和它们的值之间的键值对，比如：“age”:29 。</p>
<p><strong>要从JSON表达法中取回一个对象，</strong>要调用deserialize函数：</p>
<pre><code class="kotlin">&gt;&gt;&gt; val json=&quot;&quot;&quot;{&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:29}&quot;&quot;&quot;
&gt;&gt;&gt; println(deserialize&lt;Person&gt;(json))
Person(name=Alice,age = 29)</code></pre>
<p><strong>当你从JSON数据中创建实例的时候，必须显式的指定一个类作为类型参数，因为JSON没有存储对象的类型，</strong>这种情况下，你要传递Person类。</p>
<p>下图，展示了一个对象和它的JSON表示法之间的关系。注意序列化之后的类能包含的不仅是图中展示的这些基本数据类型或者字符串类型的值，还可以是集合，以及其他值对象类的实例。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2022-02-20_19-56-13.jpg" alt="Person实例的序列化和反序列化"></p>
<p>你可以使用注解来定制对象序列化和反序列化的方式。当把一个对象序列化成JOSN的时候，默认情况下这个库尝试序列化的所有属性，并使用属性名称作为键。注解允许你改变默认的行为，两个注解，@JsonExclude和@JsonName，稍后查看它们的实现：</p>
<ul>
<li>@JsonExclude注解用来标记一个属性，这个属性应该排除在序列化和反序列化之外。</li>
<li>@JsonName注解让你说明代表这个属性的（JSON）<strong>键值对中的键应该是一个给定的字符串，而不是属性的名称。</strong></li>
</ul>
<p>参考一个例子：</p>
<pre><code class="kotlin">data class Person {
    @JsonName(&quot;alias&quot;)
    val firstName: String,
    @JsonExclude
    val age: Int? = null
}</code></pre>
<p>你注解了属性firstName，来改变JSON中用来表示它的键。<strong>而属性age也被注解了，在序列化和反序列化时会排除它。注意你必须指定age的默认值。否则，在反序列化时你无法创建一个Person的新实例。</strong> 如下展示了Person内实例的表示法发生了怎样的变化。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220228145204.png" alt="应用注解之后Person实例的序列化和反序列化"></p>
<blockquote>
<p>键名是@JsonName注解的字符串“alias”。</p>
</blockquote>
<p>已经见过了JKid中出现的大多数功能：serialize()、deserialize()、@JsonName和@JsonExclude。讨论如何实现它们吧。</p>
<h3 id="10-1-4-声明注解"><a href="#10-1-4-声明注解" class="headerlink" title="10.1.4 声明注解"></a>10.1.4 声明注解</h3><p>这次你会以<strong>JKid库中的注解为例学习怎样声明他们</strong>。注解@JsonExclude有着最简单的形式，因为它没有任何参数：</p>
<pre><code class="kotlin">annotation class JsonExclude</code></pre>
<p>语法看起来和普通类的声明很像，只是在class关键词之前加上了annotation修饰符。<strong>因为注解类只是用来定义关联到声明和表达式的元数据的结构，它们不能包含任何代码。</strong>因此，编译器禁止为一个注解类指定主体。</p>
<p><strong>对拥有参数的注解来说，在类的主构造方法中声明这些参数：</strong></p>
<pre><code class="kotlin">annotation class JsonName(val name:String)</code></pre>
<p>你用的是常规的主构造方法的声明语法。对一个注解类的所有参数来说，val关键字是强制的。</p>
<pre><code class="kotlin">/*    Java    */
public @interface JsonName{
    String value();
}</code></pre>
<p>注意，Java注解拥有一个叫做value的方法，而Kotlin注解拥有一个name属性。Java中value方法很特殊：当你应用一个注解时，你需要提供value以外所有指定特性的显式名称。而另一方面，在Kotlin中应用注解就是常规的构造方法调用。可以使用命名实参语法让实参的名称变成显式的，或者可以省略掉这些实参的名称：@JsonName(name = “first_name”) 和 @JsonName(“first_name”)含义一样。因为name是JsonName构造方法的第一个形参（它的名称可以省略）。（<strong>Kotlin中如何使用Java中声明的注解？</strong>）然而，如果你需要把Java中声明的注解应用到Kotlin元素上，必须对除啦value以外的所有实参使用命名实参语法，而value也会被kotlin特殊对待。</p>
<p>如何控制注解的使用，以及如何把注解应用到其他注解上。</p>
<h3 id="10-1-5-元注解：控制如何处理一个注解"><a href="#10-1-5-元注解：控制如何处理一个注解" class="headerlink" title="10.1.5 元注解：控制如何处理一个注解"></a>10.1.5 元注解：控制如何处理一个注解</h3><p>和Java一样，一个Kotlin注解类自己也可以被注解。可以应用到注解类上的注解被称为<strong>元注解</strong>。标准库中定义了一些元注解，它们会控制编译器如何处理注解。其他一些框架也会用到元注解——<em>例如，许多依赖注入库使用了元注解来标记其他注解，表示这些注解用来识别拥有同样类型的不用的可注入对象。</em></p>
<p>标准库定义的<strong>元注解</strong>中最常见的就是@Target。<strong>JKid</strong>中@JsonExclude和@JsonName的声明中使用它为这些注解指定有效的目标。下面展示它们是如何应用到这些注解上的。</p>
<pre><code class="kotlin">@Traget(AnnotationTarget.PROPERTY)
annotation class JsonExclude</code></pre>
<p>@Target <strong>元注解说明了注解可以被应用到元素类型</strong>。<strong>如果不使用它，所有的声明都可以应用这个注解</strong>。这并不是JKid想要的，因为它只处理属性的注解。</p>
<p>AnnotationTarget枚举的值列出了可以应用注解的全部可能目标。例如：类、文件、函数、属性、属性访问器、所有的表达式，等等。如果需要，你还可以声明多个目标：@Target(AnnotationTarget.CLASS,AnnotationTarget.METHOD)。</p>
<p>要声明你自己的元注解，使用ANNOTATION_CLASS作为目标就好了</p>
<pre><code class="kotlin">@Target(AnotationTarget.ANNOTATION_CLASS)
annotation class BindingAnnotation

@BindingAnnotation
annotation class MyBinding</code></pre>
<p><em>在Java代码中无法使用目标PROPERTY的注解：要让这样的注解在Java中使用，可以给它添加第二个目标AnnotationTarget.FIELD。这样注解既可以应用到Kotlin中的属性上，也可以应用到Java中的字段上。</em></p>
<blockquote>
<p>@Retention 注解</p>
<p>你也许在Java中见过另一个重要的元注解：<strong>@Retention。它被用来说明你声明的注解时候会存储到.class文件，以及在运行时是否可以通过反射来访问它。</strong>Java默认会在.class文件中保留注解但不会让它们在运行期间被访问到。大多数注解确实需要在运行时存在，所以Kotlin的默认行为不同：注解拥有RUNTIME保留期。因此JKid中的注解没有显示地指定保留期。</p>
</blockquote>
<h3 id="10-1-6-使用类做注解参数"><a href="#10-1-6-使用类做注解参数" class="headerlink" title="10.1.6 使用类做注解参数"></a>10.1.6 使用类做注解参数</h3><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h3 id="字段和属性"><a href="#字段和属性" class="headerlink" title="字段和属性"></a>字段和属性</h3><p><a href="https://blog.csdn.net/chenchunlin526/article/details/71424844" target="_blank" rel="noopener">深入理解Java中的字段与属性的区别</a></p>
<h4 id="属性和字段的区别"><a href="#属性和字段的区别" class="headerlink" title="属性和字段的区别"></a>属性和字段的区别</h4><p>属性（property），通常可以理解为get 和 set 方法。</p>
<p>字段（field），通常叫做 <strong>类成员</strong>，或者 <strong>类变量</strong> ，有时也叫 域 ，理解为 数据成员，用来承担数据的。</p>
<h4 id="属性和字段详解"><a href="#属性和字段详解" class="headerlink" title="属性和字段详解"></a>属性和字段详解</h4><p><strong>字段（field）</strong></p>
<p>类成员（字段field），通常在类中定义成员变量例如：</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200909213136.png" alt=""> </p>
<p>解释为：<strong>FacebookUser类拥有成员变量nickname，有一个字段 nickname。</strong></p>
<p>字段一般用于承担数据，所以为了数据的安全性，一般设置为私有的。</p>
<p>字段和常量描述的类的数据（域），当这些数据的某些部分不运行外界访问时，<strong>根据”对象封装“原则，应该尽量避免将类的字段以公有方式提供给外部</strong>。除啦final修饰的常量。</p>
<p><strong>属性（property）</strong></p>
<p><strong>属性只局限于类中方法的声明，并不与类中其它成员相关</strong>，数据JavaBean范畴：</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200909220317.png" alt=""></p>
<p>这是一个属性，一个字段。</p>
<p>总结：属性是对字段的封装，供外部访问。通常<strong>属性</strong>将对应的<strong>私有字段</strong>通过封装成公共属性，以便于外界访问和修改。</p>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>是指可以被求值的代码。</p>
<p>例如</p>
<pre><code class="c">int result = add(x + 1,y)</code></pre>
<blockquote>
<p>x + 1 作为表达式传递了数值</p>
</blockquote>
<pre><code class="c">int result = add（if(x==1),y）</code></pre>
<blockquote>
<p>这段语句在 c 中是没有办法作为表达式的。</p>
</blockquote>
<h3 id="Kotlin-this表达式"><a href="#Kotlin-this表达式" class="headerlink" title="Kotlin this表达式"></a>Kotlin this表达式</h3><p>为了表示当前的 <strong>接收者</strong> 使用 this{:.keyword} 表达式：</p>
<ul>
<li>在类的成员中，this{:.keyword}指的是当前对象</li>
<li>在扩展函数或者带接受者的函数字面值中，this{:.keyword}表示在点左侧的接收者参数。</li>
</ul>
<h3 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h3><p>函数引用 是kotlin引入的一个功能。使用(::)表示对函数的引用</p>
<p>代码</p>
<pre><code class="kotlin">val sum:(Int,Int) -&gt; Int = {x,y -&gt; x +y}</code></pre>
<blockquote>
<p>sum 是一个函数类型的变量，lambda表达式执行了相加的操作。</p>
</blockquote>
<pre><code class="kotlin">fun applyOp(x: Int, y: Int, op: (Int, Int) -&gt; Int): Int = op(x, y)</code></pre>
<p>applyOp 是一个接受三个参数的函数，第三个参数是lambda类型。可以用下面的返回调用这个函数：</p>
<pre><code class="kotlin">applyOp(2,3,sum)</code></pre>
<p>即高阶函数可以作为一个类型赋值给变量，也可以作为另一个函数的参数。</p>
<h4 id="函数引用：函数可以是一个-lambda"><a href="#函数引用：函数可以是一个-lambda" class="headerlink" title="函数引用：函数可以是一个 lambda"></a>函数引用：函数可以是一个 lambda</h4><p>上述的lambda表达式，可以用纯函数的形式：</p>
<pre><code class="kotlin">fun sum(x: Int, y: Int) = x + y</code></pre>
<p>实现效果是一样的，区别在于不再需要使用变量来保持对函数的引用，但是这样需要对applOp函数要做一些修改，原来的</p>
<p><strong>applOp(2,3,sum)</strong>写法会报类型不匹配的语法错误。需要修改为使用<strong>函数引用</strong>代码如下：</p>
<pre><code class="kotlin">applOp(2,3,::sum)</code></pre>
<p>这些算是 函数引用 的大致概念。同时<strong>函数引用</strong>也是可以赋值给变量的。</p>
<pre><code class="kotlin">val sumLambda: (Int, Int) -&gt; Int = ::sum
applyOp(2, 3, sumLambda)</code></pre>
<h3 id="lamnda-表达式-与-匿名内部类的区别"><a href="#lamnda-表达式-与-匿名内部类的区别" class="headerlink" title="lamnda 表达式 与 匿名内部类的区别"></a>lamnda 表达式 与 匿名内部类的区别</h3><blockquote>
<ul>
<li>lambda 表达式只能为函数式接口创建实例；匿名内部类可以为任意接口创建实例 – 不管接口包含多少抽象方法，只要匿名内部类是实现所有的抽象方法即可。</li>
<li>lambda 表达式只能为函数式接口创建实例；匿名内部类可以为抽象类甚至普通话类创建实例；</li>
<li>lambda 表达式的代码不允许调用接口中定义的默认方法；匿名内部类实现的抽象方法的方法体允许调用接口中定义的默认方法。</li>
</ul>
</blockquote>
<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><h2 id="Reified实化类型参数"><a href="#Reified实化类型参数" class="headerlink" title="Reified实化类型参数"></a>Reified实化类型参数</h2><p>背景：</p>
<blockquote>
<p>Java中泛型是在JDK1.5版本后引入的，但集合Collection实在JDK1.2版本时引入的，现在看到的List，是在泛型出现后加入的，那么JDK1.2之前就直接用LIst（java中俗称原生态类型）表示。在为了兼容之前的版本Java采用所谓的伪泛型，伪泛型有一个特征就是<strong>泛型擦除</strong>，表示泛型类型信息在编译时期会被抹除掉，包括你是List还是List在运行时它们都是一样，那都是List类型，泛型类型信息已经被抹除掉了。</p>
</blockquote>
<h2 id="Kotlin中的形参和实参"><a href="#Kotlin中的形参和实参" class="headerlink" title="Kotlin中的形参和实参"></a>Kotlin中的形参和实参</h2><p>ps：</p>
<p><a href="https://juejin.cn/post/6844903694119485447#heading-6" target="_blank" rel="noopener">一个简单方式教你记住Kotlin的形参和实参</a></p>
<h2 id="什么才是泛型擦除"><a href="#什么才是泛型擦除" class="headerlink" title="什么才是泛型擦除"></a>什么才是泛型擦除</h2><p>ps:</p>
<p><a href="https://juejin.cn/post/6844904083199918093" target="_blank" rel="noopener">面试官问我：“泛型擦除是什么，会带来什么问题？”</a></p>
<p><strong>引用：</strong></p>
<p><a href="https://www.web3.xin/code/2606.html" target="_blank" rel="noopener">Kotlin this表达式</a></p>
<p><a href="https://www.jianshu.com/p/10358883455c" target="_blank" rel="noopener">kotlin中的函数引用详解</a>    </p>
<p><a href="http://c.biancheng.net/view/6559.html" target="_blank" rel="noopener">Lambda表达式与匿名内部类的联系和区别</a></p>
<p>Kotlin 实战 </p>
<p> 著(Dmitry Jemerov ,Svetlana Isakova)</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-8-3-1.gif" alt="如果有些方法没有详细说明你可以自行搜索查看"></p>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://thecara.github.io" rel="external nofollow noreferrer">TheCara</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://thecara.github.io/2020/07/26/kotlin-in-Action-Kotlin%E5%AE%9E%E6%88%98/">https://thecara.github.io/2020/07/26/kotlin-in-Action-Kotlin%E5%AE%9E%E6%88%98/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by-nc/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY-NC 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://thecara.github.io" target="_blank">TheCara</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/07/26/choco%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%89%E8%A3%85/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/21.jpg" class="responsive-img" alt="Chocolatey的配置与应用的安装">
                        
                        <span class="card-title">Chocolatey的配置与应用的安装</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            使用 Chocolatey安装7zip全程使用科学上网
choco install 7zip如何安装Chocolatey在桌面下载
使用管理员打开cmd访问到下载的目录中
输入👇.安装的同时要使用科学上网
@powershell -NoP
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-07-26
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Chocolatey/" class="post-category">
                                    Chocolatey
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Chocolatey/">
                        <span class="chip bg-color">Chocolatey</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/07/26/RecyclerView%E5%9C%A8Kotlin%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/">
                    <div class="card-image">
                        
                        <img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-05-31_13-09-29.png" class="responsive-img" alt="RecyclerView在Kotlin中的使用">
                        
                        <span class="card-title">RecyclerView在Kotlin中的使用</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            创建项目RecyclerExample项目需要引入依赖
需要子项布局在 “RecyclerViewExample\app\src\main\res\layout”下创建 “example_item.xml” 👇
&lt;?xml vers
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-07-26
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Android/" class="post-category">
                                    Android
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Android/">
                        <span class="chip bg-color">Android</span>
                    </a>
                    
                    <a href="/tags/Kotlin/">
                        <span class="chip bg-color">Kotlin</span>
                    </a>
                    
                    <a href="/tags/RecyclerView/">
                        <span class="chip bg-color">RecyclerView</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('h1'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="/about" target="_blank">TheCara</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/TheCara" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:qyx2013@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1099178659" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1099178659" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
