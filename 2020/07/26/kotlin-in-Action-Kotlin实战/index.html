<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="kotlin in Action-Kotlin实战, TheCara">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>kotlin in Action-Kotlin实战 | TheCara</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">TheCara</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">TheCara</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/TheCara" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/TheCara" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200831160049.png')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">kotlin in Action-Kotlin实战</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Android/">
                                <span class="chip bg-color">Android</span>
                            </a>
                        
                            <a href="/tags/Kotlin/">
                                <span class="chip bg-color">Kotlin</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Kotlin/" class="post-category">
                                Kotlin
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-07-26
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="2-Kotlin-基础"><a href="#2-Kotlin-基础" class="headerlink" title="2 Kotlin 基础"></a>2 Kotlin 基础</h1><h3 id="2-1-基本要素-函数变量"><a href="#2-1-基本要素-函数变量" class="headerlink" title="2.1 基本要素: 函数变量"></a>2.1 基本要素: 函数变量</h3><h4 id="2-1-3-变量"><a href="#2-1-3-变量" class="headerlink" title="2.1.3 变量"></a>2.1.3 变量</h4><p><strong>可变变量和不可变变量</strong></p>
<ul>
<li>val–不可变引用。使用val声明的变量不能在初始化之后再次赋值。它对应的是java中的final变量</li>
<li>var–可变引用。这种变量的值可以被改变。这种声明对应的是普通(非final)变量</li>
</ul>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595899792330.png" alt=""></p>
<p>👆在定义了val变量的代码块期间,<strong>val变量只能进行唯一一次初始化</strong>。但是,如果编译器能确保只有唯一一次初始化语句会被执行,可以根据条件使用不同的值来初始化它。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595899976491.png" alt=""></p>
<p>自身不可变(只可以执行一次,初始化一次)</p>
<p>注意,尽管val引用自身是不可变的,但是它指向的对象<strong>`可能</strong>`是可变的。列如</p>
<pre><code>val languages = arrayListOf(&quot;Java&quot;)
lenguages.add(&quot;Kotlin&quot;)</code></pre><h3 id="2-3-表示和处理选择：枚举和“when”"><a href="#2-3-表示和处理选择：枚举和“when”" class="headerlink" title="2.3 表示和处理选择：枚举和“when”"></a>2.3 表示和处理选择：枚举和“when”</h3><h4 id="2-3-1-声明枚举类"><a href="#2-3-1-声明枚举类" class="headerlink" title="2.3.1 声明枚举类"></a>2.3.1 声明枚举类</h4><p><strong>什么是枚举</strong></p>
<p>为了让编译器能够自动检查某个值在枚举的集合中，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用 <strong>enum</strong> 来定义枚举类。</p>
<pre><code class="kotlin">enum class Color{
    RED,ORANGE,YELLOW,GREEN,BLUE,INDIGO,VIOLET
}</code></pre>
<p>kotlin 中 enum 是一个所谓的软关键词：只有当它出现在class前面时才会有特殊的意义，在其他地方可以把它当作普通的名称使用。</p>
<h4 id="2-3-5-智能转换：合并类型检查和转换"><a href="#2-3-5-智能转换：合并类型检查和转换" class="headerlink" title="2.3.5 智能转换：合并类型检查和转换"></a>2.3.5 智能转换：合并类型检查和转换</h4><h5 id="kotlin智能转换的案例"><a href="#kotlin智能转换的案例" class="headerlink" title="kotlin智能转换的案例"></a>kotlin智能转换的案例</h5><h6 id="表达式类型层次"><a href="#表达式类型层次" class="headerlink" title="表达式类型层次"></a>表达式类型层次</h6><pre><code class="kotlin">interface Expr
class Num(val value: Int) : Expr    // 简单的值对象类，只有一个属性value，实现了Expr接口
class Sum(val left: Expr, val right: Expr) : Expr   // Sum运算的实参可以是任何Expr:Num 或者 Sum</code></pre>
<h6 id="对表达式求值"><a href="#对表达式求值" class="headerlink" title="对表达式求值"></a>对表达式求值</h6><pre><code class="kotlin">fun eval(e: Expr): Int {
    if (e is Num) {
//        val n = e.value as Num //显示的转换为Num类型多余的
        return e.value
    }
    if (e is Sum) {
        return eval(e.left) + eval(e.right) // 变量 e 被智能的转换了类型
    }
    throw IllegalArgumentException(&quot;test&quot;)
}</code></pre>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200831171911.png" alt=""></p>
<p>结果</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200831171248.png" alt=""></p>
<h5 id="“is”-修饰符"><a href="#“is”-修饰符" class="headerlink" title="“is” 修饰符"></a>“is” 修饰符</h5><p>在 kotlin 中，你要使用 is 检查来判断一个变量是否是某个类型。</p>
<h5 id="什么时候进行智能转换？"><a href="#什么时候进行智能转换？" class="headerlink" title="什么时候进行智能转换？"></a>什么时候进行智能转换？</h5><p>如果你检查过一个变量是某种类型，后面就不再需要转换它了，可以就把它当作你检查过的类型使用。事实上编译器为你执行了类型转换，我们把这种行为称为 <strong>智能转换。</strong></p>
<h1 id="3-函数的订阅和调用"><a href="#3-函数的订阅和调用" class="headerlink" title="3 函数的订阅和调用"></a>3 函数的订阅和调用</h1><h2 id="3-3-给别人的类添加方法：扩展函数和属性"><a href="#3-3-给别人的类添加方法：扩展函数和属性" class="headerlink" title="3.3 给别人的类添加方法：扩展函数和属性"></a>3.3 给别人的类添加方法：扩展函数和属性</h2><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><blockquote>
<p>扩展函数非常简单，作为一个类的成员函数，不过它定义在类的外边。</p>
</blockquote>
<h1 id="4-类、对象和接口"><a href="#4-类、对象和接口" class="headerlink" title="4 类、对象和接口"></a>4 类、对象和接口</h1><h3 id="4-1-定义类继承结构"><a href="#4-1-定义类继承结构" class="headerlink" title="4.1 定义类继承结构"></a>4.1 定义类继承结构</h3><h4 id="4-1-1-Kotlin-中的接口"><a href="#4-1-1-Kotlin-中的接口" class="headerlink" title="4.1.1 Kotlin 中的接口"></a>4.1.1 Kotlin 中的接口</h4><h5 id="声明接口"><a href="#声明接口" class="headerlink" title="声明接口"></a>声明接口</h5><pre><code class="kotlin">interface Clickable{
    fun click()
}</code></pre>
<h5 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h5><pre><code>class Button : Clickble {
    override fun click() {
        println(&quot;I was clicked&quot;)
    }
}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200826205307.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200826205356.png" alt=""></p>
<h5 id="Kotlin实现接口与-Java-有那些不同"><a href="#Kotlin实现接口与-Java-有那些不同" class="headerlink" title="Kotlin实现接口与 Java 有那些不同"></a>Kotlin实现接口与 Java 有那些不同</h5><p>Kotlin 在类后面使用冒号来代替 <strong>Java</strong> 中的 extends 和 implements 关键词。 和 Java 一样，<strong>一个类可以实现任意多个接口</strong>，但<strong>只能继承一个类型</strong>。</p>
<h5 id="override-修饰符的作用"><a href="#override-修饰符的作用" class="headerlink" title="override 修饰符的作用"></a>override 修饰符的作用</h5><ul>
<li>相同</li>
</ul>
<p>与 Java 中的 @Override 注解类似，<strong>override 修饰符用来标注被重写的父类或者接口的方法和属性</strong>。</p>
<ul>
<li>不同</li>
</ul>
<p>在 Kotlin 中使用 override 修饰符是强制要求的。<strong>这会避免先写出实现方法再添加抽象方法造成的意外重写：</strong>你的代码将不能编译，除非你显式地将这个方法标注为 Override 或者重命名它。</p>
<h5 id="如何给接口添加一个默认实现的方法"><a href="#如何给接口添加一个默认实现的方法" class="headerlink" title="如何给接口添加一个默认实现的方法"></a>如何给接口添加一个默认实现的方法</h5><p>接口的方法可以有一个默认实现的方法。</p>
<pre><code class="kotlin">interface Clickable{
    fun click() // 普通的方法声明
    fun showOff() = println(&quot;I&#39;m clickable!&quot;) // 带默认实现的方法
}</code></pre>
<h5 id="实现一个带有默认实现的方法的接口要注意什么"><a href="#实现一个带有默认实现的方法的接口要注意什么" class="headerlink" title="实现一个带有默认实现的方法的接口要注意什么"></a>实现一个带有默认实现的方法的接口要注意什么</h5><p>如果你实现了这个接口，你需要为 click 提供一个实现。可以重新定义 showOff() 方法的行为，或者如果你对默认行为感到满意也可以直接省略它。（默认实现的方法也可以被重写）</p>
<h5 id="定义实现了同样方法的接口"><a href="#定义实现了同样方法的接口" class="headerlink" title="定义实现了同样方法的接口"></a>定义实现了同样方法的接口</h5><pre><code class="kotlin">interface Focusable {
    fun setFocus(b: Boolean) = println(&quot;I ${if (b) &quot;got&quot; else &quot;lost&quot;} focus.&quot;)
    fun showOff() = println(&quot;I&#39;m focusable!&quot;)
}</code></pre>
<h5 id="在类中实现两个有相同默认实现方法的接口会发生什么"><a href="#在类中实现两个有相同默认实现方法的接口会发生什么" class="headerlink" title="在类中实现两个有相同默认实现方法的接口会发生什么"></a>在类中实现两个有相同默认实现方法的接口会发生什么</h5><p>在这两个接口中都带有默认实现的 showOff() 方法：在没有显示的实现 showOff() ,会得到编译错误信息。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827000446.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827000526.png" alt=""></p>
<h6 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h6><p>必须显式的实现相同方法。</p>
<h5 id="调用继承-接口-的默认实现方法"><a href="#调用继承-接口-的默认实现方法" class="headerlink" title="调用继承(接口)的默认实现方法"></a>调用继承(接口)的默认实现方法</h5><pre><code class="kotlin">class Button : Clickable, Focusable {
    override fun click() {
        TODO(&quot;Not yet implemented&quot;)
    }

    //如果同样的继承成员不止一个实现，必须提供一个显示的实现。
    override fun showOff() {
        // 使用尖括号加上父类名字的“super”表明了你想要调用哪一个父类的方法
        super&lt;Clickable&gt;.showOff()
        super&lt;Focusable&gt;.showOff()
    }

}</code></pre>
<p>通过调用继承的两个父类型中的实现来实现 showOff() 。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827005257.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827005432.png" alt=""></p>
<h4 id="4-1-2-open、final-和-abstract-修饰符：默认为-final"><a href="#4-1-2-open、final-和-abstract-修饰符：默认为-final" class="headerlink" title="4.1.2 open、final 和 abstract 修饰符：默认为 final"></a>4.1.2 open、final 和 abstract 修饰符：默认为 final</h4><h5 id="kotlin-中如何继承一个类"><a href="#kotlin-中如何继承一个类" class="headerlink" title="kotlin 中如何继承一个类"></a>kotlin 中如何继承一个类</h5><p>如果你想要创建一个类的子类，需要使用 open 修饰符来标示这个类。此外<strong>需要给每个可以被重写的属性或者方法添加 open 属性</strong>。</p>
<h5 id="声明一个带open-方法的-open-类"><a href="#声明一个带open-方法的-open-类" class="headerlink" title="声明一个带open 方法的 open 类"></a>声明一个带open 方法的 open 类</h5><pre><code class="kotlin">open class RichButton : Clickable {
    fun disable() {}    // 这个函数是 final 的： 不能在子类中重写它。
    open fun animate() {} // 这个函数是 open 的： 可以在子类中重写它

    // 这个函数重写了 open 函数并且它本身同样是 open 的
    override fun click() {
        TODO(&quot;Not yet implemented&quot;)
    }

}</code></pre>
<h5 id="默认-final-的好处"><a href="#默认-final-的好处" class="headerlink" title="默认 final 的好处"></a>默认 final 的好处</h5><p>类默认 final 带来了一个重要的好处就是这使得在大量的场景中的只能转换成为可能。</p>
<h5 id="智能转换的前提"><a href="#智能转换的前提" class="headerlink" title="智能转换的前提"></a>智能转换的前提</h5><p><strong>智能转换只能在进行类型检查后没有改变过的变量上起的作用。</strong>对于一个类来说，这意味着<strong>智能转换在val类型并且没有自定义访问器的类属性上使用</strong>。 这个前提意味着属性必须是 final 的，否则如果一个子类可以重写属性并且定义一个自定义的访问器将会打破智能转换的关键前提。</p>
<h5 id="抽象类的默认修饰符"><a href="#抽象类的默认修饰符" class="headerlink" title="抽象类的默认修饰符"></a>抽象类的默认修饰符</h5><p>抽象成员始终是open的，所以不需要显式地使用open修饰符。</p>
<h5 id="声明一个抽象类"><a href="#声明一个抽象类" class="headerlink" title="声明一个抽象类"></a>声明一个抽象类</h5><pre><code class="kotlin">abstract class Animated {
    abstract fun animate()  // 这个函数是抽象的：它没有实现必须被子类重写

    // 抽象类中的非抽象函数 并不是默认 open 的，但是可以标注为 open的
    open fun stopAnimating() {

    }

    fun animateTwice() {}
}</code></pre>
<h4 id="4-1-4-内部类和嵌套类：默认嵌套类"><a href="#4-1-4-内部类和嵌套类：默认嵌套类" class="headerlink" title="4.1.4 内部类和嵌套类：默认嵌套类"></a>4.1.4 内部类和嵌套类：默认嵌套类</h4><p>内部类：非静态嵌套类，也被成为内部类。</p>
<p>嵌套类：静态嵌套类，嵌套类多称为：静态嵌套类。</p>
<h5 id="Kotlin中嵌套类和Java中的不同"><a href="#Kotlin中嵌套类和Java中的不同" class="headerlink" title="Kotlin中嵌套类和Java中的不同"></a>Kotlin中嵌套类和Java中的不同</h5><p>在Kotlin中的嵌套类不能访问外部类的实例，除非你特别的做出要求。 </p>
<h5 id="在序列化时使用内部类"><a href="#在序列化时使用内部类" class="headerlink" title="在序列化时使用内部类"></a>在序列化时使用内部类</h5><p>在你定义一个 View 元素，它的状态时可序列化的。<strong>想要序列化一个视图可能并不容易，但是可以把所有需要的数据复制到另一个辅助类中去。</strong></p>
<pre><code class="kotlin">interface State : Serializable
interface View {
    fun getCurrentState(): State
    fun restoreState(state: State) {}
}</code></pre>
<p>声明State接口去实现Serializable。View接口声明了可以用来保存视图状态的getCurrentState和restoreState方法。</p>
<h5 id="用内部类的java代码来实现View"><a href="#用内部类的java代码来实现View" class="headerlink" title="用内部类的java代码来实现View"></a>用内部类的java代码来实现View</h5><pre><code class="java">public class Button implements View{
    @Override
    public State getCurrentState(){
        return new ButtonState();
    }
    @Override
    public voiew restoreState(State state){
        /**/
    }
    public class ButtonState implements State{
        /**/
    }
}</code></pre>
<p>问题：在运行时你会得到 java.io.NotSerializable.Exception:Button 异常，在你序列化声明的按钮状态时。这个可能看起来会很奇怪：你序列化的变量是ButtonState类型，为什么会有Button异常呢？</p>
<h5 id="无法序列化的原因"><a href="#无法序列化的原因" class="headerlink" title="无法序列化的原因"></a>无法序列化的原因</h5><p>在java中，当你在另一个类中声明一个类时，它会默认变成内部类。案例中：ButtonState类隐示的存储了它的外部Button类的应用。从而解释了为什么ButtonState不能被序列化。</p>
<h5 id="修复无法序列化"><a href="#修复无法序列化" class="headerlink" title="修复无法序列化"></a>修复无法序列化</h5><p><strong>需要声明ButtonState类是static的</strong>。将嵌套类声明为static会冲这个类中删除包围它的类的隐式引用。</p>
<h5 id="在kotlin中使用嵌套类来实现-View"><a href="#在kotlin中使用嵌套类来实现-View" class="headerlink" title="在kotlin中使用嵌套类来实现 View"></a>在kotlin中使用嵌套类来实现 View</h5><pre><code class="kotlin">class Button : View {
    override fun getCurrentState(): State {
        TODO(&quot;Not yet implemented&quot;)
    }

    override fun restoreState(state: State) {
        TODO(&quot;Not yet implemented&quot;)
    }

    // 这个类与Java中的静态潜逃类类似
    class ButtonState : State {

    }

}</code></pre>
<p><strong>kotlin中默认行为是嵌套类。</strong></p>
<h5 id="如何让默认嵌套类的类型变为内部类！"><a href="#如何让默认嵌套类的类型变为内部类！" class="headerlink" title="如何让默认嵌套类的类型变为内部类！"></a>如何让默认嵌套类的类型变为内部类！</h5><p>要把它（嵌套类）变成为一个内部类来持有一个外部类的引用的话需要使用 <strong>inner</strong> 修饰符。</p>
<h5 id="kotlin中内部类访问外部类"><a href="#kotlin中内部类访问外部类" class="headerlink" title="kotlin中内部类访问外部类"></a>kotlin中内部类访问外部类</h5><p>在kotlin中引用外部类实例的语法与java不同。需要使用this@Outer从Inner类去访问Outer类。</p>
<h4 id="4-1-5-密封类：定义受限的类继承结构"><a href="#4-1-5-密封类：定义受限的类继承结构" class="headerlink" title="4.1.5 密封类：定义受限的类继承结构"></a>4.1.5 密封类：定义受限的类继承结构</h4><h5 id="什么是密封类”sealed“"><a href="#什么是密封类”sealed“" class="headerlink" title="什么是密封类”sealed“"></a>什么是密封类”sealed“</h5><p>sealed 类。为父类添加了一个新的 sealed 修饰符，可对创建的子类做出严格的限制。<strong>所有的子类必须嵌套在父类中。</strong></p>
<h5 id="为什么要使用密封类（定义受限的类继承结构）"><a href="#为什么要使用密封类（定义受限的类继承结构）" class="headerlink" title="为什么要使用密封类（定义受限的类继承结构）"></a>为什么要使用密封类（定义受限的类继承结构）</h5><p><strong>作为接口实现的表达式 👇</strong></p>
<pre><code class="kotlin">interface Expr
class Num(val value: Int) : Expr
class Sum(val left: Expr, val right: Expr):Expr

fun eval(e: Expr): Int =
    when (e) {
        is Num -&gt; e.value
        is Sum -&gt; eval(e.left) + eval(e.right)
        else -&gt; // 必须检查 else 分支
            throw  IllegalArgumentException(&quot;Unknown expression!&quot;)
    }
</code></pre>
<p><strong>当使用 when 结构来执行表达式的时候，Kotlin 编译器会强制检查默认选项</strong>。在这个例子中，<strong>不能返回一个有意义的值，所以直接返回异常状态。</strong></p>
<p>更重要的是，如果你添加了一个新的子类，编译器并不能发现你修改了。<strong>如果你忘记添加一个新的分支，就会选择默认选项，这又可能导致潜在的 bug。</strong></p>
<h5 id="如何使用密封类-“sealed”"><a href="#如何使用密封类-“sealed”" class="headerlink" title="如何使用密封类 “sealed”"></a>如何使用密封类 “sealed”</h5><pre><code class="kotlin">sealed class Expr { //将基类标记为封闭的
    class Num(val value: Int) : Expr()
    class Sum(val left: Expr, val right: Expr) : Expr() // 将所有可能的类作为嵌套类列出
}

fun eval(expr: Expr): Int =
    // “when”表达式覆盖了所有的可能情况，所以不再需要 else 分支
    when (expr) {
        is Expr.Num -&gt; expr.value
        is Expr.Sum -&gt; eval(expr.left) + eval(expr.right)
    }</code></pre>
<p><strong>如果你在 when 表达式中处理了所有的 sealed 类的子类，你就不再需要提供默认分支。</strong>注意，sealed 修饰符隐含的这个类是一个 open 类，你不再需要显式地添加 open 修饰符。</p>
<h3 id="4-2-声明一个带默认构造方法或属性的类"><a href="#4-2-声明一个带默认构造方法或属性的类" class="headerlink" title="4.2 声明一个带默认构造方法或属性的类"></a>4.2 声明一个带默认构造方法或属性的类</h3><p><strong>kotlin中构造方法和java中有那些不同</strong></p>
<p>与java中一个类可以声明一个或多个构造方法。kotlin也是类似的，只是做出了一些修改：区分了主构造方法（通常是主要而简洁的初始化类的方法，并且在类体外部声明）和从构造方法。</p>
<h4 id="4-2-1-初始化类：主构造方法和初始化代码块"><a href="#4-2-1-初始化类：主构造方法和初始化代码块" class="headerlink" title="4.2.1 初始化类：主构造方法和初始化代码块"></a>4.2.1 初始化类：主构造方法和初始化代码块</h4><h5 id="什么是主构造方法。"><a href="#什么是主构造方法。" class="headerlink" title="什么是主构造方法。"></a>什么是主构造方法。</h5><pre><code class="kotlin">class User(val nickname:String)</code></pre>
<p>这段被括号围起来的代码块就叫<strong>做主构造方法</strong>。它有两个目的：表明构造方法的<strong>参数</strong>，以及定义使用这个<strong>参数</strong>的属性。</p>
<h5 id="明确的主构造方法声明"><a href="#明确的主构造方法声明" class="headerlink" title="明确的主构造方法声明"></a>明确的主构造方法声明</h5><pre><code class="kotlin">class User constructor(_nickname: String) {   // 带一个参数的主构造方法
    val nickname: String

    init {  // 初始化代码块
        nickname = _nickname
    }
}</code></pre>
<p>现在来看看完成同样功能的代码具体是什么样子。</p>
<blockquote>
<p>两个关键词 <strong>construtor</strong> 和 <strong>init</strong>。 constructor 关键词用来开始一个<strong>构造方法</strong>或者<strong>从构造方法</strong>的声明。init 关键词用来引入初始化代码块。这种代码块包含了类在创建时执行的代码，并且会和主构造方法一起使用。<strong>因为主构造方法有语法限制，不能包含初始化代码，这就是需要初始化代码块（init）的原因。</strong>同时可以创建多个初始化代码块。</p>
</blockquote>
<h5 id="用参数来初始化属性"><a href="#用参数来初始化属性" class="headerlink" title="用参数来初始化属性"></a>用参数来初始化属性</h5><pre><code class="kotlin">class User(_nickname: String) { // 带一个参数的构造方法
    val nickname: String = _nickname    // 用参数来初始化属性

}</code></pre>
<blockquote>
<p>在例子中，不需要把初始化代码放在初始化代码块中，因为它可以与nickname属性声明结合。如果主构造方法没有注解或可见性修饰符，同样可以去除 constructor 关键词。</p>
</blockquote>
<h5 id="用最简洁的方法再次初始化类"><a href="#用最简洁的方法再次初始化类" class="headerlink" title="用最简洁的方法再次初始化类"></a>用最简洁的方法再次初始化类</h5><pre><code class="kotlin">class User(val nickname:String)    // “val” 意味相对应的属性会用构造方法的参数来初始化。</code></pre>
<p>前几个案例用 val 关键词声明了属性。如果属性用相对应的构造方法参数来初始化，<strong>代码可以通过把 val 关键词加载参数前的方法来简化它</strong>。可以用来代替类中的属性定义了。</p>
<h5 id="为构造方法提供默认值"><a href="#为构造方法提供默认值" class="headerlink" title="为构造方法提供默认值"></a>为构造方法提供默认值</h5><pre><code class="kotlin">class User(val nickname: String, val isSubscribed: Boolean = true) // 为构造方法提供一个默认值    </code></pre>
<p>可以像函数参数一样为构造方法声明默认值。</p>
<h5 id="如何让一个类不被其他代码实例化"><a href="#如何让一个类不被其他代码实例化" class="headerlink" title="如何让一个类不被其他代码实例化"></a>如何让一个类不被其他代码实例化</h5><p>如果想要你的类不被其他代码实例化，必须把构造方法标记为 private。</p>
<pre><code class="kotlin">class Secretive private constructor()   // 这个类有 private 构造方法</code></pre>
<h4 id="4-2-2-构造方法：用不同的方法来初始化方法"><a href="#4-2-2-构造方法：用不同的方法来初始化方法" class="headerlink" title="4.2.2 构造方法：用不同的方法来初始化方法"></a>4.2.2 构造方法：用不同的方法来初始化方法</h4><h5 id="为什么要使用多种方法初始化父类"><a href="#为什么要使用多种方法初始化父类" class="headerlink" title="为什么要使用多种方法初始化父类"></a><strong>为什么要使用多种方法初始化父类</strong></h5><p>最常见的一种就是当你需要扩展一个框架类来提供多个构造方法，以便于通过不同的方法来初始化类的时候。</p>
<h5 id="父类使用从构造方法"><a href="#父类使用从构造方法" class="headerlink" title="父类使用从构造方法"></a><strong>父类使用从构造方法</strong></h5><pre><code class="kotlin">open class View {
    constructor(ctx: Context) { // 从构造方法
        //some code
    }

    constructor(ctx: Context, attr: AttributeSet) { // 从构造方法
        //some code
    }
}</code></pre>
<h5 id="扩展父类"><a href="#扩展父类" class="headerlink" title="扩展父类"></a>扩展父类</h5><pre><code class="kotlin">class MyButton : View {
    constructor(ctx: Context) : super(ctx) {
        // 调用父类构造方法
    }

    constructor(ctx: Context, attr: AttributeSet) : super(ctx, attr) {

    }
}</code></pre>
<h5 id="调用父类的另一个构造方法"><a href="#调用父类的另一个构造方法" class="headerlink" title="调用父类的另一个构造方法"></a>调用父类的另一个构造方法</h5><pre><code class="kotlin">class MyButton : View {
    constructor(ctx: Context) : this(ctx, My_SYTLE) {
        // 委托给这个类的另一个构造方法
    }

    constructor(ctx: Context, attr: AttributeSet) : super(ctx, attr) {

    }
}</code></pre>
<p>从<strong>构造方法</strong>中调用你自己类的另一个<strong>构造方法</strong>。</p>
<p>可以修改 MyButton类 <strong>使得一个构造方法委托给同一个类的另一个构造方法</strong>，为参数传入默认值，图下👇。第二个方法继续调用super()。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200906113216.png" alt=""></p>
<h4 id="4-2-3-实现在接口中声明的属性"><a href="#4-2-3-实现在接口中声明的属性" class="headerlink" title="4.2.3 实现在接口中声明的属性"></a>4.2.3 实现在接口中声明的属性</h4><h5 id="在接口中声明一个属性"><a href="#在接口中声明一个属性" class="headerlink" title="在接口中声明一个属性"></a>在接口中声明一个属性</h5><pre><code class="kotlin">interface User {
    val nickname: String
}</code></pre>
<p>接口可以包含抽象属性声明。</p>
<p>这意味这<strong>实现User接口的类需要</strong>提供一个取得nickname值的方式。</p>
<h5 id="实现接口中的属性-三种"><a href="#实现接口中的属性-三种" class="headerlink" title="实现接口中的属性 三种"></a>实现接口中的属性 三种</h5><p>第一种</p>
<pre><code class="kotlin">// 主构造方法属性
class PrivateUser(override val nickname: String) : User {

}</code></pre>
<p>对于 PrivateUser 来说，<strong>你是用了间接的语法直接在主构造方法中声明了一个属性</strong>。这个属性实现了来自于User的抽象属性，所以你将其标记为 override。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908100413.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908095819.png" alt=""></p>
<p>运行结果</p>
<p>第二种</p>
<pre><code class="kotlin">class SubscribingUser(val email: String) : User {
    override val nickname: String get() = email.substringBefore(&#39;@&#39;)  // 自定义getter
}</code></pre>
<p>对于 SubscribeingUser 来说，nikename属性通过一个自定义 getter 实现。<strong>这个属性没有一个支持字段来存储它的值，它只有一个 getter 在每次调用时从 email 中得到昵称。</strong></p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908100342.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908100257.png" alt=""></p>
<p>运行结果</p>
<p>第三种</p>
<pre><code class="kotlin">class FacebookUser(val accoundId: Int) : User {
    override val nickname = getFacebookName(accoundId)  // 属性初始化
    fun getFacebookName(text: String): String {
        return text
    }
}</code></pre>
<p>nickname在SubscribingUser和FackbookUser中的不同实现。即使它们看起来很相似，第一个属性有一个自定义getter在每次访问时计算 subscringBefore，然后 FackbookUser中的属性有一个<strong>支持字段来存储在类初始化时计算得到数据</strong>。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908104646.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908111027.png" alt=""></p>
<p>运行结果</p>
<h4 id="4-2-4-通过-getter或setter访问支持字段"><a href="#4-2-4-通过-getter或setter访问支持字段" class="headerlink" title="4.2.4 通过 getter或setter访问支持字段"></a>4.2.4 通过 getter或setter访问支持字段</h4><p>关于两种属性的例子：存储值的属性和具有自定义访问器在每次访问时的属性。<strong>现在让我们来看看怎么结合这两种来实现一个既可以存储值又可以被值访问和修改时提供额外逻辑的属性。</strong>要支持这种情况，需要能够从属性的访问器中访问它的支持字段。</p>
<p>假设在任何适合对存储的属性中的数据进行修改时输出日志，你声明了一个可变属性并且在每次 setter 访问时执行额外的代码。</p>
<pre><code class="kotlin">/*    在 setter 中访问支持字段    */
class User(val name:String) {
    var address: String = &quot;unspecified&quot;
        set(value: String){
            println(&quot;&quot;&quot;
                Address was changed for $name:&quot;$field&quot; -&gt; &quot;$value&quot;.&quot;&quot;&quot;.trinmIndent())    //读取支持字段的值
                field = value    // 更新支持字段的值
        }
}</code></pre>
<pre><code class="kotlin">&gt;&gt;&gt; val user = User(&quot;Alice&quot;)
&gt;&gt;&gt; user.address = &quot;Elasenheimerstrasse 47, 80687 Muenchen&quot;
Address was changed for Alice:
&quot;unspecified&quot; -&gt; &quot;Elsenheimerstrasse 47, 80687 Muenchen&quot;</code></pre>
<blockquote>
<p>可以像平常一样通过使用 user.address = “new value” 来修改一个属性的值，这其实在底层调用了setter。在这个例子中，setter 被重新定义了，所以额外的输出日志的代码被执行了（简单起见，这里直接将其打印出来）。</p>
<p>在 setter 的函数体中，使用了特殊的标识符 field来访问支持字段的值。在 getter 中，只能读取值：而在 setter 中，既能读取它也能修改它。</p>
</blockquote>
<h3 id="4-3-编译器生成的方法-数据类和委托"><a href="#4-3-编译器生成的方法-数据类和委托" class="headerlink" title="4.3 编译器生成的方法:数据类和委托"></a>4.3 编译器生成的方法:数据类和委托</h3><h4 id="4-3-2-数据类-自动生成通用方法的实现"><a href="#4-3-2-数据类-自动生成通用方法的实现" class="headerlink" title="4.3.2 数据类:自动生成通用方法的实现."></a>4.3.2 数据类:自动生成通用方法的实现.</h4><p>实现一个数据类需要重写方法:toString、equals和hashcode。</p>
<p><strong>数据类</strong></p>
<pre><code class="kotlin">data class Client(val name:String,val postalCode:Int)</code></pre>
<p>这是一个数据类,重写了所有标准的Java方法:</p>
<ul>
<li>equals 用来比较实例</li>
<li>hashCode用来作为例如HashMap这种基于哈希容器的键</li>
<li>toString用来为类生成按声明顺序排列的所有字段的字符串表达形式</li>
</ul>
<h3 id="4-4-“object”-关键字：-将声明一个类与创建一个实例结合起来"><a href="#4-4-“object”-关键字：-将声明一个类与创建一个实例结合起来" class="headerlink" title="4.4 “object” 关键字： 将声明一个类与创建一个实例结合起来"></a>4.4 “object” 关键字： 将声明一个类与创建一个实例结合起来</h3><p>这个关键词定义一个类并同时创建一个实例（换句话说就是一个对象）。</p>
<ul>
<li><strong>对象声明</strong>是定义一个单例的一种方式。</li>
<li><strong>伴生对象</strong>可以持有<strong>工场方法</strong>和其他与这个类的相关，但是在调用时并不依赖类实例方法。<strong>它们的成员可以通过类名来访问</strong>。</li>
<li><strong>对象表达式用来代替Java的匿名内部类</strong></li>
</ul>
<h4 id="4-4-1-对象声明：创建单例易如反掌"><a href="#4-4-1-对象声明：创建单例易如反掌" class="headerlink" title="4.4.1 对象声明：创建单例易如反掌"></a>4.4.1 对象声明：创建单例易如反掌</h4><h5 id="为什么使用对象声明？"><a href="#为什么使用对象声明？" class="headerlink" title="为什么使用对象声明？"></a>为什么使用对象声明？</h5><p>在面向对象系统中一个相当常见的情形就是只需要一个实例的类。例如，可以使用一个对象声明来表示一个组织的工资单。</p>
<h5 id="在Java中是如何实现单例模式？"><a href="#在Java中是如何实现单例模式？" class="headerlink" title="在Java中是如何实现单例模式？"></a>在Java中是如何实现单例模式？</h5><p>定义一个使用private构造方法并且用静态字段来持有这个类仅有的实例。</p>
<h5 id="什么是对象声明"><a href="#什么是对象声明" class="headerlink" title="什么是对象声明"></a>什么是对象声明</h5><p>Kotlin通过使用对象声明功能为这一切提供了最高级的语言支持。<strong>对象声明将类声明与该类的单一实例声明结合到了一起。</strong></p>
<h5 id="对象声明使用"><a href="#对象声明使用" class="headerlink" title="对象声明使用"></a>对象声明使用</h5><pre><code>object Payroll {
    val allEmployees = arrayListOf&lt;Person&gt;()
    fun calculateSalary() {
        for (person in allEmployees){

        }
    }
}</code></pre><p>对象声明通过 object 关键词引入。与类一样，一个对象声明也可以包含属性、方法、初始化语句块等的声明，唯一不允许的是构造方法。对象声明在定义时就创建了构造对象，不需要在代码的其他地方调用构造方法。对象声明同样可以继承类和接口。</p>
<h1 id="5-Lambda-编程"><a href="#5-Lambda-编程" class="headerlink" title="5 Lambda 编程"></a>5 Lambda 编程</h1><h2 id="5-1-Lambda表达式和成员引用"><a href="#5-1-Lambda表达式和成员引用" class="headerlink" title="5.1 Lambda表达式和成员引用"></a>5.1 Lambda表达式和成员引用</h2><h3 id="5-1-1-Lambda-简介：作为函数参数的代码块"><a href="#5-1-1-Lambda-简介：作为函数参数的代码块" class="headerlink" title="5.1.1 Lambda 简介：作为函数参数的代码块"></a>5.1.1 Lambda 简介：作为函数参数的代码块</h3><p>在代码中存储和传递一小段行为是常有的任务。例如，“当一个事件发生的时候运行这个事件处理器”又或是“把这个操作应用到这个数据结构的所有元素上”。在老版本的Java中可以使用匿名函数。</p>
<blockquote>
<p>使用函数式编程 提供了另外一种解决问题的方法：</p>
<p>把函数当作值来对待。可以直接传递函数，而不需要先声明一个类再传递一个类的实例。使用 lambda 表达式后代码会变的更加简洁。</p>
</blockquote>
<p>例子。假设你要定义一个点击按钮的行为，添加一个处理点击的监听器。监听器实现了想对应的接口 OnClickListener 和它的一个方法 onClick。</p>
<pre><code class="java">/*    用匿名内部类实现监听器    */
button.setOnClickListener(new OnClickListener(){
    @Override
    public void onClick(View view){
        /*点击之后执行的动作*/
    }
})</code></pre>
<p>使用匿名内部类的写法，更加冗余。接下来使用 lambda 写法</p>
<pre><code class="kotlin">/*    用 lambda 实现监听器    */
button.setOnClickListener{    /*    点击后执行操作    */    }</code></pre>
<h3 id="5-1-2-Lamda-和-集合"><a href="#5-1-2-Lamda-和-集合" class="headerlink" title="5.1.2 Lamda 和 集合"></a>5.1.2 Lamda 和 集合</h3><p>良好的编程风格原则之一是避免代码的重复。我们对集合执行大部分任务都遵循这几个通用的模式，所以要实现这几个模式的代码应该放在一个库里。在没有 lambda 的帮助，很难为集合提供一个好用方便的库。</p>
<p>看个例子。</p>
<p>创建一个 Person 类，它包含了这个了的名字和年龄信息。</p>
<pre><code class="kotlin">data class Person(val name:String, val age :Int)</code></pre>
<p>假设你现在要在列表中找到年龄最大的那个人。</p>
<pre><code class="kotlin">/*    手动在集合中搜索    */
fun findTheOldest(people:List&lt;Person&gt;){
    var maxAge = 0    //存储最大年龄
    var theOldest:Person ?= null //存储年龄最大的人
    for (person in people){
        if(person.age &gt; maxAge){    //如果下一个比现在年龄最大的人还要大，改变最大值
            maxAge = person.age
            theOldest = person
        }
    }
    println(theOldest)
}
&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31))
&gt;&gt;&gt; findTheOldest(people)
Person(name = Bob,age = 31)</code></pre>
<pre><code class="kotlin">/*    用 lambda 在集合中搜索    */
&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31))
&gt;&gt;&gt; println(people.maxBy{it.age})    // 比较年龄最大的元素
Person(name = Bob, age = 31)</code></pre>
<p>maxBy函数可以在任何集合上调用，且只需要一个参数：函数指定比较哪个值来找到最大元素。</p>
<p>花括号中的代码 <strong>{it.age}</strong>就是实现了这个逻辑的lmabda。 它接收一个集合中的元素作为实参(作用 it 引用它)并且返回用来比较的值。在这个例子中，集合元素是Person对象，用来比较的是存储在其age属性中的年龄。</p>
<pre><code class="kotlin">/*    用成员引用    */
people.maxBy(Person:age)</code></pre>
<h3 id="5-1-3-Lambda-表达式的语法"><a href="#5-1-3-Lambda-表达式的语法" class="headerlink" title="5.1.3 Lambda 表达式的语法"></a>5.1.3 Lambda 表达式的语法</h3><p>概述 lambda</p>
<blockquote>
<p>一个 lambda 把一小段行为进行编码，你能把它当作值到处传递。它可以被独立地声明并储存一个变量。</p>
</blockquote>
<pre><code class="kotlin">/*    lambda 表达式的语法    */
{x:Int,y:Int -&gt; x+y}
/*    参数 -&gt; 函数体    */</code></pre>
<blockquote>
<p>Kotlin 的lambda 表达式始终用花括号包围。实参并没有用括号括起来。箭头把实参列表和lambda 函数体隔开了。</p>
</blockquote>
<p>可以把 lambda表达式存储在一个变量中，把这个变量当作普通函数对待（即通过相应实参调用它）</p>
<pre><code class="kotlin">&gt;&gt;&gt; val sum = {x:Int,y:int -&gt; x+y}
&gt;&gt;&gt; println(sum(1,2))    // 调用保存在变量中的lambda
3</code></pre>
<blockquote>
<p>Kotlin 中的语法约定，如果 lambda 表达式是函数调用的最后一个实参，它可以放到括号外边。在这个例子中lambda是唯一的实参，所以可以放到括号外边</p>
<pre><code class="kotlin">people.maxBy(){p:Person -&gt; p.age}</code></pre>
<p>当 lamdba 是函数的唯一实参时，还可以去除调用代码中的空括号。</p>
<pre><code class="kotlin">people.maxBy{p:Person -&gt; p.age}</code></pre>
<p>三种语法形式的含义都是一样的，但最后都是易读的。如果lambda是唯一的实参，你当然愿意在写代码的时候省掉这个括号。而当你有多个实参时，既可以把lambda留在括号内来强调它是一个实参，也可以把它放在括号外面，两种选择都是可行的。如果你想传递两个或多个lamdba，不能把超过一个的lamdba放在外面。这时使用常规语法来传递它们通常是更好的选择。</p>
</blockquote>
<p>回顾 joinToString 函数 （对元素添加分隔符）。 Kotlin 标准库中也有定义它，标准库中的这个版本的不同之处在于它可以接收一个附加的函数参数。这个函数可以使用 toString函数以外的方法把一个元素转换成字符串。</p>
<p><strong>打印出人的名字</strong></p>
<pre><code class="kotlin">/*    把 lambda 作为命名实参传递    */
&gt;&gt;&gt;val people = listOf(Person(&quot;Alice&quot;,31),Person(&quot;Bob&quot;,29))
&gt;&gt;&gt;val names = people.joinToString(separator = &quot;&quot;,transform = {p:Person -&gt; p.name})

&gt;&gt;&gt;println(names)
Alices Bob</code></pre>
<p><strong>用更简单的方法</strong></p>
<pre><code class="kotlin">/*    把 lambda 放在括号外传递    */
people.joinToString(&quot; &quot;){p:Person -&gt; p.name}</code></pre>
<p><strong>简化语法，移除参数类型</strong></p>
<pre><code class="kotlin">/*    省略 lambda 参数类型    */
people.maxBy{p:Person -&gt; p.age}    // 显式地写出参数类型
people.maxBY{p-&gt;p.age}    // 推导出参数类型</code></pre>
<p>和局部变量一样，如果 lambda 参数的类型可以被推导出来，你就不需要显式地指定它。以这里的 maxBy 为例子，其参数类型始终和集合的元素类型相同。编译器知道你是对一个Person对象的集合调用maxBy函数，所以它能推断出 lambda参数也会是Person类型。<strong>也存在不能推断出的情况，先遵循：先不声明类型，等编译器报错后再指定它。</strong></p>
<p><strong>最后的简化是使用默认参数名称 it 代替命名参数</strong></p>
<pre><code class="kotlin">/*    使用默认参数名称    */
people.maxBy(it.age)    //&quot;it&quot;是自动生成的参数名称</code></pre>
<p>仅在参数名称没有显式地指定时这个默认的名称才会生成。</p>
<p><strong>可以用变量存储 lambda 表达式</strong></p>
<pre><code class="kotlin">&gt;&gt;&gt; val getAge = {p:Person -&gt; p.age}
&gt;&gt;&gt; people.maxBy(getAge)</code></pre>
<blockquote>
<p>lambda 并没有被限制在这样小的规模，它可以包含更多的语句。</p>
</blockquote>
<pre><code class="kotlin">&gt;&gt;&gt; val sum = {x:Int,y:Int -&gt;
    println(&quot;Computing the sum of $x and $y...&quot;)
    x + y}
&gt;&gt;&gt; println(sum(1,2))
Computing the sum of 1 and 2...
3</code></pre>
<h3 id="5-1-4-在作用域中访问变量"><a href="#5-1-4-在作用域中访问变量" class="headerlink" title="5.1.4 在作用域中访问变量"></a>5.1.4 在作用域中访问变量</h3><blockquote>
<p>在声明一个匿名内部类的时候，能够在这个匿名类内部引用这个函数的参数和局部变量。</p>
<p>而在使用 lambda 声明的时候，也可以做同样的事情。如果在函数内部使用 lambda 也可以访问这个函数的参数，还有在 lambda 之前定义的局部变量。</p>
</blockquote>
<p><strong>forEach 函数</strong></p>
<p> 用 forEach 函数展示 上述行为。</p>
<p>它是最基本集合操作函数之一；它所作的全部事情就是在集合中的每个元素上都调用给定的 lambda。forEach 函数比普通for 函数循环更简洁，除此之外没有其它优势，所以并不急于把所有的循环更改为  lambda。</p>
<pre><code class="kotlin">/*    在 lambda 中使用函数参数    */
fun printMessageWithPrefix(message : Collection&lt;String&gt;,prefix:String){
    messages.forEach{    // 接受 lambda 作为实参指定对每个元素操作
        println(&quot;$prefix $it&quot;)    // 在 lambda 中访问 “prefix”
    }
}

&gt;&gt;&gt; val errors = listOf(&quot;433 Forbidden&quot;,&quot;404 Not Found&quot;)
&gt;&gt;&gt; printMessagesWithPrefix(errors,&quot;Error:&quot;)
Error:403 Forbidden
Error:404 Not Found</code></pre>
<blockquote>
<p>Kotlin 和 Java的一个显著区别就是，在 Kotlin 中不会仅限于访问 final 变量，在 lambda 内部也可以修改变量。</p>
</blockquote>
<pre><code class="kotlin">/*    在lambda中改变局部变量    */
fun printProblemCounts(responeses:Collection&lt;String&gt;){
    var clientErrors = 0
    var serverErrors = 0
    responeses.forEach{
        if(it.startsWith(&quot;4&quot;)){
            clientErrors ++
        }else if(it.startsWith(&quot;5&quot;)){
            serverErrors++
        }
    }
    println(&quot;$clientErrors client error,$serverErrors server errors&quot;)
}
&gt;&gt;&gt; val responses = listOf(&quot;200 OK&quot;,&quot;418 I&#39;m a teapot&quot;,&quot;500 Internal Server Error&quot;)
...
&gt;&gt;&gt; printProblemCounts(responses)
1 client errors,1 server errors</code></pre>
<blockquote>
<p>于 Java 不同，Kotlin 允许在 lambda 内部访问非 final 变量甚至修改它们。从 lambda 内访问外部变量，我们称这个变量被 <strong>lambda捕捉</strong>，如同上述的案例中的 prefix，clientErrors，serverErrors一样。</p>
</blockquote>
<p><strong>默认情况下，局部变量的声明期被限制在声明这个变量的函数中。但是如果它被lambda捕捉了，使用这个变量的代码可以被存储并稍后执行。</strong></p>
<p><strong>如果 lambda 被用作 <em>事件处理器</em> 或者用在其他 <em>异步执行</em> 的情况下，对局部变量的修改只会在 lambda 执行的时候发生。</strong></p>
<blockquote>
<p>反面案例</p>
<pre><code class="kotlin">fun tryToCountButtonClicks(button:Button):Int{
    var clicks = 0
    button.onClick{clicks++}
    return clicks
}</code></pre>
<p>这个函数始终返回0。尽管 onClick 处理器可以修改clicks的值，你并不能观察到值发生了变化，因为onClick处理器是在函数返回之后调用的。<strong>这个函数正确的实现方法需要把点击次数存储在函数外依然可以访问到的地方–例如类的属性，而不是存储在函数的局部变量中。</strong></p>
</blockquote>
<h3 id="5-1-5-成员引用"><a href="#5-1-5-成员引用" class="headerlink" title="5.1.5 成员引用"></a>5.1.5 成员引用</h3><p>​    如果把函数转换成一个值，你就可以传递它。</p>
<pre><code class="kotlin">val getAge = Person::age    //引用 age</code></pre>
<blockquote>
<p>这种表达式称为 <strong>成员引用</strong>，它提供了简明语法，来创建一个调用单个方法或者访问单个属性的函数值。 <strong>双冒号把类名称与你要引用的成员（一个方法或者一个属性）名称隔开</strong></p>
<pre><code class="kotlin">Person::age //类::成员</code></pre>
</blockquote>
<p>等价于 </p>
<pre><code class="kotlin">val getAge = {person:Person -&gt;person.age}</code></pre>
<blockquote>
<p>注意，不管你引用的是函数还是属性，都不要在成员引用的名称后面添加括号。</p>
</blockquote>
<blockquote>
<p>成员引用和调用该函数的lambda具有一样的类型，所以可以互换使用：</p>
<pre><code class="kotlin">people.maxBy(Person::age)</code></pre>
<p>还可以引用顶层函数</p>
<pre><code class="kotlin">fun salute() = println(&quot;Salute!&quot;)
&gt;&gt;&gt; run(::salute)    // 引用顶层函数
Salute!</code></pre>
<p>这种情况下，你省略了类名称，直接以::开头。成员引用::salute被当作实参传递给库函数run，它会调用想对应的函数。</p>
<p>如果 lambda 要委托给一个接收多个参数的函数，提供成员引用代替它将会非常方便</p>
<pre><code class="kotlin">val action = {person:Person,message:String -&gt;
    sendEmail(person,massage)    //这个lambda委托sendEmail函数
    }
val nextAction = :: sendEmail    //用成员引用代替</code></pre>
<pre><code class="kotlin">/*    用构造方法引用存储或者延期执行创建类实例的动作。 构造方法引用的形式在双冒号后指定类的名称：    */
data class Person(val name:String,val age:Int)
&gt;&gt;&gt; val createPerson = :：Person    //创建Person实例的动作被保存成了值
&gt;&gt;&gt; val p = createPerson(&quot;Alice&quot;,29)
&gt;&gt;&gt; println(p)
Person(name = Alice,age = 29)</code></pre>
<p><strong>可以用同样的方法引用扩展函数</strong></p>
<pre><code class="kotlin">fun Person.isAdult() = age &gt;= 21
val predicate = Person::isAdult</code></pre>
<p>尽管 isAdult 不同类的成员，还是可以通过引用访问它，这个访问的成员没有两样：person.isAdult()。</p>
</blockquote>
<p><strong>绑定引用</strong></p>
<blockquote>
<p>在 kotlin 1.0 中 ，当接受一个类的方法或者属性引用时，你始终需要提供一个该类的实例来调用这个引用。Kotlin1.1计划支持绑定成员引用，它允许你使用成员引用语法捕捉特定实例对象的方法引用。</p>
<pre><code class="kotlin">&gt;&gt;&gt; val p = Person(&quot;Dmitry&quot;,34)
&gt;&gt;&gt; val personAgeFunction = Person::age
&gt;&gt;&gt; println(personsAgeFunction(p))
34 
&gt;&gt;&gt; val dmitrysAgeFunction = p::age
&gt;&gt;&gt; println(dmitryAgeFunction())
34</code></pre>
<p>注意，personsAgeFunction是一个当参数函数（返回给定了的年龄），而dmitryAgeFunction是一个零参数的函数（返回已经指定好的人的年龄）。</p>
<p>在 Kotlin1.1之前，你需要显式地写出 lambda{p.age},而不是使用绑定成员引用p::age。</p>
</blockquote>
<h2 id="5-2-集合的函数式API"><a href="#5-2-集合的函数式API" class="headerlink" title="5.2 集合的函数式API"></a>5.2 集合的函数式API</h2><p>我们先从filter和map这类函数及它们背后的概念开始。</p>
<h3 id="5-2-1-基础：filter和map"><a href="#5-2-1-基础：filter和map" class="headerlink" title="5.2.1 基础：filter和map"></a>5.2.1 基础：filter和map</h3><p>filter和map函数形成了集合操作的基础，很多集合操作都是借助它们来表达的。</p>
<p>通过两种样子的例子帮助你来理解，一个纯数字形式一个使用<strong>自定义</strong>的Person类来实现。</p>
<pre><code class="kotlin">data class Person(val name:String,val age:Int)</code></pre>
<p><strong>filter函数</strong></p>
<blockquote>
<p>遍历集合并选出引用给定 lambda 条件 后会返回true的那些元素</p>
<pre><code class="kotlin">&gt;&gt;&gt; val list = listOf(1,2,3,4)
&gt;&gt;&gt; println(list.filter{it%2==0})
[2,4]</code></pre>
</blockquote>
<p><strong>map函数</strong></p>
<blockquote>
<p>对集合中每个元素应用给定的函数并把结果收集到一个新的集合中。</p>
<p>根据lambda参数作为判断生成新的集合。</p>
<pre><code class="kotlin">&gt;&gt;&gt; val list = listOf(1,2,3,4)
&gt;&gt;&gt; println(list.map{it*it})
[1,4,9,16]</code></pre>
</blockquote>
<blockquote>
<p>如果直想打印名字列表，而不是完整信息，可以用map变换列表：</p>
<pre><code class="kotlin">&gt;&gt;&gt; val people=listOf(Person(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31))
&gt;&gt;&gt; println(people.map{it.name})
[Alice,Bob]</code></pre>
<p>使用 <strong>成员引用</strong> 同样可以</p>
<pre><code class="kotlin">people.map(Person::name)</code></pre>
</blockquote>
<blockquote>
<p>当需要获得分组中最大人的名字时。</p>
<pre><code class="kotlin"> val maxAge = people.maxBy(Person::age).age
 people.filter{it.age == maxAge}</code></pre>
<p><strong>map 应用过滤和变换函数</strong></p>
<pre><code class="kotlin">&gt;&gt;&gt; val numbers = mapOf(0 to &quot;zero&quot;,1 to &quot;one&quot;)
&gt;&gt;&gt; println(numbers.mapValues{it.value.toUppterCase()})    // 对map集合的值进行操作
[0=ZERO,1=ONE]</code></pre>
<p>键和值分别由各自的函数来处理。<strong>filterKeys和mapKeys过滤和变换map的键，而另外的filterValues和mapValues过滤和变换对应的值。</strong></p>
</blockquote>
<h3 id="5-2-2-“all”“any”“count”和“find”：对集合引用判断式"><a href="#5-2-2-“all”“any”“count”和“find”：对集合引用判断式" class="headerlink" title="5.2.2 “all”“any”“count”和“find”：对集合引用判断式"></a>5.2.2 “all”“any”“count”和“find”：对集合引用判断式</h3><blockquote>
<p>这些方法作用</p>
<p>Kotlin中，它们是通过 all 和 any 函数表达式的（检查集合中的所有元素是否都符合某个条件）。count 函数检查由多少元素满足判断式，而find函数返回第一个符合条件的元素。</p>
<p>案例：</p>
<p>检查一个人是否还没有到28岁。</p>
<pre><code class="kotlin">val canBeInClub27 = {p:Person -&gt; p.age &lt;=27}</code></pre>
<p>如果是<strong>所有元素都满足判断式条件</strong>的应该使用 all 函数。（）</p>
<pre><code class="kotlin">&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,27),Person(&quot;Bob&quot;,31))
&gt;&gt;&gt; println(people.all(canBeInClub27))
false</code></pre>
<p>如果你<strong>检查集合中至少存在一个匹配的元素</strong>，则使用 any 函数</p>
<pre><code class="kotlin">&gt;&gt;&gt; println(people.any(canBeInClub27))</code></pre>
<p>true</p>
<p>如果<strong>你想知道有多少元素满足判断式</strong>，使用count：</p>
<pre><code class="kotlin">&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,27),Person(&quot;Bob&quot;,31))
&gt;&gt;&gt; println(people.count(canBeInClub27))
1</code></pre>
</blockquote>
<p><strong>使用正确的函数完成工作：”count” VS. “size”</strong></p>
<p>count 方法容易被遗忘，然后通过过滤集合之后再取大小来实现它：</p>
<pre><code class="kotlin">&gt;&gt;&gt; println(people.filter(canBeInClub27).size)
1</code></pre>
<p>再这种情况下，一个集合中间会被创建并用来存储所有满足判断式的元素。</p>
<p>而另一方面，count 方法只是最终匹配元素的数量，不关心元素本身，所以更高效。</p>
<blockquote>
<p><strong>要找到一个满足判断式的元素，使用 find 函数</strong></p>
<pre><code class="kotlin">&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,27),Person(&quot;Bob&quot;,31))
&gt;&gt;&gt; println(people.find(canBeInClub27))
Person[name = Alice,age = 27]</code></pre>
<p>存在多个能够匹配的元素就返回其中第一个元素：或者返回 null，如果没有一个元素能满足判断式。find还有一个同义方法 firstOrNull，可以使用这个方法更加清楚的表达你的意图。</p>
</blockquote>
<h3 id="5-2-3-groupBy：把列表转换成分组的map"><a href="#5-2-3-groupBy：把列表转换成分组的map" class="headerlink" title="5.2.3 groupBy：把列表转换成分组的map"></a>5.2.3 groupBy：把列表转换成分组的map</h3><blockquote>
<p><strong>当你想把人按照年龄分组，相同年龄的人放在一组。</strong></p>
<p>groupBy: 按照表达式将几个进行分组并返回一个 map 集合</p>
<pre><code class="kotlin">&gt;&gt;&gt; val people = listOf(Perosn(&quot;Alice&quot;,31),Perosn(&quot;Bob&quot;,29),Person(&quot;Carol&quot;,31))
&gt;&gt;&gt; println(people.groupBy{it.age})</code></pre>
<p>返回结果 map，是元素分组依据的键（这个例子中是age）和元素分组（persons）之间映射</p>
<pre><code class="kotlin">{
29 = [Person(name = Bob,age = 29)],
31 = [Person(name = Alice,age = 31),
        Person(name = Carol,age = 31)]
        }</code></pre>
<p>每个分组都是存储在一个列表中，<strong>结果的类型就是Map&lt;Int,List<Person>&gt;</strong>。</p>
<p>可以使用像 mapKeys 和 mapValues 这也的函数对这个map做进一步的修改。</p>
</blockquote>
<blockquote>
<p><strong>使用成员引用把字符串按照首字母分组：</strong></p>
<pre><code class="kotlin">&gt;&gt;&gt; val list = listOf(&quot;a&quot;,&quot;ab&quot;,b)
&gt;&gt;&gt; println(list.groupBy(String::first))
{a = [a,ab],
 b = [b]}</code></pre>
<p>first并不是String类的成员，而是一个扩展。然而，可以把它当作成员引用访问。</p>
</blockquote>
<h3 id="5-2-4-flatMap-和-flatten：处理嵌套集合和元素"><a href="#5-2-4-flatMap-和-flatten：处理嵌套集合和元素" class="headerlink" title="5.2.4 flatMap 和 flatten：处理嵌套集合和元素"></a>5.2.4 flatMap 和 flatten：处理嵌套集合和元素</h3><p><strong>例子</strong></p>
<blockquote>
<p>假设你有一堆藏书，使用Book表示：</p>
<pre><code class="kotlin">class Book(val title:String,val authors:List&lt;String&gt;)</code></pre>
<p>authors ：保存书的所有作者。</p>
<p>统计出图书馆中所有作者的set；</p>
<pre><code class="kotlin">books.flatMap{it.authros}.toSet()    //包含撰写 “books” 集合中书籍的所有作者 set</code></pre>
<p>flatMap:作用，1.首先根据作为实参给定的函数对集合中的每个元素做转换（或者说映射），然后把多个列表合并（或者说平铺）成一个列表。</p>
</blockquote>
<blockquote>
<p>说明：</p>
<pre><code class="kotlin">&gt;&gt;&gt; val strings = listOf(&quot;abc&quot;,&quot;def&quot;)
&gt;&gt;&gt; pritnln(strings.flatMap{it.toList()})
[a,b,c,d,e,f]</code></pre>
<p>字符串上的toList函数把它转换成字符列表。</p>
<p>使用 map 函数，你会得到一个字符列表的列表。</p>
<p>flatMap 函数：执行后面操作，并返回一个包含所有元素（字符）的列表</p>
<p>回到例子中：</p>
<pre><code class="kotlin">&gt;&gt;&gt; val books = listOf(Book(&quot;Thursday Next&quot;,listOf(&quot;Jasper Fforde&quot;)),
                        Book(&quot;Mort&quot;,listOf(&quot;Terry Pratchett&quot;)),
                        Book(&quot;Good Omens&quot;,listOf(&quot;Terry Pratchett&quot;,
                                                &quot;Neil Gaiman&quot;)))
&gt;&gt;&gt; println(books.flatMap{it.authors}.toSet)                                                
[Jasper Fforde,Terry Pratchett,Neil Gaiman]</code></pre>
<p>book.authors 是存储了多个作者的集合。flatMap 函数把所有书籍的作者合并成变频的列表。</p>
<p><strong>toSet调用移除了结果集合中的所有重复元素。</strong></p>
<p>所以 Terry Pratchett 在输出中只出现了一次。</p>
<p><strong>如果你只需要平铺一个集合，可以使用 flatten 函数：listOfLists.flatten</strong></p>
</blockquote>
<h2 id="5-3-惰性集合操作：序列"><a href="#5-3-惰性集合操作：序列" class="headerlink" title="5.3 惰性集合操作：序列"></a>5.3 惰性集合操作：序列</h2><blockquote>
<p>你看到了关于许多链式调用的例子，例如 map 和 filter。这些函数会及早的创建中间集合，也就是说每一步的中间结果都被存储在一个临时列表。</p>
<pre><code class="kotlin">people.map(Person::name).filter{it.startsWith(&quot;A&quot;)}</code></pre>
<p>Kotlin 标准库参考文档说明，filter 和 map 都会返回一个列表。这意味这上面的例子中的链式调用会创建两个列表：一个保存filter函数的结果，另一个保存 map函数的结果。如果源列表只有两个元素，这不是什么问题，但是如果有一百万个元素，（链式）调用就会变得十分低效。</p>
<p>为了提高效率可以将操作变换成序列，而不是使用集合：</p>
<pre><code class="kotlin">people.asSequence()    //把初始集合转换成序列
      .map(Person::name)    
      .filter{it.startsWith(&quot;A&quot;)}    //系列支持和集合一样的API
      .toList()    // 把结果序列转换会列表</code></pre>
<p>这个例子没有创建任何一个存储元素的，所以元素数量巨大的情况下性能显著提升。</p>
<p>Kotlin 惰性集合操作的入口就是 Sequence 接口。这个接口表示可以诸葛列举的元素序列。Sequence 只提供了一个方法，iterator，用来从序列中获取值</p>
</blockquote>
<p>优势</p>
<blockquote>
<p>Sequence接口的强大之处在于其操作的实现方式。序列中的元素求值是惰性的，因此可以使用序列更高效地对集合元素执行链式操作，而不需要创建额外的集合来保存过程中产生的总结结果。</p>
</blockquote>
<p>为什么需要把序列转换回集合？把序列代替集合不是更方便吗？特别是它的这些优点。</p>
<blockquote>
<p>大多数是这样的。如果你需要迭代序列中的元素，可以直接使用。而要使用其他API方法，例如下标访问元素，那么你需要将序列转换成列表。</p>
</blockquote>
<blockquote>
<p>通常，对一个大型集合执行链式操作时要使用序列。在后面的章节中继续讨论Kotlin常规集合的及早操作高效的原因，尽管它会创建中间集合。当集合拥有数量巨大的元素，元素为中间结果进行重新分配开销巨大，所以惰性求值是更好的选择。</p>
</blockquote>
<h3 id="5-3-1-执行序列操作：中间和末端操作"><a href="#5-3-1-执行序列操作：中间和末端操作" class="headerlink" title="5.3.1 执行序列操作：中间和末端操作"></a>5.3.1 执行序列操作：中间和末端操作</h3><p><strong>序列操作共分两种</strong>：</p>
<blockquote>
<p>中间和末端。</p>
<p>一次中间操作返回的是另一个序列，这个序列知道如何变换原始序列中的元素。</p>
<p>而末端操作返回的是一个结果，这个结果可能是集合、元素、数字，或者其他的初始集合的变换序列中获得的任意对象。</p>
<pre><code class="kotlin">sequence.map{...}.filter{...}//中间操作
        .toList()//末端操作</code></pre>
</blockquote>
<p><strong>没有末端操作的例子：</strong></p>
<pre><code class="kotlin">&gt;&gt;&gt; listOf(1,2,3,4).asSequence()    //序列化
...        .map{print(&quot;map($it)&quot;);it*it}    // 转换成map集合并操作它
...        .filter{ print(&quot;filter($it)&quot;);it%2==0}    //调用对象，然后根据条件过滤</code></pre>
<blockquote>
<p>执行这段代码并不会在控制台上输出任何内容。这意味着map和filter变换被延期了，它们只有在获取结果的是否才会被应用(即末端操作被调用的时候)：</p>
<pre><code class="kotlin">&gt;&gt;&gt;listOf(1,2,3,4).asSequence()
...                .map{print(&quot;map($it);it*it&quot;)}
...                .filter{print(filter(&quot;$it&quot;);it%2 == 0)}
...                .toList()
map(1) filter(1) map(2) filter(4) map(3) filter(9) map(4) filter(16)</code></pre>
<p>末端操作触发执行了所有的延期计算。</p>
</blockquote>
<p><strong>计算执行的顺序。</strong></p>
<blockquote>
<p>一个笨办法实在每个元素上调用map函数，然后再结果序列的每个元素上再调用filter函数。</p>
<p>map和filter对集合就是这样做的，而序列不一样。对序列来说，所有操作是按序列应用再每个元素上：处理完第一个元素（先映射再过滤），然后完成第二个元素的处理，以此类推。</p>
<p><strong>这种方法意味着部分元素根本不会发生任何转换</strong></p>
<p>如果在轮到它们之前就已经取得了结果。我们来看一个map和find的例子。首先一个数字映射成它的平方，然后找到第一个比数字3大的条目：</p>
<pre><code class="kotlin">&gt;&gt;&gt; println(listOf(1,2,3,4).asSequence()
                           .map{it*it}
                           .find{it &gt; 3}
                           )
4</code></pre>
<p>如果同样的操作被应用在集合而不是序列上时，那么 map 的结果首先被求出来。即变换初始集合中的所有元素。第二步，中间集合中满足判断式的一个元素会被找出来。而对于序列来说，惰性方法意味这你可以跳过处理部分元素。图 5.8 阐明了 这段代码两种求值方法之间的区别，一种是及早求值（使用集合），一种是惰性求值（使用序列）。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210402111938.png" alt="及早求值在整个集合上执行每个操作；惰性求值则逐个处理元素"></p>
<p><strong>在集合上执行操作的顺序也会影响性能。</strong></p>
<p>假设你有一个人的集合，想要打印集合中那些长度小于某个限制的人名。</p>
<p>这时你需要做两件事：把每个人映射成他们的名字，然后过滤掉其中那些不够短的名字。</p>
<p><strong>这种情况可以用任何顺序应用map和filter操作。两种顺序得到的结果是一样的如下</strong></p>
<pre><code class="kotlin">&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31),Person(&quot;Charles&quot;,31),Person(&quot;Dan&quot;,21))
&gt;&gt;&gt; println(people.asSequence().map(Person::name).filter{it.length &lt; 4}.toList()) // 先 “map” 后 “filter”
[Bob,Dan]
&gt;&gt;&gt; println(people.asSequence().filter{it.name.length &lt; 4}
...            .map(Person::name).tolist())    // 先“filter”后 map
[Bob,Dan]</code></pre>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210402103856.png" alt="先应用filter有助于减少变换的总次数"></p>
<blockquote>
<p>如果 filter 在强，不适合的元素会被尽早地过滤掉且不会发生变换。</p>
</blockquote>
<h3 id="5-3-2-创建序列"><a href="#5-3-2-创建序列" class="headerlink" title="5.3.2 创建序列"></a>5.3.2 创建序列</h3><blockquote>
<p>asSequence()：函数用来在集合中创建序列</p>
<p>generateSequence()函数：给定序列中的前一个元素，这个函数会计算出下一个元素。</p>
<p><strong>案例 使用 generateSequence 计算 100 以内所有的自然数之和。</strong></p>
<pre><code>&gt;&gt;&gt; val naturalNumbers = generateSequence(0) {it +1}
&gt;&gt;&gt; val numbersTo100 = naturalNumbers.takeWhile{it &lt;= 100}
&gt;&gt;&gt; println(numbersTo100.sum())    //当获得结果 “sum” 时，所有被推迟的操作都被执行
5050</code></pre><p>例子中 naturalNumbers 和 numbersTo100都有延期操作序列。这些序列中的实际数字知道你调用末端操作的时候才会求值。（sum）</p>
</blockquote>
<p><strong>创建父目录的序列</strong></p>
<blockquote>
<p>如果元素的父元素和它的类型相同（比如人类或者java文件），你可能会对它的所有祖先组成的序列的特质感兴趣。下列这个例子可以查询是否放在隐藏目录中，通过创建一个其父目录的序列并检查每个目录的属性来实现。</p>
<pre><code class="kotlin">/*    创建并使用父目录的序列    */
fun File.isInsideHiddenDirectory() = 
        generateSequence(this){it.parentFile}.any{it.isHidden}    // 查询文件是否放在隐藏目录中。

&gt;&gt;&gt; val file = File(&quot;/Users/svtk/.HiddenDir/a.txt&quot;)        
&gt;&gt;&gt; println(file.IsInsideHiddenDirectory())
true</code></pre>
<p>你生成了一个序列，通过提供第一个元素和获取每个后续元素的方式来实现。如果把any换成find，你还可以得到你想要的那个目录（对象）。注意，使用序列允许你找到需要的目录之后立即停止遍历父目录。</p>
</blockquote>
<h2 id="5-4-使用-Java-函数式接口"><a href="#5-4-使用-Java-函数式接口" class="headerlink" title="5.4  使用 Java 函数式接口"></a>5.4  使用 Java 函数式接口</h2><p>Kotlin 的 lambda 可以和 Java API 互操作。</p>
<p>在本章节开头处，有看过一个把 lambda 传递给 Java 方法的例子：</p>
<pre><code class="kotlin">button.setOnClickListener{/*    点击之后的动作     */}    //复习 作为方法的最后一个参数可以省略()。把lambda作为实参传递。</code></pre>
<p>Botton 通过接收类型为OnClickListener的实参的setOnClickListener方法给按钮设置一个新的监听器：</p>
<pre><code class="java">/*    Java    */
public class Button{
    public void setOnClickListener(OnClickListener l){...}
}</code></pre>
<p>OnClickListener 接口声明了一个方法，onClick：</p>
<blockquote>
<p><em>接口可以被实现，但不能被实例化。</em></p>
</blockquote>
<pre><code class="java">public interface OnClickListener{
    void onClick(View v)
}</code></pre>
<p>在Java 8 之前你不得不创建一个匿名类的实例来作为实参传递给 setOnClickListener方法：</p>
<pre><code class="java">button.setOnClickListener(new OnClickListener(){
    @Override
    public void onClick(View v){
        ...
    }
})</code></pre>
<p>在 kotlin 中 可以传递一个 lambda，代替这个实例：</p>
<pre><code class="kotlin">button.setOnClickListener{view -&gt; ...}</code></pre>
<p>lambda 用来实现 OnClickListener，它有一个类型为View的参数，和onClick一样。</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210402121803.png" alt="Lmabda的参数和方法参数对应"></p>
<blockquote>
<p>这个方法可以工作的原因是OnClickListener接口只有一个方法。<strong>这种方法被称为函数式接口，或者 SAM 接口，SAM 代表单抽象方法。Java API随处可见像Runnable和Callable这样的函数式接口，以及支持它的方法。</strong>Kotlin允许你在调用接口函数式接口作为参数的方法时使用lambda，来保证你的Kotlin代码即整洁又符合习惯。</p>
</blockquote>
<p>​             </p>
<h3 id="5-4-1-把lambda-当作参数传递给Java方法"><a href="#5-4-1-把lambda-当作参数传递给Java方法" class="headerlink" title="5.4.1 把lambda 当作参数传递给Java方法"></a>5.4.1 把lambda 当作参数传递给Java方法</h3><p>可以把lambda传给任何期望函数式接口的方法。</p>
<blockquote>
<p>例如，如下的方法 Runable类型的参数：</p>
<pre><code class="Java">/*    Java    */
void postponeComputation(int delay,Runnable computation);</code></pre>
<p>在 Kotlin 中，可以调用它并把一个lambda作为实参传给它。编译器会<strong>自动</strong>把它转换成一个Runnable的实例：</p>
<p>postponeComputation(1000){ println(42) }</p>
<p>当我们说“一个Runnnable的实例”时，指的是“一个实现了Runnable接口的匿名类的实例”。编译器会帮你创建它，并使用lambda作为单抽象方法–这个例子中式run方法–的方法体。</p>
<p>如下：显式的创建一个Runnable的匿名对象也能达到同样的效果：</p>
<pre><code class="kotlin">postponeComputation(1000,object:Runnable{    //把对象表达式作为函数式接口的实现传递。
    override fun run(){
        println(42)
    }
})</code></pre>
<p>但是这里有点不一样。当你显式地声明对象时，每次调用都会创建一个新的实例。使用lambda的情况不同：如果lambda没有访问任何来自定义它的函数变量，相应的匿名类实例可以在多次调用之间重（chóng）用：</p>
<pre><code class="kotlin">postponeComputation(1000){println(42)}    //整个程序只会创建一个Runnable的实例</code></pre>
<p>想要完全等价的实现应该是下面这段代码中的显式object声明，它把Runnable实例存储在一个变量中，并且每次调用的时候都使用这个变量：</p>
<pre><code class="kotlin">val runnable = Runnable{println(42)}    //编译成全局变量：程序中仅此一个实例
fun handleComputation(){
    postponeComputation(1000,runnable)    //每次postponeComputation调用时用的是一个对象
}</code></pre>
<p>如果lambda在包围它的作用域中捕捉到了变量，那么每次调用就不再可能重用同一个实例了。</p>
<p>这时，每次调用编译器都要创建一个新对象，其中存储着被捕捉的变量的值。</p>
<p>如下：每次调用都会使用一个新的Runnable实例，把id值存储在它的字段中：</p>
<pre><code class="kotlin">fun handleComputation(id:String){    //lambda会捕捉“id”这个变量
    postponeComputation(1000){println(id)}    //每次handleComputation调用都创建一个Runnable的新实例。
}</code></pre>
</blockquote>
<p>Lmabda的实现细节</p>
<blockquote>
<p>从 Kotlin1.0起，每次lambda表达式都会被编译成一个匿名类，除非它是内联lambda。（内联函数不会创建匿名类）。在后续版本支持生成java8字节码后，编译器就可以避免为每一个lambda表达式都生成一个独立的.class文件。如果lambda捕捉了变量，每个被捕捉的变量会在匿名类中有对应的字段，而且每次（对lambda）的调用都会创建一个这个匿名类的新实例。</p>
<p><em>否则，一个单例就会被创建。类的名称由lambda声明所在的函数名字称加上后缀衍生出来：这个例子中就是 HandleComputation$1。如果你反编译之前lambda表达式的代码，就会看到：</em> </p>
<pre><code class="kotlin">class HandleComputation$1(val id:String):Runnable{
    override fun run(){
        println(id)
    }
}
fun handleComputation(id:String){
    postponeComputation(1000,HandleComputation$1(id))    //底层创建一个特殊的实例，而不是lambda
}</code></pre>
<p>编译器给每个被捕捉的变量生成了一个字段和一个构造方法参数。</p>
</blockquote>
<p><strong>把lambda传给标记成 inline 的Kotlin函数，是不会创建任何匿名类的。</strong></p>
<h3 id="5-4-2-SAM构造方法：显式地把lambda转换成函数式接口"><a href="#5-4-2-SAM构造方法：显式地把lambda转换成函数式接口" class="headerlink" title="5.4.2 SAM构造方法：显式地把lambda转换成函数式接口"></a>5.4.2 SAM构造方法：显式地把lambda转换成函数式接口</h3><blockquote>
<p>SAM<strong>构造方法</strong>是<strong>编译器生成的函数</strong>。用来让你执行从lambda到函数式接口实例的显式转换。</p>
<p>可以用在编译器不会自动应用转换的上下文中使用它。</p>
<p><strong>例如：如果有一个方法返回一个函数式接口（只有一个抽象方法的实例）的实例，不能直接返回一个lambda，要用SAM构造方法把它包装起来。</strong></p>
<p><strong>如下例子：</strong></p>
<pre><code class="kotlin">/*    使用SAM构造方法来返回值    */
fun createAllDoneRunnable():Runnable{
    return Runnable {println(&quot;All done!&quot;)}
}
&gt;&gt;&gt; createAllDoneRunnable().run()
All done!</code></pre>
<p><strong>SAM（函数式接口）构造返回的名称和底层函数式接口的名称一样。</strong>SAM构造方法只接收一个参数— 一个被用作函数式接口单抽象方法的lambda – 并返回实现了这个接口类的一个实例。</p>
</blockquote>
<blockquote>
<p>除开返回值外，SAM构造方法还可以用在需要<strong>把从lambda生成的函数式接口实例存储在一个变量中的情况。**</strong>假设你要在多个按钮上重用同一个监听器**，就像下面的代码清单一样（在Android应用中，这段代码可以作为Activity.onCreate方法的一部分）</p>
<pre><code class="kotlin">/*    使用SAM构造方法来重用listener实例    */
val listener =OnClickListener{    view -&gt;
    val text = when (view.id){
        R.id.button1 -&gt; &quot;First button&quot;
        R.id.button2 -&gt; &quot;Second button&quot;
        else -&gt; &quot;Unknown button&quot;
    }
    toast(text)
}
button1.setOnClickListener(listener)
button2.setOnClickListener(listener)</code></pre>
<p>listener 会检查那个按钮是点击的事件源并作出对应的行为。可以使用实现了OnClickListener的对象声明来定义监听器，但是SAM构造方法提供了更简洁的方法。</p>
</blockquote>
<blockquote>
<p><strong>Lambda 和 添加/移除监听器</strong></p>
<p>lambda 内部类有匿名对象那样的this：没有办法应用lambda转换成的匿名类实例。<strong>从编译器的角度来看，lambda是一个代码块，而不是一个对象，而且也不能当作一个对象来引用</strong>。<strong>Lambda中的this引用指向的是包围它的类。</strong></p>
<ul>
<li><input disabled="" type="checkbox"> 如果你的事件监听器在处理事件时需要取消它自己，不能使用lambda这样做。<strong>这种情况使用实现了接口的匿名对象</strong>。<strong>在匿名对象内，this关键词指向该对象实例，可以把它传递给移除监听器的API</strong></li>
</ul>
</blockquote>
<p>尽管方法调用中的SAM转换一般都会自动发生，<strong>但是当把lambda作为参数传给一个重载方法</strong>，<strong>也有编译器不能选择正确的重载情况</strong>。这时显式的SAM构造方法时解决错误的好方法。</p>
<h2 id="5-5-带接收器的lambda：”with“-与-”apply“"><a href="#5-5-带接收器的lambda：”with“-与-”apply“" class="headerlink" title="5.5 带接收器的lambda：”with“ 与 ”apply“"></a>5.5 带接收器的lambda：”with“ 与 ”apply“</h2><p><strong>带接收者的lambda：</strong></p>
<p>此节将办理逐步熟悉Kotlin的lambda的独特功能：<strong>在lambda函数体类可以调用一个不同对象的方法，而却无需借助任何限定符</strong>；此方法在java中是不存在的。这样的lambda叫做带接收者的lambda</p>
<p><strong>什么是带接收者的 lambda？</strong></p>
<blockquote>
<p>Kotlin 中独特的 lambda 功能：在lambda函数体内可以调用一个不同的对象方法，而且无需借助任何额外的限定符。</p>
</blockquote>
<p><strong>接收者：</strong>调用者</p>
<h3 id="5-5-1-“with”-函数"><a href="#5-5-1-“with”-函数" class="headerlink" title="5.5.1 “with” 函数"></a>5.5.1 “with” 函数</h3><p>从 with 函数开始它用到了带接收者lambda。</p>
<p>with的库函数：</p>
<blockquote>
<p>它对同一个对象执行多次操作，而不需要反复把对象的名称写出来。</p>
</blockquote>
<h5 id="构建字母表"><a href="#构建字母表" class="headerlink" title="构建字母表"></a>构建字母表</h5><pre><code class="kotlin">fun alphabet(): String {
    val result = StringBuilder()
    for (letter in &#39;A&#39;..&#39;Z&#39;) {
        result.append(letter)
    }
    result.append(&quot;\n Now I know the alphbet!&quot;)
    return result.toString()
}</code></pre>
<pre><code class="kotlin">fun main() {
    println(alphabet())
}</code></pre>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201022214803.png" alt=""></p>
<h5 id="使用场景（为什么要用”with“）"><a href="#使用场景（为什么要用”with“）" class="headerlink" title="使用场景（为什么要用”with“）"></a><strong>使用场景</strong>（为什么要用”with“）</h5><p>案例中多次调用到 “<strong>result</strong>“实例。使用”<strong>with</strong>“减少对实例的调用。</p>
<h5 id="如何使用-”with“？"><a href="#如何使用-”with“？" class="headerlink" title="如何使用 ”with“？"></a>如何使用 ”with“？</h5><pre><code class="kotlin">fun alphabet(): String {
    val result = StringBuilder()
    return with(result) {// 指定接收者的值
        for (letter in &#39;A&#39;..&#39;Z&#39;) {
            this.append(letter) // 显式的使用‘this’来调用接收者值的方法（result.appned()方法）
        }
        append(&quot;\n Now I know the alphabet!&quot;)   // 隐藏 ‘this’ 同样可以使用
        this.toString()
    }
}</code></pre>
<pre><code class="kotlin">fun main() {
    println(alphabet())
}</code></pre>
<h5 id="”with“的结构"><a href="#”with“的结构" class="headerlink" title="”with“的结构"></a>”with“的结构</h5><blockquote>
<p>with 结构看上去像是一种特殊的语法结构，但它实际上是一个接收两个参数的函数：这个例子中两个参数分别是 stringBuilder 和 lambda 。</p>
</blockquote>
<p>with 函数把第一个参数转换为第二个参数传递给 lambda 的接收者。</p>
<h5 id="在普通函数中与扩展函数中带接收者的-lambda-有那些不同"><a href="#在普通函数中与扩展函数中带接收者的-lambda-有那些不同" class="headerlink" title="在普通函数中与扩展函数中带接收者的 lambda 有那些不同"></a>在普通函数中与扩展函数中带接收者的 lambda 有那些不同</h5><blockquote>
<p>在扩展函数体内部，this 指向了这个函数扩展的那个类型实例，而且也可以被省略掉，让你直接访问接收者的成员。</p>
</blockquote>
<blockquote>
<p>上面的代码中，this 指定了stringBuilder，这时传给with的第一个参数。可以通过显式的this引用来访问stringBuilder的方法，就像this，append(latter)这样：也可以像append（”\nNow…”)</p>
</blockquote>
<p><strong>重构初始的alphabet函数，去除stringBuilder变量。</strong></p>
<blockquote>
<pre><code class="kotlin">/*    使用with和一个表达式函数体来构造字母表    */
fun alphabet() = with(StringBuilder){
    for(letter in &#39;A&#39;...&#39;Z&#39;){
        append(letter)
    }
    append(&quot;\n Now I know the alphabet!&quot;)
    toString()
}</code></pre>
<p>现在此函数只返回一个表达式，所有表达式函数体语法重写了它。</p>
<p>可以创建一个新的StringBuilder实例直接当作实例传递给这个函数，然后 lambda中不需要显式的this就可以引用到这个实例。</p>
</blockquote>
<h3 id="5-5-2-“apply”-函数"><a href="#5-5-2-“apply”-函数" class="headerlink" title="5.5.2 “apply” 函数"></a>5.5.2 “apply” 函数</h3><h5 id="apply-和-with-的不同"><a href="#apply-和-with-的不同" class="headerlink" title="apply 和 with 的不同"></a>apply 和 with 的不同</h5><blockquote>
<p>apply 函数同with 函数功能相同，区别在于 apply 始终会返回作为实参传递给它的对象。（返回本身作为实例）</p>
</blockquote>
<pre><code class="kotlin">fun alphabet() = StringBuilder().apply {
    for (letter in &#39;A&#39;..&#39;Z&#39;) {
        append(letter)
    }
    append(&quot;\n Now I know the alphbet!&quot;)
}.toString()</code></pre>
<p>apply 被声明成一个扩展函数。它的<strong>接收者</strong>变成了作为实参的 lambda 的接收者。执行 apply 的结果是StringBuilder,所以接下来里可以调用 toString 把它转换成 String。</p>
<p><strong>使用apply初始化一个TextView</strong></p>
<pre><code class="kotlin">fun createViewWithCustomAttributes(context : Context) = {
    TextView(context).apply{
        text = &quot;Sample Text&quot;
        textSize = 20.0
        setPadding(10,0,0,0)
    }
}</code></pre>
<p><strong>apply函数允许里使用紧凑的表达式函数体风格</strong>。新的<strong>TextView</strong>实例<strong>创建</strong>之后立即被传给了<strong>apply</strong>。</p>
<p><strong>那个是接收者?</strong></p>
<p>TextView实例变成了 (lambda 的) 接收者，你可以调用它的属性和方法。</p>
<p>with 函数和 apply 函数是最基本和最通用的使用带接收者的 lambda 的例子。更多的函数也可以使用这种模式。例如，使用<strong>标准库函数buildString进一步简化alphbet函数</strong>，它会负责<strong>创建StringBuilder</strong>并<strong>调用toString</strong>。<strong>building实际是带接收者的lambda</strong>，<strong>接收者</strong>就是<strong>StringBuilder</strong>。</p>
<p><strong>使用buildString创建字母表</strong></p>
<pre><code class="kotlin">/*    使用bulderString创建字母表    */
fun alphabet()=builderString{
    for (letter in &#39;A&#39;...&#39;Z&#39;){
        append(latter)
    }
    append(&quot;\n Now I know tha alphabet!&quot;)
}</code></pre>
<p>buildString 函数完成了借助StringBuilder创建String的任务。</p>
<h2 id="5-6-小结"><a href="#5-6-小结" class="headerlink" title="5.6 小结"></a>5.6 小结</h2><ul>
<li><strong>Lambda 允许你将代码块当作参数传递给函数。</strong></li>
<li><strong>Kotlin可以把lambda放在括号括号外穿的给函数，而且可以使用it引用单个lambda参数</strong></li>
<li>lambda中的代码可以访问和修改包括这个lambda调用的函数的变量（访问修改调用者的变量）</li>
</ul>
<h1 id="6-Kotlin的类型系统"><a href="#6-Kotlin的类型系统" class="headerlink" title="6  Kotlin的类型系统"></a>6  Kotlin的类型系统</h1><h2 id="6-1-可空性"><a href="#6-1-可空性" class="headerlink" title="6.1 可空性"></a>6.1 可空性</h2><h3 id="6-17-“let”-函数"><a href="#6-17-“let”-函数" class="headerlink" title="6.17 “let” 函数"></a>6.17 “let” 函数</h3><p>用来处理可空表达式。和安全调用运算符一起使用，允许你对表达式求值，检查求值结果是否null，并把结果保存为一个变量。</p>
<pre><code class="kotlin">fun sendEmailTo(email : String){
    println(&quot;Sending emaill to $emaill&quot;)
}

&gt;&gt;&gt; var email:String ? = &quot;yole@example.com&quot;
&gt;&gt;&gt; email?.let{sendEmailTo(it)}
&gt;&gt;&gt; emaill = null
&gt;&gt;&gt; emaill?.let{    sendEmailTo(it)        }</code></pre>
<blockquote>
<p>所以说只有这段表达式不为空时才会执行代码块里的代码</p>
</blockquote>
<h3 id="6-18-延迟初始化的属性"><a href="#6-18-延迟初始化的属性" class="headerlink" title="6.18 延迟初始化的属性"></a>6.18 延迟初始化的属性</h3><h4 id="使用-延迟初始化属性的原因"><a href="#使用-延迟初始化属性的原因" class="headerlink" title="使用 延迟初始化属性的原因"></a>使用 延迟初始化属性的原因</h4><blockquote>
<p>Kotlin 通常要求你在构造方法中初始化所有属性，如果某个属性是可空类型，你就必须提供一个非空的初始化值。否则，你就必须使用可空类型。如果你这样做，该属性的每一次访问都需要null检查或者！！运算符</p>
</blockquote>
<p><strong>使用非空断言访问可控属性</strong></p>
<pre><code class="kotlin">class MyService{
    fun performAction():String = &quot;foo&quot;
}
class MyText{
    private var myService : MyService ?= null    // 声明了一个可空类型初始化为 null
    @Before fun setUp(){    // 在 setUp方法中提供真正的初始化器
        myService = MyService()
    }
    @Test fun testAction(){
        Assert.assertEquals(&quot;foo&quot;,myService!!.performAction())    // 必须注意可空性：要么用&quot;!!&quot;，要么用&quot;?.&quot;
    }
}</code></pre>
<p><strong>使用延迟初始化</strong></p>
<pre><code class="kotlin">class MyService{
    fun performAction():String = &quot;foo&quot;
}
class MyText{
    private lateinit var myService : MyService    // 声明了一个不需要初始化器的非空类型属性
    @Before fun setUp(){    // 在 setUp 方法中初始化 myService
        myService = MyService()
    }
    @Test fun testAction(){
        Assert.assertEquals(&quot;foo&quot;,myService.performAction())    // 不需要 null 检查直接访问属性
    }
}</code></pre>
<p>注意</p>
<blockquote>
<p>初始化的属性必须为var，因为需要在构造方法外修改它的值，使用val属性被编译时必须在构造方法中初始化final片段。</p>
<p>尽管 myService 属性是非空的，你不需要在构造方法中初始化它。在属性没有被初始化之前调用会得到异常 “lateinit property myService has not been initialized”。</p>
<p>lateinit 属性常见的一种用法是在依赖注入。在某种情况下，lateinit 属性的值是被依赖注入框架从外部设置的。为了保证和各种依赖注入框架的兼容性</p>
<p>，Kotlin 会自动生成一个和 lateinit 属性具有相同可见性的字段。如果属性的可见性是public，生成的字段意思public</p>
</blockquote>
<h1 id="8-高阶函数：Lambda作为形参和返回值"><a href="#8-高阶函数：Lambda作为形参和返回值" class="headerlink" title="8 高阶函数：Lambda作为形参和返回值"></a>8 高阶函数：Lambda作为形参和返回值</h1><p><strong>内联函数作用</strong></p>
<p>能够消除lambda带来的性能开销，还能够使lambda内的控制流更加灵活。</p>
<h2 id="8-1-声明高阶函数"><a href="#8-1-声明高阶函数" class="headerlink" title="8.1 声明高阶函数"></a>8.1 声明高阶函数</h2><p>定义</p>
<blockquote>
<p>高阶函数就是以另一个函数作为参数或者返回值的函数。在kotlin中，函数可以用lambda或者函数引用来表示。因此，<strong>任何以lambda或者函数引用作为参数的函数，或者返回值为lambda或函数引用的函数</strong>，或者两者都有满足的函数都是高阶函数。</p>
</blockquote>
<p>标准库中的filter函数将一个判断式函数作为参数，因此它是一个高阶函数：</p>
<pre><code class="kotlin">list.filter{x&gt;0}</code></pre>
<h3 id="8-1-1-函数类型"><a href="#8-1-1-函数类型" class="headerlink" title="8.1.1 函数类型"></a>8.1.1 函数类型</h3><p>在变量中我们有<strong>Int类型</strong>，<strong>String类型</strong>等那么也有属于函数的<strong>函数类型</strong>。</p>
<p>声明一个lambda作为实参的函数，你需要知道如何声明对应形参的类型。在那之前，看接下来的例子，把 lambda 表达式保存在局部变量中。在不声明类型的情况下，这些就依赖于Kotlin的类型推导。</p>
<pre><code class="kotlin">val sum = {x:Int,y:Int -&gt; x+y}
val action = {println(42)}</code></pre>
<p>编译器推导出sum和action两个变量具有<strong>函数类型</strong>。</p>
<p>显式声明<strong>函数类型的变量</strong></p>
<pre><code class="kotlin">val sum:(Int ,Int) -&gt; Int = {x,y-&gt;x+y}    // 有两个Int类型参数和Int类型返回值
val action:() - &gt; Unit = { println(42) }    //没有参数和返回值</code></pre>
<p>声明函数类型，需要将函数参数类型放在括号中，紧接着是一个箭头和函数的返回值类型。</p>
<pre><code class="kotlin">(Int,String) -&gt; Unit
// ↑参数类型    ↑返回类型</code></pre>
<p>在声明函数类型时Unit是不能省略的，其他情况下可以。</p>
<p>函数类型的返回值标记为可空类型：</p>
<pre><code class="kotlin">val canReturnNull: (Int,Int) -&gt; Int?={null}</code></pre>
<p>定义函数类型的可空变量。</p>
<blockquote>
<p>为了明确表示是变量本身可空，而不是函数类型的返回类型可空，你需要将整个函数类型的定义包含在括号内并在括号后添加问号。</p>
<pre><code class="kotlin">val funOrNull:((Int,Int) -&gt; Int) ?= null</code></pre>
</blockquote>
<h3 id="8-1-2-调用作为参数的函数"><a href="#8-1-2-调用作为参数的函数" class="headerlink" title="8.1.2 调用作为参数的函数"></a>8.1.2 调用作为参数的函数</h3><p>实现一个高阶函数。</p>
<p>实现2，3两个数字的任意操作。</p>
<blockquote>
<p>函数类型作为参数，形参和实参更像是接口，形参是接口实参则用来具体的实现。</p>
</blockquote>
<p>定义一个简单的高阶函数</p>
<pre><code class="kotlin">//    定义一个函数类型的参数
fun twoAndThree(operation: (Int,Int) -&gt; Int){
    val result = opration(2,3)    // 调用参数（函数类型）
    println(&quot;The result is $result&quot;)
}
&gt;&gt;&gt; twoAndThree{a,b -&gt; a+b}
The result is 5
&gt;&gt;&gt; twoAndThree(a,b -&gt; a*b)
The result is 6</code></pre>
<p>实现最常用的标准库函数：filter函数。为了更让事情更简单一些，将实现基于String类型的filter函数，但和作用于泛型的版本原理是显示的。</p>
<pre><code class="kotlin">/* &quot;String&quot;:接收者类型。
    “predicate”：参数类型
    “(Char) -&gt; Boolean”：函数类型参数
    “Char”:函数类型参数的参数类型
    “Boolean”：函数类型的参数返回类型
    */
fun String.filter(predicate:(Char) -&gt; Boolean):String</code></pre>
<blockquote>
<p>filter 函数的声明，以一个判断式作为参数</p>
</blockquote>
<p>判断式的类型是一个函数，以字符作为参数并返回boolean类型的值。如果要让传递给判断式的字符出现在最终返回的字符串中，判断式需要返回ture，反之false。</p>
<pre><code class="kotlin">//    实现一个简单版本的filer函数
fun String.filter(predicate: (Char) -&gt; Boolean):String{
    val sb = StringBuilder()
    for (index in 0 until length){
        val element = get(index)
        if (predicate(element)) sb.append(element)    // 调用引用的String类型参数给predicate函数进行判断
    }
    return sb.toString()
}

&gt;&gt;&gt; println(&quot;ab1c&quot;.filter{it in &#39;a&#39;..&#39;z&#39;})    //传递 lambda 作为 &#39;predicate&#39;参数
abc</code></pre>
<blockquote>
<p>filter 函数的实现非常简单明了。它检查每个字符时候满足判断式，如果满足就将字符添加到包含结果的StringBuilder中。</p>
</blockquote>
<h3 id="8-1-3-在Java中使用函数类"><a href="#8-1-3-在Java中使用函数类" class="headerlink" title="8.1.3 在Java中使用函数类"></a>8.1.3 在Java中使用函数类</h3><p><strong>原理</strong></p>
<blockquote>
<p>函数类型被声明为普通的接口：一个函数类型的变量是<strong>FunctionN接口的实现</strong>。</p>
<p>Kotlin 标准库定义了一系列的接口，这些接口对应于不同的参数数量的函数：<strong>Function0<R>(没有参数的函数)、Function&lt;P1,R&gt;(一个参数的函数)</strong>。</p>
<p>每个接口定义了一个 invoke 方法，调用这个方法就会执行函数。</p>
<p>一个函数类型的变量就是实现了对应的Function接口的实现类的实力，实现类的invoke方法包含了lambda函数体。</p>
</blockquote>
<p><strong>在 Java 中调用使用了函数类型的 Kotlin 函数。</strong></p>
<pre><code class="kotlin">/*    kotlin声明    */
fun processTheAnswer(f:(Int) -&gt;){
    println(f(42))
}</code></pre>
<pre><code class="kotlin">/*    Java    */
&gt;&gt;&gt; processTheAnswe(number -&gt; number+1);
43</code></pre>
<p>在旧版 Java 中，可以传递一个实现了函数接口中 invoke 方法的匿名类的实例：</p>
<pre><code class="java">/*    Java    */
&gt;&gt;&gt; processTheAnswer(
...        new Function1&lt;Integer,Integer&gt;(){    // 在Java 8 以前使用函数类型
...            @Override
...            public Integer invoke(Integer number){
...                System.out.println(number);
...                return number+1;
...                }
...        });
43</code></pre>
<p>在 Java 中使用函数类型必须显示地传递一个接收者对象作为第一个参数。</p>
<p>在Java中可以很容易地使用 Kotlin 标准库中以lambda作为参数的扩展函数。</p>
<pre><code class="java">/*    Java    */
&gt;&gt;&gt; List&lt;String&gt; strings = new ArrayList()；
&gt;&gt;&gt; strings.add(&quot;42&quot;)
&gt;&gt;&gt; CollectionKt.forEach(strings, s -&gt;{    //可以在Java中使用Kotlin标准库中的函数
...        System.out.println(a);
...        return unit.INSTANCE;    // 必须显示的返回一个Unit类型的值。
...})</code></pre>
<blockquote>
<p>在 Java 中 ，函数或许lambda可以返回Unit。因为在 Kotlin 中 Unit 类型是有值的，所以需要显示的返回它。</p>
<p>一个返回 void 的lambda 不能作为返回 Unit 的函数类型的实参，就像之前的例子中的(String) -&gt;Unit.</p>
</blockquote>
<h3 id="8-1-4-函数类型的参数默认值和null值"><a href="#8-1-4-函数类型的参数默认值和null值" class="headerlink" title="8.1.4 函数类型的参数默认值和null值"></a>8.1.4 函数类型的参数默认值和null值</h3><p>声明函数类型的参数时可以指定参数的默认值。</p>
<p><strong>用来理解参数默认值的关键作用</strong></p>
<pre><code class="kotlin">/*    使用了硬编码toString转换的joinToString函数    */
fun &lt;T&gt; Collection&lt;T&gt;.joinToString(
        separator: String = &quot;,&quot;,
        prefix: String = &quot;&quot;,
        postfix: String = &quot;&quot;
): String{
        val result = StringBuilder(prefix)
        for ((index,element) in this.withIndex()){
            if(index &gt;0) result.append(separator)
            result.append(element)    // 使用默认toString方法将对象转换成字符串
        }
        result.append(postfix)
        return result.toString()
}</code></pre>
<blockquote>
<p>这里的实现很灵活但是并没有让你控制转换的关键点： 集合中的原始是如何转换成字符串的。</p>
</blockquote>
<blockquote>
<p>这里使用 StringBuilder.append(o:Any?) (result.append(element)),他总是使用toString方法将对象转换成字符串。在大多数情况下这样是可以的，但是不总是这样。</p>
</blockquote>
<blockquote>
<p>现在可以传递一个lambda去指定如何将对象转换成字符串。</p>
</blockquote>
<blockquote>
<p>但是要求所有调用者都传递lambda是比较烦人的，因为大部分调用者使用默认的行为就可以了。为了解决这个问题，可以定义一个函数类型的参数并用一个lambda作为它的默认值。</p>
</blockquote>
<pre><code class="kotlin">/*    给函数类型的参数指定默认值    */
fun &lt;T&gt; Collection&lt;T&gt;.joinToString(
        separator: String = &quot;,&quot;,
        prefix: String = &quot;&quot;,
        postfix: String = &quot;&quot;,
        transform: (T) -&gt; String = {it.toString()}    //声明一个lambda为默认值的函数类型的参数
): String {
        val result = StringBuilder(prefix)
        for ((index,element) in this.withIndex()){
            if(index &gt; 0 ) result.append(separator)
            result.append(transform(element))    // 调用作为实参的element传递给 “transform”形参的函数
        }
        result.append(postfix)
        return result.toString()
}


&gt;&gt;&gt; val letters = listOf(&quot;Alpha&quot;,&quot;Beta&quot;)
&gt;&gt;&gt;  println(letters.joinToString())    // 使用默认的转换函数
Alpha, Beta
&gt;&gt;&gt; println(letters.joinToString{it.toLowerCase()})    // 传递一个 lambda 作为参数
alpha,beta
&gt;&gt;&gt; println(letters.joinToString(separator = &quot;!&quot;,postifx = &quot;!&quot;, transform = {it.ToUpperCase()}))    // 使用命名参数参数语法几个参数，包括lambda。
ALPHA,BETA</code></pre>
<blockquote>
<p>这个带默认值的函数类型是一个泛型参数T表示集合中的元素类型。 Lambda transform 将接收这个类型的参数。</p>
</blockquote>
<blockquote>
<p>声明函数类型的默认值并不需要特殊的语法，只需要把 lambda 作为值放在 = 号后。上述例子展示了多种方式调用函数类型。</p>
</blockquote>
<p><strong>声明函数类型其参数是可空的</strong></p>
<pre><code class="kotlin">/*    案例1    一般情况*/
fun foo(callback: (() -&gt;Unit)?){
    if(callback != null){
        callback()
    }
}
</code></pre>
<blockquote>
<p>这里不能直接调用作为参数传递进行的函数：Kotlin 会因为检查到潜在的空指针异常而导致编译失败。<strong>这里可选的办法是显式地检查null</strong>。</p>
</blockquote>
<pre><code class="kotlin">/*    使用函数类型的可空参数    */
fun &lt;T&gt; Collection&lt;T&gt;.joinToString(
        separator: String = &quot;,&quot;,
        prefix: String = &quot;&quot;,
        postfix: String = &quot;&quot;,
        transform:    ((T) -&gt; String ) ?=null    // 声明一个函数类型的可空参数
): String{
    val result = StringBuilder(prefix)
    for ((index,element) in this.withIndex()){
        if (index &gt; 0) result.append(separator)
        val str = transform?.invoke(element)    // 使用安全调用语法，调用函数
            ?: element.toString()    //使用 Elvis 运算符处理回调没有被指定的情况
        result.append(str)
    }
    result.append(postfix)
    return result.toString()

}</code></pre>
<blockquote>
<p>这是一个更简单的版本，它利用了一个事实 ，函数类型是包含 invoke 方法的接口具体实现。作为一个普通方法，invoke可以通过安全调用语法被调用：callback?.invoke()方法</p>
</blockquote>
<h3 id="8-1-5-返回函数的函数"><a href="#8-1-5-返回函数的函数" class="headerlink" title="8.1.5 返回函数的函数"></a>8.1.5 返回函数的函数</h3><pre><code class="kotlin">/*    定义一个返回函数的函数    */
enum class Delivery {STANDARD, EXPEDITED}
class Order(val itemCount:Int)
fun getShippingCostCalculator(delivery:Delivery):(Order)-&gt;Double{    // 声明返回函数的函数
    if (delivery == Delivery.EXPEDITEM){    // 返回 lambda
        return {order -&gt; 6+2.1 * order.itemCount}
    }
    return {order -&gt;1.2*order.itemCount}
}
&gt;&gt;&gt; val calculator = getShippingCostCalculator(Delivery.EXPEDITEM)    // 将返回的函数保存在变量中
&gt;&gt;&gt; println(&quot;Shapping costs ${calculator(Order(3))}&quot;)    // 调用返回的函数
Shipping costs 12.3</code></pre>
<blockquote>
<p><strong>使用场景</strong></p>
<p>例如，运输费用的计算依赖于选择恰当的逻辑变体并将它作为另一个函数返回。<strong>声明一个 返回另一个函数的函数，需要指定一个函数类型作为返回类型。</strong></p>
<p>函数 getShippingCostCalculator返回一个函数，这个函数以Order最为参数并返回一个Double类型的值。</p>
<p><strong>要返回一个函数，需要写一个return表达式，跟上一个lambda、一个成员引用，或者其他的函数类型的表达式，比如一个函数的局部变量。</strong></p>
</blockquote>
<p><strong>另一个返回函数的例子</strong></p>
<blockquote>
<p>例如，你可以在 UI 上输入一个字符串，然后只显示那些名字以这个字符串开头的联系人；还可以隐藏没有电话号码的联系人。用ContactListFilters这个类来保存这个选项的状态。</p>
</blockquote>
<pre><code class="kotlin">class ContactListFilters{
    var prefix: String = &quot;&quot;
    var onlyWithPhoneNumber: Boolean = false
}</code></pre>
<blockquote>
<p>当用户输入 D 来查看姓或者名以 D 开头的联系人时，prefix的值会被更新。</p>
</blockquote>
<pre><code class="kotlin">/*    在UI代码中定义一个返回函数的函数    */
data class Persion(
    val firstName:String,
    val lastName:String,
    val phoneNumber:String?
)

class ContactListFilters{
    val prefix:String = &quot;&quot;
    val onlyWithPhoneNumber: Boolean = false
    fun getPredicate():(Person) -&gt; Boolean{    //声明一个返回函数的函数
        val    startWithPrefix  = {p:Persion -&gt; p.firstName.startsWith(prefix) || p.lastName.startsWith(prefix)
        }
        if (!onlyWithPhoneNumber){
            return startWithPrefix    // 返回一个函数类型的变量
        }
        return { startsWithPrefix(it)&amp;&amp;it.phoneNumber != null }    //从函数返回一个lambda

    }
}
&gt;&gt;&gt; val contacts = listOf(Persion(&quot;Dmitry&quot;,&quot;Jemeroy&quot;,&quot;123-4567&quot;),
...                          Persion(&quot;Svetlane&quot;,&quot;Isakova&quot;,null))
&gt;&gt;&gt; val contactListFilters = ContactListFilters()
&gt;&gt;&gt; with (contactListFilters){
&gt;&gt;&gt;        prefix = &quot;Dm&quot;
&gt;&gt;&gt;     onlyWithPhoneNumber = true
&gt;&gt;&gt; }
&gt;&gt;&gt; println(contacts.filter(
...        contactListFilters.getPredicate()))        // 将 getPredicate 返回的函数作为参数传递给 “filter” 函数
[Persion (firstName = Dmitry,lastName = Jemetov,phoneNumber = 123-4567)]</code></pre>
<blockquote>
<p>为了让展示联系人列表的逻辑代码和输入的过滤条件的UI条件解耦，可以定义一个函数来创建一个判断式，用来过滤联系人列表。判断式检查前戳，如果有需要也检查电话号码时候存在。</p>
</blockquote>
<blockquote>
<p>getPredicate 函数返回一个函数（类型）的值，这个值被传递给filter作为参数。</p>
</blockquote>
<h3 id="8-1-6-通过lambda-去除重复代码"><a href="#8-1-6-通过lambda-去除重复代码" class="headerlink" title="8.1.6 通过lambda 去除重复代码"></a>8.1.6 通过lambda 去除重复代码</h3><p>例子</p>
<blockquote>
<p>这是一个分析网站访问的例子。SiteVisit类用来保存每次访问的如今、持续时间和用户的操作系统。不同的操作系统使用枚举来表示。</p>
</blockquote>
<pre><code class="kotlin">/*    定义站点访问数据    */
data calss SiteVisit(
    val path: String,
    val dutation: Double,
    val os: OS
    )
enum class OS{ WINDOWS,LINUX,MAC,IOS,ANDROID}
val log = listOf(
    SiteVisit(&quot;/&quot;,34.0,OS.WINDOWS),
    SiteVisit(&quot;/&quot;,22.0,OS.MAC),
    SiteVisit(&quot;/login&quot;,12.0,OS.WINDOWS),
    SiteVisit(&quot;/signup&quot;,8.0,OS.IOS),
    SiteVisit(&quot;/&quot;,16.3.OS.ANDROID)
)</code></pre>
<blockquote>
<p>需要显示来自 Windows 的平均访问时间，可以使用 average 函数来完成这个任务。</p>
</blockquote>
<pre><code class="kotlin">/*    使用硬编码的过滤器分析站点访问数据    */
val averageWindowsDutation = log
    .filter {it.os == OS.WINDOWS}
    .map(SiteVisit::dutation)
    .avaerage()
&gt;&gt;&gt;println(averageWindowsDutaion)
23.0</code></pre>
<blockquote>
<p>显示来自于Windows机器的平均访问时间，用 average 函数来完成任务。</p>
</blockquote>
<pre><code class="kotlin">/*    使用普通的方法去除重复代码    */
fun List&lt;SiteVisit&gt;.averageDurationFor(os:OS) = filter{it.os == os}.map(SiteVisit::dutation).average()    // 将重复代码抽取到函数中
&gt;&gt;&gt; println(log.averageDurationFor(OS.WINDOWS))
23.0
&gt;&gt;&gt; println(log.averageDurationFor(OS.MAC))
22.0</code></pre>
<blockquote>
<p>现在你要计算一个来自MAC用户的相同数据，为了避免重复，可以将平台类型抽象成一个参数.</p>
<p>注意这个函数作为扩展函数增强了可读性。如果它值在局部的上下文中有用，你甚至可以将这个函数声明为局部的扩展函数。</p>
</blockquote>
<pre><code class="kotlin">/*    用一个重复的硬编码函数分析站点访问数据    */
val averageMobileDutation = log
    .filter{it.os == setOf(OS.IOS,OS.ANDROID)}
    .map(SiteVisit::duration)
    .average()

&gt;&gt;&gt; println(averageMobileDuration)
12.15
</code></pre>
<blockquote>
<p>如果你对移动平台的访问的平均时间感兴趣。</p>
<p>这时已经不能再再用简单的参数表示不同的平台了。可能还需要使用更加复杂的条件查询日志，比如，“来自IOS平台对注册页面的访问平均时间是多少？”</p>
<p><strong>可以使用函数类型将需要的条件抽象到一个参数中</strong></p>
</blockquote>
<pre><code class="kotlin">/*    用高阶函数去除重复代码    */
fun List&lt;SiteVisit&gt;.averageDutationFor(predicate:(SiteVisit) -&gt; Boolean) = filter(predicate).map(SiteVisit::duration).average()
&gt;&gt;&gt; println(log.averageDurationFor{
...        it.os in setOf(OS.ANDROID,OS.IOS)
})
12.15
&gt;&gt;&gt; println(log.averageDurationFor{
...        it.os == OS.IOS &amp;&amp; it.path == &quot;/signup&quot;    // 满足系统为IOS，访问地址为 注册界面的条件
})
8.0</code></pre>
<blockquote>
<p>函数类型可以帮助去除重复代码。使用lambda，不仅可以去除重复的数据，也可以去除重复的行为。</p>
</blockquote>
<h2 id="8-2-内联函数：消除lambda带来的运行时开销"><a href="#8-2-内联函数：消除lambda带来的运行时开销" class="headerlink" title="8.2 内联函数：消除lambda带来的运行时开销"></a>8.2 内联函数：消除lambda带来的运行时开销</h2><blockquote>
<p>Kotlin 中传递 lambda 作为函数参数的简明语法与普通的表达式语法很相似。</p>
<p><strong>lambda 表达式会被正常地编译成匿名类。这表示每调用一次 lambda 表达式，就会额外的创建一个类。并且如果 lambda 捕捉了某个变量，那么每次调用的时候都会创建一个新的对象。这会带来运行时的额外开销，导致使用 lambda 比使用一个直接执行相同代码的函数效率更低。</strong></p>
<p>有没有可能让编译器生成跟 Java 语句相同高效的代码，但还是能把重复的逻辑抽取到库函数中呢？（作用）</p>
<p>如果使用 <strong>inline</strong> 修饰符标记一个函数，在函数被使用的时候编译器并不会生成函数调用的代码，而是使用函数实现的真实代码替换每一次的函数调用。</p>
</blockquote>
<p><strong>内联函数简介</strong></p>
<blockquote>
<p>在<a href="https://baike.baidu.com/item/计算机科学" target="_blank" rel="noopener">计算机科学</a>中，<strong>内联函数</strong>（有时称作<strong>在线函数</strong>或<strong>编译时期展开函数</strong>）是一种<a href="https://baike.baidu.com/item/编程语言" target="_blank" rel="noopener">编程语言</a>结构，用来建议<a href="https://baike.baidu.com/item/编译器" target="_blank" rel="noopener">编译器</a>对一些特殊<a href="https://baike.baidu.com/item/函数" target="_blank" rel="noopener">函数</a>进行内联扩展（有时称作<strong>在线扩展</strong>）；也就是说建议编译器将指定的函数体插入并取代每一处调用该函数的地方（<a href="https://baike.baidu.com/item/上下文" target="_blank" rel="noopener">上下文</a>），从而节省了每次调用函数带来的额外时间开支。但在选择使用内联函数时，必须在程序占用空间和程序执行效率之间进行权衡，因为过多的比较复杂的函数进行内联扩展将带来很大的存储资源开支。另外还需要特别注意的是对<a href="https://baike.baidu.com/item/递归函数" target="_blank" rel="noopener">递归函数</a>的内联扩展可能引起部分编译器的无穷编译。</p>
</blockquote>
<h3 id="8-2-1-内联函数如何运作"><a href="#8-2-1-内联函数如何运作" class="headerlink" title="8.2.1 内联函数如何运作"></a>8.2.1 内联函数如何运作</h3><blockquote>
<p><strong>内联函数！</strong></p>
<p>当一个函数被声明为 inline 时，它的函数体是内联的–换句话说，函数体会被直接替换到函数被调用的地方，而不是被正常调用。</p>
</blockquote>
<pre><code class="kotlin">/*    定义一个内联函数    */
inline fun &lt;T&gt; sysnchronized(lock:Lock,action : () -&gt; T):T{
    lock.lock()
    try{
        return action()
    }
    finally    {
        lock.unlock()
    }
}
val l = Lock()
synchronized(1){
    //...
}</code></pre>
<blockquote>
<p>函数用于确保一个共享资源不会并发地被多个线程访问。函数锁住一个Lock对象，执行代码块。</p>
</blockquote>
<blockquote>
<p>调用这个函数的语法跟Java中使用 synchronized 语法完全一直。<strong>区别</strong>，Java 的 synchronized 语法可以用于<strong>任何对象</strong>，这个函数则要求传入一个Lock实例。</p>
<p>同时，Kotlin 标准库中定义了一个可以接受<strong>任何对象</strong>作为参数的 synchronized 函数版本。</p>
<p>这里使用同步操作时显式的对象锁能够提升代码的可读性和维护性。</p>
</blockquote>
<blockquote>
<p><strong>使用 inline 的效果！</strong></p>
<p>因为已经将 synchronized 函数声明为 inline，所以每次调用它所生成的代码跟 Java 的synchronized 语句都是一样的。</p>
</blockquote>
<p><strong>使用 synchronized 的例子。</strong></p>
<pre><code class="kotlin">fun foo(l:Lock){
    println(&quot;Before sync&quot;)
    synchronized(1){
        println(&quot;Action&quot;)    //内联函数
    }
    println(&quot;After sync&quot;)
}</code></pre>
<pre><code class="kotlin">/*    编译后的 foo 函数    */
fun _foo_(l:Lock){
    println(&quot;Before sync&quot;)    //这是调用者 foo 的代码
    l.lock()    // 这是被内联的 synchronized 函数代码
    try(
        println(&quot;Action&quot;)    //被内联的lmabda题代码
    )finally{
        l.unlock()        //这是调用者 foo 的代码
    }
    println(&quot;After sync&quot;)    //这是调用者 foo 的代码
}</code></pre>
<blockquote>
<p>展示的是作用相同的代码，将会被编译成同样的字节码。</p>
</blockquote>
<blockquote>
<p>这里 lambda 表达式 和 synchronized 函数实现了内联。</p>
<p>由于lambda 生成的字节码成为了函数调用这定义的部分，而不是被包含在一个实现了函数接口的匿名类中</p>
</blockquote>
<pre><code class="kotlin">/*    调用内联函数的时候可以传递函数类型的变量作为参数    */
class LockOwner(val lock:Lock){
    fun runUnderLock(body:() -&gt; Unit){
        synchronized(lock,body)    //作为函数类型的变量作为参数，而不是lambda
    }
}</code></pre>
<blockquote>
<p>使用函数类型的变量作为参数，不会被内联。</p>
</blockquote>
<blockquote>
<p>只有synchronized 函数体被内联了，lambda 才会被正确调用。</p>
</blockquote>
<pre><code>/*    runUnderLock 的函数字节码    */
class LockOwner(val lock:Lock){
    fun runUnderLock(body:() -&gt; Unit){    //函数类似于真正的runUnberLock被编译成的字节码
        lock.lock()
        try{
            body() // body 没有被内联，因为在调用到地方换没有 lambda
        }finally{
            lock.unlock()
        }
    }
}</code></pre><h3 id="8-2-2-内联函数的限制"><a href="#8-2-2-内联函数的限制" class="headerlink" title="8.2.2 内联函数的限制"></a>8.2.2 内联函数的限制</h3><blockquote>
<p>鉴于内联的运作方式，不是所有使用lambda的函数都可以被内联的。</p>
</blockquote>
<blockquote>
<p>当函数被内联的时候，作为参数的lambda表达式函数体会被直接替换成最终生成的代码中。这会限制函数体中对应的（lambda）参数使用。如果（lambda）参数被调用，这样的代码能被容易的内联。<strong>但是如果（lambda）参数在某个地方被保存起来，一遍后边可以继续使用，lambda表达式的代码将不能被内联，因为必须要有一个包含这些代码的对象存在。</strong></p>
</blockquote>
<blockquote>
<p>一般来说，参数如果被直接调用或者作为参数传递给另外一个inline函数，它是可以被内联的。否则，编译器会禁止参数被内联并给出错误信息“Illeal usage of inline-parameter”</p>
</blockquote>
<blockquote>
<p>例如，许多作用域序列的函数会返回一些类的实例，这些类代表对应的序列操作并接受lambda作为构造参数。 这是 Sequence.map函数的定义：</p>
</blockquote>
<pre><code class="kotlin">fun &lt;T,R&gt; Sequence&lt;T&gt;.map(transform:(T) -&gt; R):Sequence&lt;R&gt;{
    return TransformingSequence(this,transform)

}</code></pre>
<blockquote>
<p>map 函数没有直接调用作为 transform参数传递进来的函数。而是将这个函数传递给类的构造方法，构造方法将它保存在一个属性中。</p>
<p>这时为了支持这一点，作为transform参数传递的lambda需要被编译成标准的非内联的表达式，即实现了一个函数接口的匿名类。</p>
</blockquote>
<blockquote>
<p> 当函数期望两个或多个 lambda 参数，可以选择只内联其中一些参数。这是有道理的，因为一个lambda可能会包含很多代码或者不允许内联的方式使用。接受这样的非内联lambda的参数，可以用 noinline 修饰符来标记它：</p>
<pre><code class="kotlin">inline fun foo(inlined:() -&gt; Unit,noinlune notInlined:() -&gt; Unit){
    //...
}</code></pre>
</blockquote>
<h3 id="8-2-3-内联集合操作"><a href="#8-2-3-内联集合操作" class="headerlink" title="8.2.3 内联集合操作"></a>8.2.3 内联集合操作</h3><p>Kotlin 标准库中操作集合函数的性能。大部分标准库中的集合函数都带有lambda参数。<strong>不管使用标准库函数，还是直接实现这些操作效率都是一样的。</strong></p>
<p>我们来比较一下。</p>
<pre><code class="kotlin">/*    使用lambda过滤一个集合    */
data class Person(val name:String,val age:Int)
val people = listOf(Persion(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31))
&gt;&gt;&gt; println(people.filter(it.age&lt;30))
[Person(name = Alice,age = 29)]</code></pre>
<pre><code class="kotlin">/*    手动过滤一个集合 不用lambda表达式来实现*/
&gt;&gt;&gt; val result = mutableListOf&lt;Person&gt;()
&gt;&gt;&gt; for (person in people){
&gt;&gt;&gt;         if(person.age &lt; 30) result.add(person)
&gt;&gt;&gt;}
&gt;&gt;&gt; println(result)
[Person(name = &quot;Alice&quot;, age = 29)]</code></pre>
<blockquote>
<p>Kotlin 对内联函数的支持让你不必担心性能问题。</p>
</blockquote>
<blockquote>
<p>在Kotlin中，filter 函数被声明为内联函数。这意味着 filter 函数，以及传递给它的lambda的字节码会被一起内联到filter被调用的地方。最终，第一种实现所产生的字节码和第二种实现所产生的字节码大致是一样的。你可以很安全地使用符合语言习惯的集合操作。</p>
</blockquote>
<blockquote>
<p>现象你在连续使用 filter 和 map 两个操作。</p>
<pre><code class="kotlin">&gt;&gt;&gt; println(people.filter{it.age &gt; 30}
...                .map (Persion::name))
[Bob]</code></pre>
<p><strong>这个例子使用了 lambda 表达式和一个成员引用。</strong></p>
<p>这里 filter 和 map 都被声明为了 inline 函数，所以他们的函数体会被内联，因此不会产生额外的类和对象。上述的代码却创建了一个中间集合来把偶出来列表过滤的结果，由 filter 函数生成的代码会向这个集合种添加元素，而由 map 函数生成的代码会读取这个几个。</p>
<p><strong>如果有大量的元素需要处理，中间集合的运行开销将成为不可忽视的问题，这时可以在调用链后加上一个asSequence调用，用序列代替集合。</strong></p>
<p>同时如同上一节看到的一样，用于处理序列的 lambda 不能够被内联，每个中间序列被表示成lambda保存在其字段中的对象，<strong>而末端操作会导致由每个中间序列调用组成的链被执行</strong>。因此，即便序列上的操作是惰性的，你不应该总是试图在集合操作的链后<strong>asSequence</strong>。只有在处理大量数据时有用，小的集合可以用普通集合处理。</p>
</blockquote>
<h3 id="8-2-4-决定何时将函数声明成内联"><a href="#8-2-4-决定何时将函数声明成内联" class="headerlink" title="8.2.4 决定何时将函数声明成内联"></a>8.2.4 决定何时将函数声明成内联</h3><p>使用 inline 关键词只能提高 lambda 参数的函数性能，其他情况需要额外的度量和研究。</p>
<p><strong>将带有 lambda 参数的函数内联能够带来什么好处。</strong></p>
<blockquote>
<p>首先， 通过内联避免运行时开销更加明显了。毕竟节约了函数运行时的开销，而且节约了 lambda 创建匿名类，以及创建 lambda 实例对象的开销。其次，JVM 还没有聪明到总是能将函数调用内联。内联可以使用一些不可能被普通 lambda 使用的特征，比如非局部返回。</p>
</blockquote>
<p><strong>注意</strong></p>
<blockquote>
<p><strong>在使用 inline 关键字的时候，你还是应该注意代码的长度。如果你要内联的函数不大，将它的字节码拷贝到每一个调用点将会极大地增加字节码的长度。在这种情况下，你应该将那些与 lambda 参数无关的代码抽取到一个独立的非内联函数中。在 Kotlin 中内联函数总是很小的。</strong></p>
</blockquote>
<h3 id="8-2-5-使用-内联-lambda-管理资源"><a href="#8-2-5-使用-内联-lambda-管理资源" class="headerlink" title="8.2.5  使用 内联 lambda 管理资源"></a>8.2.5  使用 内联 lambda 管理资源</h3><p><strong>Lambda 可以去除重复代码的一个常见模式是资源模式</strong></p>
<blockquote>
<p>先获取资源，完成一个操作，释放资源。</p>
<p>这里资源表示多种不同的东西：一个文件、一个锁、一个数据库事务等。</p>
<p>实现这个模式的标准做法是使用 try/finally 语句。资源在 try 代码块之前被获取，在 finally 代码块中释放。</p>
</blockquote>
<p><strong>synchronization</strong></p>
<blockquote>
<p>前部分讲到将 try/finally的逻辑封装在一个函数中，然后将使用资源的代码作为 lambda 传递给这个方法。</p>
<p>synchronization将一个锁对象作为参数。</p>
</blockquote>
<p>代替 <strong>synchronization</strong></p>
<blockquote>
<p>Kotlin 标准库定义了一个叫 withLock的函数，它提供了实现同样功能的更符合语言习惯的API：它是 Lock 接口的扩展函数。</p>
<p>如何使用。</p>
<pre><code class="kotlin">val l:Lock = ...
l.withLock{
    // access the resource protected by this lock 在加锁的情况下执行指定的操作。
}
/*    在Kotlin标准库中的定义    */
fun &lt;T&gt; Lock.withLock(action : () -&gt; T):T{    //需要加锁的代码被抽取到一个独立的方法中
    lock()
    try{
        return action()
    } finally{
        unlock()
    }

}</code></pre>
</blockquote>
<p><strong>文件是另一种可以使用这种模式的常见资源类型。（文件使用 资源模式）</strong></p>
<blockquote>
<p>Java 7 为这种模式引入了特殊的语法：try-with-resource 语句。</p>
<pre><code class="kotlin">/*    下述代码来读取文件的第一行Java方法    */
/*    在Java中使用try-with-resource语句    */
static String readFirstLineFromFile(String path) throws IOException{
    try(BufferedReader br = new BufferedReader(new FileReader(path))){
        return br.readLine();
    }
}</code></pre>
<p>Kotlin 中并没有等价的语法，因为通过使用一个带有函数类型参数的函数可以无缝地完成相同的事情。这个函数叫use()</p>
<p><strong>使用 use 函数 重写上述代码</strong></p>
<pre><code class="kotlin">/*    使用use函数作为资源管理    */
fun readFirstLineFromFile (path:String):String{
    BufferedReader(FileReader(path)).use{    // 构成 BufferedReader，调用 “use” 函数，传递一个lambda执行文件操作
        br -&gt; return br.readLine()    // 从函数中返回文件的一行
    }
}</code></pre>
<p>use 函数是一个扩展函数，被用来操作可关闭的资源，它接受一个lambda作为参数。这个返回调用lambda并且确保资源被关闭，无论lambda正常执行饭是抛出了异常。当然使用use函数是内联函数，所以使用它并不会引发任何性能开销。</p>
</blockquote>
<h2 id="8-3-高阶函数中的控制流"><a href="#8-3-高阶函数中的控制流" class="headerlink" title="8.3 高阶函数中的控制流"></a>8.3 高阶函数中的控制流</h2><p>把 return 语句放在循环的中间是很简单的事情，但是如果将循环转换成一个类似于 <strong>filter （filter 是内联函数）</strong> 的函数呢？这种情况下 return 会如何工作。</p>
<h3 id="8-3-1-lambda-中的返回语句：从一个封闭的函数返回"><a href="#8-3-1-lambda-中的返回语句：从一个封闭的函数返回" class="headerlink" title="8.3.1 lambda 中的返回语句：从一个封闭的函数返回"></a>8.3.1 lambda 中的返回语句：从一个封闭的函数返回</h3><p>比较两种不同的 遍历集合的返回： 在下面的代码清单中，如果一个人的名字是 “Alice” ，就应该从函数lookForAlice 返回。</p>
<pre><code class="kotlin">/*    在一个普通循环中使用return    */
data class Person(val neme:String, val age:Int)
val people = listOf(Person (&quot;Alice&quot;,29),Person(&quot;Bob&quot;,11))
fun lookForAlice(people:List&lt;Person&gt;){
    for (person in people){
        if (person.name == &quot;Alice&quot;){
            println(&quot;Found!&quot;)
            return
        }
    }
    println(&quot;Alice is not found&quot;)     //如果“people”中没用Alice，这一行就会被打印出来
}

&gt;&gt;&gt; lookForAlice(people)
Found!</code></pre>
<blockquote>
<p>使用 forEach迭代重写这段代码安全吗？</p>
<pre><code class="kotlin">/*    在传递给 forEach 的lambda 中使用 return    */
fun lookForAlice(people:List&lt;Person&gt;){
    people.forEach{
        if (it.name == &quot;Alice&quot;){
            println(&quot;Found!&quot;)
            return
        }
    }

    println(&quot;Alice is not found&quot;)    //和上一个代码清单中的效果是一样的
}</code></pre>
<p>这是安全的</p>
</blockquote>
<blockquote>
<p>当你在 lambda 中使用 return 关键字，它会从调用 lambda 的函数中返回，并不是从 lambda 中返回。这个叫做<strong>非局部返回</strong>。<strong>因为它从一个比包含 return 的代码块更大的代码块中返回了。</strong></p>
</blockquote>
<blockquote>
<p>为了理解这条规则背后的逻辑，从Java函数中在for循环或者synchronized 代码块中使用 return 关键字。显然这会从函数中返回，而不是从循环或者代码块中返回。使用以 lambda 作为参数的函数的时候 kotlin 保留了同样的行为。</p>
</blockquote>
<blockquote>
<p>需要注意的是，<strong><em>只有在以 lambda 作为参数的函数是内联函数的时候才能从跟外层的函数返回。</em></strong>在上述代码中，forEach 的函数体和lambda的函数体一起被内联了，所以在编译的时候能很容易做到从包含它的函数中返回。在 非内联函数的lambda 中使用 return 表达式是不允许的。一个非内联函数可以把传给它的lambda保存在变量中，以便在函数返回以后可以继续使用，这个时候lambda先去影响函数的返回已经太晚了。</p>
</blockquote>
<h3 id="8-3-2-从-lambda-返回：使用标签返回"><a href="#8-3-2-从-lambda-返回：使用标签返回" class="headerlink" title="8.3.2 从 lambda 返回：使用标签返回"></a>8.3.2 从 lambda 返回：使用标签返回</h3><p><strong>标签返回</strong></p>
<blockquote>
<p>可以在lambda表达式总使用<strong>局部返回</strong>。</p>
<p>lambda 中的局部返回跟 for 循环中的 break 表达式显示。它会终止 lambda 的执行，并接着从调用 lambda 的代码处执行。</p>
</blockquote>
<p><strong>区分 局部返回和非局部返回</strong></p>
<blockquote>
<p>要区分局部返回和非局部返回，要用到<strong>标签</strong>。</p>
<p><strong>如何区分。</strong></p>
<p>想从 lambda 表达式处返回你可以标记它，然后在 return 关键字后面引用这个标签。</p>
</blockquote>
<pre><code class="kotlin">/*    用一个标签实现局部返回    */
fun lookForAlice(people:List&lt;Person&gt;){
    people.forEach lable@{    // ←给lambda表达式加上标签
        if (it.name == &quot;Alice&quot;) return@label    //← return@label 引用了这个标签
    }
    println(&quot;Alice might be somewhere&quot;)    //这里总被打印
}

&gt;&gt;&gt; lookForAlice(people)
Alice might be somewhere!</code></pre>
<blockquote>
<p><strong>如何使用标签</strong></p>
<p>要标记一个lambda表达式，在 lambda 的花括号之前放一个标签名，接着放一个 @ 符号。（标签名可以是任意的）、</p>
<p>要从一个lambda返回，在return关键词后放一个@符号，接着放标签名。</p>
<pre><code class="kotlin">// “label@” lambda标签
people.forEach label@{
    if (it.name == &quot;Alice&quot;) return@label //返回表达式标签
}
/*    用 “@” 符号标记一个标签从一个lambda返回    */</code></pre>
</blockquote>
<blockquote>
<p><strong>另一种方式，使用 lambda 作为参数的函数的函数名可以作为标签</strong></p>
<pre><code class="kotlin">/*    用函数名 return 标签    */
fun lookForAlice(people:List&lt;Person&gt;) {
    people.forEach{
        if(it.name == &quot;Alice&quot;)    return@forEach    // ←return@forEach从 lambda 表达式返回
    }
    println(&quot;Alice might be somewhere&quot;)
}</code></pre>
<p>当里显式的<strong>指定了 lambda 表达式的标签</strong>，再使用函数名作为标签没有任何效果。</p>
<p>一个 lambda 表达式的标签数量不能多于一个。</p>
</blockquote>
<blockquote>
<p><strong>带标签的 “this” 表达式</strong></p>
<p>同样的规则也适用于this表达式。在带接收者的lambda中–包含一个隐式上下文对象的lamdba也有通过一个this去访问。</p>
<p>如果你给带接收者 lambda 指定标签，就可以通过对应的带有标签的this表达式访问它的隐式接收者。</p>
<pre><code class="kotlin">&gt;&gt;&gt; println(StringBuilder().apply sb@{    // 这个 lambda 隐式接收者可以通过 this@sb 访问
...        listOf(1,2,3).apply{    // ”this”指定作用域内最近的隐式接收者
...            this@sb.append(this.toString())    // 所以隐式接收者都可以被访问，外层的接收者通过显式的标签访问
...        }
...    }) 
    [1,2,3]</code></pre>
<p>局部返回的语法相当冗长，如果一个 lambda 包含多个返回语句会变得更加笨重。所以这里可以使用 <strong>匿名函数。</strong></p>
</blockquote>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h3 id="字段和属性"><a href="#字段和属性" class="headerlink" title="字段和属性"></a>字段和属性</h3><p><a href="https://blog.csdn.net/chenchunlin526/article/details/71424844" target="_blank" rel="noopener">深入理解Java中的字段与属性的区别</a></p>
<h4 id="属性和字段的区别"><a href="#属性和字段的区别" class="headerlink" title="属性和字段的区别"></a>属性和字段的区别</h4><p>属性（property），通常可以理解为get 和 set 方法。</p>
<p>字段（field），通常叫做 <strong>类成员</strong>，或者 <strong>类变量</strong> ，有时也叫 域 ，理解为 数据成员，用来承担数据的。</p>
<h4 id="属性和字段详解"><a href="#属性和字段详解" class="headerlink" title="属性和字段详解"></a>属性和字段详解</h4><p><strong>字段（field）</strong></p>
<p>类成员（字段field），通常在类中定义成员变量例如：</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200909213136.png" alt=""></p>
<p>解释为：<strong>FacebookUser类拥有成员变量nickname，有一个字段 nickname。</strong></p>
<p>字段一般用于承担数据，所以为了数据的安全性，一般设置为私有的。</p>
<p>字段和常量描述的类的数据（域），当这些数据的某些部分不运行外界访问时，<strong>根据”对象封装“原则，应该尽量避免将类的字段以公有方式提供给外部</strong>。除啦final修饰的常量。</p>
<p><strong>属性（property）</strong></p>
<p><strong>属性只局限于类中方法的声明，并不与类中其它成员相关</strong>，数据JavaBean范畴：</p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200909220317.png" alt=""></p>
<p>这是一个属性，一个字段。</p>
<p>总结：属性是对字段的封装，供外部访问。通常<strong>属性</strong>将对应的<strong>私有字段</strong>通过封装成公共属性，以便于外界访问和修改。</p>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>是指可以被求值的代码。</p>
<p>例如</p>
<pre><code class="c">int result = add(x + 1,y)</code></pre>
<blockquote>
<p>x + 1 作为表达式传递了数值</p>
</blockquote>
<pre><code class="c">int result = add（if(x==1),y）</code></pre>
<blockquote>
<p>这段语句在 c 中是没有办法作为表达式的。</p>
</blockquote>
<h3 id="Kotlin-this表达式"><a href="#Kotlin-this表达式" class="headerlink" title="Kotlin this表达式"></a>Kotlin this表达式</h3><p>为了表示当前的 <strong>接收者</strong> 使用 this{:.keyword} 表达式：</p>
<ul>
<li>在类的成员中，this{:.keyword}指的是当前对象</li>
<li>在扩展函数或者带接受者的函数字面值中，this{:.keyword}表示在点左侧的接收者参数。</li>
</ul>
<h3 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h3><p>函数引用 是kotlin引入的一个功能。使用(::)表示对函数的引用</p>
<p>代码</p>
<pre><code class="kotlin">val sum:(Int,Int) -&gt; Int = {x,y -&gt; x +y}</code></pre>
<blockquote>
<p>sum 是一个函数类型的变量，lambda表达式执行了相加的操作。</p>
</blockquote>
<pre><code class="kotlin">fun applyOp(x: Int, y: Int, op: (Int, Int) -&gt; Int): Int = op(x, y)</code></pre>
<p>applyOp 是一个接受三个参数的函数，第三个参数是lambda类型。可以用下面的返回调用这个函数：</p>
<pre><code class="kotlin">applyOp(2,3,sum)</code></pre>
<p>即高阶函数可以作为一个类型赋值给变量，也可以作为另一个函数的参数。</p>
<h4 id="函数引用：函数可以是一个-lambda"><a href="#函数引用：函数可以是一个-lambda" class="headerlink" title="函数引用：函数可以是一个 lambda"></a>函数引用：函数可以是一个 lambda</h4><p>上述的lambda表达式，可以用纯函数的形式：</p>
<pre><code class="kotlin">fun sum(x: Int, y: Int) = x + y</code></pre>
<p>实现效果是一样的，区别在于不再需要使用变量来保持对函数的引用，但是这样需要对applOp函数要做一些修改，原来的</p>
<p><strong>applOp(2,3,sum)</strong>写法会报类型不匹配的语法错误。需要修改为使用<strong>函数引用</strong>代码如下：</p>
<pre><code class="kotlin">applOp(2,3,::sum)</code></pre>
<p>这些算是 函数引用 的大致概念。同时<strong>函数引用</strong>也是可以赋值给变量的。</p>
<pre><code class="kotlin">val sumLambda: (Int, Int) -&gt; Int = ::sum
applyOp(2, 3, sumLambda)</code></pre>
<h3 id="lamnda-表达式-与-匿名内部类的区别"><a href="#lamnda-表达式-与-匿名内部类的区别" class="headerlink" title="lamnda 表达式 与 匿名内部类的区别"></a>lamnda 表达式 与 匿名内部类的区别</h3><blockquote>
<ul>
<li>lambda 表达式只能为函数式接口创建实例；匿名内部类可以为任意接口创建实例 – 不管接口包含多少抽象方法，只要匿名内部类是实现所有的抽象方法即可。</li>
<li>lambda 表达式只能为函数式接口创建实例；匿名内部类可以为抽象类甚至普通话类创建实例；</li>
<li>lambda 表达式的代码不允许调用接口中定义的默认方法；匿名内部类实现的抽象方法的方法体允许调用接口中定义的默认方法。</li>
</ul>
</blockquote>
<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p><strong>引用：</strong></p>
<p><a href="https://www.web3.xin/code/2606.html" target="_blank" rel="noopener">Kotlin this表达式</a></p>
<p><a href="https://www.jianshu.com/p/10358883455c" target="_blank" rel="noopener">kotlin中的函数引用详解</a>    </p>
<p><a href="http://c.biancheng.net/view/6559.html" target="_blank" rel="noopener">Lambda表达式与匿名内部类的联系和区别</a></p>
<p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-8-3-1.gif" alt="如果有些方法没有详细说明你可以自行搜索查看"></p>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://thecara.github.io" rel="external nofollow noreferrer">TheCara</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://thecara.github.io/2020/07/26/kotlin-in-Action-Kotlin%E5%AE%9E%E6%88%98/">https://thecara.github.io/2020/07/26/kotlin-in-Action-Kotlin%E5%AE%9E%E6%88%98/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by-nc/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY-NC 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://thecara.github.io" target="_blank">TheCara</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Android/">
                                    <span class="chip bg-color">Android</span>
                                </a>
                            
                                <a href="/tags/Kotlin/">
                                    <span class="chip bg-color">Kotlin</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/07/26/choco%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%89%E8%A3%85/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/21.jpg" class="responsive-img" alt="Chocolatey的配置与应用的安装">
                        
                        <span class="card-title">Chocolatey的配置与应用的安装</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            使用 Chocolatey安装7zip全程使用科学上网
choco install 7zip如何安装Chocolatey在桌面下载
使用管理员打开cmd访问到下载的目录中
输入👇.安装的同时要使用科学上网
@powershell -NoP
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-07-26
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Chocolatey/" class="post-category">
                                    Chocolatey
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Chocolatey/">
                        <span class="chip bg-color">Chocolatey</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/07/26/RecyclerView%E5%9C%A8Kotlin%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/">
                    <div class="card-image">
                        
                        <img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-05-31_13-09-29.png" class="responsive-img" alt="RecyclerView在Kotlin中的使用">
                        
                        <span class="card-title">RecyclerView在Kotlin中的使用</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            创建项目RecyclerExample项目需要引入依赖
需要子项布局在 “RecyclerViewExample\app\src\main\res\layout”下创建 “example_item.xml” 👇
&lt;?xml vers
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-07-26
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Android/" class="post-category">
                                    Android
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Android/">
                        <span class="chip bg-color">Android</span>
                    </a>
                    
                    <a href="/tags/Kotlin/">
                        <span class="chip bg-color">Kotlin</span>
                    </a>
                    
                    <a href="/tags/RecyclerView/">
                        <span class="chip bg-color">RecyclerView</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('h1'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="/about" target="_blank">TheCara</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/TheCara" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:qyx2013@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1099178659" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1099178659" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
