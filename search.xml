<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Kotlin 协程</title>
      <link href="/2020/10/14/Kotlin-%E5%8D%8F%E7%A8%8B/"/>
      <url>/2020/10/14/Kotlin-%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h1><blockquote><p><strong>用同步的方式写异步的代码</strong></p></blockquote><p>【协程 Coroutines】 源于Simula 和 Modula-2语言，术语来自于 1958 年的 <strong>Melvin Edward Conway</strong> 发明并且拥有构建汇编程序，说明 <strong>协程是一种编程思想</strong>， 并不局限于特定的语言。</p><h5 id="线程和协程的关系"><a href="#线程和协程的关系" class="headerlink" title="线程和协程的关系"></a>线程和协程的关系</h5><p>从 Android 开发者的角度去理解它们的关系：</p><ul><li>Android中我们所有的代码都跑在线程中的，<strong>而线程是跑在进程中的</strong>。</li><li><strong>协程没有直接和操作系统关联</strong>，它也是<strong>跑在线程中的</strong>，可以是单线程，也可以是多线程。</li><li>单线程中的协程总的<strong>执行时间</strong>并不会比不用协程少。</li><li>Android总，如果在主线程中进行网络访问，会抛出 <strong>NetworkOnMainThreadException</strong>，对于在主线程上的协程也不例外，所以在这种使用场景中也是要切换线程的。</li></ul><h4 id="协程的应用场景之一-线程控制"><a href="#协程的应用场景之一-线程控制" class="headerlink" title="协程的应用场景之一 线程控制"></a>协程的应用场景之一 线程控制</h4><blockquote><p>协程可以让我们在写<strong>代码时不用更多的关注多线程同时更方便的写出并发操作</strong>。</p></blockquote><p><strong>场景</strong></p><p>在Java中实现并发操作通常需要开启 Thread：</p><pre><code class="java">new Thread(new Runnable() {    @Override    public void run() {        ...    }}).start();</code></pre><p>Kotlin中</p><pre><code class="kotlin">Thread({    ...}).start()</code></pre><p><strong>Kotlin和Java使用线程同样存在的问题：</strong></p><ul><li>线程什么时候执行结束</li><li>线程间如何相互通信</li><li>多线程的管理</li></ul><p>可以用Java控制线程 Executor线程池来进行<strong>线程管理</strong>：</p><pre><code class="kotlin">val executor = Executors.newCachedThreadPool()executor.execute({    ...})</code></pre><p>用Android的<strong>AsyncTask</strong>来<strong>解决线程之间的通讯</strong></p><pre><code class="kotlin">object : AsyncTask&lt;T0, T1, T2&gt; {     override fun doInBackground(vararg args: T0): String { ... }    override fun onProgressUpdate(vararg args: T1) { ... }    override fun onPostExecute(t3: T3) { ... }}</code></pre><p>使用<strong>AsyncTask</strong>进行<strong>线程之间</strong>的<strong>通讯</strong>带来的<strong>缺点</strong>（<strong>AsyncTask</strong>是<strong>Android</strong>对<strong>线程池</strong>Executor的<strong>封装</strong>）：</p><ul><li>需要处理多个回调，容易陷入【回调地狱】。</li><li>将业务强行拆分到前台、中间更新、后台三个函数。</li></ul><p>使用 RxJava和协程都可以很好的解决上述的问题。</p><h5 id="例子-使用协程进行网络访问将请求到的数据显示到对应的控件上："><a href="#例子-使用协程进行网络访问将请求到的数据显示到对应的控件上：" class="headerlink" title="例子 使用协程进行网络访问将请求到的数据显示到对应的控件上："></a>例子 使用协程进行网络访问将请求到的数据显示到对应的控件上：</h5><pre><code class="kotlin">launch({    val user = api.getUser() // 👈 网络请求（IO 线程）    nameTv.text = user.name  // 👈 更新 UI（主线程）})</code></pre><p>无需关心 <strong>launch</strong> 它<strong>不是</strong>一个<strong>顶层函数</strong>，只需要关系它的业务逻辑：</p><p>launch <strong>函数</strong>加上实现在 {} 中的<strong>具体逻辑构成</strong>了<strong>协程</strong>。</p><p>通常我们进行网络请求，会传一个callback，或者在IO线程里进行阻塞式的同步调用，而在这段代码中，上下两个语句分别工作在两个线程里，并且写法上和普通单线程代码是一样的。</p><p>这里的 api.getUser是一个挂起函数，所以能够保证nameTv.text的正确赋值，这就涉及到了协程中最著名的【非阻塞式挂起】了。</p><h1 id="协程好在哪里"><a href="#协程好在哪里" class="headerlink" title="协程好在哪里"></a>协程好在哪里</h1><h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><h4 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h4><p><strong>闭包</strong>并<strong>不</strong>是<strong>kotlin</strong>中提出的新概念，在Java8中就已经支持。</p><p>以Thread为例，看看什么是闭包：</p><pre><code class="kotlin">// 创建一个 Thread 的完整写法Thread(object : Runnable {    override fun run() {        ...    }})// 满足 SAM，先简化为Thread({    ...})// 使用闭包，再简化为Thread {    ...}</code></pre><p>语法糖：当函数的最后一个参数是lambda表达式时，可以将<strong>lambda</strong>写在<strong>括号外</strong>。这就是它的<strong>闭包原则</strong>。</p><h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><p>需要一个类型为 Runnable 的参数，而 Runnable 是一个接口，且只定义了一个函数 run，这种情况满足了 Kotlin 的SAM，可以转换成一个传递的 lambda表达式（第二段），以为闭包原则直接写成 Thread{…}（第三段）。</p><p>通过<strong>闭包简化 launch 函数</strong></p><pre><code class="kotlin">launch {    ...}</code></pre><h2 id="基本使用协程"><a href="#基本使用协程" class="headerlink" title="基本使用协程"></a>基本使用协程</h2><p>说过<strong>launch函数不是顶层函数</strong> 并不能直接使用，我们通过下列方法来创建协程：</p><pre><code class="kotlin">// 方法一，使用 runBlocking 顶层函数runBlocking {    getImage(imageId)}// 方法二，使用 GlobalScope 单例对象//            👇 可以直接调用 launch 开启协程GlobalScope.launch {    getImage(imageId)}// 方法三，自行通过 CoroutineContext 创建一个 CoroutineScope 对象//                                    👇 需要一个类型为 CoroutineContext 的参数val coroutineScope = CoroutineScope(context)coroutineScope.launch {    getImage(imageId)}</code></pre><p>方法①，多用于单元测试，业务开发不会用到它，因为它是线程阻塞的。</p><p>方法②，在Android中不推荐这种用法，因为它的生命周期会和app一直，且不能够取消。和使用runBlocking不同它不会阻塞线程。</p><p>方法三，<strong>推荐用法</strong>，通过context参数去管理和控制协程的生命周期（这里的context和Android里的不是同一种东西，更像是一种概念，会有Android平台的封装配合使用）</p><p>其中 <strong>GlobaScope</strong>与<strong>CoroutineScope</strong> 的更多内容后面的文章再说。</p><p>协程<strong>最常用</strong>的<strong>功能</strong>是<strong>并发</strong>，而并发最常用的场景是多线程。可以使用<strong>Dispatchers</strong>.<strong>IO</strong>参数把<strong>任务切换到IO线程执行</strong>：</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.IO) {    ...}</code></pre><p>使用 <strong>DIspatchers.Main</strong> 参数切换到主线程：</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.Main) {    ...}</code></pre><p>所以【什么是协程】中说到的异步请求的完整例子是这样的：</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.Main) {   // 在主线程开启协程    val user = api.getUser() // IO 线程执行网络请求    nameTv.text = user.name  // 主线程更新 UI}</code></pre><p>在Java中回调式的写法是这样的：</p><pre><code class="kotlin">api.getUser(new Callback&lt;User&gt;() {    @Override    public void success(User user) {        runOnUiThread(new Runnable() {            @Override            public void run() {                nameTv.setText(user.name);            }        })    }    @Override    public void failure(Exception e) {        ...    }});</code></pre><h2 id="更为麻烦的并发场景"><a href="#更为麻烦的并发场景" class="headerlink" title="更为麻烦的并发场景"></a>更为麻烦的并发场景</h2><p>对于回调式的写法，如果并发场景再复杂一点，嵌套的可能够多。如果使用协程，多层网络请求。</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.Main) {       // 开始协程：主线程    val token = api.getToken()                  // 网络请求：IO 线程    val user = api.getUser(token)               // 网络请求：IO 线程    nameTv.text = user.name                     // 更新 UI：主线程}</code></pre><p>如果进行多个<strong>网络请求</strong>等待完成后<strong>再刷新UI</strong>。</p><pre><code class="kotlin">api.getAvatar(user, callback)api.getCompanyLogo(user, callback)</code></pre><p>如果使用回调式写法，我们可能会选择妥协，则使用先后请求代替同时请求。</p><pre><code class="kotlin">api.getAvatar(user) { avatar -&gt;    api.getCompanyLogo(user) { logo -&gt;        show(merge(avatar, logo))    }}</code></pre><p>使用窗帘方式去实现可能会导致等待时长了一倍，也相差了一倍的性能。</p><h5 id="协程并行请求网络"><a href="#协程并行请求网络" class="headerlink" title="协程并行请求网络"></a>协程并行请求网络</h5><p>使用协程可以直接并行请求上下两行，最后把结果合并即可：</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.Main) {    //            👇  async 函数之后再讲    val avatar = async { api.getAvatar(user) }    // 获取用户头像    val logo = async { api.getCompanyLogo(user) } // 获取用户所在公司的 logo    val merged = suspendingMerge(avatar, logo)    // 合并结果    //                  👆    show(merged) // 更新 UI}</code></pre><p>即便是比较复杂的并行网络请求，也可以使用并行写出结构清晰的代码。<strong>suspendingMerge</strong> 并不是协程API提供的方法，而是自定义挂起的结果合并方法。</p><h5 id="协程的优势"><a href="#协程的优势" class="headerlink" title="协程的优势"></a>协程的优势</h5><p>让复杂的并发代码，变得简单且清晰是协程的优势。</p><p><strong>引用：</strong></p><p><a href="https://kaixue.io/kotlin-coroutines-1/" target="_blank" rel="noopener">Kotlin 的协程用力瞥一眼 - 学不会协程？很可能因为你看过的教程都是错的</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lifecycle 讲解</title>
      <link href="/2020/10/11/Lifecycle/"/>
      <url>/2020/10/11/Lifecycle/</url>
      
        <content type="html"><![CDATA[<h1 id="Lifecycle使用详解"><a href="#Lifecycle使用详解" class="headerlink" title="Lifecycle使用详解"></a>Lifecycle使用详解</h1><h2 id="Lifecycle可以做什么"><a href="#Lifecycle可以做什么" class="headerlink" title="Lifecycle可以做什么"></a>Lifecycle可以做什么</h2><p><strong>Lifecycle 是具有生命周期感知能力的组件，也就是说，在Activity或者Fragment的生命周期发生变动的是否得到通知</strong>。我们往往会在Activity的各种生命周期方法里执行特定的方法。</p><pre><code class="java">public class TestActivity extends AppCompatActivity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_test);    }    @Override    protected void onStart() {        super.onStart();        EventBus.getDefault().register(this);    }    @Override    protected void onDestroy() {        EventBus.getDefault().unregister(this);        super.onDestroy();    }}</code></pre><p>如果我们把很多这种需要跟生命周期相关的逻辑代码直接放在Activity的生命周期方法中，Activity会变的很难以维护的。通过使用Lifecycle，来避免这种情况。</p><h2 id="Lifecycle使用"><a href="#Lifecycle使用" class="headerlink" title="Lifecycle使用"></a>Lifecycle使用</h2><p>导入Lifecycle依赖</p><p>AndroidX:</p><pre><code class="groovy">implementation &quot;androidx.lifecycle:lifecycle-runtime:2.0.0&quot;</code></pre><h3 id="Lifecycler-实现机制"><a href="#Lifecycler-实现机制" class="headerlink" title="Lifecycler 实现机制"></a>Lifecycler 实现机制</h3><ol><li><strong>需要一个构建Lifecycle对象</strong>（通过一个实现了LifecycleOwner接口的对象 getLifecycle() 方法返回），这个对象就是一个被观察者，具有生命感知能力。</li><li><strong>构建一个LifecycleObserver对象，</strong>对指定的Lifecycle对象进行监听（<strong>观察者</strong>）</li><li>通过将Lifecyc对象的addObserver()方法，将Lifecycle对象和LifecycleObserver对象进行绑定。</li></ol><h3 id="继承AppCompatActivity"><a href="#继承AppCompatActivity" class="headerlink" title="继承AppCompatActivity"></a>继承AppCompatActivity</h3><p>创建 MyObserver.java 让它实现LifeyclerObserver 接口（<strong>LifecycleObserver接口是一个空接口，主要给注解处理器使用</strong>):</p><pre><code class="kotlin">/** *   by:Thecara home *   date:2020/10/11 */class MyObserver : LifecycleObserver {    // 使用注解 @OnLifecycleEvent() 该方法需要监听指定的生命周期事件    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)    fun connectListener() {        Log.d(&quot;MyObserver&quot;, &quot;ON_RESUME&quot;)    }    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)    fun disconnectListener() {        Log.d(&quot;MyObserver&quot;, &quot;ON_PAUSE&quot;)    }}</code></pre><p>可以看到，通过在方法上使用 <strong>@onLifecycleEvent</strong> 注解使得方法具有生命感知能力。<strong>括号里的参数，表明需要监听的是什么生命周期事件。</strong>Lifecycle 主要<strong>通过Event和State者两个枚举类来追踪关联组件的生命周期状态</strong>。具体的Event和State之间的转换关系，可以参考如下：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1692ebbac5daa896" alt=""></p><p>让Activity继承自AppCompatActivity，然后再OnCreate()方法中通过 <strong>getLifecycle().addObserver(new MyObserver())</strong> 完成<strong>Lifecycle</strong>和<strong>LifecycleObser</strong>的绑定:</p><pre><code class="kotlin">class MainActivity : AppCompatActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        // 绑定        lifecycle.addObserver(MyObserver())    }}</code></pre><p>通过切换后台观察状态。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-10-11-0.gif" alt="切换"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-10-11-1.gif" alt="Log"></p><p>library 26.1.0 及之后的库中，<strong>AppCompatActivity的父类SupportActivity已经默认实现了LifecycleOwner接口，直接通过getLifecycle() 方法获得Lifecycle对象。</strong></p><p>之后通过 <strong>addObserver()</strong> 方法将Lifecycle 跟指定 LifecycleObserver 进行绑定。</p><p><strong>引用：</strong></p><p><a href="https://juejin.im/post/6844903784166998023" target="_blank" rel="noopener">Android生命周期组件Lifecycle使用详解</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Lifecycle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是BuildConfig</title>
      <link href="/2020/09/17/BuildConfig/"/>
      <url>/2020/09/17/BuildConfig/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-BuildConfig"><a href="#什么是-BuildConfig" class="headerlink" title="什么是 BuildConfig"></a>什么是 BuildConfig</h1><p><strong>在打包时自动生成的类。</strong>类似于R.class，生成后不能修改。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200917233605.png" alt="在项目中的位置"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Timber</title>
      <link href="/2020/09/17/Timber/"/>
      <url>/2020/09/17/Timber/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Timber"><a href="#使用-Timber" class="headerlink" title="使用 Timber"></a>使用 Timber</h1><ul><li>配置 timber</li></ul><pre><code class="groovy">implementation &#39;com.jakewharton.timber:timber:4.7.1&#39;</code></pre><ul><li><h5 id="准备Log输出的自定义格式"><a href="#准备Log输出的自定义格式" class="headerlink" title="准备Log输出的自定义格式"></a><strong>准备Log输出的自定义格式</strong></h5></li></ul><blockquote><p>可以直接在Application的onCreate()中调用<code>Timber.plant(new DebugTree())</code>实现Debug功能。但是功能有所欠缺，<strong>可以用来上传crash信息</strong>等。</p><p>ps：</p><p>Timber主要通过添加Tree实例来实现，添加Tree实例可以通过方法Timber.plant完成。</p><p>而使用DebugTree实现自动实例化</p></blockquote><ol><li>不会<strong>打印当前线程</strong></li><li>不会<strong>打印当前行号</strong></li></ol><p>自己创建一个继承类来实现这两个功能。</p><pre><code class="kotlin">class ThreadAwareDebugTree : Timber.DebugTree() {    //添加当前线程    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {        if (tag != null) {            val threadName = Thread.currentThread().name            tag != &quot;&lt;&quot; + threadName + &quot;&gt;&quot;        }        super.log(priority, tag, message, t)    }    // 添加行号    override fun createStackElementTag(element: StackTraceElement): String? {        return super.createStackElementTag(element) + &quot;Line(&quot; + element.lineNumber + &quot;)&quot;    }}</code></pre><p><strong>还有一个类在 release 版本时调用打印log信息</strong></p><blockquote><p>release 版本用来以一种跟踪日志的形式上报给 <strong>Bugly</strong>，它只会显示 w，e，wtf。</p></blockquote><pre><code class="kotlin">class ReleaseTree : ThreadAwareDebugTree() {    override fun isLoggable(tag: String?, priority: Int): Boolean {        return if (priority == Log.VERBOSE || priority == Log.DEBUG || priority == Log.INFO) {            false        } else true    }    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {        if (!isLoggable(tag, priority)) {            return        }        super.log(priority, tag, message, t)    }}</code></pre><ul><li>准备 Application</li></ul><pre><code class="kotlin">class TimberDemoApplication : Application() {    override fun onCreate() {        super.onCreate()        if (DEBUG)            Timber.plant(ThreadAwareDebugTree())    }}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200921111610.png" alt="添加Application"></p><ul><li>调用一个log</li></ul><pre><code class="kotlin">println(Timber.v(&quot;hello&quot;))</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200921112051.png" alt="通过自定义的类型输出了行号的信息"></p><h2 id="重写-Log-方法"><a href="#重写-Log-方法" class="headerlink" title="重写 Log 方法"></a>重写 Log 方法</h2><p><strong>参数</strong></p><blockquote><p>priority:Int 优先级</p><p>tag:String 打印时的标签</p><p>message:String 内容</p><p>t:Throwable 抛出的异常</p></blockquote><p>此方法可以用来根据发送来的 <strong>异常等信息</strong> 自定义接下来的动作。这些信息并不会被从log日志打印出来。</p><p><strong>调用</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201009123005.png" alt="调用log方法"></p><pre><code class="kotlin"> Timber.log(1, &quot;测试打印&quot;)</code></pre><h4 id="打印我们发送来的信息"><a href="#打印我们发送来的信息" class="headerlink" title="打印我们发送来的信息"></a>打印我们发送来的信息</h4><pre><code class="kotlin">class MyTimberFree : Timber.Tree() {    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {        super.log(priority, tag, message, t)        Timber.v(message)    }}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201009123216.png" alt="发送成功，我们可以根据这些信息上传到crash中。"></p><h1 id="为什么使用Timber"><a href="#为什么使用Timber" class="headerlink" title="为什么使用Timber"></a>为什么使用Timber</h1><ol><li><p>项目开发时，为了方便调试，需要输出log，但是发布后，log中包含很多项目信息，如果全部暴露可能会造成安全隐患，当完全删除也不利于后期调试，因此需要一个开关，关闭开关不能输出bug，打开开关则可以输出log。</p></li><li><p>每次需要打印 TAG</p></li><li><p>不会打印当前线程</p></li><li><p>不会打印当前行号</p></li></ol><p><a href="https://xiazdong.github.io/2017/05/17/Timber/" target="_blank" rel="noopener">Timber和Bugly使用入门</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Timber </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用gradle</title>
      <link href="/2020/09/09/%E4%BD%BF%E7%94%A8gradle/"/>
      <url>/2020/09/09/%E4%BD%BF%E7%94%A8gradle/</url>
      
        <content type="html"><![CDATA[<h1 id="创建-Gradle-项目"><a href="#创建-Gradle-项目" class="headerlink" title="创建 Gradle 项目"></a>创建 Gradle 项目</h1><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-9-9-0.gif" alt=""></p><p>👆 联网状态打开 IDEA</p><h1 id="项目结构介绍"><a href="#项目结构介绍" class="headerlink" title="项目结构介绍"></a>项目结构介绍</h1><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910110408.png" alt=""></p><p><strong>src/main/java</strong> 正式代码目录</p><p><strong>src/main/resources</strong> 正式配置文件目录</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910111041.png" alt=""></p><p><strong>src/test/java</strong> 放置单元测试代码目录</p><p><strong>src/test/resources</strong> 放置单元测试配置文件目录</p><p><strong>src/main/webapp</strong> 还有一个可放置的 web 目录（页面信息）</p><h4 id="src-build-gradle-文件"><a href="#src-build-gradle-文件" class="headerlink" title="src/build.gradle 文件"></a>src/build.gradle 文件</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910162235.png" alt=""></p><p><strong>plugins{}</strong></p><blockquote><p>指运行环境</p></blockquote><p><strong>repositories{}</strong></p><blockquote><p>mavenContral() 为中央仓库，在没有指定情况的下会直接从中央仓库下载 jar 包。</p></blockquote><p><strong>dependenciese{}</strong></p><blockquote><p>gradle工程所有的jar包的坐标都在dependencies属性内放置。</p><p>同时每个jar包的坐标都有三个基本元素构成，group，name，version 组成</p></blockquote><p><strong>group</strong>：多分为多段，第一段为 域，第二段公司名称。其中 org 为非盈利组织，con 为商业组织。例如：tomat：为 apache项目 groupid为org.apache。</p><p><strong>name</strong>：项目的全名称。</p><p><strong>version</strong>：版本号。</p><p><strong>testCompile</strong>：测试时所依赖的jar包，在dradle可由 implementation 代替。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910165023.png" alt=""></p><p>创建项目有提到 👆</p><h4 id="项目-build-gradle-文件"><a href="#项目-build-gradle-文件" class="headerlink" title="项目/build.gradle 文件"></a>项目/build.gradle 文件</h4><p><strong>buildscript{} 属性</strong></p><blockquote><p>gradle执行所需要的依赖，分别对应maven库和插件</p></blockquote><h1 id="通过-mevenCentral-引入-jar-包"><a href="#通过-mevenCentral-引入-jar-包" class="headerlink" title="通过 mevenCentral 引入 jar 包"></a>通过 <strong>mevenCentral</strong> 引入 jar 包</h1><p>使用 compile 添加 jar 包</p><blockquote><p>用来解析所需要的依赖在classpath中可用，并且将它们打包。</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-9-10-1.gif" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910180423.png" alt=""></p><p>依赖完成</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910182006.png" alt=""></p><p>在 用户的 user/用户名/.gradle/caches/modules-2/files-2.1 下有我们加载的 jar 包</p><h1 id="demo-引入一个spring包-并测试使用"><a href="#demo-引入一个spring包-并测试使用" class="headerlink" title="demo 引入一个spring包 并测试使用"></a>demo 引入一个spring包 并测试使用</h1><h3 id="在-mavenRepository-中引入jar-包"><a href="#在-mavenRepository-中引入jar-包" class="headerlink" title="在 mavenRepository 中引入jar 包"></a>在 mavenRepository 中引入jar 包</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200911162643.png" alt=""></p><pre><code class="groovy">// https://mvnrepository.com/artifact/org.springframework/spring-contextcompile group: &#39;org.springframework&#39;, name: &#39;spring-context&#39;, version: &#39;5.2.8.RELEASE&#39;</code></pre><h3 id="引入后的依赖包位置查看"><a href="#引入后的依赖包位置查看" class="headerlink" title="引入后的依赖包位置查看"></a>引入后的依赖包位置查看</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200911162549.png" alt=""></p><h3 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h3><p><strong>创建 接口 ”AccountDao“</strong></p><p>位置 ”com.gradlelearn.dao“</p><pre><code class="java">public interface AccountDao {    public List findAll();}</code></pre><p>作为接口，查询方法</p><p><strong>创建 ”AccountDaoImpl“</strong></p><p>位置 ”com.gradlelearn.dao.impl“</p><pre><code class="java">public class AccountDaoImpl implements AccountDao {    @Override    public List findAll() {        System.out.println(&quot;test&quot;);        return null;    }}</code></pre><p>实现查询功能</p><h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><p><strong>创建 ”AccountTest“</strong></p><p>位置 test 文件下 ”com.gradle.test“</p><p><strong>ClassPathXmlApplicationContext</strong> 类型</p><blockquote><p>获得当前 bean 容器</p><p>创建对象 ApplicationContext 类型</p></blockquote><p><strong>applicationContext.getBean</strong> 方法</p><blockquote><p>从容器中获得当前 Dao</p></blockquote><pre><code class="java">public class AccountTest {    @Test    public void acccountTest() {        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);        AccountDao bean = applicationContext.getBean(AccountDao.class);        bean.findAll();    }}</code></pre><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200911164758.png" alt=""></p><h3 id="打包-jar-包"><a href="#打包-jar-包" class="headerlink" title="打包 jar 包"></a>打包 jar 包</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-9-11-0.gif" alt=""></p><p><strong>jar 包的位置</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200911165345.png" alt=""></p><h1 id="创建-web-工程-demo"><a href="#创建-web-工程-demo" class="headerlink" title="创建 web 工程 demo"></a>创建 web 工程 demo</h1><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h5 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h5><p>使用 ext 扩展块可以一次添加多个属性。</p><p>声明多个属性。添加了键值对的属性集合。</p><pre><code class="groovy">ext.versions = [minSdk:21,targetSdk:29]</code></pre><h5 id="apply-plugin"><a href="#apply-plugin" class="headerlink" title="apply plugin"></a>apply plugin</h5><p>此方式用来引入 <strong>Gradle 官方插件库</strong>。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915181918.png" alt=""></p><h5 id="apply-from"><a href="#apply-from" class="headerlink" title="apply from"></a>apply from</h5><p>引用本地资源</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915182720.png" alt=""></p><h2 id="android"><a href="#android" class="headerlink" title="android"></a>android</h2><p>这个闭包主要为了配置项目结构的各种属性。</p><h5 id="compileSdkVersion"><a href="#compileSdkVersion" class="headerlink" title="compileSdkVersion"></a>compileSdkVersion</h5><p>设置编译时用的Android版本</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915183321.png" alt=""></p><h2 id="defaultConfig-闭包"><a href="#defaultConfig-闭包" class="headerlink" title="defaultConfig 闭包"></a>defaultConfig 闭包</h2><p>默认闭包</p><h5 id="applicationId"><a href="#applicationId" class="headerlink" title="applicationId"></a>applicationId</h5><p>项目的包名</p><h5 id="minSdkVersion"><a href="#minSdkVersion" class="headerlink" title="minSdkVersion"></a>minSdkVersion</h5><p>最低兼容版本</p><h5 id="targetSdkVersion"><a href="#targetSdkVersion" class="headerlink" title="targetSdkVersion"></a>targetSdkVersion</h5><p>目标兼容版本</p><h5 id="versionCode"><a href="#versionCode" class="headerlink" title="versionCode"></a>versionCode</h5><p>项目版本号</p><h5 id="versionName"><a href="#versionName" class="headerlink" title="versionName"></a>versionName</h5><p>版本名称</p><h5 id="testInstrumentationRunner"><a href="#testInstrumentationRunner" class="headerlink" title="testInstrumentationRunner"></a>testInstrumentationRunner</h5><p>用来进行 AndroidJUnitRunner 进行单元测试</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915183913.png" alt="detailtConfig闭包"></p><h2 id="buildTypes-闭包"><a href="#buildTypes-闭包" class="headerlink" title="buildTypes 闭包"></a>buildTypes 闭包</h2><p>生成安装文件的主要配置，多数为两个子闭包，    一个debug闭包，<strong>用于指定生成测试版安装文件的配置</strong>，可忽略。一个release闭包，<strong>用于指定生成正式版的配置</strong>。两者配置参数大多一致，区别为<strong>默认属性配置不一样</strong>。</p><h5 id="minifyEnabled"><a href="#minifyEnabled" class="headerlink" title="minifyEnabled"></a>minifyEnabled</h5><p>是否对代码进行混淆</p><h5 id="proguardFiles"><a href="#proguardFiles" class="headerlink" title="proguardFiles"></a>proguardFiles</h5><p>指定混淆的规则文件</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915185118.png" alt=""></p><h2 id="dependencies闭包"><a href="#dependencies闭包" class="headerlink" title="dependencies闭包"></a>dependencies闭包</h2><p>定义了项目的依赖关系，三种依赖方式：<strong>本地依赖，库依赖，和远程依赖</strong>。</p><blockquote><p>自AndroidStudio3.0后 compile 引入库不再使用，而通过api和implementation，api完全等同于先前的 compile</p><p>，通过 api 引入 整个项目是可以使用当前的依赖库的。<strong>implementation 引入的库只有对应的 Module 使用</strong>。</p><p>在使用 compile时导致模块之间的耦合过高，不利于项目的拆解，<strong>通过 implementation做到降低耦合提高安全性</strong>。</p></blockquote><p>Module：指项目中创建的不同Module。</p><h5 id="implementation"><a href="#implementation" class="headerlink" title="implementation"></a>implementation</h5><p>远程依赖</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915190215.png" alt=""></p><h5 id="testImplementation-和-androidTestImplementation"><a href="#testImplementation-和-androidTestImplementation" class="headerlink" title="testImplementation 和 androidTestImplementation"></a>testImplementation 和 androidTestImplementation</h5><p>测试用依赖库</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915190143.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915190127.png" alt=""></p><h1 id="groovy-快速使用"><a href="#groovy-快速使用" class="headerlink" title="groovy 快速使用"></a>groovy 快速使用</h1><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-9-10-0.gif" alt=""></p><p>打开 idea 的 groovy 编辑器</p><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p><strong>groovy hellow word！</strong></p><pre><code class="groovy">println(&quot;hello world!&quot;);</code></pre><p>groovy 更类似于 java 语言。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910113424.png" alt=""></p><p><strong>groovy 可以省略末尾 “;”号</strong></p><pre><code class="groovy">println(&quot;hello world!&quot;)</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910112155.png" alt=""></p><p><strong>groovy 可以 省略括号</strong></p><pre><code class="groovy">println &quot;hello world!&quot;</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910120309.png" alt=""></p><p><strong>定义变量</strong></p><pre><code class="groovy">def x = 15println x</code></pre><p>def 修饰符是 <strong>弱类型</strong> 声明，groovy会自动根据情况来给变量赋予对应的类型。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910150342.png" alt=""></p><p><strong>定义集合</strong></p><pre><code class="groovy">def x = [&#39;x&#39;, &#39;f&#39;, &#39;c&#39;]x &lt;&lt; &#39;y&#39;println x</code></pre><p>定义集合：通过 “[]” 中括号声明</p><p>集合添加数据，”&lt;&lt;” 双小于号即可</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910151126.png" alt=""></p><p><strong>提取元素</strong></p><pre><code class="groovy">x.get(2)</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910151255.png" alt=""></p><p>提取元素下标为 2 的元素</p><h4 id="定义map"><a href="#定义map" class="headerlink" title="定义map"></a><strong>定义map</strong></h4><p><strong>声明map</strong></p><pre><code class="groovy">def m = [&#39;key1&#39;: &#39;value1&#39;]</code></pre><p>在初始化时必须要有初始化的值，用来对弱类型进行修改。</p><p><strong>添加键值对</strong></p><pre><code class="groovy">m.key2 = &quot;value2&quot;</code></pre><p>打印键值对</p><pre><code class="groovy">println m.get(&#39;key2&#39;)println m</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910152935.png" alt=""></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="groovy-中的闭包"><a href="#groovy-中的闭包" class="headerlink" title="groovy 中的闭包"></a>groovy 中的闭包</h3><p><strong>什么是闭包？</strong></p><p>groovy中的一个代码块。用于在<strong>gradle中把闭包当作参数使用</strong>。</p><p><strong>定义闭包和携带参数的闭包</strong></p><pre><code class="groovy">def b = {    println &quot;hello world!&quot;}</code></pre><pre><code class="groovy">def b = {   v-&gt; println &quot;hello world! $v&quot;}</code></pre><p>花括号 “{}” 即为闭包的样式。</p><p>v 表示一个变量，通过 “$v” 引用变量。</p><p><strong>闭包作为方法的参数，为闭包添加参数</strong></p><pre><code class="groovy">def method(Closure closure) {    closure()}</code></pre><pre><code class="groovy">def method(Closure closure) {    closure(&quot;arguments&quot;)}</code></pre><p>Closure：为闭包的类型，位于 “groovy.lang” 包下。</p><p>字符“arguments”作为参数传递给了闭包，<strong>在使用时将对应闭包添加到方法中即可</strong>。</p><p><strong>使用闭包</strong></p><pre><code class="groovy">method (b)</code></pre><p>method 为自己创建的方法。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910155625.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> gradle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> gradle </tag>
            
            <tag> groovy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJava2 Android 中使用</title>
      <link href="/2020/08/21/Android-RxJava/"/>
      <url>/2020/08/21/Android-RxJava/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是RxJava"><a href="#什么是RxJava" class="headerlink" title="什么是RxJava"></a>什么是RxJava</h2><p>实现异步操作的库</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><pre><code class="groovy">    implementation &quot;io.reactivex.rxjava2:rxjava:2.2.6&quot;    implementation &quot;io.reactivex.rxjava2:rxandroid:2.1.0&quot;</code></pre><h4 id="使用一次订阅并打印出来"><a href="#使用一次订阅并打印出来" class="headerlink" title="使用一次订阅并打印出来"></a>使用一次订阅并打印出来</h4><ul><li>需要 Observable.fromArray 方法</li></ul><blockquote><p>fromArray用来创建一个Observable（被观察者）对象，可以将一个数组转化为可被观察的序列并且将它的数据逐个发送。</p><p>返回值：Observable</p></blockquote><ul><li>需要 subscribe 方法</li></ul><blockquote><p>subscribe 只用于连接被观察者和观察者</p></blockquote><ul><li>需要 Consumber 类作为参数</li></ul><blockquote><p>当你只关心观察者的onNext方法时可以使用Consumer类</p></blockquote><ul><li>需要 Subscriber.onNext() 方法</li></ul><blockquote><p>被观察者执行Subscriber.onNext()方法时会在 观察者 订阅时复写该方法来进行发送数据</p></blockquote><p>启动它即可</p><pre><code class="kotlin">        Observable.fromArray(&quot;Ted&quot;, &quot;Ryan&quot;, &quot;Billy&quot;)            .subscribe { onNext -&gt; println(&quot;name: $onNext&quot;) </code></pre><p>观察者打印了字符</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200824012835.png" alt=""></p><p><a href="https://www.youtube.com/watch?v=v7drKJyxo10&list=PL8g0JDLEKun5cDCSkiLkZ1t4r0kE4j0sV" target="_blank" rel="noopener">Android Kotlin - RxJava Intro</a></p><h4 id="刷新一次界面控件"><a href="#刷新一次界面控件" class="headerlink" title="刷新一次界面控件"></a>刷新一次界面控件</h4><ul><li>需要 Obserbable.subscribeOn()</li></ul><blockquote><p>指定Observable（被观察者）自身在哪个调度器上执行</p></blockquote><ul><li>需要 Schedule() 线程控制器</li></ul><blockquote><p>作用：指定每一段代码在什么样的线程中执行</p></blockquote><ul><li>需要 filer() 过滤操作符号</li></ul><blockquote><p>作用：输出过滤条件后的结果项。</p></blockquote><ul><li>需要 Obserbable.observeOn() 方法</li></ul><blockquote><p>指定 Subscribe 所运行在的线程。或者事件消费的线程。</p><p>指定一个观察者在哪个调度器上观察这个Observable。</p><p><strong>observeOn()可以多次使用，可以随意变换线程</strong>。</p></blockquote><ul><li>使用 AndroidSchedulers.mainThread() 方法</li></ul><blockquote><p>切换至主线程</p></blockquote><pre><code class="kotlin">        Observable.fromArray(&quot;Ted&quot;, &quot;Ryan&quot;, &quot;Billy&quot;)            .subscribeOn(Schedulers.newThread())            .filter { item -&gt; item == &quot;Ted&quot; }            .observeOn(AndroidSchedulers.mainThread())            .subscribe { onNext -&gt; textView.text = onNext }</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200825112654.png" alt=""></p><h4 id="执行一次网络访问"><a href="#执行一次网络访问" class="headerlink" title="执行一次网络访问"></a>执行一次网络访问</h4><ul><li>使用 Observable.create() 方法</li></ul><blockquote><p>作用：创建一个被观察者。</p><p>可以通过泛型<String>指定发送数据的类型</p><p>参数：复写 ObservableOnSubscribe 类型，当被观察者被订阅时会执行 subscribe() 中的事件。</p></blockquote><ul><li>需要 onError() 方法</li></ul><blockquote><p>被观察者执行Subscriber.onError()方法时会在 观察者 订阅时复写该方法来进行发送数据</p><p>参数： 发送的泛型数据类型</p></blockquote><ul><li>需要 onComplate() 方法</li></ul><blockquote><p>被观察者执行Subscriber.onComplate()方法时会在 观察者 订阅时复写该方法来进行发送数据</p><p>参数： 发送的泛型数据类型</p></blockquote><p>创建 方法 getTextFromNetwork () </p><p>创建 Observable （被观察者）处理完成后发送事件，subscribeOn 让 subscribe 到一个新的线程中执行，observeOn 切换观察者的线程到主线程刷新UI，并不断接受被观察者发送来的事件。<strong>这是一个异步的操作。</strong></p><pre><code class="kotlin">    fun getTextFromNetwork() {        val task = Observable.create&lt;String&gt; { subscriber -&gt;            try {                subscriber.onNext(&quot;网络访问&quot;)            } catch (e: Exception) {                subscriber.onError(e)            }            subscriber.onComplete()        }        task.subscribeOn(Schedulers.newThread())        task.observeOn(AndroidSchedulers.mainThread())            .subscribe { onNext -&gt; textView.text = onNext }    }</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200825210344.png" alt=""></p><p>在调用 MainActivity </p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200825211048.png" alt=""></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="Observer-接口"><a href="#Observer-接口" class="headerlink" title="Observer 接口"></a>Observer 接口</h3><pre><code class="kotlin">        val observer = object: Observable&lt;String&gt;() {            //观察者接收事件前，默认最先调用复写 onSubscribe()            override fun subscribeActual(observer: Observer&lt;in String&gt;?) {                TODO(&quot;Not yet implemented&quot;)            }        }</code></pre><h3 id="Subscriber-接口"><a href="#Subscriber-接口" class="headerlink" title="Subscriber 接口"></a>Subscriber 接口</h3><p>Subscriber 接口对 Observer 接口进行了扩展</p><pre><code class="kotlin">        val subscribe= object : Subscriber&lt;String&gt;{            //被观察者调用 onSubscribe 时发送事件，观察者会调用此方法进行响应接受此事件            override fun onSubscribe(s: Subscription?) {                TODO(&quot;Not yet implemented&quot;)            }            //被观察者调用 onNext 时发送事件，观察者会调用此方法进行响应接受此事件            override fun onNext(t: String?) {                TODO(&quot;Not yet implemented&quot;)            }            //被观察者调用 onError 时发送事件，观察者会调用此方法进行响应接受此事件            override fun onError(t: Throwable?) {                TODO(&quot;Not yet implemented&quot;)            }            //被观察者调用 onComplete 时发送事件，观察者会调用此方法进行响应接受此事件            override fun onComplete() {                TODO(&quot;Not yet implemented&quot;)            }        }</code></pre><h3 id="Single与SingleObserver"><a href="#Single与SingleObserver" class="headerlink" title="Single与SingleObserver"></a>Single与SingleObserver</h3><p><strong>什么情况下使用 Single。</strong></p><p>如果你使用一个单一的连续事件流，既然只有一个onNext()事件，接着就触发onComplete或者onError，这样你使用Single。</p><p><strong>Single共包含那些</strong></p><p>一个正常处理成功的onSuccess，另一个处理失败的onError，当然它之发送一次信息，其中Single类似于Observable。</p><p><strong>被观察者</strong></p><pre><code class="kotlin">        val single: Single&lt;String&gt; = Single.create&lt;String&gt;(object : SingleOnSubscribe&lt;String&gt; {            override fun subscribe(emitter: SingleEmitter&lt;String&gt;) {                emitter.onSuccess(&quot;t&quot;)                emitter.onSuccess(&quot;c&quot;)                // 连续发送两次是不能成功的。            }        })</code></pre><p><strong>观察者</strong></p><pre><code class="kotlin">        single.subscribe(object : SingleObserver&lt;String&gt; {            // 在被观察者调用 onSubscribe 后，观察者回调到这里。            override fun onSubscribe(d: Disposable) {            }            // 在被观察者调用 onSuccess 后，观察者回调到这里。            override fun onSuccess(t: String) {                tv.text = t            }            // 在被观察者调用 onError 后，观察者回调到这里。            override fun onError(e: Throwable) {            }        })</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-10-10-0.gif" alt="并没有按照预期变成“c”"></p><p>所有 single只适合单次事件流。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>RxJava 是基于<strong>事件流的、实现异步操作的库</strong></p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>实现异步操作</p><h4 id="什么是同步"><a href="#什么是同步" class="headerlink" title="什么是同步"></a>什么是同步</h4><p>在执行功能前必须一件一件做完才能进行下一步。</p><h4 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h4><p>与同步是相对的，在我们执行完某个功能之后，我们并不需要立刻得到结果，我们可以正确的做其他的操作，这个功能可以在完成后通知或者回调告诉我们；</p><p>例如：后台下载的例子中，在执行下载功能后，我们无需关心它的下载过程，在它下载完毕之后通知我们就可以了。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p><a href="https://www.runoob.com/design-pattern/observer-pattern.html" target="_blank" rel="noopener">观察者模式</a></p><p>当对象间存在一对多的关系时，则使用观察者模式（Observer Patterm）。    例如：当前对象被修改时这会通知依赖它的对象。观察者模式属于行为型模式。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图</strong>:定义对象之间的一种对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并且被自动更新。</p><p><strong>主要解决</strong>:一个对象状态改变给其他对象通知的问题，而且要考虑到易用性和低耦合，保证高度的协作。</p><p><strong>何时使用</strong>:一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象)都将得到通知，进行广播通知。</p><p>如何解决当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。</p><p><strong>如何解决</strong>：使用面向对象技术，可以将这种关系弱化。</p><p><strong>关键代码</strong>：在抽象类中有一个ArrayList存放观察者。</p><p><strong>应用实例</strong>：</p><ol><li>拍卖时，拍卖师观察最高标价，然后通知其他竞价者竞价。</li><li>菩萨通过洒水招来老乌龟，老乌龟就是观察者，观察菩萨的洒水动作</li></ol><p><strong>优点</strong>：</p><ol><li>观察者和被观察者是抽象耦合的。</li><li>建立一套触发机制</li></ol><p><strong>缺点</strong>：</p><ol><li>如果一个被观察者对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li><li>如果观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅知道观察目标发送变化。</li></ol><p><strong>使用场景</strong>：</p><p>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装到独立的对象中使它们可以各自独立的改变和复用。</p><p>一个对象的改变将导致一个或多个对象也发生改变，而不知道有多少对象改变，可以降低对象之间的耦合度。</p><p>一个对象必须通知其他对象，而不知道这个对象时谁。</p><p>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……。可以使用观察者模式创建一种链式触发机制。</p><h3 id="谁是观察者谁是被观察者？"><a href="#谁是观察者谁是被观察者？" class="headerlink" title="谁是观察者谁是被观察者？"></a>谁是观察者谁是被观察者？</h3><p>当你做出了某些动作另一个人根据你的动作做出某些行为，这时你就是被观察者，另一个人是观察者。</p><h2 id="订阅-发布模式"><a href="#订阅-发布模式" class="headerlink" title="订阅-发布模式"></a>订阅-发布模式</h2><p>订阅-发布模式是观察者模式的另一个别称。</p><p>但是随着时间的变化，已经独立于观察者模式，成为另一种的设计模式。</p><p>在现在的发布订阅模式中，成为发布者的消息发送者不会将信息直接发送给订阅者，这意味这发布者和订阅者不知道彼此的存在。在发布者和订阅者之间存在第三个组件，称为调度中心或事件通道，它维持着发布者和订阅者之间的联系，过滤所有发布者传入的信息并相应的分发给它的订阅者。</p><p>例子：</p><p>你在微博关注了A，同时其他很多人也关注了A，那么当A发布动态的时候，微博就会为你推送这条动态。A就是发布者，你是订阅者，微博就是调度中心，你和A之间没有直接的消息往来，全是通过微博来协调的。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-8-3-1.gif" alt="如果有些方法没有详细说明你可以自行搜索查看"></p><p><strong>引用：</strong></p><p><a href="(https://www.cnblogs.com/onepixel/p/10806891.html)">观察者模式与订阅发布模式的区别</a></p><p><a href="https://maxwell-nc.github.io/android/rxjava2-1.html#Single%E5%92%8CSingleObserver" target="_blank" rel="noopener"><strong>RxJava 2.x 使用详解(一) 快速入门</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> RxJava </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>koin依赖注入框架</title>
      <link href="/2020/08/13/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-koin/"/>
      <url>/2020/08/13/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-koin/</url>
      
        <content type="html"><![CDATA[<h2 id="koin的使用"><a href="#koin的使用" class="headerlink" title="koin的使用"></a>koin的使用</h2><p><a href="https://www.youtube.com/watch?v=eH9UrAwKEcE&t=140s" target="_blank" rel="noopener">Dependency Injection with Koin - Android Kotlin tutorial</a></p><p><a href="https://github.com/AndyJennifer/koin_doc_zh" target="_blank" rel="noopener">koin 中文 DOC</a></p><h4 id="添加依赖库"><a href="#添加依赖库" class="headerlink" title="添加依赖库"></a>添加依赖库</h4><pre><code>    implementation &#39;org.koin:koin-androidx-viewmodel:2.0.1&#39;    implementation &#39;org.koin:koin-android:2.0.1&#39;</code></pre><h4 id="需要创建依赖对象"><a href="#需要创建依赖对象" class="headerlink" title="需要创建依赖对象"></a>需要创建依赖对象</h4><p>这里创建三个类，Student，SchoolCourse，Friend。</p><ul><li>Student类</li></ul><blockquote><p>依赖于SchoolCourse，Friend类的方法。</p></blockquote><pre><code class="kotlin">class Student(val course: SchoolCourse,val friend: Friend) {    fun beSmart() {        course.study()        friend.hangout()    }}</code></pre><ul><li>SchoolCourse类</li></ul><blockquote><p>提供方法 study 负责打印 “I am studying”</p></blockquote><pre><code>class SchoolCourse {    fun study() {        println(&quot;I am studying&quot;)    }}</code></pre><ul><li>Friend 类</li></ul><blockquote><p>提供方法 hangout 负责打印 “We’re hanging out”</p></blockquote><pre><code>class Friend {    fun hangout() {        println(&quot;We&#39;re hanging out&quot;)    }}</code></pre><h4 id="定义依赖集合"><a href="#定义依赖集合" class="headerlink" title="定义依赖集合"></a>定义依赖集合</h4><p>创建 Modeles 文件 </p><ul><li>需要使用 module 方法</li></ul><blockquote><p>提供所需要的依赖</p></blockquote><ul><li>需要 signle 方法</li></ul><blockquote><p>使当前依赖为一个单例的对象</p></blockquote><ul><li>需要 factory 方法</li></ul><blockquote><p>定义一个工场每次调用创建一个新的实例</p></blockquote><ul><li>需要 get() 方法</li></ul><blockquote><p>get 用于最终实现注入</p></blockquote><pre><code>val appModule: Module = module {    single { SchoolCourse() }    factory { Friend() }    factory { Student(get(), get()) }}</code></pre><h4 id="启动-Koin"><a href="#启动-Koin" class="headerlink" title="启动 Koin"></a>启动 Koin</h4><ul><li><p>需要系统在创建时第一个启动Application实例</p><blockquote><p>修改 application 中的 name 属性 使得应用第一个启动它</p></blockquote></li></ul><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200813224142.png" alt=""></p><ul><li>需要创建 MyApp</li></ul><blockquote><p>第一个启动的Application实例</p></blockquote><ul><li>需要 startKoin</li></ul><blockquote><p>用来启动Koin</p></blockquote><ul><li>需要 modules</li></ul><blockquote><p>注册声明的Module</p></blockquote><ul><li>需要 androidContext</li></ul><blockquote><p>向Koin中注入context</p></blockquote><pre><code>class MyApp : Application() {    override fun onCreate() {        super.onCreate()        startKoin {            androidContext(this@MyApp)            modules(listOf(appModule))        }    }}</code></pre><h4 id="使用-koin-实现注入"><a href="#使用-koin-实现注入" class="headerlink" title="使用 koin 实现注入"></a>使用 koin 实现注入</h4><p>在需要注入的地方使用</p><ul><li>需要使用 get()</li></ul><blockquote><p>非 懒加载，注入实例</p></blockquote><p>通过 注入依赖完成后的实例调用beSmart()方法</p><pre><code>        val student = get&lt;Student&gt;()        student.beSmart()        val student2 = get&lt;Student&gt;()        student2.beSmart()</code></pre><h4 id="完成注入"><a href="#完成注入" class="headerlink" title="完成注入"></a>完成注入</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/image-20200813233756977.png" alt=""></p><h4 id="什么是-koin？"><a href="#什么是-koin？" class="headerlink" title="什么是 koin？"></a>什么是 koin？</h4><p>一个轻量级的依赖注入组件。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><a href="https://zhuanlan.zhihu.com/p/188485918" target="_blank" rel="noopener">Koin in Android: 更简单的依赖注入</a></p><h4 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h4><p>get()用于实现注入。</p><p>当你所属类型不确定时，可以指定类型。get<Type>()</p><h4 id="声明：绑定一个接口"><a href="#声明：绑定一个接口" class="headerlink" title="声明：绑定一个接口"></a>声明：绑定一个接口</h4><p>一个  single 或者 factory 声明将会使用其给定的 lambda 表达式类型。比如 single{T}，该声明所匹配的类型就是表达式所声明的类型 T 让我们以一个类及其实现的接口为例：</p><pre><code class="java">// Service interfaceinterface Service{    fun doSomething()}// Service Implementationclass ServiceImp() : Service {    fun doSomething() { ... }}</code></pre><p>在koin模块(module)，我们可以使用Kotiln下的 as 操作符。如下所示：</p><pre><code class="java">val myModule = module {    // 只匹配 Service 类型    single { ServiceImp() }    // 只匹配 Service 类型    single { ServiceImp() as Service }}</code></pre><p>你也可以使用推断类型表达式</p><pre><code class="java">val myModule = module {    // 只匹配 Service 类型    single { ServiceImp() }    // 只匹配 Service 类型    single&lt;Service&gt; { ServiceImp() }}</code></pre><p>第二种风格是首选的，在接下来的文档中，也会使用该方法。</p><h4 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h4><ul><li><p><code>bind()</code> - 为给定的对象声明添加要绑定的类型</p><p>Bind 是一个中辍函数，可以用于把一个Service关联到多个类。例如现在有两个接口：Tool，Flammable，Stove实现了这两个接口。显然如果只定义1个Service是不能同时注入Stove和这两个接口的。</p><p>这是就可以发挥Bind的作用了</p><pre><code>val myModule = module{    factory { Stove() } bind Tool::class bind Flammable::class // &lt;- here!    factory { Chef(get()) }}</code></pre><p>这么一来，下面的三个注入都是合法的，并都会得到一个 Stove 实例：</p><pre><code>val chef: Chef = get()val tool:Tool = get()val flammable:Flammable = get()</code></pre></li></ul><h4 id="named"><a href="#named" class="headerlink" title="named"></a>named</h4><p>限定符，用来区别同一个类的不同实例</p><p>使用</p><pre><code class="java"> single(named(&quot;dev&quot;)) { DataRepository() } single(named(&quot;test&quot;)) { DataRepository() }</code></pre><h4 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h4><p>可通过name或者class检索到对应的实例</p><p>使用</p><pre><code class="kotlin">    factory(name = MAIN) {        AndroidSchedulers.mainThread()    }</code></pre><h2 id="依赖注入和控制反转"><a href="#依赖注入和控制反转" class="headerlink" title="依赖注入和控制反转"></a>依赖注入和控制反转</h2><h3 id="依赖注入（Dependency-Injection，简称-DI）"><a href="#依赖注入（Dependency-Injection，简称-DI）" class="headerlink" title="依赖注入（Dependency  Injection，简称 DI）"></a>依赖注入（Dependency  Injection，简称 DI）</h3><p>什么是依赖注入？</p><p>假设 A 是 耳机，B 是播放器。</p><p>当 A 依赖 B 时（也就是耳机想要播放以音乐时），A 要想播放音乐就必须要有B的实例，也就是</p><ol><li>通过A的接口，把B传入；</li><li>通过A的构造，把B传入；</li><li>通过就该A的属性，把B传入；</li></ol><p>这些过程叫做<strong>依赖注入（DI）</strong></p><h3 id="控制反转（Inversion-of-Control，简称-Ioc）"><a href="#控制反转（Inversion-of-Control，简称-Ioc）" class="headerlink" title="控制反转（Inversion of Control，简称 Ioc）"></a>控制反转（Inversion of Control，简称 Ioc）</h3><p>但是 A 并不能控制 B 何时播放(创建)或者关闭(销毁)，仅使用 B ，那么 B 的控制权交给 A 之外的事务处理，这些叫做 <strong>控制反转（Ioc）</strong></p><h3 id="为什么需要依赖注入"><a href="#为什么需要依赖注入" class="headerlink" title="为什么需要依赖注入"></a>为什么需要依赖注入</h3><p>降低耦合</p><p>什么是耦合</p><p>耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。两个或多个功能模块之间的关联程度。</p><p>什么是解耦</p><p>解除类（模块）之间的直接关系，将直接关系转换成间接关系</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-8-3-1.gif" alt="如果有些方法没有详细说明你可以自行搜索查看"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> Kotlin </tag>
            
            <tag> koin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BottomSheet、BottomShaeetDialog使用流程</title>
      <link href="/2020/08/06/BottomSheets/"/>
      <url>/2020/08/06/BottomSheets/</url>
      
        <content type="html"><![CDATA[<h1 id="BottomSheet"><a href="#BottomSheet" class="headerlink" title="BottomSheet"></a>BottomSheet</h1><p>Demo 代码 <a href="https://medium.com/@droidbyme/android-bottom-sheet-7e9cfcec6427" target="_blank" rel="noopener">https://medium.com/@droidbyme/android-bottom-sheet-7e9cfcec6427</a><br>使用 BottomSheet、BottomSheetDialog、BottomSheetDialogFragment</p><h4 id="BottomSheet使用流程"><a href="#BottomSheet使用流程" class="headerlink" title="BottomSheet使用流程"></a>BottomSheet使用流程</h4><p>BottomSheet实现按钮在点击之后滑动布局.不联动也是可以的只要不设置它就可以了。</p><p><strong>被联动的布局使用</strong></p><pre><code>app:layout_behavior=&quot;@string/bottom_sheet_behavior&quot;</code></pre><p><strong>联动按钮使用属性</strong></p><pre><code>app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;</code></pre><p><img src="/img/Snipaste_2020-07-17_21-58-16.png" alt=""></p><p><strong>在初始化时被联动</strong></p><pre><code>          //  设置绑定动作        //  控件和它绑定        var buttomSheetBehavior = BottomSheetBehavior.from(bottom_sheet_layout)</code></pre><p><strong>设置按钮了</strong></p><p>也就是在现在监听按钮的时候才进行这个按钮的联动滑动</p><pre><code>     btnBottomSheet.setOnClickListener {            if (buttomSheetBehavior.getState() != BottomSheetBehavior.STATE_EXPANDED)                buttomSheetBehavior.state = BottomSheetBehavior.STATE_EXPANDED            else                buttomSheetBehavior.state = BottomSheetBehavior.STATE_COLLAPSED        }</code></pre><p>设置在显示时不显示,不显示时显示。</p><p>设置监听器在它被拖动、滑动、切换时产生提示。</p><pre><code>        buttomSheetBehavior.setBottomSheetCallback(object : BottomSheetCallback() {            //这里是拖拽中的回调，根据slideOffset可以做一些动画            override fun onSlide(bottomSheet: View, slideOffset: Float) {            }            //这里是bottomSheet状态的改变            override fun onStateChanged(bottomSheet: View, newState: Int) {                when (newState) {                    BottomSheetBehavior.STATE_EXPANDED -&gt; {                        Toast.makeText(this@MainActivity, &quot;展开&quot;, Toast.LENGTH_LONG).show()                    }                    BottomSheetBehavior.STATE_COLLAPSED -&gt; {                        Toast.makeText(this@MainActivity, &quot;关闭&quot;, Toast.LENGTH_LONG).show()                    }                    BottomSheetBehavior.STATE_DRAGGING -&gt; {                        Toast.makeText(this@MainActivity, &quot;拖拽状态&quot;, Toast.LENGTH_LONG).show()                    }                    BottomSheetBehavior.STATE_HIDDEN -&gt; {                        Toast.makeText(this@MainActivity, &quot;隐藏状态&quot;, Toast.LENGTH_LONG).show()                    }                    BottomSheetBehavior.STATE_SETTLING -&gt; {                        Toast.makeText(                            this@MainActivity,                            &quot; 拖拽松开之后到达终点位置（collapsed or expanded）前的状态&quot;,                            Toast.LENGTH_LONG                        ).show()                    }                }            }        })</code></pre><h4 id="BottomSheetDialog使用流程"><a href="#BottomSheetDialog使用流程" class="headerlink" title="BottomSheetDialog使用流程"></a>BottomSheetDialog使用流程</h4><p>点击按钮之后弹出Dialog提示(布局界面有且准备好的)</p><p><strong>设置按钮的监听器，点击之后直接弹出Dialog窗口。</strong></p><pre><code>  /*        * Java函数式接口        * 弹窗提示        * */        btnBottomSheetDialog.setOnClickListener {            //使用布局加载器layoutInflater            val view = layoutInflater.inflate(R.layout.fragment_bottom_sheet, null)            //实例话BottomSheetDialog():用来实现弹出提示功能            val dialog = BottomSheetDialog(this)            dialog.setContentView(view)            dialog.show()        }</code></pre><h4 id="BottomSheetDialogFragment在当前界面加载Dialog碎片"><a href="#BottomSheetDialogFragment在当前界面加载Dialog碎片" class="headerlink" title="BottomSheetDialogFragment在当前界面加载Dialog碎片"></a>BottomSheetDialogFragment在当前界面加载Dialog碎片</h4><pre><code>        /*        * 在当前界面加载碎片        * */        btnBottomSheetDialogFragment.setOnClickListener {            val bottomSHeetFragment = BottomSheetFragment()            bottomSHeetFragment.show(supportFragmentManager, bottomSHeetFragment.tag)        }</code></pre><p><strong>准备好要加载的碎片,它是要有bottom_sheet_dialog类型的界面</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MediaStore访问图片、视频</title>
      <link href="/2020/08/01/MediaStore%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/08/01/MediaStore%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="使用”MediaStore”访问图片、视频的缩略图"><a href="#使用”MediaStore”访问图片、视频的缩略图" class="headerlink" title="使用”MediaStore”访问图片、视频的缩略图"></a>使用”MediaStore”访问图片、视频的缩略图</h2><h3 id="需要动态申请权限"><a href="#需要动态申请权限" class="headerlink" title="需要动态申请权限"></a>需要动态申请权限</h3><p>需要配置文件中添加要 申请的权限 “AndroidManifest.xml”</p><pre><code class="xml">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</code></pre><h4 id="注册动态权限"><a href="#注册动态权限" class="headerlink" title="注册动态权限"></a>注册动态权限</h4><ul><li><p>需要自定义 “checkReadExternalStoragePermission()”方法</p></li><li><p>需要 “Build.VERSION.SDK_INT”方法获得当前系统的版本号</p></li><li><p>需要 “Build.VERSION_CODES.M”表示安卓6</p></li><li><p>需要 “ContextCompat.checkSelfPermission()”方法, 判断是否获得了权限.</p></li></ul><blockquote><p>参数1:上下文.参数2:要判断的权限. </p><p>返回值:PackageManager.<strong>PERMISSION_GRANTED</strong> <strong>表示授予权限</strong>,PackageManager.<strong>PERMISSION_DENIED</strong>  = -1    <strong>表示权限未开启</strong>；</p></blockquote><ul><li>需要 “shouldShowRequestPermissionRationale()”方法.</li></ul><blockquote><p>判断当前权限是否被拒绝,并且显示窗口,显示”运行”和”拒绝”选项.</p><p>第一次不显示”不再提醒”按钮,第二次窗口添加”不再显示选择框”。</p><p>返回值:拒绝返回 true ,允许返回 false 或者 不再提醒选中后 返回 false</p></blockquote><ul><li>需要 “requestPermission()”方法.</li></ul><blockquote><p>用来申请系统权限. <strong>每次被调用时都会回调”onRequestPermissionsResult()”方法。</strong></p><p>参数1:要申请的权限.</p><p>参数2:要申请权限的 code 以用来在申请方法回调时确定是当前的申请操作.</p></blockquote><p>在需要注册权限的活动上添加</p><pre><code>    private fun checkReadExternalStoragePermission() {        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {            if (ContextCompat.checkSelfPermission(                    this,                    permission.READ_EXTERNAL_STORAGE                ) == PackageManager.PERMISSION_GRANTED            ) {                   } else {                if (shouldShowRequestPermissionRationale(permission.READ_EXTERNAL_STORAGE)) {                    Toast.makeText(this, &quot;App needs to view thumbnails&quot;, Toast.LENGTH_LONG).show()                }                requestPermissions(                    arrayOf(permission.READ_EXTERNAL_STORAGE),                    READ_EXTERNAL_STORAGE_PERMISSION_RESULT                )            }        } else {        }    }</code></pre><pre><code>    private val READ_EXTERNAL_STORAGE_PERMISSION_RESULT: Int = 0</code></pre><ul><li>需要重写 “onRequestPermissionsResult()”方法</li></ul><blockquote><p>申请权限时会调用它(申请权限时的回调)</p><p>参数1:申请权限时的Code,表示申请权限的操作是否相同.</p><p>参数2:这是要申请的权限永远不为空.</p><p>参数3:表示权限授权的结果永远封装在grantResult数组中</p></blockquote><pre><code>override fun onRequestPermissionsResult(        requestCode: Int,        permissions: Array&lt;out String&gt;,        grantResults: IntArray    ) {        super.onRequestPermissionsResult(requestCode, permissions, grantResults)        when (requestCode) {            READ_EXTERNAL_STORAGE_PERMISSION_RESULT -&gt; {                if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {                    Toast.makeText(this, &quot;now have access to view thumbs&quot;, Toast.LENGTH_LONG).show()                }            }        }    }</code></pre><h3 id="需要RecyclerView的适配器"><a href="#需要RecyclerView的适配器" class="headerlink" title="需要RecyclerView的适配器"></a>需要RecyclerView的适配器</h3><p><a href="https://thecara.github.io/2020/07/26/RecyclerView%E5%9C%A8Kotlin%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/#toc-heading-7">使用此案例创建适配器</a></p><p>初始化控件不再复述了,</p><ul><li>需要变量”mMediaStoreCursor”</li></ul><blockquote><p>表示当前的Cursor</p></blockquote><pre><code>class MediaStoreAdapter(private val mActivity: Activity) :    RecyclerView.Adapter&lt;MediaStoreAdapter.ViewHolder&gt;() {    private var mMediaStoreCursor: Cursor? = null        }</code></pre><ul><li><strong>需要自定义”getBitmapFromMediaStore()”方法</strong></li></ul><blockquote><p>获得系统中图片和视频的缩略图.通过Cursor获得照片和Video的缩略图</p><p>参数1:移动到对应Cursor的行.</p></blockquote><ul><li>需要使用”Cursor.getColumnIndex()”方法</li></ul><blockquote><p>获得当前MediaStoreCursor的”参数1”的索引</p><p>参数1:要索引的位置</p><p>返回值: 返回在当前 Cursor 中的位置,没有返回 -1 </p></blockquote><ul><li>需要使用”Cursor.getInt()’方法</li></ul><blockquote><p>获得”Cursor”中索引(列)的数值.</p><p>参数1:你想要获得的列</p><p>返回值:返回指定列的数值</p></blockquote><ul><li>需要 “MediaStore.Images.Thumbnails.getThumbnail”方法</li></ul><blockquote><p>获得缩略图.</p><p>参数1:表示内容提供器. 参数2:当前”Cursor”缩略图的ID. </p><p>参数3:返回时的清晰度.MICRO_KIND,MINI_KIND字面意思为微型和迷你缩略模式,前者分辨率更低.</p><p>返回值:返回一个Bitmap格式</p></blockquote><p>在适配器中添加</p><pre><code>class MediaStoreAdapter(private val mActivity: Activity) :    RecyclerView.Adapter&lt;MediaStoreAdapter.ViewHolder&gt;() {              private fun getBitmapFromMediaStore(position: Int): Bitmap? {        val idIndex: Int = mMediaStoreCursor!!.getColumnIndex(MediaStore.Files.FileColumns._ID)        val mediaTypeIndex: Int =            mMediaStoreCursor!!.getColumnIndex(MediaStore.Files.FileColumns.MEDIA_TYPE)        mMediaStoreCursor!!.moveToPosition(position)        when (mMediaStoreCursor!!.getInt(mediaTypeIndex)) {            // 当前类型为 IMAGE 时            MediaStore.Files.FileColumns.MEDIA_TYPE_IMAGE -&gt; {                return MediaStore.Images.Thumbnails.getThumbnail(                    mActivity.contentResolver,                    mMediaStoreCursor!!.getLong(idIndex),                    MediaStore.Images.Thumbnails.MICRO_KIND, null                )            }            // 当前类型为 VIDEO            MediaStore.Files.FileColumns.MEDIA_TYPE_VIDEO -&gt; {                return MediaStore.Video.Thumbnails.getThumbnail(                    mActivity.contentResolver,                    mMediaStoreCursor!!.getLong(idIndex),                    MediaStore.Video.Thumbnails.MICRO_KIND, null                )            }        }        return null    }}</code></pre><ul><li><strong>需要自定义方法”swapCursor()”</strong></li></ul><blockquote><p>获得上一个Cursor.</p></blockquote><ul><li>需要 “notifyDataSetChanged()” 方法</li></ul><blockquote><p>检测当前UI线程,刷新UI</p></blockquote><pre><code>class MediaStoreAdapter(private val mActivity: Activity) :    RecyclerView.Adapter&lt;MediaStoreAdapter.ViewHolder&gt;() {   private fun swapCursor(cursor: Cursor): Cursor? {        if (mMediaStoreCursor == cursor) {            return null        }        val oldCursor: Cursor? = mMediaStoreCursor        this.mMediaStoreCursor = cursor        if (cursor != null) {            this.notifyDataSetChanged()        }        return oldCursor    }}</code></pre><ul><li><strong>需要 自定义方法”changeCursor()”</strong></li></ul><blockquote><p>检测上一个Cursor,用来关闭上个Cursor.</p></blockquote><pre><code>class MediaStoreAdapter(private val mActivity: Activity) :    RecyclerView.Adapter&lt;MediaStoreAdapter.ViewHolder&gt;() {        fun changeCursor(cursor: Cursor?) {        val oldCursor: Cursor? = swapCursor(cursor!!)        if (oldCursor != null)            oldCursor.close()    }}</code></pre><ul><li>需要重写 “onBindViewHolder()”方法</li></ul><pre><code>    override fun onBindViewHolder(holder: ViewHolder, position: Int) {        val bitmap: Bitmap? = getBitmapFromMediaStore(position)        if (bitmap != null) {            holder.mediastoreImageView.setImageBitmap(bitmap)        }    }</code></pre><ul><li>需要重写”getItemCount()”方法</li></ul><pre><code>    override fun getItemCount(): Int {        return if (mMediaStoreCursor == null) 0 else mMediaStoreCursor!!.count    }</code></pre><ul><li>需要重写”onCreateViewHolder()”方法</li></ul><pre><code>    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {        val view =            LayoutInflater.from(parent.context).inflate(R.layout.media_image_view, parent, false)        return ViewHolder(view)    }</code></pre><h3 id="需要”LoaderManager-LoaderCallbacks”"><a href="#需要”LoaderManager-LoaderCallbacks”" class="headerlink" title="需要”LoaderManager.LoaderCallbacks”"></a>需要”LoaderManager.LoaderCallbacks”</h3><ul><li>需要实现LoaderManager.LoaderCallbacks<cursor>.(在MediaMainActivity)</li></ul><blockquote><p>在需要的Fragment或Activity中实现它。</p></blockquote><pre><code>class MediaMainActivity : AppCompatActivity(), LoaderManager.LoaderCallbacks&lt;Cursor&gt; {}</code></pre><ul><li>需要重写”onCreateLoader”</li></ul><blockquote><p>在调用initLoader()返回时创建一个Loader.</p><p>根据传入的ID,初始化并返回一个新的加载器.</p></blockquote><ul><li>需要返回的列</li></ul><blockquote><p>MediaStore.Files.FileColums.ID 返回Id列</p><p>MediaStore.Files.FIleColums.DATE_ADDED 图片被添加的时间</p><p>MediaStore.Files.FileColums.MEDIA_TYPE 媒体类型</p><p>MediaStore.Files.FileColums.MEDIA_TYPE_IMAGE 图片列(索引)</p><p>MediaStore.Files.FileColums.MEDIA_TYPE_VIDEO 视频列(索引)</p></blockquote><ul><li>需要”CursorLoader()”匿名类</li></ul><blockquote><p>它查询ContentResolver然后返回一个Cursor.</p><p>参数1:上下文. 参数2:要操作的URI.当前表示所有图片的URI.</p><p>参数3:要返回的列. 参数4:一个过滤器,表明哪些行要被返回.当前返回类型为IMAGE 或 VIDEO</p><p>参数5:用作过滤器的参数. </p><p>参数6:设置排序.相当于SQL语句中Order by.这里使用 DATA_ADDED + DESC 表示按照时间进行排序.</p></blockquote><pre><code class="kotlin">    override fun onCreateLoader(p0: Int, p1: Bundle?): androidx.loader.content.Loader&lt;Cursor&gt; {        val projection = arrayOf&lt;String&gt;(            MediaStore.Files.FileColumns._ID,            MediaStore.Files.FileColumns.DATE_ADDED,            MediaStore.Files.FileColumns.MEDIA_TYPE        )        // SQL命令        val selection =            MediaStore.Files.FileColumns.MEDIA_TYPE +                    &quot; = &quot; + MediaStore.Files.FileColumns.MEDIA_TYPE_IMAGE + &quot; or &quot; + MediaStore.Files.FileColumns.MEDIA_TYPE +                    &quot; = &quot; + MediaStore.Files.FileColumns.MEDIA_TYPE_VIDEO        return object : CursorLoader(            this,            MediaStore.Files.getContentUri(&quot;external&quot;),            projection,            selection,            null,            MediaStore.Files.FileColumns.DATE_ADDED + &quot; DESC &quot;        ) {}    }</code></pre><ul><li>需要重写 “onLoadFinished()”方法</li></ul><blockquote><p>更新UI操作.当一个加载器完成了它的装载过程后被调用.</p></blockquote><ul><li>需要调用changeCursor()方法</li></ul><blockquote><p>刷新当前参数1,关闭上一个Cursor</p><p>参数1:当前的Cursor</p></blockquote><pre><code>class MediaMainActivity : AppCompatActivity(), LoaderManager.LoaderCallbacks&lt;Cursor&gt; {    override fun onLoadFinished(loader: androidx.loader.content.Loader&lt;Cursor&gt;, data: Cursor?) {        mMediaStoreAdapter?.changeCursor(data!!)    }}</code></pre><ul><li>需要重写”onLoaderReset()”方法</li></ul><blockquote><p>何时释放内存,当一个加载器完成了它的装载工作之后被调用</p></blockquote><pre><code>class MediaMainActivity : AppCompatActivity(), LoaderManager.LoaderCallbacks&lt;Cursor&gt; {   override fun onLoaderReset(loader: androidx.loader.content.Loader&lt;Cursor&gt;) {        mMediaStoreAdapter?.changeCursor(null)    }}</code></pre><ul><li><p>需要在用于权限和申请权限之后添加</p></li><li><p>需要在”onRequestPermissionsResult()”中调用”getSupportLoaderManager.initLoader()”</p></li></ul><blockquote><p>启动加载器</p><p>参数1:一个唯一的ID来标志加载器.</p><p>参数2:可选参数,用于加载初始化时(本例为null)</p><p>参数3:LoaderManager.LoaderCallbacks的实现.被LoaderManger调用以报告加载事件,在例子中是传递给自己”this”</p></blockquote><pre><code>when (requestCode) {            READ_EXTERNAL_STORAGE_PERMISSION_RESULT -&gt; {                if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {                //添加 supportLoaderManager.initLoader(MEDIASTORE_LODAR_ID, null, this)                }            }        }</code></pre><ul><li>需要在”checkReadExternalStoragePermission()”中调用</li><li>需要在拥有权限后调用,在”checkSelfPermission()”判断拥有权限后调用</li></ul><pre><code>        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {                  if (ContextCompat.checkSelfPermission(                    this,                    permission.READ_EXTERNAL_STORAGE                ) == PackageManager.PERMISSION_GRANTED            ) {              //添加  supportLoaderManager.initLoader(MEDIASTORE_LODAR_ID, null, this)            }         } else {            //添加  supportLoaderManager.initLoader(MEDIASTORE_LODAR_ID, null, this)        }</code></pre><p>ps:显示了在哪里添加其他的代码不用修改.</p><ul><li>需要添加唯一的ID标志加载器.</li></ul><pre><code>class MediaMainActivity : AppCompatActivity(), LoaderManager.LoaderCallbacks&lt;Cursor&gt; {    private val MEDIASTORE_LODAR_ID: Int = 0}</code></pre><ul><li>需要GridLayoutManger,在 “onCreate()” 中添加</li></ul><blockquote><p>设置RecyclerView的布局</p><p>参数1:上下文 . 参数2:多少列</p></blockquote><pre><code>val gridLayoutManager: GridLayoutManager = GridLayoutManager(this, 3)</code></pre><ul><li>需要RecyclerView的setLayoutManager</li></ul><blockquote><p>设置 GridLayoutManager</p></blockquote><pre><code>thumbnailRecyclerView.layoutManager = gridLayoutManager</code></pre><ul><li>需要设置适配器省略..</li></ul><h3 id="使用-“Glide”的方式加载图片"><a href="#使用-“Glide”的方式加载图片" class="headerlink" title="使用 “Glide”的方式加载图片"></a>使用 “Glide”的方式加载图片</h3><ul><li>需要添加依赖</li></ul><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200803180403.png" alt=""></p><ul><li>需要“MediaStore.Files.FileColumns.DATA”（需要在onCreateLoader的projection修改）</li></ul><blockquote><p>表述索引在磁盘中位置</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200803180843.png" alt=""></p><p>需要创建自定义返回“getUriFromMediaStore()”（在MediaStoreAdapter中添加）</p><blockquote><p>获得缩略图在ContentResolver中的uri</p><p>参数1：media的那个行</p></blockquote><p>需要“Uri.parse()” 方法</p><blockquote><p>将字符串解析成uri对象</p></blockquote><pre><code>    private fun getUriFromMediaStore(position: Int): Uri {        val dataIndex: Int = mMediaStoreCursor!!.getColumnIndex(MediaStore.Files.FileColumns.DATA)        mMediaStoreCursor!!.moveToPosition(position)        val mediaUri: Uri =            Uri.parse(&quot;file://&quot; + mMediaStoreCursor!!.getString(dataIndex).toString())        return mediaUri    }</code></pre><p>需要“Glide” - (在onBindViewHolder()中添加)</p><blockquote><p>with(content:Content) - 需要上下文</p><p>load(uri:String) - 图片的uri</p><p>centerCrop() - 将图片按比例缩放到足以填充ImageView的尺寸，但是图片可能会显示不完整。</p><p>override(width,height) 重新改变图片大小。</p><p>into() - 你需要显示图片的目标。</p></blockquote><pre><code>      Glide.with(mActivity).load(getUriFromMediaStore(position)).centerCrop().override(96, 96)            .into(holder.mediastoreImageView)</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200803184305.png" alt=""></p><h2 id="什么是Loader"><a href="#什么是Loader" class="headerlink" title="什么是Loader"></a>什么是Loader</h2><p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/developer/2014/0325/1602.html" target="_blank" rel="noopener">android 加载器loader详解</a></p><p>Loader简化了activity和Fragment中异步加载数据的步骤.</p><p>特点:适用于每个Activity和Fragment,提供异步加载的实现方式,监听数据源,在数据发生改变时自动返回新的结果。当由于配置改变后被重新创建后,它们自动重新链接上一个加载游标,所以不必重新查数据.</p><p>loader API 说明</p><table><thead><tr><th align="center">Class/Interface</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">LoaderManager</td><td align="center">一个与Activity和Fragment相关联的抽象类,它管理一个或者多个Loader实例,帮助一个应用管理哪些与Activity或Fragment的声明周期相关的长时间操作.常见方式是与CursorLoader一起使用,然后应用也可以自己写一个加载其他数据类型或者数据源的loader。<strong>每个Activity或者Fragment只有一个LoaderManager.但是一个LoaderManager可以拥有多个加载器</strong></td></tr><tr><td align="center">LoaderManager.LoaderCallbacks</td><td align="center">用于一个客户端与LoaderManager交互的会调接口.例如,你使用回调方法onCreateLoader()来创建一个新的加载器.</td></tr><tr><td align="center">Loader</td><td align="center">一个执行异步数据加载的抽象类,它是加载器的基础类.你可以使用经典的CursorLoader,但是你也可以实现你的子类.一旦加载器被激活,它们将监听它的数据源并且在数据改变时发送新的结果.</td></tr><tr><td align="center">AsyncTaskLoader</td><td align="center">提供一个AsyncTask来执行异步加载工作的抽象类</td></tr><tr><td align="center">CursorLoader</td><td align="center">AsyncTaskLoader的子类,它查询ContentResolver然后返回一个Cursor.这个类为查询Cursor以标准的方式实现了加载器协议,它的游标查询是通过AsyncTaskLoader在后台线程中执行,从而不会阻断线程</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-8-3-1.gif" alt="如果有些方法没有详细说明你可以自行搜索查看"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLite Database 使用</title>
      <link href="/2020/07/28/SQLite-Database-%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/07/28/SQLite-Database-%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><h5 id="需要-创建数据库-类-“MyHelper”"><a href="#需要-创建数据库-类-“MyHelper”" class="headerlink" title="需要 创建数据库 类 “MyHelper”"></a>需要 创建数据库 类 “MyHelper”</h5><pre><code class="kotlin">class MyHelper(    private val mContext: Context? = null,    private val dbname: String = &quot;mydb&quot;,    private val version: Int = 1) : SQLiteOpenHelper(mContext, dbname, null, version) {    /*    * 需要变量sql确定表的格式    * 需要 execSQL()执行创建表的动作    * */    override fun onCreate(p0: SQLiteDatabase?) {        // 创建数据库表        val sql: String =            &quot;CREATE TABLE PRODUCTS (_id INTEGER PRIMARY KEY AUTOINCREMENT, NAME TEXT, DESCRIPTION TEXT, PRICE READ)&quot;        // 执行创建表的动作        p0?.execSQL(sql)    }    /*    *    * */    override fun onUpgrade(p0: SQLiteDatabase?, p1: Int, p2: Int) {        TODO(&quot;Not yet implemented&quot;)    }}</code></pre><ul><li>创建数据库需要继承SQLiteOpenHelper()类型,需要四个参数进行初始化</li><li>(四个参数:mContext:上下文,dbname: 数据库名称,version:数据库版本,factory:null)</li><li>需要实现两个方法onCreate()和onUpgrade()方法</li></ul><h5 id="在需要创建数据库时调用"><a href="#在需要创建数据库时调用" class="headerlink" title="在需要创建数据库时调用"></a>在需要创建数据库时调用</h5><pre><code class="kotlin"> var myHelper: MyHelper = MyHelper(mContext = this) val sqlLiteDatabase: SQLiteDatabase = myHelper.readableDatabase</code></pre><p>这时数据库就创建完成了</p><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>创建仓库后插入数据</p><p>需要”ContentValues()”类型</p><p>需要”SQLiteDatabase的insert()”方法</p><p>在”自定义数据库中”中添加方法</p><pre><code>    private fun instertData(        name: String,        description: String,        price: Double,        database: SQLiteDatabase    ) {        // ContentValues() 类型负责存放键值的数据.你只需要记住它是往数据库中存放数据的.        val values: ContentValues = ContentValues()        values.put(&quot;NAME&quot;, name)        values.put(&quot;DESCRIPTION&quot;, description)        values.put(&quot;PRICE&quot;, price)        // 向当前数据库(database)插入数据(values)        database.insert(&quot;PRODUCTS&quot;, null, values)    }</code></pre><p>在<strong>外部要插入数据</strong>设置类型为 “public”即可。</p><p>插入数据在外部调用方法</p><pre><code>        // insert        instertData(&quot;Jam&quot;, &quot;Fruit Jam&quot;, 300.1, p0!!)        instertData(&quot;Yli&quot;, &quot;Te Jam&quot;, 305.13, p0!!)        instertData(&quot;Tom Li&quot;, &quot;Zhou Jam&quot;, 210.7, p0!!)</code></pre><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>需要”MyHelper”自定义<strong>数据库类的实例</strong></p><p>需要”MyHelper.readableDatabase”方法读取数据库方法<strong>返回一个可对数据库读写的对象</strong>.</p><p>需要”sqlLiteDatabase.rawQuery()”方法<strong>获得(数据库表)每行的集合</strong>(Cursor类型).</p><pre><code>  // 实例话自定义的数据类        var myHelper: MyHelper = MyHelper(mContext = this)        // 创建数据库        val sqlLiteDatabase: SQLiteDatabase = myHelper.readableDatabase        val cursor: Cursor =            sqlLiteDatabase.rawQuery(&quot;SELECT NAME, PRICE FROM PRODUCTS&quot;, arrayOf&lt;String&gt;())        if (cursor != null)            cursor.moveToFirst()        val builder: StringBuilder = StringBuilder()        do {            val name: String = cursor.getString(0)            val price: Double = cursor.getDouble(1)            builder.append(&quot;NAME - &quot; + name + &quot;PRICE - &quot; + price)        } while (cursor.moveToNext())        // 这是在界面上刷新了读取的数据        text_view.setText(builder.toString())</code></pre><p><img src="1595946627126.png" alt=""></p><h4 id="按照条件查询指定数据"><a href="#按照条件查询指定数据" class="headerlink" title="按照条件查询指定数据"></a>按照条件查询指定数据</h4><pre><code>   val cursor: Cursor =            sqlLiteDatabase.rawQuery(&quot;SELECT NAME, PRICE FROM PRODUCTS WHERE NAME = ?&quot;, arrayOf&lt;String&gt;(&quot;Tom Li&quot;))</code></pre><p>查询 列 “NAME,PRICE” 来自表 “PRODUCTS” 根据条件 “NAME = ?”</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200731132244.png" alt=""></p><p>查询完成</p><h2 id="什么是Cursor类型"><a href="#什么是Cursor类型" class="headerlink" title="什么是Cursor类型"></a>什么是Cursor类型</h2><p><a href="https://blog.csdn.net/android_zyf/article/details/53420267" target="_blank" rel="noopener">引用:Android中的Cursor到底是什么？如何理解Cursor的方法都在做什么事情？</a></p><blockquote><p>Cursor是每行的集合</p></blockquote><p>表中共有多行数据.</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200729122947.png" alt=""></p><p>假如:获得通过”select”语句”gender”获得符合这列的男性那么得到的是 “张三,赵六”这两行数据.也就是<strong>说 “Cursor”类型存放了两行数据。</strong></p><h4 id="如何获得Cursor类型"><a href="#如何获得Cursor类型" class="headerlink" title="如何获得Cursor类型"></a>如何获得Cursor类型</h4><p>通过数据库对象的方法获得。👇</p><pre><code>SQLiteDataBase db;Cursor cursor = db.query(各种参数);</code></pre><p>这些就是每一行的集合</p><h4 id="索引在Cursor中是什么"><a href="#索引在Cursor中是什么" class="headerlink" title="索引在Cursor中是什么"></a>索引在Cursor中是什么</h4><p>在Cursor中索引指的就是<strong>表中的列</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200731174701.png" alt=""></p><p>返回了”PRICE”列在表中的索引(位置)。</p><h4 id="关于为何要使用-“moveToFirst-”-方法"><a href="#关于为何要使用-“moveToFirst-”-方法" class="headerlink" title="关于为何要使用 “moveToFirst()” 方法"></a>关于为何要使用 “moveToFirst()” 方法</h4><p>利用反证法,<strong>不使用”moveToFirst()”方法,</strong>获得游标后,直接输出当前的”position”值</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200729210143.png" alt=""></p><p><strong>“position”的值会直接输出 “-1”</strong>,也就是说当我们不适用”moveToFirst()”方法时它会在坐标”position”(0)的<strong>上边</strong>。</p><p>所以我们应该使用方法”moveToFirst()”使”position”为”0”。</p><h4 id="源码分析-使用”moveToNext-”方法是如何得知遍历完成的"><a href="#源码分析-使用”moveToNext-”方法是如何得知遍历完成的" class="headerlink" title="源码分析 使用”moveToNext()”方法是如何得知遍历完成的?"></a>源码分析 使用”moveToNext()”方法是如何得知遍历完成的?</h4><p>先说明 <strong>调用”moveToNext()”方法最总会调用”moveToPosition()”方法</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200729212802.png" alt=""></p><p>👆界面在被初始化时,指当前页面的对象。这时源<strong>码中的”mPos=-1”会被在一个空参数构造方法里初始化</strong>。</p><p>仅理解的话: <strong>“moveToFirst()”调用的是”moveToPostion(0)”,”moveToNext()” 调用的是”moveToNext(mPos+1)”,所以说当首次调用的他们两个的结果是一样的。</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200729215028.png" alt=""></p><p>ps:个人理解:在使用”cursor.moveToFirst()”先进行判断可以更有效的避免空指针异常j</p><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>需要修改<strong>数据库返回的类型为可写入类型</strong></p><pre><code class="kotlin">        // 创建数据库        val sqlLiteDatabase: SQLiteDatabase = myHelper.writableDatabase</code></pre><p>需要 “ContentValues()” 类型存放更新的值</p><pre><code>        //更新数据        val values: ContentValues = ContentValues()        values.put(&quot;PRICE&quot;, 280)        // 参数1:表示更新的表.参数2:表示更新的数据.参数3:表示条件(表示通过那个条件更新值) 参数4:条件的值        sqlLiteDatabase.update(&quot;PRODUCTS&quot;, values, &quot;_id = ?&quot;, arrayOf&lt;String&gt;(&quot;1&quot;))</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200731130854.png" alt=""></p><p>“280”价格更新了</p><h4 id="多条件更新"><a href="#多条件更新" class="headerlink" title="多条件更新"></a>多条件更新</h4><p>更新表 “<strong>PRODUCTS</strong>“ 的值 “<strong>values</strong>“,根据 “<strong>NAME</strong>“为”<strong>Tom Li</strong>“ 和”<strong>DESCRIPTION</strong>“ 为 “<strong>Zhou Jam</strong>“ 的行中的数据.</p><pre><code>sqlLiteDatabase.update(&quot;PRODUCTS&quot;, values, &quot;NAME = ? AND DESCRIPTION = ?&quot;, arrayOf&lt;String&gt;(&quot;Tom Li&quot;,&quot;Zhou Jam&quot;))</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200731132831.png" alt=""></p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>在获得数据库的<strong>可写入类型后。</strong> 调用 “delete()”方法。</p><pre><code>        // 根据条件删除一行数据        // 参数1:要删除的表名字,参数2:选择删除的条件(根据这个条件删除),参数3:条件的值        sqlLiteDatabase.delete(&quot;PRODUCTS&quot;, &quot;_id=?&quot;, arrayOf&lt;String&gt;(&quot;1&quot;))</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200731131332.png" alt=""></p><p>删除成功了.</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> SQLite </tag>
            
            <tag> Cursor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库索引</title>
      <link href="/2020/07/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
      <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是数据库索引"><a href="#什么是数据库索引" class="headerlink" title="什么是数据库索引"></a>什么是数据库索引</h2><p>MySql官网的介绍,索引是帮助<code>MySQL</code>高效获得数据的结构。类似于书本的目录,从而提高查询速度。</p><p><a href="https://segmentfault.com/a/1190000022341554" target="_blank" rel="noopener">初探MySQL索引</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chocolatey的配置与应用的安装</title>
      <link href="/2020/07/26/choco%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2020/07/26/choco%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-Chocolatey安装7zip"><a href="#使用-Chocolatey安装7zip" class="headerlink" title="使用 Chocolatey安装7zip"></a>使用 Chocolatey安装7zip</h2><p>全程使用科学上网</p><pre><code>choco install 7zip</code></pre><h2 id="如何安装Chocolatey"><a href="#如何安装Chocolatey" class="headerlink" title="如何安装Chocolatey"></a>如何安装Chocolatey</h2><p><a href="https://chocolatey.org/install.ps1" target="_blank" rel="noopener">在桌面下载</a></p><p>使用管理员打开cmd访问到下载的目录中</p><p>输入👇.安装的同时要使用科学上网</p><pre><code>@powershell -NoProfile -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&#39;install.ps1&#39;))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin&quot;</code></pre><p>查看是否安装成功：</p><p>choco</p><p><img src="1595823753408.png" alt=""></p><h2 id="什么是Chocolatey"><a href="#什么是Chocolatey" class="headerlink" title="什么是Chocolatey"></a>什么是Chocolatey</h2><p>Chocolatey是一个Windows下的软件包管理器，你可以像在类Unix系统中使用Yum和APT一样使用它，在Windows中实现自动化轻松管理Windows软件的所有方面。</p><p> <a href="https://zh.wikipedia.org/zh-cn/Chocolatey" target="_blank" rel="noopener">维基百科</a></p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2>]]></content>
      
      
      <categories>
          
          <category> Chocolatey </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chocolatey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin in Action-Kotlin实战</title>
      <link href="/2020/07/26/kotlin-in-Action-Kotlin%E5%AE%9E%E6%88%98/"/>
      <url>/2020/07/26/kotlin-in-Action-Kotlin%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h2 id="2-Kotlin-基础"><a href="#2-Kotlin-基础" class="headerlink" title="2 Kotlin 基础"></a>2 Kotlin 基础</h2><h3 id="2-1-基本要素-函数变量"><a href="#2-1-基本要素-函数变量" class="headerlink" title="2.1 基本要素: 函数变量"></a>2.1 基本要素: 函数变量</h3><h4 id="2-1-3-变量"><a href="#2-1-3-变量" class="headerlink" title="2.1.3 变量"></a>2.1.3 变量</h4><p><strong>可变变量和不可变变量</strong></p><ul><li>val–不可变引用。使用val声明的变量不能在初始化之后再次赋值。它对应的是java中的final变量</li><li>var–可变引用。这种变量的值可以被改变。这种声明对应的是普通(非final)变量</li></ul><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595899792330.png" alt=""></p><p>👆在定义了val变量的代码块期间,<strong>val变量只能进行唯一一次初始化</strong>。但是,如果编译器能确保只有唯一一次初始化语句会被执行,可以根据条件使用不同的值来初始化它。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595899976491.png" alt=""></p><p>自身不可变(只可以执行一次,初始化一次)</p><p>注意,尽管val引用自身是不可变的,但是它指向的对象<strong>`可能</strong>`是可变的。列如</p><pre><code>val languages = arrayListOf(&quot;Java&quot;)lenguages.add(&quot;Kotlin&quot;)</code></pre><h3 id="2-3-表示和处理选择：枚举和“when”"><a href="#2-3-表示和处理选择：枚举和“when”" class="headerlink" title="2.3 表示和处理选择：枚举和“when”"></a>2.3 表示和处理选择：枚举和“when”</h3><h4 id="2-3-5-智能转换：合并类型检查和转换"><a href="#2-3-5-智能转换：合并类型检查和转换" class="headerlink" title="2.3.5 智能转换：合并类型检查和转换"></a>2.3.5 智能转换：合并类型检查和转换</h4><h5 id="kotlin智能转换的案例"><a href="#kotlin智能转换的案例" class="headerlink" title="kotlin智能转换的案例"></a>kotlin智能转换的案例</h5><h6 id="表达式类型层次"><a href="#表达式类型层次" class="headerlink" title="表达式类型层次"></a>表达式类型层次</h6><pre><code class="kotlin">interface Exprclass Num(val value: Int) : Expr    // 简单的值对象类，只有一个属性value，实现了Expr接口class Sum(val left: Expr, val right: Expr) : Expr   // Sum运算的实参可以是任何Expr:Num 或者 Sum</code></pre><h6 id="对表达式求值"><a href="#对表达式求值" class="headerlink" title="对表达式求值"></a>对表达式求值</h6><pre><code class="kotlin">fun eval(e: Expr): Int {    if (e is Num) {//        val n = e.value as Num //显示的转换为Num类型多余的        return e.value    }    if (e is Sum) {        return eval(e.left) + eval(e.right) // 变量 e 被智能的转换了类型    }    throw IllegalArgumentException(&quot;test&quot;)}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200831171911.png" alt=""></p><p>结果</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200831171248.png" alt=""></p><h5 id="“is”-修饰符"><a href="#“is”-修饰符" class="headerlink" title="“is” 修饰符"></a>“is” 修饰符</h5><p>在 kotlin 中，你要使用 is 检查来判断一个变量是否是某个类型。</p><h5 id="什么时候进行智能转换？"><a href="#什么时候进行智能转换？" class="headerlink" title="什么时候进行智能转换？"></a>什么时候进行智能转换？</h5><p>如果你检查过一个变量是某种类型，后面就不再需要转换它了，可以就把它当作你检查过的类型使用。事实上编译器为你执行了类型转换，我们把这种行为称为 <strong>智能转换。</strong></p><h2 id="4-类、对象和接口"><a href="#4-类、对象和接口" class="headerlink" title="4 类、对象和接口"></a>4 类、对象和接口</h2><h3 id="4-1-定义类继承结构"><a href="#4-1-定义类继承结构" class="headerlink" title="4.1 定义类继承结构"></a>4.1 定义类继承结构</h3><h4 id="4-1-1-Kotlin-中的接口"><a href="#4-1-1-Kotlin-中的接口" class="headerlink" title="4.1.1 Kotlin 中的接口"></a>4.1.1 Kotlin 中的接口</h4><h5 id="声明接口"><a href="#声明接口" class="headerlink" title="声明接口"></a>声明接口</h5><pre><code class="kotlin">interface Clickable{    fun click()}</code></pre><h5 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h5><pre><code>class Button : Clickble {    override fun click() {        println(&quot;I was clicked&quot;)    }}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200826205307.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200826205356.png" alt=""></p><h5 id="Kotlin实现接口与-Java-有那些不同"><a href="#Kotlin实现接口与-Java-有那些不同" class="headerlink" title="Kotlin实现接口与 Java 有那些不同"></a>Kotlin实现接口与 Java 有那些不同</h5><p>Kotlin 在类后面使用冒号来代替 <strong>Java</strong> 中的 extends 和 implements 关键词。 和 Java 一样，<strong>一个类可以实现任意多个接口</strong>，但<strong>只能继承一个类型</strong>。</p><h5 id="override-修饰符的作用"><a href="#override-修饰符的作用" class="headerlink" title="override 修饰符的作用"></a>override 修饰符的作用</h5><ul><li>相同</li></ul><p>与 Java 中的 @Override 注解类似，<strong>override 修饰符用来标注被重写的父类或者接口的方法和属性</strong>。</p><ul><li>不同</li></ul><p>在 Kotlin 中使用 override 修饰符是强制要求的。<strong>这会避免先写出实现方法再添加抽象方法造成的意外重写：</strong>你的代码将不能编译，除非你显式地将这个方法标注为 Override 或者重命名它。</p><h5 id="如何给接口添加一个默认实现的方法"><a href="#如何给接口添加一个默认实现的方法" class="headerlink" title="如何给接口添加一个默认实现的方法"></a>如何给接口添加一个默认实现的方法</h5><p>接口的方法可以有一个默认实现的方法。</p><pre><code class="kotlin">interface Clickable{    fun click() // 普通的方法声明    fun showOff() = println(&quot;I&#39;m clickable!&quot;) // 带默认实现的方法}</code></pre><h5 id="实现一个带有默认实现的方法的接口要注意什么"><a href="#实现一个带有默认实现的方法的接口要注意什么" class="headerlink" title="实现一个带有默认实现的方法的接口要注意什么"></a>实现一个带有默认实现的方法的接口要注意什么</h5><p>如果你实现了这个接口，你需要为 click 提供一个实现。可以重新定义 showOff() 方法的行为，或者如果你对默认行为感到满意也可以直接省略它。（默认实现的方法也可以被重写）</p><h5 id="定义实现了同样方法的接口"><a href="#定义实现了同样方法的接口" class="headerlink" title="定义实现了同样方法的接口"></a>定义实现了同样方法的接口</h5><pre><code class="kotlin">interface Focusable {    fun setFocus(b: Boolean) = println(&quot;I ${if (b) &quot;got&quot; else &quot;lost&quot;} focus.&quot;)    fun showOff() = println(&quot;I&#39;m focusable!&quot;)}</code></pre><h5 id="在类中实现两个有相同默认实现方法的接口会发生什么"><a href="#在类中实现两个有相同默认实现方法的接口会发生什么" class="headerlink" title="在类中实现两个有相同默认实现方法的接口会发生什么"></a>在类中实现两个有相同默认实现方法的接口会发生什么</h5><p>在这两个接口中都带有默认实现的 showOff() 方法：在没有显示的实现 showOff() ,会得到编译错误信息。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827000446.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827000526.png" alt=""></p><h6 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h6><p>必须显式的实现相同方法。</p><h5 id="调用继承-接口-的默认实现方法"><a href="#调用继承-接口-的默认实现方法" class="headerlink" title="调用继承(接口)的默认实现方法"></a>调用继承(接口)的默认实现方法</h5><pre><code class="kotlin">class Button : Clickable, Focusable {    override fun click() {        TODO(&quot;Not yet implemented&quot;)    }    //如果同样的继承成员不止一个实现，必须提供一个显示的实现。    override fun showOff() {        // 使用尖括号加上父类名字的“super”表明了你想要调用哪一个父类的方法        super&lt;Clickable&gt;.showOff()        super&lt;Focusable&gt;.showOff()    }}</code></pre><p>通过调用继承的两个父类型中的实现来实现 showOff() 。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827005257.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827005432.png" alt=""></p><h4 id="4-1-2-open、final-和-abstract-修饰符：默认为-final"><a href="#4-1-2-open、final-和-abstract-修饰符：默认为-final" class="headerlink" title="4.1.2 open、final 和 abstract 修饰符：默认为 final"></a>4.1.2 open、final 和 abstract 修饰符：默认为 final</h4><h5 id="kotlin-中如何继承一个类"><a href="#kotlin-中如何继承一个类" class="headerlink" title="kotlin 中如何继承一个类"></a>kotlin 中如何继承一个类</h5><p>如果你想要创建一个类的子类，需要使用 open 修饰符来标示这个类。此外<strong>需要给每个可以被重写的属性或者方法添加 open 属性</strong>。</p><h5 id="声明一个带open-方法的-open-类"><a href="#声明一个带open-方法的-open-类" class="headerlink" title="声明一个带open 方法的 open 类"></a>声明一个带open 方法的 open 类</h5><pre><code class="kotlin">open class RichButton : Clickable {    fun disable() {}    // 这个函数是 final 的： 不能在子类中重写它。    open fun animate() {} // 这个函数是 open 的： 可以在子类中重写它    // 这个函数重写了 open 函数并且它本身同样是 open 的    override fun click() {        TODO(&quot;Not yet implemented&quot;)    }}</code></pre><h5 id="默认-final-的好处"><a href="#默认-final-的好处" class="headerlink" title="默认 final 的好处"></a>默认 final 的好处</h5><p>类默认 final 带来了一个重要的好处就是这使得在大量的场景中的只能转换成为可能。</p><h5 id="智能转换的前提"><a href="#智能转换的前提" class="headerlink" title="智能转换的前提"></a>智能转换的前提</h5><p><strong>智能转换只能在进行类型检查后没有改变过的变量上起的作用。</strong>对于一个类来说，这意味着<strong>智能转换在val类型并且没有自定义访问器的类属性上使用</strong>。 这个前提意味着属性必须是 final 的，否则如果一个子类可以重写属性并且定义一个自定义的访问器将会打破智能转换的关键前提。</p><h5 id="抽象类的默认修饰符"><a href="#抽象类的默认修饰符" class="headerlink" title="抽象类的默认修饰符"></a>抽象类的默认修饰符</h5><p>抽象成员始终是open的，所以不需要显式地使用open修饰符。</p><h5 id="声明一个抽象类"><a href="#声明一个抽象类" class="headerlink" title="声明一个抽象类"></a>声明一个抽象类</h5><pre><code class="kotlin">abstract class Animated {    abstract fun animate()  // 这个函数是抽象的：它没有实现必须被子类重写    // 抽象类中的非抽象函数 并不是默认 open 的，但是可以标注为 open的    open fun stopAnimating() {    }    fun animateTwice() {}}</code></pre><h4 id="4-1-4-内部类和嵌套类：默认嵌套类"><a href="#4-1-4-内部类和嵌套类：默认嵌套类" class="headerlink" title="4.1.4 内部类和嵌套类：默认嵌套类"></a>4.1.4 内部类和嵌套类：默认嵌套类</h4><p>内部类：非静态嵌套类，也被成为内部类。</p><p>嵌套类：静态嵌套类，嵌套类多称为：静态嵌套类。</p><h5 id="Kotlin中嵌套类和Java中的不同"><a href="#Kotlin中嵌套类和Java中的不同" class="headerlink" title="Kotlin中嵌套类和Java中的不同"></a>Kotlin中嵌套类和Java中的不同</h5><p>在Kotlin中的嵌套类不能访问外部类的实例，除非你特别的做出要求。 </p><h5 id="在序列化时使用内部类"><a href="#在序列化时使用内部类" class="headerlink" title="在序列化时使用内部类"></a>在序列化时使用内部类</h5><p>在你定义一个 View 元素，它的状态时可序列化的。<strong>想要序列化一个视图可能并不容易，但是可以把所有需要的数据复制到另一个辅助类中去。</strong></p><pre><code class="kotlin">interface State : Serializableinterface View {    fun getCurrentState(): State    fun restoreState(state: State) {}}</code></pre><p>声明State接口去实现Serializable。View接口声明了可以用来保存视图状态的getCurrentState和restoreState方法。</p><h5 id="用内部类的java代码来实现View"><a href="#用内部类的java代码来实现View" class="headerlink" title="用内部类的java代码来实现View"></a>用内部类的java代码来实现View</h5><pre><code class="java">public class Button implements View{    @Override    public State getCurrentState(){        return new ButtonState();    }    @Override    public voiew restoreState(State state){        /**/    }    public class ButtonState implements State{        /**/    }}</code></pre><p>问题：在运行时你会得到 java.io.NotSerializable.Exception:Button 异常，在你序列化声明的按钮状态时。这个可能看起来会很奇怪：你序列化的变量是ButtonState类型，为什么会有Button异常呢？</p><h5 id="无法序列化的原因"><a href="#无法序列化的原因" class="headerlink" title="无法序列化的原因"></a>无法序列化的原因</h5><p>在java中，当你在另一个类中声明一个类时，它会默认变成内部类。案例中：ButtonState类隐示的存储了它的外部Button类的应用。从而解释了为什么ButtonState不能被序列化。</p><h5 id="修复无法序列化"><a href="#修复无法序列化" class="headerlink" title="修复无法序列化"></a>修复无法序列化</h5><p><strong>需要声明ButtonState类是static的</strong>。将嵌套类声明为static会冲这个类中删除包围它的类的隐式引用。</p><h5 id="在kotlin中使用嵌套类来实现-View"><a href="#在kotlin中使用嵌套类来实现-View" class="headerlink" title="在kotlin中使用嵌套类来实现 View"></a>在kotlin中使用嵌套类来实现 View</h5><pre><code class="kotlin">class Button : View {    override fun getCurrentState(): State {        TODO(&quot;Not yet implemented&quot;)    }    override fun restoreState(state: State) {        TODO(&quot;Not yet implemented&quot;)    }    // 这个类与Java中的静态潜逃类类似    class ButtonState : State {    }}</code></pre><p><strong>kotlin中默认行为是嵌套类。</strong></p><h5 id="如何让默认嵌套类的类型变为内部类！"><a href="#如何让默认嵌套类的类型变为内部类！" class="headerlink" title="如何让默认嵌套类的类型变为内部类！"></a>如何让默认嵌套类的类型变为内部类！</h5><p>要把它（嵌套类）变成为一个内部类来持有一个外部类的引用的话需要使用 <strong>inner</strong> 修饰符。</p><h5 id="kotlin中内部类访问外部类"><a href="#kotlin中内部类访问外部类" class="headerlink" title="kotlin中内部类访问外部类"></a>kotlin中内部类访问外部类</h5><p>在kotlin中引用外部类实例的语法与java不同。需要使用this@Outer从Inner类去访问Outer类。</p><h4 id="4-1-5-密封类：定义受限的类继承结构"><a href="#4-1-5-密封类：定义受限的类继承结构" class="headerlink" title="4.1.5 密封类：定义受限的类继承结构"></a>4.1.5 密封类：定义受限的类继承结构</h4><h5 id="什么是密封类”sealed“"><a href="#什么是密封类”sealed“" class="headerlink" title="什么是密封类”sealed“"></a>什么是密封类”sealed“</h5><p>sealed 类。为父类添加了一个新的 sealed 修饰符，可对创建的子类做出严格的限制。<strong>所有的子类必须嵌套在父类中。</strong></p><h5 id="为什么要使用密封类（定义受限的类继承结构）"><a href="#为什么要使用密封类（定义受限的类继承结构）" class="headerlink" title="为什么要使用密封类（定义受限的类继承结构）"></a>为什么要使用密封类（定义受限的类继承结构）</h5><p><strong>作为接口实现的表达式 👇</strong></p><pre><code class="kotlin">interface Exprclass Num(val value: Int) : Exprclass Sum(val left: Expr, val right: Expr):Exprfun eval(e: Expr): Int =    when (e) {        is Num -&gt; e.value        is Sum -&gt; eval(e.left) + eval(e.right)        else -&gt; // 必须检查 else 分支            throw  IllegalArgumentException(&quot;Unknown expression!&quot;)    }</code></pre><p><strong>当使用 when 结构来执行表达式的时候，Kotlin 编译器会强制检查默认选项</strong>。在这个例子中，<strong>不能返回一个有意义的值，所以直接返回异常状态。</strong></p><p>更重要的是，如果你添加了一个新的子类，编译器并不能发现你修改了。<strong>如果你忘记添加一个新的分支，就会选择默认选项，这又可能导致潜在的 bug。</strong></p><h5 id="如何使用密封类-“sealed”"><a href="#如何使用密封类-“sealed”" class="headerlink" title="如何使用密封类 “sealed”"></a>如何使用密封类 “sealed”</h5><pre><code class="kotlin">sealed class Expr { //将基类标记为封闭的    class Num(val value: Int) : Expr()    class Sum(val left: Expr, val right: Expr) : Expr() // 将所有可能的类作为嵌套类列出}fun eval(expr: Expr): Int =    // “when”表达式覆盖了所有的可能情况，所以不再需要 else 分支    when (expr) {        is Expr.Num -&gt; expr.value        is Expr.Sum -&gt; eval(expr.left) + eval(expr.right)    }</code></pre><p><strong>如果你在 when 表达式中处理了所有的 sealed 类的子类，你就不再需要提供默认分支。</strong>注意，sealed 修饰符隐含的这个类是一个 open 类，你不再需要显式地添加 open 修饰符。</p><h3 id="4-2-声明一个带默认构造方法或属性的类"><a href="#4-2-声明一个带默认构造方法或属性的类" class="headerlink" title="4.2 声明一个带默认构造方法或属性的类"></a>4.2 声明一个带默认构造方法或属性的类</h3><p><strong>kotlin中构造方法和java中有那些不同</strong></p><p>与java中一个类可以声明一个或多个构造方法。kotlin也是类似的，只是做出了一些修改：区分了主构造方法（通常是主要而简洁的初始化类的方法，并且在类体外部声明）和从构造方法。</p><h4 id="4-2-1-初始化类：主构造方法和初始化代码块"><a href="#4-2-1-初始化类：主构造方法和初始化代码块" class="headerlink" title="4.2.1 初始化类：主构造方法和初始化代码块"></a>4.2.1 初始化类：主构造方法和初始化代码块</h4><h5 id="什么是主构造方法。"><a href="#什么是主构造方法。" class="headerlink" title="什么是主构造方法。"></a>什么是主构造方法。</h5><pre><code class="kotlin">class User(val nickname:String)</code></pre><p>这段被括号围起来的代码块就叫<strong>做主构造方法</strong>。它有两个目的：表明构造方法的<strong>参数</strong>，以及定义使用这个<strong>参数</strong>的属性。</p><h5 id="明确的主构造方法声明"><a href="#明确的主构造方法声明" class="headerlink" title="明确的主构造方法声明"></a>明确的主构造方法声明</h5><pre><code class="kotlin">class User constructor(_nickname: String) {   // 带一个参数的主构造方法    val nickname: String    init {  // 初始化代码块        nickname = _nickname    }}</code></pre><p>现在来看看完成同样功能的代码具体是什么样子。</p><blockquote><p>两个关键词 <strong>construtor</strong> 和 <strong>init</strong>。 constructor 关键词用来开始一个<strong>构造方法</strong>或者<strong>从构造方法</strong>的声明。init 关键词用来引入初始化代码块。这种代码块包含了类在创建时执行的代码，并且会和主构造方法一起使用。<strong>因为主构造方法有语法限制，不能包含初始化代码，这就是需要初始化代码块（init）的原因。</strong>同时可以创建多个初始化代码块。</p></blockquote><h5 id="用参数来初始化属性"><a href="#用参数来初始化属性" class="headerlink" title="用参数来初始化属性"></a>用参数来初始化属性</h5><pre><code class="kotlin">class User(_nickname: String) { // 带一个参数的构造方法    val nickname: String = _nickname    // 用参数来初始化属性}</code></pre><blockquote><p>在例子中，不需要把初始化代码放在初始化代码块中，因为它可以与nickname属性声明结合。如果主构造方法没有注解或可见性修饰符，同样可以去除 constructor 关键词。</p></blockquote><h5 id="用最简洁的方法再次初始化类"><a href="#用最简洁的方法再次初始化类" class="headerlink" title="用最简洁的方法再次初始化类"></a>用最简洁的方法再次初始化类</h5><pre><code class="kotlin">class User(val nickname:String)    // “val” 意味相对应的属性会用构造方法的参数来初始化。</code></pre><p>前几个案例用 val 关键词声明了属性。如果属性用相对应的构造方法参数来初始化，<strong>代码可以通过把 val 关键词加载参数前的方法来简化它</strong>。可以用来代替类中的属性定义了。</p><h5 id="为构造方法提供默认值"><a href="#为构造方法提供默认值" class="headerlink" title="为构造方法提供默认值"></a>为构造方法提供默认值</h5><pre><code class="kotlin">class User(val nickname: String, val isSubscribed: Boolean = true) // 为构造方法提供一个默认值    </code></pre><p>可以像函数参数一样为构造方法声明默认值。</p><h5 id="如何让一个类不被其他代码实例化"><a href="#如何让一个类不被其他代码实例化" class="headerlink" title="如何让一个类不被其他代码实例化"></a>如何让一个类不被其他代码实例化</h5><p>如果想要你的类不被其他代码实例化，必须把构造方法标记为 private。</p><pre><code class="kotlin">class Secretive private constructor()   // 这个类有 private 构造方法</code></pre><h4 id="4-2-2-构造方法：用不同的方法来初始化方法"><a href="#4-2-2-构造方法：用不同的方法来初始化方法" class="headerlink" title="4.2.2 构造方法：用不同的方法来初始化方法"></a>4.2.2 构造方法：用不同的方法来初始化方法</h4><h5 id="为什么要使用多种方法初始化父类"><a href="#为什么要使用多种方法初始化父类" class="headerlink" title="为什么要使用多种方法初始化父类"></a><strong>为什么要使用多种方法初始化父类</strong></h5><p>最常见的一种就是当你需要扩展一个框架类来提供多个构造方法，以便于通过不同的方法来初始化类的时候。</p><h5 id="父类使用从构造方法"><a href="#父类使用从构造方法" class="headerlink" title="父类使用从构造方法"></a><strong>父类使用从构造方法</strong></h5><pre><code class="kotlin">open class View {    constructor(ctx: Context) { // 从构造方法        //some code    }    constructor(ctx: Context, attr: AttributeSet) { // 从构造方法        //some code    }}</code></pre><h5 id="扩展父类"><a href="#扩展父类" class="headerlink" title="扩展父类"></a>扩展父类</h5><pre><code class="kotlin">class MyButton : View {    constructor(ctx: Context) : super(ctx) {        // 调用父类构造方法    }    constructor(ctx: Context, attr: AttributeSet) : super(ctx, attr) {    }}</code></pre><h5 id="调用父类的另一个构造方法"><a href="#调用父类的另一个构造方法" class="headerlink" title="调用父类的另一个构造方法"></a>调用父类的另一个构造方法</h5><pre><code class="kotlin">class MyButton : View {    constructor(ctx: Context) : this(ctx, My_SYTLE) {        // 委托给这个类的另一个构造方法    }    constructor(ctx: Context, attr: AttributeSet) : super(ctx, attr) {    }}</code></pre><p>从<strong>构造方法</strong>中调用你自己类的另一个<strong>构造方法</strong>。</p><p>可以修改 MyButton类 <strong>使得一个构造方法委托给同一个类的另一个构造方法</strong>，为参数传入默认值，图下👇。第二个方法继续调用super()。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200906113216.png" alt=""></p><h4 id="4-2-3-实现在接口中声明的属性"><a href="#4-2-3-实现在接口中声明的属性" class="headerlink" title="4.2.3 实现在接口中声明的属性"></a>4.2.3 实现在接口中声明的属性</h4><h5 id="在接口中声明一个属性"><a href="#在接口中声明一个属性" class="headerlink" title="在接口中声明一个属性"></a>在接口中声明一个属性</h5><pre><code class="kotlin">interface User {    val nickname: String}</code></pre><p>接口可以包含抽象属性声明。</p><p>这意味这<strong>实现User接口的类需要</strong>提供一个取得nickname值的方式。</p><h5 id="实现接口中的属性-三种"><a href="#实现接口中的属性-三种" class="headerlink" title="实现接口中的属性 三种"></a>实现接口中的属性 三种</h5><p>第一种</p><pre><code class="kotlin">// 主构造方法属性class PrivateUser(override val nickname: String) : User {}</code></pre><p>对于 PrivateUser 来说，<strong>你是用了间接的语法直接在主构造方法中声明了一个属性</strong>。这个属性实现了来自于User的抽象属性，所以你将其标记为 override。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908100413.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908095819.png" alt=""></p><p>运行结果</p><p>第二种</p><pre><code class="kotlin">class SubscribingUser(val email: String) : User {    override val nickname: String get() = email.substringBefore(&#39;@&#39;)  // 自定义getter}</code></pre><p>对于 SubscribeingUser 来说，nikename属性通过一个自定义 getter 实现。<strong>这个属性没有一个支持字段来存储它的值，它只有一个 getter 在每次调用时从 email 中得到昵称。</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908100342.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908100257.png" alt=""></p><p>运行结果</p><p>第三种</p><pre><code class="kotlin">class FacebookUser(val accoundId: Int) : User {    override val nickname = getFacebookName(accoundId)  // 属性初始化    fun getFacebookName(text: String): String {        return text    }}</code></pre><p>nickname在SubscribingUser和FackbookUser中的不同实现。即使它们看起来很相似，第一个属性有一个自定义getter在每次访问时计算 subscringBefore，然后 FackbookUser中的属性有一个<strong>支持字段来存储在类初始化时计算得到数据</strong>。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908104646.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908111027.png" alt=""></p><p>运行结果</p><h3 id="4-3-编译器生成的方法-数据类和委托"><a href="#4-3-编译器生成的方法-数据类和委托" class="headerlink" title="4.3 编译器生成的方法:数据类和委托"></a>4.3 编译器生成的方法:数据类和委托</h3><h4 id="4-3-2-数据类-自动生成通用方法的实现"><a href="#4-3-2-数据类-自动生成通用方法的实现" class="headerlink" title="4.3.2 数据类:自动生成通用方法的实现."></a>4.3.2 数据类:自动生成通用方法的实现.</h4><p>实现一个数据类需要重写方法:toString、equals和hashcode。</p><p><strong>数据类</strong></p><pre><code class="kotlin">data class Client(val name:String,val postalCode:Int)</code></pre><p>这是一个数据类,重写了所有标准的Java方法:</p><ul><li>equals 用来比较实例</li><li>hashCode用来作为例如HashMap这种基于哈希容器的键</li><li>toString用来为类生成按声明顺序排列的所有字段的字符串表达形式</li></ul><h3 id="4-4-“object”-关键字：-将声明一个类与创建一个实例结合起来"><a href="#4-4-“object”-关键字：-将声明一个类与创建一个实例结合起来" class="headerlink" title="4.4 “object” 关键字： 将声明一个类与创建一个实例结合起来"></a>4.4 “object” 关键字： 将声明一个类与创建一个实例结合起来</h3><p>这个关键词定义一个类并同时创建一个实例（换句话说就是一个对象）。</p><ul><li><strong>对象声明</strong>是定义一个单例的一种方式。</li><li><strong>伴生对象</strong>可以持有<strong>工场方法</strong>和其他与这个类的相关，但是在调用时并不依赖类实例方法。<strong>它们的成员可以通过类名来访问</strong>。</li><li><strong>对象表达式用来代替Java的匿名内部类</strong></li></ul><h4 id="4-4-1-对象声明：创建单例易如反掌"><a href="#4-4-1-对象声明：创建单例易如反掌" class="headerlink" title="4.4.1 对象声明：创建单例易如反掌"></a>4.4.1 对象声明：创建单例易如反掌</h4><h5 id="为什么使用对象声明？"><a href="#为什么使用对象声明？" class="headerlink" title="为什么使用对象声明？"></a>为什么使用对象声明？</h5><p>在面向对象系统中一个相当常见的情形就是只需要一个实例的类。例如，可以使用一个对象声明来表示一个组织的工资单。</p><h5 id="在Java中是如何实现单例模式？"><a href="#在Java中是如何实现单例模式？" class="headerlink" title="在Java中是如何实现单例模式？"></a>在Java中是如何实现单例模式？</h5><p>定义一个使用private构造方法并且用静态字段来持有这个类仅有的实例。</p><h5 id="什么是对象声明"><a href="#什么是对象声明" class="headerlink" title="什么是对象声明"></a>什么是对象声明</h5><p>Kotlin通过使用对象声明功能为这一切提供了最高级的语言支持。<strong>对象声明将类声明与该类的单一实例声明结合到了一起。</strong></p><h5 id="对象声明使用"><a href="#对象声明使用" class="headerlink" title="对象声明使用"></a>对象声明使用</h5><pre><code>object Payroll {    val allEmployees = arrayListOf&lt;Person&gt;()    fun calculateSalary() {        for (person in allEmployees){        }    }}</code></pre><p>对象声明通过 object 关键词引入。与类一样，一个对象声明也可以包含属性、方法、初始化语句块等的声明，唯一不允许的是构造方法。对象声明在定义时就创建了构造对象，不需要在代码的其他地方调用构造方法。对象声明同样可以继承类和接口。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="字段和属性"><a href="#字段和属性" class="headerlink" title="字段和属性"></a>字段和属性</h3><p><a href="https://blog.csdn.net/chenchunlin526/article/details/71424844" target="_blank" rel="noopener">深入理解Java中的字段与属性的区别</a></p><h4 id="属性和字段的区别"><a href="#属性和字段的区别" class="headerlink" title="属性和字段的区别"></a>属性和字段的区别</h4><p>属性（property），通常可以理解为get 和 set 方法。</p><p>字段（field），通常叫做 <strong>类成员</strong>，或者 <strong>类变量</strong> ，有时也叫 域 ，理解为 数据成员，用来承担数据的。</p><h4 id="属性和字段详解"><a href="#属性和字段详解" class="headerlink" title="属性和字段详解"></a>属性和字段详解</h4><p><strong>字段（field）</strong></p><p>类成员（字段field），通常在类中定义成员变量例如：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200909213136.png" alt=""></p><p>解释为：<strong>FacebookUser类拥有成员变量nickname，有一个字段 nickname。</strong></p><p>字段一般用于承担数据，所以为了数据的安全性，一般设置为私有的。</p><p>字段和常量描述的类的数据（域），当这些数据的某些部分不运行外界访问时，<strong>根据”对象封装“原则，应该尽量避免将类的字段以公有方式提供给外部</strong>。除啦final修饰的常量。</p><p><strong>属性（property）</strong></p><p><strong>属性只局限于类中方法的声明，并不与类中其它成员相关</strong>，数据JavaBean范畴：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200909220317.png" alt=""></p><p>这是一个属性，一个字段。</p><p>总结：属性是对字段的封装，供外部访问。通常<strong>属性</strong>将对应的<strong>私有字段</strong>通过封装成公共属性，以便于外界访问和修改。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-8-3-1.gif" alt="如果有些方法没有详细说明你可以自行搜索查看"></p>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RecyclerView在Kotlin中的使用</title>
      <link href="/2020/07/26/RecyclerView%E5%9C%A8Kotlin%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/07/26/RecyclerView%E5%9C%A8Kotlin%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="创建项目RecyclerExample项目"><a href="#创建项目RecyclerExample项目" class="headerlink" title="创建项目RecyclerExample项目"></a>创建项目RecyclerExample项目</h2><h3 id="需要引入依赖"><a href="#需要引入依赖" class="headerlink" title="需要引入依赖"></a>需要引入依赖</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595735673809.png" alt=""></p><h3 id="需要子项布局"><a href="#需要子项布局" class="headerlink" title="需要子项布局"></a>需要子项布局</h3><p>在 “RecyclerViewExample\app\src\main\res\layout”下创建 “example_item.xml” 👇</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.cardview.widget.CardView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;&gt;    &lt;RelativeLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:padding=&quot;8dp&quot;&gt;        &lt;ImageView            android:id=&quot;@+id/image_view&quot;            android:layout_width=&quot;50dp&quot;            android:layout_height=&quot;50dp&quot;            android:layout_marginEnd=&quot;8dp&quot;            android:src=&quot;@drawable/ic_baseline_android_24&quot; /&gt;        &lt;TextView            android:id=&quot;@+id/text_view_1&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_toEndOf=&quot;@+id/image_view&quot;            android:text=&quot;Line 1&quot;            android:textColor=&quot;@color/cardview_dark_background&quot;            android:textSize=&quot;18sp&quot; /&gt;        &lt;TextView            android:id=&quot;@+id/text_view_2&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_below=&quot;@+id/text_view_1&quot;            android:layout_toEndOf=&quot;@+id/image_view&quot;            android:text=&quot;Line 2&quot; /&gt;    &lt;/RelativeLayout&gt;&lt;/androidx.cardview.widget.CardView&gt;</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595735521036.png" alt=""></p><p>需要自定义的图片 ↓</p><p>选中”drawable”文件夹,选中”New”,选中”Vactor Asset”</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915232142.png" alt=""></p><p>选中”Clip Art” 选中喜欢的图形就可以了。点击 “Next”,再点击 Finish。 创建三个。</p><h3 id="需要-数据类👇"><a href="#需要-数据类👇" class="headerlink" title="需要 数据类👇"></a>需要 数据类👇</h3><p>在 “recyclerviewexample” 包下</p><pre><code>/** *   @DATE : 2020/7/26 *   @Time : 11:42 *   @By : TheCara *   &quot;data&quot; 数据类 */data class Exampleitem(val imageResource: Int, val text1: String, val text2: String)</code></pre><h3 id="需要适配器"><a href="#需要适配器" class="headerlink" title="需要适配器"></a>需要适配器</h3><p>需要适配器”ExampleAdapter”</p><pre><code>/** *   @DATE : 2020/7/27 *   @Time : 15:54 *   @By : TheCara *   需要继承RecyclerView.Adapter类型 *   需要内嵌类继承RecyclerView.ViewHolder类型 */class ExampleAdapter(private val exampleList: List&lt;ExampleItem&gt;) :    RecyclerView.Adapter&lt;ExampleAdapter.ExampleViewHolder&gt;() {    // 关键方法，用于确定列表项    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ExampleViewHolder {        val view = LayoutInflater.from(parent.context).inflate(R.layout.example_item, parent, false)        return ExampleViewHolder(view)    }    override fun getItemCount() = exampleList.size    // 将数据和容器绑定    override fun onBindViewHolder(holder: ExampleViewHolder, position: Int) {        val currenItem = exampleList[position]        holder.imageView.setImageResource(currenItem.imageResource)        holder.textView1.setText(currenItem.text1)        holder.textView2.setText(currenItem.text1)    }    // 获得每个控件的实例,需要ExampleViewHolder的参数(子项布局)作为RecyclerView.ViewHolder()用作实例化    class ExampleViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {        val imageView: ImageView = itemView.image_view        val textView1: TextView = itemView.text_view_1        val textView2: TextView = itemView.text_view_2    }}</code></pre><p>在”MainActivity”修改</p><pre><code>class MainActivity : AppCompatActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        val listExample = generateDummyList(500)        recycler_view.adapter = ExampleAdapter(listExample)        // 设置RecyclerView的布局管理器        recycler_view.layoutManager = LinearLayoutManager(this)        // 确保RecyclerView的尺寸是一个常数        recycler_view.setHasFixedSize(true)    }    // 获得布局中的数据    private fun generateDummyList(size: Int): List&lt;ExampleItem&gt; {        val list = ArrayList&lt;ExampleItem&gt;()        // 使⽤区间&quot;until&quot;        for (i in 0 until size) {            val drawable = when (i % 4) {                0 -&gt; R.drawable.ic_baseline_add_to_home_screen_24                1 -&gt; R.drawable.ic_baseline_airline_seat_flat_angled_24                2 -&gt; R.drawable.ic_baseline_airline_seat_recline_extra_24                else -&gt; R.drawable.ic_baseline_android_24            }            val item = ExampleItem(drawable, &quot;Line $i&quot;, &quot;Line 2&quot;)            list += item        }        return list    }}</code></pre><p>👆”setHasFixedSize()”方法:当我们确定Item的改变不会影响RecyclerView的宽高时,可以<strong>设置这个方法</strong>,并且Adapter的增删方法去刷新RecyclerView,而不是通过notifyDataSetChanged()。(其实可以直接设置为true，当需要改变宽高的时候就用notifyDataSetChanged()去整体刷新一下)</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595841353310.png" alt=""></p><h2 id="添加-增删-功能"><a href="#添加-增删-功能" class="headerlink" title="添加 增删 功能"></a>添加 增删 功能</h2><h2 id="使用RecyclerView在案例中需要什么"><a href="#使用RecyclerView在案例中需要什么" class="headerlink" title="使用RecyclerView在案例中需要什么"></a>使用RecyclerView在案例中需要什么</h2><ul><li>需要引入依赖</li><li>需要适配器</li><li>需要ItemLayout</li><li>需要数据类</li><li>控制器需要初始化</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
            <tag> RecyclerView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataBinding的使用</title>
      <link href="/2020/07/24/DataBinding%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/07/24/DataBinding%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="DataBinding-配合-LiveData-和-ViewModel-使用"><a href="#DataBinding-配合-LiveData-和-ViewModel-使用" class="headerlink" title="DataBinding 配合 LiveData 和 ViewModel 使用"></a>DataBinding 配合 LiveData 和 ViewModel 使用</h2><ol><li>需要创建MyViewModel类,继承ViewModel</li><li>需要添加DataBinding的gradle(app)配置信息</li></ol><p>添加配置信息 在gradle(app)中添加 ↓</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-25_10-40-29.png" alt=""></p><h4 id="创建MyViewModel-↓"><a href="#创建MyViewModel-↓" class="headerlink" title="创建MyViewModel ↓"></a>创建MyViewModel ↓</h4><pre><code>/** *   @DATE : 2020/7/24 *   @Time : 21:10 *   @By : TheCara *  负责处理界面数据 *  需要 LiveData 来观察数据刷新UI */class MyViewModel : ViewModel() {    var numberLiveData = MutableLiveData&lt;Int&gt;()    init {        numberLiveData.value = 0    }    // 加值    fun add() {        numberLiveData?.value = numberLiveData?.value?.plus(1)    }}</code></pre><h4 id="修改MainActivity-↓"><a href="#修改MainActivity-↓" class="headerlink" title="修改MainActivity ↓"></a>修改MainActivity ↓</h4><pre><code>/** 需要 ActivityMainBinding 类用来绑定数据* 需要 MyViewModel 来和 ActivityMainBinding 绑定数据* */class MainActivity : AppCompatActivity() {    var myViewModel: MyViewModel? = null    // 设置类型为可空类型    var activityMainBinding: ActivityMainBinding? = null    //ActivityMainBinding 是在DataBingding配置完成之后自动生成的    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        // 初始化DataBindingUtil,用来绑定布局        activityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main)        // 初始化数据类        var myViewModel = ViewModelProviders.of(this).get(MyViewModel::class.java)        activityMainBinding?.myViewModel=myViewModel        activityMainBinding?.lifecycleOwner = this    }}</code></pre><h4 id="布局-使用-“data”-标签-↓"><a href="#布局-使用-“data”-标签-↓" class="headerlink" title="布局 使用 “data” 标签 ↓"></a>布局 使用 “data” 标签 ↓</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595645673021.png" alt=""></p><p>需要 layout 布局保存布局,需要 “data “标签保存绑定来的数据,需要 “variable” 标签设置变量。</p><h4 id="需要使用-“-”-方式访问变量-↓"><a href="#需要使用-“-”-方式访问变量-↓" class="headerlink" title="需要使用 “@{}” 方式访问变量 ↓"></a>需要使用 “@{}” 方式访问变量 ↓</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595645903565.png" alt=""></p><h4 id="需要使用-“-参数-gt-方法-参数-”访问方法-↓"><a href="#需要使用-“-参数-gt-方法-参数-”访问方法-↓" class="headerlink" title="需要使用 “@{(参数)-&gt;方法(参数)}”访问方法 ↓"></a>需要使用 “@{(参数)-&gt;方法(参数)}”访问方法 ↓</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595645888188.png" alt=""></p><p>demo ↓</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595646636793.png" alt=""></p><h2 id="什么是DataBinding"><a href="#什么是DataBinding" class="headerlink" title="什么是DataBinding"></a>什么是DataBinding</h2><p>DataBinding是谷歌在2015年I/O开发者大会上发布的一个数据绑定框架,也就是把数据捆绑到UI上,DataBinding可以让Activity和Fragment减少逻辑,使其方便维护。同时也能提高性能,避免空指针异常,同时DataBinding也支持双向绑定,使UI的改变同时同步到数据上,DataBinding不是MVVM架构的必需品。</p><h2 id="DataBinding有哪些优缺点"><a href="#DataBinding有哪些优缺点" class="headerlink" title="DataBinding有哪些优缺点"></a>DataBinding有哪些优缺点</h2><p><strong>优点</strong></p><ol><li>减少Activity和Fragment的逻辑处理,使Activity和Fragment逻辑更加清晰。</li><li>提高性能,避免内存泄漏以及空指针</li><li>支持双向绑定,当View改变的时候会通知Model,当Model改变时会通知View</li></ol><p><strong>缺点</strong></p><ol><li>bug难定位,出现bug时无法定位到是View中的bug还是Model中的bug,又或是编写的逻辑bug。</li><li>双向绑定不利于View的复用</li></ol><p>引用:<a href="https://juejin.im/post/5edb12346fb9a047da364349#heading-2" target="_blank" rel="noopener">https://juejin.im/post/5edb12346fb9a047da364349#heading-2</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> DataBinding </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LiveData与ViewModel</title>
      <link href="/2020/07/20/LiveData/"/>
      <url>/2020/07/20/LiveData/</url>
      
        <content type="html"><![CDATA[<h4 id="单独使用LiveData"><a href="#单独使用LiveData" class="headerlink" title="单独使用LiveData"></a>单独使用LiveData</h4><ol><li>创建LiveData实例。持有特定的数据类型，例如 int ,String。</li><li>创建一个Observer对象,并且实现onChanged()方法。在onChanged()方法类可以进行UI的刷新等。</li><li>使用LiveData实例的observe(…,…)方法,将Observer对象添加到LiveData中。方法原型为 <strong>observe(LifecycleOwner owner,Observer observer)</strong>,第一个参数是LifecycleOwner对象，为LiveData能够监听生命周期的能力来源。第二个参数为我们的监听对象。</li></ol><p>添加LiveData和ViewModel的依赖 ↓</p><pre><code>// 添加LiveData和ViewModel的依赖implementation &#39;android.arch.lifecycle:extensions:1.1.1&#39;</code></pre><p>界面准备按钮用来开启,使得UI刷新 ↓</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-20_15-48-40.png" alt=""></p><p> MainActivity中的代码 ↓</p><pre><code>class MainActivity : AppCompatActivity() {    val TAG = &quot;MainActivity&quot;    val btnStart = btn_start    val mTvNumber = tv_number    var mNumberLiveData: MutableLiveData&lt;Int&gt;? = null // 声明变量    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        mNumberLiveData = MutableLiveData()        btnStart.setOnClickListener { view: View? -&gt;            thread {                var number = 0                while (number &lt; 5) {                    mNumberLiveData?.postValue(number)                    Log.d(TAG, &quot;setOnClickListener&quot; + number)                    Thread.sleep(3000)                    number++                }            }        }        mNumberLiveData?.observe(this, object : Observer&lt;Int&gt; {            override fun onChanged(t: Int?) {                mTvNumber.setText(&quot;&quot; + t)                Log.d(TAG, &quot;onChanged&quot; + t)            }        })    }}</code></pre><p>界面的TextView会根据数据进行刷新。</p><h4 id="单独使用ViewModel"><a href="#单独使用ViewModel" class="headerlink" title="单独使用ViewModel"></a>单独使用ViewModel</h4><ol><li>创建ViewModel的继承类</li><li>在控制器中实例化继承类</li></ol><p>创建ViewModel继承类 ↓</p><pre><code>class MyViewModel() : ViewModel() {    var number = 0}</code></pre><p>修改控制器 ↓</p><pre><code>class MainActivity : AppCompatActivity() {    val TAG = &quot;MainActivity&quot;    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        // ViewModelProvider.of() 获得MyViewModel持久类用来保存UI数据        // &quot;MyViewModel::class.java&quot; 反射引用类型        var myViewModel = ViewModelProviders.of(this).get(MyViewModel::class.java)        tv_number.setText(myViewModel.number.toString())        btn_start.setOnClickListener {            myViewModel.number++            tv_number.setText(myViewModel.number.toString())        }    }}</code></pre><p>简单的界面样式 ↓</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-21_19-16-39.png" alt=""></p><h4 id="LiveData和ViewModel配合使用"><a href="#LiveData和ViewModel配合使用" class="headerlink" title="LiveData和ViewModel配合使用"></a>LiveData和ViewModel配合使用</h4><ol><li>需要有ViewModel的继承类</li><li>需要在ViewModel的继承类中实例化LiveData类型</li><li>需要在控制器中初始化ViewModel的继承类</li><li>需要调用LiveData的observe的方法</li></ol><pre><code>class MyViewModel : ViewModel() {    var mutableLiveData = MutableLiveData&lt;Int&gt;()    init {        mutableLiveData.value=0    }    fun getLive(): MutableLiveData&lt;Int&gt; {        return mutableLiveData    }    fun addNumber(number: Int) {        mutableLiveData?.value=number+ mutableLiveData.value!!    }}</code></pre><pre><code>class MainActivity : AppCompatActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        // 获得MyViewModel实例        var myViewModel = ViewModelProviders.of(this).get(MyViewModel::class.java)        btn_addone.setOnClickListener {            myViewModel?.addNumber(1)        }        myViewModel?.getLive()?.observe(this, object : Observer&lt;Int&gt; {            override fun onChanged(t: Int?) {                tv_number.setText(t.toString())            }        })    }}</code></pre><h4 id="什么是LiveData"><a href="#什么是LiveData" class="headerlink" title="什么是LiveData"></a>什么是LiveData</h4><p>LiveData是一个可以观察的数据持有类,但是不同于通常的观察者,它具有声明周期的感知能力。通俗些讲,它所持有的数据发生改变时,并且Lifecycle对象还处于活跃状态,LiveData将立即通知观察者数据发生了变化。相比于不同的观察者它多了生命周期和感知能力。</p><h4 id="什么是ViewModel"><a href="#什么是ViewModel" class="headerlink" title="什么是ViewModel"></a>什么是ViewModel</h4><p>简单说ViewModel是一种用来存储和管理UI相关数据的类。但是与其他的Model不同的是,他支持在系统改变时保存数据。</p><p>当屏幕发生改变时,会导致Activity/Fragment重新绘制,会导致我们之前的数据丢失。比如,在EditText中输入了内容,但是当屏幕扭转时,会发现editText中的文本被清空了。</p><p>当对于一下简单的数据,我们可以通过Activity的onSaveInstanceState()方法中储存,然后通过onCreate()中进行恢复,但是这种方式只适合存储少量的数据，并且是能被序列化和反序列的数据。而对那些大量的数据则不适用。</p><p>此外,它也使View的数据持有者和Viewcontroller逻辑更加分离，便于解耦和测试。</p><p>引用:<a href="https://juejin.im/post/5ca9f9156fb9a05e3d0a8aea#heading-6" target="_blank" rel="noopener">https://juejin.im/post/5ca9f9156fb9a05e3d0a8aea#heading-6</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
            <tag> LiveData </tag>
            
            <tag> ViewModel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2020/07/19/git%E8%AE%BE%E7%BD%AE%E6%8F%90%E4%BA%A4%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F/"/>
      <url>/2020/07/19/git%E8%AE%BE%E7%BD%AE%E6%8F%90%E4%BA%A4%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="修改提交文件大小"><a href="#修改提交文件大小" class="headerlink" title="修改提交文件大小"></a>修改提交文件大小</h1><p>在要提交的项目根目录下使用。</p><pre><code>$ git config --local http.postBuffer 524288000</code></pre><p>设置为500MB。</p><h1 id="查看本地分支"><a href="#查看本地分支" class="headerlink" title="查看本地分支"></a>查看本地分支</h1><pre><code>git branch</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923155804.png" alt="本地的两个分支"></p><h1 id="查看远程仓库所有分支"><a href="#查看远程仓库所有分支" class="headerlink" title="查看远程仓库所有分支"></a>查看远程仓库所有分支</h1><pre><code>git branch -r</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923155838.png" alt="远程仓库的分支"></p><h1 id="查看本地仓库和远程仓库"><a href="#查看本地仓库和远程仓库" class="headerlink" title="查看本地仓库和远程仓库"></a>查看本地仓库和远程仓库</h1><pre><code>git branch -a</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923160933.png" alt="本地和远程共有仓库"></p><h1 id="创建本地分支"><a href="#创建本地分支" class="headerlink" title="创建本地分支"></a>创建本地分支</h1><pre><code>git branch annotationVersion</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923120947.png" alt="创建了本地分支"></p><h1 id="切换到创建的分支"><a href="#切换到创建的分支" class="headerlink" title="切换到创建的分支"></a>切换到创建的分支</h1><pre><code>git checkout 分支</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923121359.png" alt="切换到创建的 annotationVersion 分支"></p><h1 id="本地分支提交到远程分支"><a href="#本地分支提交到远程分支" class="headerlink" title="本地分支提交到远程分支"></a>本地分支提交到远程分支</h1><p><strong>切换到创建的分支</strong>（annotationVersion）。</p><pre><code>git push origin annotationVersion</code></pre><p>如果<strong>远程仓库</strong>没有这个分支，那么也会创建一个该分支。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923153643.png" alt="由于远程仓库没有本地的分支在push时自动创建了annotationVersion分支"></p><h1 id="本地获得一个远程分支"><a href="#本地获得一个远程分支" class="headerlink" title="本地获得一个远程分支"></a>本地获得一个远程分支</h1><p>使用命令</p><pre><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;例如git pull origin v1.0:v1.0</code></pre><p>pull 了<strong>远程仓库的v1.0分支</strong>本地命名<strong>为v1.0</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923172540.png" alt="pull 完成"></p><h1 id="合并本地两个分支"><a href="#合并本地两个分支" class="headerlink" title="合并本地两个分支"></a>合并本地两个分支</h1><p>如果当前分支（annotationVersion）分支，想与远程分支 master 合并（merge），可以使用如下命令：</p><p>切换到 master 分支：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923161205.png" alt="master分支"></p><p>在 master 分支合并另一个分支（annotationVersion）：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923161241.png" alt="合并完成"></p><p>随后可以将master分支 push 掉（用来提交两个合并了仓库）：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923161838.png" alt="push完成"></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-theme-matery使用手册</title>
      <link href="/2020/07/19/hexo-theme-%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
      <url>/2020/07/19/hexo-theme-%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h4 id="修改头部的渐变颜色"><a href="#修改头部的渐变颜色" class="headerlink" title="修改头部的渐变颜色"></a>修改头部的渐变颜色</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-19_18-44-57.png" alt=""></p><p>修改跟目录下的 themes\hexo-theme-matery\source\css\matery.css 文件。修改”bg-color”即可。</p><h4 id="修改底部的加载进度条"><a href="#修改底部的加载进度条" class="headerlink" title="修改底部的加载进度条"></a>修改底部的加载进度条</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-19_18-47-15.png" alt=""></p><p>修改”progress-bar”即可。</p><h4 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h4><p>下载插件,修改配置即可。</p><pre><code>npm install hexo-generator-search --save</code></pre><p>在根目录下安装插件。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-20_08-57-52.png" alt=""></p><p>修改配置信息。</p><p>打开根目录下的 “_config.yml”文件,添加配置信息。</p><pre><code>search:  path: search.xml  field: post</code></pre><h4 id="修改友情链接"><a href="#修改友情链接" class="headerlink" title="修改友情链接"></a>修改友情链接</h4><p>在 “Blog\source_data\friends.json” 目录下修改配置文件</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595649945373.png" alt=""></p><h4 id="自动添加文章的名称、时间等信息"><a href="#自动添加文章的名称、时间等信息" class="headerlink" title="自动添加文章的名称、时间等信息"></a>自动添加文章的名称、时间等信息</h4><p>需要创建文件 “scaffolds\post.md”</p><pre><code class="yaml">---title: {{ title }}date: {{ date }}tags: [标签]author: 用户名top: falsecover: falsetoc: truemathjax: truecategories: &quot;分类&quot;---</code></pre><h4 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a>完整实例</h4><p>👇修改文章封面,修改文章轮播图等</p><pre><code class="yaml">---title: {{title}}date: {{data}}author: 作者名字img: /source/images/xxx.jpg &quot;文章特征图,路径在source中&quot;top: true &quot;推荐文章&quot;cover: true &quot;表示该文章是否需要加入到首页轮播封面中&quot;coverImg: /images/1.jpg &quot;轮播图中的封面,访问的是&quot;source&quot;下的&quot;images&quot;&quot;password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: false &quot;是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项&quot;mathjax: false &quot;是否开启数学公式支持,本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行&quot;summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---</code></pre><h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><h2 id="备份和还原Blog"><a href="#备份和还原Blog" class="headerlink" title="备份和还原Blog"></a>备份和还原Blog</h2><h3 id="备份github创建私有仓库"><a href="#备份github创建私有仓库" class="headerlink" title="备份github创建私有仓库"></a>备份github创建私有仓库</h3><p>私有仓库设置为名字Blog(与文件夹名字相同即可),将文件下载到Blog的根目录下,将”.git”文件和”.gitignore”文件拖拽到Blog目录下。</p><p>‘’.gitignore’文件内添加要忽视的文件夹</p><pre><code>.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/</code></pre><p>正常提交即可</p><p>ps:可能会出现文件夹过大的原因 </p><p><a href="https://thecara.github.io/2020/07/19/git%E8%AE%BE%E7%BD%AE%E6%8F%90%E4%BA%A4%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F/">办法</a></p><h3 id="还原Blog"><a href="#还原Blog" class="headerlink" title="还原Blog"></a>还原Blog</h3><p>建议:使用新的电脑或者使用虚拟机来测试</p><p>安装git,配置git </p><p>使用”git Bash” 输入👇.</p><pre><code>$ git config --global user.name &quot;your name&quot;$ git config --global user.email &quot;your_email@youremail.com&quot;ssh-keygen -t rsa -C &quot;自己的邮箱&quot;</code></pre><p><a href="https://github.com/settings/ssh/new" target="_blank" rel="noopener">设置SHH</a></p><p>完成后会出现shh文件的目录,打开”.pub”类型文件将内容复制到这里。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595819104102.png" alt=""></p><p>完成后克隆我们的”Blog”</p><h3 id="安装nove-js"><a href="#安装nove-js" class="headerlink" title="安装nove.js"></a>安装nove.js</h3><p>在Blog目录下使用”git Bash”</p><p>直接安装 hexo,如果网络过慢建议配置仓库.</p><pre><code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p><a href="https://developer.aliyun.com/mirror/NPM" target="_blank" rel="noopener">更多</a></p><pre><code>npm i hexo-cli -g 或者 npm install hexo --save</code></pre><p>搭建</p><pre><code class="g">hexo ghexo shexo d</code></pre><p>ps:</p><p>如果出现 “ERROR Plugin load failed: hexo-prism-plugin”错误 直接删除”node_modules\hexo-prism-plugin”下的文件夹。</p><p>安装 nove.js 自动安装choco<a href="https://thecara.github.io/2020/07/26/choco%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%89%E8%A3%85/">可能会报错使用</a></p><p>引用:<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md</a></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在使用 目录导航时不建议 “标题” 配合 “无序列表” 使用</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-8-19-0.gif" alt=""></p><p>会出现无法跳转到指定目录。</p>]]></content>
      
      
      <categories>
          
          <category> hexo-theme </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> hexo-theme </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
