<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DASH协议</title>
      <link href="/2021/06/25/DASH/"/>
      <url>/2021/06/25/DASH/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-DASH"><a href="#什么是-DASH" class="headerlink" title="什么是 DASH"></a>什么是 DASH</h1><p>DASH（MPEG-DASH)是Dynamic Adaptive Straming over HTTP 的缩写，在国际标准MPEG 2014年份中推出的技术标准，目的是形成IP网络承载单一格式的流媒体并提供高效与高质量服务的统一方案，解决多制式传输方案（HTTP Live Streaming，Microsoft Smooth Streaming，HTTP Dynamic Streaming）并存格局下的存储与服务能力浪费、运营高成本与复杂度、系统间互操作弱等问题。</p><blockquote></blockquote><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://www.cnblogs.com/lidabo/p/13223961.html" target="_blank" rel="noopener">前端要懂的视频知识DASH协议</a></p>]]></content>
      
      
      <categories>
          
          <category> 流媒体 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Internet </tag>
            
            <tag> 流媒体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用shh推送文件</title>
      <link href="/2021/06/21/%E4%BD%BF%E7%94%A8shh%E6%8E%A8%E9%80%81%E6%96%87%E4%BB%B6/"/>
      <url>/2021/06/21/%E4%BD%BF%E7%94%A8shh%E6%8E%A8%E9%80%81%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="配置-SSH"><a href="#配置-SSH" class="headerlink" title="配置 SSH"></a>配置 SSH</h1><p>安装好 git 后生成SSH密钥对</p><pre><code class="sh">ssh-keygen -t rea -c &quot;你的邮箱@example.com&quot;</code></pre><p>默认（Windows）会在“用户/.ssh”文件下生成一对密钥，分别为 公钥，私钥。</p><p>私钥：id_rsa</p><p>公钥：id_rsa.pub</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210621185244.png" alt=""></p><p>打开获取<strong>公钥</strong></p><h1 id="在-github-上配置SSH"><a href="#在-github-上配置SSH" class="headerlink" title="在 github 上配置SSH"></a>在 github 上配置SSH</h1><p>登录你的 github 账号</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210621185412.png" alt="选择 Settings"></p><p>进入后点击 SSH and GPG kays</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210621185639.png" alt=""></p><p>选择 title 和 key</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210621185745.png" alt=""></p><p>添加完成后配对完成了。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210621185959.png" alt=""></p><p>输入</p><pre><code class="sh">ssh git@github.com</code></pre><p>其他操作和正常 推送，拉取一样更多的是少了验证密码。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络协议</title>
      <link href="/2021/06/05/network/"/>
      <url>/2021/06/05/network/</url>
      
        <content type="html"><![CDATA[<h1 id="网络层次划分"><a href="#网络层次划分" class="headerlink" title="网络层次划分"></a>网络层次划分</h1><p>为促使不同计算机厂家生产的计算机能够相互通信，以便建立更大范围的计算机网络，国际标准化组织（ISO）于 1978 年提出了“开放系统互联参考模型”，即OSI/RM模型（Open System Interconnection/Reference Model）。将计算机网络结构的通讯协议划分为七层，由：物理层（Physics Layer）、数据链路层（Data Link Layer）、网络层（Network Layer）、传输层（Transport Layer）、会话层（Session Layer）、表示层（Presentation Layer）、应用层（Application Layer）。其中传输层完成数据传送服务。</p><table><thead><tr><th>OSI 七层网络模型</th><th>TCP/IP四层概念模型</th><th>对应网络协议</th></tr></thead><tbody><tr><td>应用层（Application）</td><td>应用层</td><td>HTTP、TFTP、FTP、NFS、WAIS、SMTP</td></tr><tr><td>表示层（Presentation）</td><td>应用层</td><td>Telent、Rlogin、SNMP、Gopher</td></tr><tr><td>会话层（Session）</td><td>应用层</td><td>SMTP、DNS</td></tr><tr><td>传输层（Transport）</td><td>传输层</td><td>TCP、UDP、</td></tr><tr><td>网络层（Network）</td><td>网络层</td><td>IP、ICMP、ARP、RARP、AKP、UUCP</td></tr><tr><td>数据链路层（Data Link）</td><td>数据链路层</td><td>FDDI、Ethernet、Arpanet、PDN、SLIP、PPP</td></tr><tr><td>物理层（Physical）</td><td>数据链路层</td><td>IEEE 802.1A，IEEE 802.2 到 IEEE802.11</td></tr></tbody></table><p>1.<strong>物理层（Physical Layer）</strong></p><p><strong>物理层确保原始的数据可在各种物理媒体上传输。</strong></p><p>2.<strong>数据链路层（Data Link Layer）</strong></p><ul><li>数据链路层为网络层提供可靠的数据传输；</li><li>基本数据单位为帧</li><li>主要的协议：以太网协议；</li><li>两个重要设备名称：网桥和交换机。</li></ul><p>3.<strong>网络层（Network Layer）</strong></p><p>网络层的目的是实现两个端系统之间的数据同名传输，具体功能包括寻址和路由选择、链接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。</p><ul><li><p>网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网络互连等功能；</p></li><li><p>基本数据单位IP数据包；</p></li><li><p>包含主要协议：</p><p>IP协议（Internet Protocol，因特网互联协议）；</p><p>ICMP 协议（Internet Control Message Protocal，因特网控制报文协议）；</p><p>ARP 协议 （Address Resolution Protocal ，地址解析协议）；</p><p>RARP协议 （Reverse Address Resolution Protocal，逆地址解析协议）。</p></li><li><p>重要设备：路由器。</p></li></ul><h1 id="Socket-编程"><a href="#Socket-编程" class="headerlink" title="Socket 编程"></a>Socket 编程</h1><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>socket 意为“插座”，计算机领域称为“套接字”，它是计算机之间进行通讯的一种约定或一种方式，一台计算机可以接收其他计算机的数据，也可以向其它计算机发送数据。</strong></p><p>Socket 是网络编程的一个抽象概念。通常一个Socket表示“打开一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再选择协议类型。</p><p>在 socket 的案例中，服务器与浏览器：在浏览器获取用户的URL后，向服务器发送请求，服务器分析接收到的URL，将对应的网页内容返回到浏览器（客户端），浏览器再解析和渲染，将文字、图片、视频等元素呈现给用户。</p><h4 id="UNIX-Linux-中的socket！"><a href="#UNIX-Linux-中的socket！" class="headerlink" title="UNIX/Linux 中的socket！"></a>UNIX/Linux 中的socket！</h4><p>在系统中，为了统一各种硬件的操作，并简化接口，不同的硬件设备也被看成一个文件。对这些文件的操作，等同于对磁盘上普通文件的操作。</p><p>在UNIX/和Linux中会给每个文件分配一个ID，这个ID就是一个整数，被称为 文件描述符（File Descriptor）。例如：</p><ul><li>0表示一个标准输入文件（stdin），它对应的硬件设备就是键盘；</li><li>1表示一个标准输出文件（stdout），它对应的设备就是显示器；</li></ul><p>UNIX/Linux程序在执行任何形式的I/O操作时，都是在读取或者写入一个文件描述符。文件描述符是一个和打开文件相关联的整数，它背后可能是一个硬盘上的普通文件、FIFO、管道、终端、键盘、显示且等，或者网络连接。</p><p><strong>网络连接也是一个文件，它也有文件描述符！</strong></p><p>可以通过socket()函数来创建一个网络连接，或者说打开一个网络文件，socket()的返回值就是文件描述，我们可以通过普通的文件操作函数来传输数据了。</p><ul><li>用read()读取从远程计算机传来的数据；</li><li>用write()向远程计算机写入数据；</li></ul><p>使用socket()创建连接后，剩下的就是文件操作了。</p><h4 id="WIndows系统中的Socket"><a href="#WIndows系统中的Socket" class="headerlink" title="WIndows系统中的Socket()!"></a>WIndows系统中的Socket()!</h4><p>Windows 中的“文件描述符”被称为“文件句柄”。</p><p>Windows不会把Socket当作文件，会把它当作一个网络连接来对待，因此需要调用专门针对socket而设计的数据传输函数，这里就用不到针对文件操作的函数了。</p><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>在创建 TCP 连接时主动发起的叫客户端，被动响应的叫服务器。</p><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><p>服务器编程需要服务器进程绑定一个端口来监听来自其他客户端的连接。当某个客户端连接时，服务器就与该客户端建立Socket连接，随后的通讯就靠这个Socket连接。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a><strong>引用</strong></h1><p><a href="https://www.runoob.com/w3cnote/summary-of-network.html" target="_blank" rel="noopener">计算机网络基础知识总结</a> </p><p><a href="http://c.biancheng.net/view/2123.html" target="_blank" rel="noopener">socket是什么？套接字是什么？</a></p>]]></content>
      
      
      <categories>
          
          <category> Internet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Internet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于链式调用</title>
      <link href="/2021/03/19/%E5%85%B3%E4%BA%8E%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/"/>
      <url>/2021/03/19/%E5%85%B3%E4%BA%8E%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是链式调用"><a href="#什么是链式调用" class="headerlink" title="什么是链式调用"></a>什么是链式调用</h1><p>当调用的样式为这样时。</p><blockquote><p>可以不受限制的通过”.”操作符调用方法。</p><pre><code class="java">a.b().c()</code></pre><p>此方法起源于 java8</p></blockquote><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><blockquote><p>每个方法返回对象本身即可</p><pre><code class="java">public class Book{    private String name;    private String author;    public static create(){        return new Student();    }    public void setName(String name){        this.name = name;     }    public void setAuthor(String author){        this.age = age;     }    public Student name(String name){        this.name = name;         return this;    }    public Student author(String author){        this.author = author;         return this;    }}</code></pre><pre><code class="java">/*    调用    */public class Main{    public static void main(String[] ages){        Book b = new Book()        b.setName(&quot;链式调用&quot;)        b.setAuthor(&quot;TheCara&quot;)        Book b2 = Book.create().name(&quot;集合&quot;).author(&quot;网友&quot;)    }}</code></pre><p><strong>优缺点</strong></p><p>优：方法关系联系紧密，简洁。</p><p>缺：方法之间依赖于上一个方法，返回空指针会报错。</p></blockquote><h1 id="静态使用"><a href="#静态使用" class="headerlink" title="静态使用"></a>静态使用</h1><p>引用：</p><p><a href="https://blog.ahao.moe//posts/what_is_Methods_Chaining_in_Java.html" target="_blank" rel="noopener"><strong>什么是链式调用</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android PendingIntent</title>
      <link href="/2020/12/07/Android-PendingIntent/"/>
      <url>/2020/12/07/Android-PendingIntent/</url>
      
        <content type="html"><![CDATA[<h1 id="PendingIntent"><a href="#PendingIntent" class="headerlink" title="PendingIntent"></a>PendingIntent</h1><blockquote><p>描述</p><p>A description of an Intent and target action to perform with it. Instances of this class are created with <code>getActivity</code>, <code>getActivities</code>, <code>getBroadcast</code>, and <code>getService</code>; the returned object can be handed to other applications so that they can perform the action you described on your behalf at a later time.</p><p>它由getActivity，getService，getBroadcast来创建对象。</p><p>用于一种特殊的异步处理机制。可归结为 “异步激发”，这种异步激发常常是要跨进程执行的。比如说 A进程作为发起段，它可以从系统获得一个PendingIntent，然后A进程可以将PendingIntent对象通过binder机制“传递“给B进程，再通过B进程在未来的某个合适时机，”回调“PendingIntent对象的send()动作，完成激发。</p><p>PendingIntent的生命周期不与主进程相关。外部程序只能调用上述三个组件。</p></blockquote><h4 id="getActivity"><a href="#getActivity" class="headerlink" title="getActivity"></a>getActivity</h4><pre><code class="kotlin">static fun getActivity(    context: Context!,     requestCode: Int,     intent: Intent!,     flags: Int): PendingIntent!</code></pre><blockquote><p>Retrieve a PendingIntent that will start a new activity, like calling <code>Context#startActivity(Intent)</code>. Note that the activity will be started outside of the context of an existing activity, so you must use the <code>Intent#FLAG_ACTIVITY_NEW_TASK</code> launch flag in the Intent.</p><p>获得一个用于启动特定Activity的PendingIntent。</p></blockquote><h4 id="三个返回需要用到的参数"><a href="#三个返回需要用到的参数" class="headerlink" title="三个返回需要用到的参数"></a>三个返回需要用到的参数</h4><ul><li>context：上下文对象</li><li>requstCode：请求码，发件人的私人请求代码（当前未使用）</li><li>intent：请求意图。用于要指明要启动的类以及数据的传递</li><li>flags：这是一个关键的标志位</li></ul><h4 id="flags常量"><a href="#flags常量" class="headerlink" title="flags常量"></a>flags常量</h4><p>FLAG_CANCEL_CURRENT</p><pre><code class="kotlin">static val FLAG_CANCEL_CURRENT: Int</code></pre><blockquote><p>Flag indicating that if the described PendingIntent already exists, the current one should be canceled before generating a new one. For use with <code>getActivity</code>, <code>getBroadcast</code>, and <code>getService</code>.</p><p>如果新请求的 PendingIntent 发现已经存在时，取消已存在的，用新的 PendingInent 替换</p></blockquote><p>FLAG_IMMUTABLE</p><pre><code class="kotlin">static val FLAG_IMMUTABLE: Int</code></pre><blockquote><p>Flag indicating that the created PendingIntent should be immutable. This means that the additional intent argument passed to the send methods to fill in unpopulated properties of this intent will be ignored.</p><p>表示这是一个不可变的 PendingIntent。</p></blockquote><p>FLAG_NO_CREATE</p><pre><code>static val FLAG_NO_CREATE: Int</code></pre><blockquote><p>Flag indicating that if the described PendingIntent does not already exist, then simply return null instead of creating it. For use with <code>getActivity</code>, <code>getBroadcast</code>, and <code>getService</code>.</p><p>如果新请求的 PendingIntent 发现已经存在时，忽视新请求的，继续使用已经存在的请求。较少使用。</p></blockquote><p>FLAG_ONE_SHOT</p><pre><code class="kotlin">static val FLAG_ONE_SHOT: Int</code></pre><blockquote><p>Flag indicating that this PendingIntent can be used only once. For use with <code>getActivity</code>, <code>getBroadcast</code>, and <code>getService</code>.</p><p>表示 PendingIntent 只能使用一次，如果已经使用过，那么 getxxx方法时会返回为NULL，也就是说同类通知只能使用一次，后续的通知单独后无法打开。</p></blockquote><p>FLAG_UPDATE_CURRENT</p><pre><code>static val FLAG_UPDATE_CURRENT: Int</code></pre><blockquote><p>Flag indicating that if the described PendingIntent already exists, then keep it but replace its extra data with what is in this new Intent. For use with <code>getActivity</code>, <code>getBroadcast</code>, and <code>getService</code>.</p><p>如果新的请求的PendingIntent 发现已经存在时，如果 Intent 有字段改变了，则更新已存在的 PendingIntent</p></blockquote><h4 id="引用"><a href="#引用" class="headerlink" title="引用:"></a>引用:</h4><p><a href="https://developer.android.com/reference/kotlin/android/app/PendingIntent" target="_blank" rel="noopener">PendingIntent</a></p><p><a href="https://www.jianshu.com/p/a37f0ce2da2e" target="_blank" rel="noopener">PendingIntent的基本理解</a></p><p><a href="https://www.jianshu.com/p/4a8fc0b78094" target="_blank" rel="noopener">Android PendingIntent</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android-PackageManager</title>
      <link href="/2020/12/07/PackageManager/"/>
      <url>/2020/12/07/PackageManager/</url>
      
        <content type="html"><![CDATA[<h1 id="PackageManager"><a href="#PackageManager" class="headerlink" title="PackageManager"></a>PackageManager</h1><blockquote><p>Class for retrieving various kinds of information related to the application packages that are currently installed on the device. You can find this class through <code>Context#getPackageManager</code>.</p><p>PackageManager 负责管理应用程序安装、卸载和升级的API。</p></blockquote><h4 id="getLaunchIntentForPackage"><a href="#getLaunchIntentForPackage" class="headerlink" title="getLaunchIntentForPackage"></a>getLaunchIntentForPackage</h4><pre><code class="kotlin">abstract fun getLaunchIntentForPackage(packageName: String): Intent?</code></pre><blockquote><p>Returns a “good” intent to launch a front-door activity in a package. This is used, for example, to implement an “open” button when browsing through packages. The current implementation looks first for a main activity in the category <code>Intent#CATEGORY_INFO</code>, and next for a main activity in the category <code>Intent#CATEGORY_LAUNCHER</code>. Returns <code>null</code> if neither are found.</p><p>负责获得应用程序Launch的Intent。</p><p>返回一个“包”中的入口Activity的Intent，例如，这个类似于在浏览包的“打开”按钮。这个当前的安装启动第一步在category(CATEGORY_INFO)中寻找main Activity，然后category(CATEGORY_LAUNCHER)寻找main Activity。如果找不到返回 null。</p></blockquote><h5 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h5><p><a href="https://developer.android.com/reference/kotlin/android/content/pm/PackageManager" target="_blank" rel="noopener">PackageManager</a></p><p><a href="https://www.jianshu.com/p/c56376916d5e" target="_blank" rel="noopener">APK安装流程详解2——PackageManager简介</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android媒体media包</title>
      <link href="/2020/12/02/Android%E5%AA%92%E4%BD%93media%E5%8C%85/"/>
      <url>/2020/12/02/Android%E5%AA%92%E4%BD%93media%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<blockquote><p>所属 android.support.v4.media包下 </p></blockquote><h1 id="媒体浏览器服务-MediaBrowserService"><a href="#媒体浏览器服务-MediaBrowserService" class="headerlink" title="媒体浏览器服务 MediaBrowserService"></a>媒体浏览器服务 MediaBrowserService</h1><h4 id="关键类型"><a href="#关键类型" class="headerlink" title="关键类型"></a>关键类型</h4><ol><li>MediaBrowserServiceCompat 媒体浏览器服务</li><li>MediaBrowserCompat 媒体浏览器</li><li>MediaControllerCompat 媒体控制器</li><li>MediaSessionCompat 媒体会话</li></ol><h1 id="MediaBrowserServiceCompat"><a href="#MediaBrowserServiceCompat" class="headerlink" title="MediaBrowserServiceCompat"></a>MediaBrowserServiceCompat</h1><blockquote><p>作用</p><p>音乐播放后台服务。</p><p>客户端中获取音乐数据的服务，所有的音乐数据都通过该服务与服务端进行交互获取。</p></blockquote><p>该类是Service类的子类，可以作为一个后台服务来使用，它实现后台服务并不能通过自身直接实现，而是通过MediaSessionCompat媒体会话来实现的。在使用过程中会话会与该服务关联起来，所有的播放操作都要给MediaSessionCompat实现。</p><p>获得数据时，通过 <strong>MediaBrowserServiceCompat</strong> 的两个方法来实现控制</p><pre><code class="kotlin">@Nullable abstract fun onGetRoot(    @NonNull clientPackageName: String,     clientUid: Int,     @Nullable rootHints: Bundle?): MediaBrowserServiceCompat.BrowserRoot?</code></pre><blockquote><p>调用以获取特定客户端浏览的根信息。</p><p>此方法自在服务连接时调用，如果返回一个 rootId为空的BrowserRoot则表示客户端可以连接服务，也可以连接其媒体资源</p><p>如果返回null则表示客户端不能连接媒体资源</p></blockquote><pre><code class="kotlin">abstract fun onLoadChildren(    @NonNull parentId: String,     @NonNull result: MediaBrowserServiceCompat.Result&lt;MutableList&lt;MediaBrowserCompat.MediaItem!&gt;!&gt;): Unit</code></pre><blockquote><p>来获取有关媒体项目的子信息。</p><p>此方法中的 parentId 与上面的方法 onGetRoot 中返回的RootId没有关系，客户端连接后，它可以通过重复调用MediaBrowserCompat.subscribe()方法来发起数据请求。而每次调用subscribe()方法都会返回onLoadChildren()回调到该service中，然后返回MediaBrowser.MediaItem()对象列表</p><p>每个MediaItem都有唯一的Id字符串，它其实是一个隐式的token。当客户想打开子菜单或者播放item时，它就将ID传入。</p></blockquote><h1 id="MediaBrowserServiceCompat-BrowserRoot-抽象类"><a href="#MediaBrowserServiceCompat-BrowserRoot-抽象类" class="headerlink" title="MediaBrowserServiceCompat.BrowserRoot 抽象类"></a>MediaBrowserServiceCompat.BrowserRoot 抽象类</h1><blockquote><p>包含浏览器首次连接客户端的信息。</p></blockquote><table><thead><tr><th align="center">修饰符</th><th align="center">（构造）方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"></td><td align="center">MediaBrowserServiceCompat.BrowserRoot(String rootId,Bundle extras)</td><td align="center">rootId：浏览的根ID。extras：浏览器的附加功能。</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="MediaBrowserServiceCompat-Result-类"><a href="#MediaBrowserServiceCompat-Result-类" class="headerlink" title="MediaBrowserServiceCompat.Result 类"></a>MediaBrowserServiceCompat.Result 类</h1><blockquote><p>异步回调方法的完成处理程序</p></blockquote><table><thead><tr><th align="center">修饰符</th><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">sendResult(T result)</td><td align="center">将结果发送给调用者</td></tr><tr><td align="center">void</td><td align="center">detach()</td><td align="center">分离线程消息，并允许稍后进行sendResult(T)调用。</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="MediaBrowserCompat"><a href="#MediaBrowserCompat" class="headerlink" title="MediaBrowserCompat"></a>MediaBrowserCompat</h1><h2 id="MediaBrowserCompat-MediaItem常量"><a href="#MediaBrowserCompat-MediaItem常量" class="headerlink" title="MediaBrowserCompat.MediaItem常量"></a>MediaBrowserCompat.MediaItem常量</h2><blockquote><p>一个包含单个媒体项目信息的类，用于浏览媒体。</p></blockquote><p><strong>常量</strong></p><h3 id="FLAG-PLAYABLE"><a href="#FLAG-PLAYABLE" class="headerlink" title="FLAG_PLAYABLE"></a>FLAG_PLAYABLE</h3><pre><code class="java">int FLAG_PLAYABLE</code></pre><p>标志：表示该项目可以播放。</p><h3 id="FLAG-BROWSABLE"><a href="#FLAG-BROWSABLE" class="headerlink" title="FLAG_BROWSABLE"></a>FLAG_BROWSABLE</h3><pre><code>int FLAG_BROWSABLE</code></pre><p>标志：表示该项目有其自己的子项。</p><h1 id="MediaControllerCompat-类"><a href="#MediaControllerCompat-类" class="headerlink" title="MediaControllerCompat 类"></a>MediaControllerCompat 类</h1><blockquote><p>属于 media.session 包下。</p><p>允许应用与正在进行的媒体会话进行互动。</p></blockquote><table><thead><tr><th align="center">方法名</th><th align="center">参数</th><th align="center">描述</th><th align="center">返回值</th></tr></thead><tbody><tr><td align="center">getMetadata</td><td align="center">无</td><td align="center">获取此会话的当前元数据。</td><td align="center">返回MediadataCompat类</td></tr><tr><td align="center">getSessionActivity</td><td align="center">无</td><td align="center">获得与启动会话关联的用户界面的意图（如果存在的话）</td><td align="center">PendingIntent意图或者null</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="MediaSessionCompat-类"><a href="#MediaSessionCompat-类" class="headerlink" title="MediaSessionCompat 类"></a>MediaSessionCompat 类</h1><blockquote><p>Allows interaction with media controllers, volume keys, media buttons, and transport controls.</p><p>允许与媒体控制器，音量键，媒体按钮和传输控件进行交互。</p><p>当应用程序想要发布媒体播放信息或处理媒体密钥时，应创建MediaSession。 一般来说，一个应用程序只需要一个会话进行所有播放，但可创建多个会话来提供更精细的媒体控制。</p><p>一旦创建会话，会话的所有者可以将其 <code>session token</code>传递给其他进程，以允许他们创建 <code>MediaControllerCompat</code>与会话进行交互。</p><p>要接收命令，媒体密钥和其他事件， <code>MediaSessionCompat.Callback</code>必须使用 <code>setCallback(Callback)</code>进行设置。</p><p>当应用程序完成播放时，它必须调用 <code>release()</code>来清理会话并通知任何控制器。</p><p>MediaSessionCompat对象不是线程安全的，所有调用都应该使用同一个线程。</p><p>这是帮助您以向后兼容的方式访问API级别4之后引入的 <code>MediaSession</code>功能。</p><p>ps:摘自 <a href="https://www.apiref.com/android-zh/android/support/v4/media/session/MediaSessionCompat.html" target="_blank" rel="noopener">apiref</a></p></blockquote><p><strong>构造方法</strong></p><p><strong>MediaSessionCompat</strong></p><pre><code>MediaSessionCompat(@NonNull context: Context, @NonNull tag: String)</code></pre><blockquote><p>Creates a new session. You must call <code>release()</code> when finished with the session.</p><p>创建对象。在完成时要调用release()释放。</p><p>参数1：创建Session的上下文</p><p>参数2：调试时所用的 tag。</p></blockquote><p><strong>MediaSessionCompat</strong></p><pre><code>MediaSessionCompat(@NonNull context: Context, @NonNull tag: String, @Nullable mbrComponent: ComponentName?, @Nullable mbrIntent: PendingIntent?)</code></pre><blockquote><p>Creates a new session with a specified media button receiver (a component name and/or a pending intent). You must call <code>release()</code> when finished with the session.</p><p>指定一个媒体接收器来创建对象。在完成时要调用release()释放。</p><p>参数1：创建Session的上下文</p><p>参数2：调试时所用的 tag。</p><p>参数3：指定媒体接收器的名称</p><p>参数4：处理媒体按钮事件的接收器组件。可选选项。</p></blockquote><p><strong>setSessionToken</strong></p><pre><code>open fun setSessionToken(token: MediaSessionCompat.Token!): Unit</code></pre><blockquote><p>Call to set the media session.</p><p>This should be called as soon as possible during the service’s startup. It may only be called once.</p><p>呼叫设置媒体会话。</p><p>这应该在服务启动期间尽快调用。 它只能被调用一次。</p></blockquote><p><strong>getSessionToken</strong></p><pre><code>@Nullable open fun getSessionToken(): MediaSessionCompat.Token?</code></pre><blockquote><p>Gets the session token, or null if it has not yet been created or if it has been destroyed.</p><p>获取会话标记，如果尚未创建或已销毁它，则为null。</p></blockquote><p><strong>setSessionActivity</strong></p><p>PendingInten pi：启动到这个会话。</p><pre><code>void setSessionActivity (PendingIntent pi)    </code></pre><blockquote><p>为此会话设置启动用户界面的意图。 这可以用作到正在进行的媒体屏幕的快速链接。 意图应该是针对可能使用<code>startActivity(Intent)</code>开始的活动。</p></blockquote><h1 id="MediaSessonCompat-Token类"><a href="#MediaSessonCompat-Token类" class="headerlink" title="MediaSessonCompat.Token类"></a>MediaSessonCompat.Token类</h1><p>运行中的Token。表示可能会被会话的所有者传递给应用程序，以允许创建一个MediaControllerCompat与会话进行通信。</p><h1 id="MediaMetadataCompat"><a href="#MediaMetadataCompat" class="headerlink" title="MediaMetadataCompat"></a>MediaMetadataCompat</h1><blockquote><p>包含有关项目的元数据，例如标题，艺术家等</p></blockquote><p><strong>各个常量</strong></p><table><thead><tr><th align="center">类型</th><th></th></tr></thead><tbody><tr><td align="center">string</td><td><code>METADATA_KEY_ALBUM</code>媒体专辑标题。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_ALBUM_ART</code>媒体原始资料专辑的作品为 <code>Bitmap</code> 。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_ALBUM_ARTIST</code>媒体原始资料专辑的艺术家。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_ALBUM_ART_URI</code>作为Uri风格字符串的媒体原始源相册的图片。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_ART</code>媒体作品为 <code>Bitmap</code> 。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_ARTIST</code>媒体艺术家。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_ART_URI</code>媒体的作品是Uri风格的字符串。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_AUTHOR</code>媒体的作者。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_COMPILATION</code>媒体的编辑状态。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_COMPOSER</code>媒体的作曲家。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_DATE</code>媒体创建或发布的日期。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_DISC_NUMBER</code>媒体原始来源的光盘号码。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_DISPLAY_DESCRIPTION</code>适合向用户显示的说明。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_DISPLAY_ICON</code>适合向用户显示的图标或缩略图。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_DISPLAY_ICON_URI</code>适合向用户显示的图标或缩略图。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_DISPLAY_SUBTITLE</code>适合向用户显示的字幕。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_DISPLAY_TITLE</code>适合向用户显示的标题。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_DURATION</code>媒体的持续时间以毫秒为单位。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_GENRE</code>媒体的流派。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_MEDIA_ID</code>用于识别内容的字符串键。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_NUM_TRACKS</code>媒体原始来源中的曲目数量。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_RATING</code>媒体整体评分。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_TITLE</code>媒体的标题。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_TRACK_NUMBER</code>媒体的曲目号码。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_USER_RATING</code>用户对媒体的评分。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_WRITER</code>媒体的作者。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_YEAR</code>媒体创建或发布的一年。</td></tr></tbody></table><table><thead><tr><th align="center">方法名</th><th align="center">参数</th><th align="center">描述</th><th align="center">返回值</th></tr></thead><tbody><tr><td align="center">getDescription</td><td align="center">无</td><td align="center">为显式，返回次元数据的简单描述</td><td align="center">MediaDescriptionCompat</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="PlaybackStateCompat-类"><a href="#PlaybackStateCompat-类" class="headerlink" title="PlaybackStateCompat 类"></a>PlaybackStateCompat 类</h1><blockquote><p>存放状态的常量类</p></blockquote><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_FAST_FORWARD</code>表示此会话支持快进命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_PAUSE</code>表示此会话支持暂停命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_PLAY</code>表示此会话支持播放命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_PLAY_FROM_MEDIA_ID</code>表示此会话支持从媒体id命令播放。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_PLAY_FROM_SEARCH</code>表示此会话支持来自搜索命令的播放。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_PLAY_FROM_URI</code>表示此会话支持来自URI命令的播放。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_PLAY_PAUSE</code>表示此会话支持播放/暂停切换命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_PREPARE</code>表示此会话支持prepare命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_PREPARE_FROM_MEDIA_ID</code>指示此会话支持从媒体id命令准备。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_PREPARE_FROM_SEARCH</code>表示此会话支持从搜索命令准备。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_PREPARE_FROM_URI</code>表示此会话支持从URI准备命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_REWIND</code>表示此会话支持倒带命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_SEEK_TO</code>表示此会话支持寻求命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_SET_RATING</code>表示此会话支持set rating命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_SKIP_TO_NEXT</code>表示此会话支持下一个命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_SKIP_TO_PREVIOUS</code>指示此会话支持上一个命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_SKIP_TO_QUEUE_ITEM</code>表示此会话支持跳转到队列项目命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_STOP</code>表示此会话支持停止命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>PLAYBACK_POSITION_UNKNOWN</code>使用此值表示位置未知。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>STATE_BUFFERING</code>指示此项目的状态当前正在缓冲，并且将在足够的数据已经缓冲时开始播放。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>STATE_CONNECTING</code>指示正在进行回放的班级的状态当前正在连接到路线。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>STATE_ERROR</code>指示此项目的状态当前处于错误状态。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>STATE_FAST_FORWARDING</code>指示此项目的状态当前正在快进。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>STATE_NONE</code>这是默认的播放状态，表示尚未添加媒体，或者表演者已重置且没有要播放的内容。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>STATE_PAUSED</code>指示此项目的状态当前已暂停。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>STATE_PLAYING</code>指示此项目正在播放的状态。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>STATE_REWINDING</code>指示此项目的状态当前正在倒带。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>STATE_SKIPPING_TO_NEXT</code>表示玩家正在跳到下一个项目的状态。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>STATE_SKIPPING_TO_PREVIOUS</code>显示玩家当前正在跳到前一个项目的状态。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>STATE_SKIPPING_TO_QUEUE_ITEM</code>指示玩家当前正在跳到队列中特定项目的状态。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>STATE_STOPPED</code>指示此项目的状态当前已停止。</td></tr></tbody></table><h1 id="ServiceCompat"><a href="#ServiceCompat" class="headerlink" title="ServiceCompat"></a>ServiceCompat</h1><p>Helper用于访问在向后兼容的API级别4之后引入的 <code>Service</code>功能。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="">关于媒体浏览器服务(MediaBrowserService)</a></p><p><a href="https://www.apiref.com/android-zh/index.html" target="_blank" rel="noopener">Android开发手册</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ExoPlayer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 图片适配</title>
      <link href="/2020/12/01/Android-%E5%9B%BE%E7%89%87%E9%80%82%E9%85%8D/"/>
      <url>/2020/12/01/Android-%E5%9B%BE%E7%89%87%E9%80%82%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>Android图片适配</p><p>android的drawable文件共有：</p><table><thead><tr><th>中文</th><th>文件夹名称</th></tr></thead><tbody><tr><td>低密度</td><td>drawable-ldpi</td></tr><tr><td>中等密度</td><td>drawable-mdpi</td></tr><tr><td>高密度</td><td>drawable-hdpi</td></tr><tr><td>超高密度</td><td>drawable-xhdpi</td></tr><tr><td>超超高密度</td><td>drawable-xxhdpi</td></tr><tr><td>超超超高密度</td><td>drawable-xxxhdpi</td></tr><tr><td>无缩放</td><td>drawable-nohdpi</td></tr><tr><td>默认</td><td>drawable</td></tr></tbody></table><p>Android 系统会按照设备dpi 范围从合适密度往上适配。</p><p>如果在中等分辨率的手机上，Android 就会现在 drawable-mdpi 文件夹下的图片。如果这里没有那么 drawable-hdpi 上查找以此类推最终会从默认的 drawable 文件夹下查找。</p><p>drawable-nodpi 文件夹，在这里存放的图片系统不会对它进行缩放操作，原图片有多大就会展示多大，匹配原则当匹配更高密度的图片时无法找到的话就会匹配这个文件夹的图片。</p><p>优缺点：放大图片会占用更多内存，缩小时内存减少但是影响打包效果。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android控件</title>
      <link href="/2020/11/29/Android%E6%8E%A7%E4%BB%B6/"/>
      <url>/2020/11/29/Android%E6%8E%A7%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="SeekBar-拖动条"><a href="#SeekBar-拖动条" class="headerlink" title="SeekBar(拖动条)"></a>SeekBar(拖动条)</h1><p>它是 ProgressBar的子类，这样ProgressBar的属性它都可以用！同时它还有自己的属性 android:thumb,允许我们自定义滑块。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Jetpack架构组件 Navigation 导航库</title>
      <link href="/2020/11/20/Navigation-%E5%AF%BC%E8%88%AA%E5%BA%93/"/>
      <url>/2020/11/20/Navigation-%E5%AF%BC%E8%88%AA%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="做什么的？"><a href="#做什么的？" class="headerlink" title="做什么的？"></a>做什么的？</h1><p>用于用户导航、进入或者退出应用中不同内容片段的交互。通过 Jetpack导航组件可帮助你实现导航，无论是简单的按钮点击，还是应用栏或抽屉式导航栏等复杂的模式，这个组件都可以应对。（简化了导航的实现）</p><p>将业务和视图分离。</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li>方便管理Fragment页面。</li><li>可视化页面导航，类似于xcode中的StoryBoard，便于看清页面之间的关系</li><li>通过destination和action来完成页面间的导航</li><li>方便页面切换动画</li><li>页面间内饰内饰的参数传递</li><li>通过NavigationUI类，对菜单，底部导航，抽屉菜单导航进行方便统一的管理</li><li>深层连接</li></ul><blockquote><p>本文中的”<strong>页面</strong>“指的是Fragment和Activity,但主要是Fragment，因为Navigation组件的主要目的就是方便我们在一个Activity中对多个Fragment进行管理。</p></blockquote><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><pre><code>dependencies {    implementation &quot;androidx.navigation:navigation-fragment-ktx:2.3.0&quot;    implementation &quot;androidx.navigation:navigation-ui-ktx:2.3.0&quot;}</code></pre><p><a href="https://developer.android.com/jetpack/androidx/releases/navigation?hl=zh-cn" target="_blank" rel="noopener">更多版本</a></p><h5 id="创建-Navigation-Graph"><a href="#创建-Navigation-Graph" class="headerlink" title="创建 Navigation Graph"></a>创建 Navigation Graph</h5><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123204418.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123204512.png" alt="ok 创建完成"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123204726.png" alt="创建nav_graph文件"></p><h5 id="添加-NavHostFragment"><a href="#添加-NavHostFragment" class="headerlink" title="添加 NavHostFragment"></a>添加 <strong>NavHostFragment</strong></h5><p>添加到Activity布局文件中，作为其他Fragment的容器</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;androidx.appcompat.widget.Toolbar        android:id=&quot;@+id/toolbar&quot;        android:layout_width=&quot;411dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:background=&quot;?attr/colorPrimary&quot;        android:minHeight=&quot;?attr/actionBarSize&quot;        android:theme=&quot;?attr/actionBarTheme&quot;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;        app:layout_constraintStart_toStartOf=&quot;parent&quot;        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;    &lt;fragment        android:id=&quot;@+id/frameLayout&quot;        android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;0dp&quot;        app:defaultNavHost=&quot;true&quot;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;        app:layout_constraintStart_toStartOf=&quot;parent&quot;        app:layout_constraintTop_toBottomOf=&quot;@+id/toolbar&quot;        app:navGraph=&quot;@navigation/nav_graph&quot;&gt;    &lt;/fragment&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><pre><code class="xml">android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;</code></pre><blockquote><p>告诉系统这是一个特殊的Fragment</p></blockquote><pre><code class="xml">app:defaultNavHost=&quot;true&quot;</code></pre><blockquote><p>点击返回按钮是，系统会自动将Fragment退出。</p></blockquote><pre><code class="xml"> app:navGraph=&quot;@navigation/nav_graph&quot;</code></pre><blockquote><p>对应的Fargment导航图</p></blockquote><h5 id="设置导航-Navigation"><a href="#设置导航-Navigation" class="headerlink" title="设置导航(Navigation)"></a>设置导航(Navigation)</h5><p>创建MainFragment和SecondeFragment</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123214054.png" alt=""></p><blockquote><p>destination 表示目的地，既你想要去的地方。Navigation 组件的目的就是方便开发者在一个Activity中管理多个Fragment。所以在这里创建一个MainFragment。</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123214146.png" alt="选择 Fragment"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123214359.png" alt=""></p><blockquote><p>表示首个加载的Fragment</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123214733.png" alt="选择 code"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123214811.png" alt=""></p><blockquote><p>app:startDestination = “@id/mainFragment”</p><p>表示首个加载的Fragment</p></blockquote><p>设置MainFragment界面</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;             xmlns:tools=&quot;http://schemas.android.com/tools&quot;             android:layout_width=&quot;match_parent&quot;             android:layout_height=&quot;match_parent&quot;             tools:context=&quot;.MainFragment&quot;&gt;    &lt;TextView        android:id=&quot;@+id/tvTitle&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_centerInParent=&quot;true&quot;        android:textSize=&quot;18sp&quot;        android:text=&quot;MainFragment&quot;/&gt;    &lt;Button        android:id=&quot;@+id/btnToSecondFragment&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_below=&quot;@+id/tvTitle&quot;        android:textAllCaps=&quot;false&quot;        android:text=&quot;to SecondFragment&quot;/&gt;&lt;/RelativeLayout&gt;</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123215621.png" alt=""></p><h5 id="设置跳转顺序"><a href="#设置跳转顺序" class="headerlink" title="设置跳转顺序"></a>设置跳转顺序</h5><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123215652.png" alt="ps:sscondFragment为secondFragment"></p><blockquote><p>选中mainFragment后点击方块连线到secondFragment</p></blockquote><p>可以看到 <action/>标签中，app:destination 属性表示目的地，这里表示的是secondFragment</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;navigation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/nav_graph&quot;    app:startDestination=&quot;@id/mainFragment&quot;&gt;    &lt;fragment        android:id=&quot;@+id/mainFragment&quot;        android:name=&quot;com.thecara.navigation.MainFragment&quot;        android:label=&quot;fragment_main&quot;        tools:layout=&quot;@layout/fragment_main&quot;&gt;        &lt;action            android:id=&quot;@+id/action_mainFragment_to_sscondFragment&quot;            app:destination=&quot;@id/secondFragment&quot; /&gt;    &lt;/fragment&gt;    &lt;fragment        android:id=&quot;@+id/secondFragment&quot;        android:name=&quot;com.thecara.navigation.SscondFragment&quot;        android:label=&quot;fragment_sscond&quot;        tools:layout=&quot;@layout/fragment_sscond&quot; /&gt;&lt;/navigation&gt;</code></pre><h5 id="设置跳转"><a href="#设置跳转" class="headerlink" title="设置跳转"></a>设置跳转</h5><p>使用这个来跳转</p><pre><code class="kotlin">        view.findViewById&lt;Button&gt;(R.id.btnToSecondFragment).setOnClickListener {            Navigation.findNavController(view).navigate(R.id.action_mainFragment_to_sscondFragment)        }</code></pre><blockquote><p>  Navigation.findNavController(params).navigate(id)</p><p>表示通过指定id跳转的哪里，这里指跳转到 secondeFragment。</p><p>其中还有</p><p>Navigation.findNavController(params).navigateUp()</p><p>负责向上跳转</p></blockquote><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-11-23-0.gif" alt=""></p><h1 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h1><ul><li>Navigation Graph </li></ul><p>这是一种新型的 XML 资源文件，里面包含了应用程序所有的页面及页面之间的关系</p><ul><li>NavHostFragment</li></ul><p>这是一个特殊的布局文件，NavigationGraph中的页面通过该Fragment展示</p><ul><li>NavController</li></ul><p>用于在代码中完成NavigationGraph中的具体页面切换</p><p><strong>所以，当你使用NavController对象，告诉它你想要去NavigationGraph中的那个页面，NavController将会将相关的页面展示在NavHostFragment中。</strong></p><h5 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h5><p><a href="https://developer.android.com/guide/navigation?hl=zh-cn" target="_blank" rel="noopener">导航</a></p><p><a href="https://zhuanlan.zhihu.com/p/69562454" target="_blank" rel="noopener">Navigation(一)基础入门</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Jetpack架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ExoPlayer2 Google依赖库</title>
      <link href="/2020/11/13/ExoPlayer2-Google%E4%BE%9D%E8%B5%96%E5%BA%93/"/>
      <url>/2020/11/13/ExoPlayer2-Google%E4%BE%9D%E8%B5%96%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>ExoPlayer构建在Android低水平媒体API之上的一个应用层媒体播放器。支持内置播放器的所有格式外加自适应格式DASH和SmoothStreaming。所有它可以高度定制和扩展。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><strong>1.添加依赖</strong></p><p>在项目的根目录下 打开 build.gradle 中添加Google和JCenter库。</p><blockquote><p>创建android 项目时 AndroidStudio 会自动添加，在这里提一下。</p></blockquote><pre><code class="groovy">repositories {    google()    jcenter()}</code></pre><ol start="2"><li>在 app module <strong>中添加依赖项</strong>。</li></ol><pre><code class="groovy">implementation &#39;com.google.android.exoplayer:exoplayer:2.X.X&#39;</code></pre><p><strong>2.x.x</strong>替换为首选的最新版本(<a href="https://github.com/google/ExoPlayer/blob/release-v2/RELEASENOTES.md" target="_blank" rel="noopener">ExoPlayer</a>)</p><p>作为完整库的代替方案，可以根据实际需要的库模块。例如，以下内容对Core,DASH和UI库模块的依赖关系，这可能时播放DASH内容的应用程序所需要的。</p><pre><code class="groovy">implementation &#39;com.google.android.exoplayer:exoplayer-core:2.X.X&#39;implementation &#39;com.google.android.exoplayer:exoplayer-dash:2.X.X&#39;implementation &#39;com.google.android.exoplayer:exoplayer-ui:2.X.X&#39;</code></pre><p>可用的库模块在下列出。</p><ul><li><strong>exoplayer-core</strong>：核心功能（必须）。</li><li><strong>exoplayer-dash</strong>：支持DASH内容。</li><li><strong>exoplayer-hls</strong>：支持HLS内容。</li><li><strong>exoplayer-smoothstraming</strong>：支持SmoothStreaming内容。</li><li><strong>exoplayer-ui</strong>：与ExoPlayer一起使用的UI组件和资源。</li></ul><p><a href="https://github.com/google/ExoPlayer/tree/release-v2/extensions/" target="_blank" rel="noopener">更多的扩展模块</a>。</p><p><strong>3.Java8</strong></p><p>在 app 目录下添加 一下内容供所有文件支持Java8</p><pre><code class="groovy">compileOptions {  targetCompatibility JavaVersion.VERSION_1_8}</code></pre><h2 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h2><pre><code class="xml">    &lt;com.google.android.exoplayer2.ui.PlayerView        android:id=&quot;@+id/playerView&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot; /&gt;</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210621172138.png" alt=""></p><h1 id="DOC"><a href="#DOC" class="headerlink" title="DOC"></a>DOC</h1><h1 id="AudioAttributes-Builder-类"><a href="#AudioAttributes-Builder-类" class="headerlink" title="AudioAttributes.Builder() 类"></a><strong>AudioAttributes.Builder() 类</strong></h1><blockquote><p>用于音频回放的属性，用于配置平台下的AudioTrack。</p><p>如果你要设置音频属性，需要创建一个 AudioAttributes实例。</p></blockquote><ul><li><strong>setContentText(int contentType)</strong></li></ul><blockquote><p>设置描述音频信号内容类型的属性。如语言或音乐。</p></blockquote><ul><li><strong>setUsage(int contentType)</strong></li></ul><blockquote><p>设置描述音频信号用途的属性，例如报警或者铃声。</p></blockquote><ul><li><strong>build()方法</strong></li></ul><blockquote><p>构建器创建一个 AudioAttributes 实例。</p></blockquote><h1 id="C-类"><a href="#C-类" class="headerlink" title="C 类"></a>C 类</h1><blockquote><p>定义标准库的常量</p></blockquote><ul><li><strong>C.CONTENT_TYPE_MUSIC</strong></li></ul><blockquote><p>C 类的常量用于</p><p>在你使用内容类型为音乐时使用的内容类型值。</p></blockquote><ul><li><strong>C.USAGE_MEDIA</strong></li></ul><blockquote><p>当使用媒体是使用这个值(如音乐或者电影原声带)</p></blockquote><h1 id="SimpleExoPlayer-类"><a href="#SimpleExoPlayer-类" class="headerlink" title="SimpleExoPlayer 类"></a>SimpleExoPlayer 类</h1><blockquote><p>实现组件的外部播放。</p><p>用SimpleExoPlayer.Build(context:Context)来实现</p></blockquote><ul><li><strong>build()方法</strong></li></ul><blockquote><p>构建器创建一个 SimpleExoPlayer实例。</p></blockquote><ul><li><strong>setAudioAttributes()</strong></li></ul><blockquote><p>设置音轨使用的音频回放属性。如果没有设置，将使用默认的属性。它们一般设置为媒体播放。设置回放音频属性期间可能回在输出中引入一个短间隙，因为音频轨道被重新创建。还生成一个新的音频会话id。如果音轨是由音轨选择器启用的，指定的音频属性将被忽视，但是当它播放时没有音轨那么指定属性将会被使用。</p><p>If the device is running a build before platform API version 21, audio attributes cannot be set directly on the underlying audio track. In this case, the usage will be mapped onto an equivalent stream type using Util.getStreamTypeForAudioUsage(int).</p><p>If audio focus should be handled, the AudioAttributes.usage must be C.USAGE_MEDIA or C.USAGE_GAME. Other usages will throw an IllegalArgumentException.</p><p><strong>Parameters:</strong></p><p><code>audioAttributes</code> - The attributes to use for audio playback. 用于音频回放的属性</p><p><code>handleAudioFocus</code> - True if the player should handle audio focus, false other wise.    用户处理音轨焦点时选择 true。</p></blockquote><ul><li><strong>setHandleAudioBecomingNoisy(boolean handleAudioBecomingNoisy)</strong></li></ul><blockquote><p>设置当前的音频从耳机重新定向到扬声器事，播放器是否应该暂停。</p><p>默认不启用。false</p><p>Sets whether the player should pause automatically when audio is rerouted from a headset to device speakers.</p><p><strong>Parameters:</strong></p><p><code>handleAudioBecomingNoisy</code> - Whether the player should pause automatically when audio is rerouted from a headset to device speakers.</p></blockquote><p><strong>方法</strong></p><table><thead><tr><th align="center">返回值类型</th><th align="center">方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">setPlayWhenReady(boolean playWhenReady)</td><td align="center">playWhenReady:准备好后时候播放。如果播放器已处于就绪状态，则将暂停改为播放。</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="DefaultDataSourceFactory-类"><a href="#DefaultDataSourceFactory-类" class="headerlink" title="DefaultDataSourceFactory  类"></a>DefaultDataSourceFactory  类</h1><blockquote><p>创建工厂，将非文件的数据委托到 DetaultHttpDataSources。</p><p>Factory that produces DefaultDataSource instances that delegate to DefaultHttpDataSources for non-file/asset/content URIs.</p></blockquote><ul><li><strong>DefaultDataSourceFactory(Context context,String userAgent)</strong></li></ul><blockquote><p>创建 DetaultDataSourceFactory 类实例</p><p><strong>Parameters:</strong></p><p><code>context</code> - A context.</p><p><code>userAgent</code> - The User-Agent string that should be used. 使用用户代理</p></blockquote><ul><li><strong>Util.getUserAgent(Context context,String applicationName)</strong></li></ul><blockquote><p>根据给定的应用程序名词和库版本返回用户代理的字符串。</p><p>Returns a user agent string based on the given application name and the library version.</p><ul><li><p><strong>Parameters:</strong></p><p><code>context</code> - A valid context of the calling application. 当前 app 上下文</p><p><code>applicationName</code> - String that will be prefix’ed to the generated user agent.</p></li></ul></blockquote><h1 id="MediaSessionConnector-类"><a href="#MediaSessionConnector-类" class="headerlink" title="MediaSessionConnector 类"></a>MediaSessionConnector 类</h1><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201204220725.png" alt="继承关系"></p><blockquote><p>介绍</p><p>Connects a MediaSessionCompat to a <a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/Player.html" target="_blank" rel="noopener"><code>Player</code></a>.</p><p>负责连接到 MediaSessionCompat 类</p></blockquote><pre><code class="java">public MediaSessionConnector(android.support.v4.media.session.MediaSessionCompat mediaSession)</code></pre><blockquote><p><code>mediaSession</code> - The <a href="https://developer.android.com/reference/android/support.v4.media.session.MediaSessionCompat.html" target="_blank" rel="noopener"><code>MediaSessionCompat</code></a> to connect to.</p><p>用来连接到 MediaSessionCompat</p></blockquote><p><strong>setPlayer</strong></p><pre><code class="java"> public void setPlayer(@Nullable Player player)</code></pre><blockquote><p>Sets the player to be connected to the media session. Must be called on the same thread that is used to access the player.</p><p>将播放器连接到媒体。主要只能在一条线程上。</p></blockquote><table><thead><tr><th align="center">修饰符</th><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">setQueueNavigator(MediaSessionConnector.QueueNavigator queueNavigator)</td><td align="center">设置处理队列导航的操作。queueNavigator：队列编辑器。</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="MediaSessionConnector-PlaybackPreparer-接口"><a href="#MediaSessionConnector-PlaybackPreparer-接口" class="headerlink" title="MediaSessionConnector.PlaybackPreparer 接口"></a>MediaSessionConnector.PlaybackPreparer 接口</h1><blockquote><p>准备播放操作的接口</p></blockquote><p><strong>抽象方法</strong></p><table><thead><tr><th align="center">返回类型</th><th align="center">方法名字</th><th align="center">参数</th><th align="center">描述</th><th align="center">返回</th></tr></thead><tbody><tr><td align="center">long</td><td align="center">getSupportedPrepareActions()</td><td align="center">空</td><td align="center">返回支持的媒体操作常量</td><td align="center">媒体常量</td></tr><tr><td align="center">void</td><td align="center">onPrepare(boolean playWhenReady)</td><td align="center">准备好后是否播放</td><td align="center">准备完成时调用</td><td align="center">空</td></tr><tr><td align="center">void</td><td align="center">onPrepareFromMediaId ( String  mediaId, boolean playWhenReady, @Nullable Bundle  extras)</td><td align="center">mediaId：媒体项的Id，playWhenReady：准备好后是否播放，extras：媒体的控制器可为null</td><td align="center">用以播放特定的媒体</td><td align="center">空</td></tr><tr><td align="center">void</td><td align="center">onPrepareFromSearch(String query, boolean playWhenReady, @Nullable Bundle extras)</td><td align="center">query：搜索，playWhenReady：准备好后是否播放，extras：媒体控制器可为null</td><td align="center">搜索特定音乐</td><td align="center">void</td></tr><tr><td align="center">void</td><td align="center">onPrepareFromUri( Uri  uri, boolean playWhenReady, @Nullable Bundle  extras)</td><td align="center">uri：要播放的媒体项目，playWhenReady：准备完成后是否播放，extras：媒体控制器可为null</td><td align="center">通过Uri处理特定媒体项目</td><td align="center">void</td></tr><tr><td align="center">void</td><td align="center">onCommand(String command,Bundle extras,ResultReceiver cb)</td><td align="center">command：命令名称，extras：命令的可选参数，cb，接收器命令发送到接收器，可为空</td><td align="center">接口继承了 MediaSessionConnector.CommandReceiver 类中的方法。控制器发送自定义命令时调用</td><td align="center">void</td></tr></tbody></table><h1 id="MediaDescriptionCompat-类"><a href="#MediaDescriptionCompat-类" class="headerlink" title="MediaDescriptionCompat 类"></a>MediaDescriptionCompat 类</h1><p>适合显示的媒体项目的一组简单元数据。 这可以使用Builder创建，也可以使用<code>getDescription()</code>从现有元数据中<code>getDescription()</code> 。</p><h1 id="MediaDescriptionCompat-Builder"><a href="#MediaDescriptionCompat-Builder" class="headerlink" title="MediaDescriptionCompat.Builder"></a>MediaDescriptionCompat.Builder</h1><h1 id="ConcatenatingMediaSource-类"><a href="#ConcatenatingMediaSource-类" class="headerlink" title="ConcatenatingMediaSource 类"></a>ConcatenatingMediaSource 类</h1><blockquote><p><code>ConcatenatingMediaSource</code>允许播放期间动态的添加和删除<code>MediaSource</code></p></blockquote><h1 id="PlayerNotificationManager-类"><a href="#PlayerNotificationManager-类" class="headerlink" title="PlayerNotificationManager 类"></a>PlayerNotificationManager 类</h1><blockquote><p>用来启动、更新和取消播放器状态的媒体样式通知的。</p></blockquote><p><strong>内部方法</strong></p><table><thead><tr><th align="center">返回值类型</th><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">setPlaybackPreparer(PlaybackPreparer playbackPreparer)</td><td align="center">准备播放器</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p><strong>嵌套类或方法</strong></p><h4 id="public-static-interface-PlayerNotificationManager-NotificationListener"><a href="#public-static-interface-PlayerNotificationManager-NotificationListener" class="headerlink" title="public static interface PlayerNotificationManager.NotificationListener"></a>public static interface PlayerNotificationManager.NotificationListener</h4><blockquote><p>监听状态的监听器。</p></blockquote><table><thead><tr><th align="center">返回值类型</th><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">onNotificationCancelled(int notificationId,boolean dismissedByUser)</td><td align="center">通知被取消时调用</td></tr><tr><td align="center">void</td><td align="center">onNotificationPosted(int notificationId, Notification notification,boolean ongoing)</td><td align="center">发布通知后调用</td></tr></tbody></table><h4 id="public-static-PlayerNotificationManager-createWithNotificationChannel"><a href="#public-static-PlayerNotificationManager-createWithNotificationChannel" class="headerlink" title="public static PlayerNotificationManager createWithNotificationChannel"></a>public static PlayerNotificationManager createWithNotificationChannel</h4><blockquote><p>创建通知管理器并指定channelId和低优先级的通知通道channelName.</p></blockquote><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">context-Context</td><td align="center">上下文</td></tr><tr><td align="center">channelId</td><td align="center">通知Id</td></tr><tr><td align="center">channelName</td><td align="center">字符串资源标识符，用于用户可见的通知名称。最多40字符过多会被裁断。</td></tr><tr><td align="center">channelDescription</td><td align="center">用户对内容可见部分的描述。没有为0。</td></tr><tr><td align="center">notificationId</td><td align="center">通知的Id</td></tr><tr><td align="center">mediaDescriptionAdapter</td><td align="center">提供当前播放内容的适配器</td></tr><tr><td align="center">notificationListener</td><td align="center">开始和取消通知的监听器</td></tr></tbody></table><h4 id="public-static-interface-PlayerNotificationManager-MediaDescriptionAdapter"><a href="#public-static-interface-PlayerNotificationManager-MediaDescriptionAdapter" class="headerlink" title="public static interface PlayerNotificationManager.MediaDescriptionAdapter"></a>public static interface PlayerNotificationManager.MediaDescriptionAdapter</h4><blockquote><p>提供当前播放内容的适配器</p></blockquote><table><thead><tr><th align="center">方法名</th><th align="center">参数</th><th>返回值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">getCurrentContentTitle()</td><td align="center">com.google.android.exoplayer2.Player player</td><td><strong>CharSequence</strong></td><td align="center">获得当前内容标题</td></tr><tr><td align="center">createCurrentContentIntent()</td><td align="center">com.google.android.exoplayer2.Player player</td><td><strong>PendingIntent</strong></td><td align="center">创建当前选项的意图</td></tr><tr><td align="center">getCurrentContentText()</td><td align="center">com.google.android.exoplayer2.Player player</td><td><strong>CharSequence</strong></td><td align="center">获取当前内容文本</td></tr><tr><td align="center">getCurrentLargeIcon()</td><td align="center">com.google.android.exoplayer2.Player player, PlayerNotificationManager.BitmapCallback callback</td><td><strong>Bitmap</strong></td><td align="center">获取当前大图标。当存在异步加载时可以返回占位符（或null），并且在 PlayerNotificationManager.BitmapCallback 加载后传递给它。由于在使用过程中适配器会多次被调用，因此图片由程序缓存，并尽可能在后续使用中同步返回。</td></tr></tbody></table><h1 id="Player-接口"><a href="#Player-接口" class="headerlink" title="Player 接口"></a>Player 接口</h1><blockquote><p>定义媒体播放器界面的高级功能常量、接口类型等，例如播放、暂停、搜索等属性能力。</p></blockquote><p><strong>常量</strong></p><table><thead><tr><th align="center">修饰类型</th><th align="center">常量</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">static int</td><td align="center">STATE_READY</td><td align="center">移动到指定位置准备播放</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="Player-EventListener-接口"><a href="#Player-EventListener-接口" class="headerlink" title="Player.EventListener 接口"></a>Player.EventListener 接口</h1><blockquote><p>检测播放器的状态。</p></blockquote><p><strong>抽象方法</strong></p><table><thead><tr><th align="center">返回类型</th><th align="center">方法名</th><th align="center">描述</th><th align="center">参数</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">onPlayerError(ExoPlaybackException error)。</td><td align="center">发生错误时调用</td><td align="center">error:错误参数。</td></tr><tr><td align="center">void</td><td align="center">onPlayerStateChanged(boolean playWhenReady,int playbackState)</td><td align="center">检测媒体的状态</td><td align="center">playWhenReady:是否准备好。playbackState：播放的状态。</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="TimelineQueueNavigator-抽象类"><a href="#TimelineQueueNavigator-抽象类" class="headerlink" title="TimelineQueueNavigator 抽象类"></a>TimelineQueueNavigator 抽象类</h1><blockquote><p>抽象类用来实现 MediaSessionConnector.QueueNavigator 窗口的映射Player，Timeline媒体会话的队列。</p></blockquote><table><thead><tr><th align="center">修饰符</th><th align="center">(构造)方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"></td><td align="center">TimelineQueueNavigator(MediaSessionCompat mediaSession)</td><td align="center">创建一个实例MediaSessionCompat。</td></tr><tr><td align="center">MediaDescriptionCompat</td><td align="center">getMediaDescription(Player player,int windowIndex)</td><td align="center">获得MediaDescriptionCompat给定窗口的索引。通常需要异步加载图标。</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>引用：</p><p><a href="https://juejin.im/post/6854573203994443789" target="_blank" rel="noopener">深入解读ExoPlayer 之 开发者指南全译-02 开始使用</a></p><p><a href="https://exoplayer.dev/doc/reference/overview-summary.html" target="_blank" rel="noopener">DOC</a></p><p><a href="https://www.apiref.com/android-zh/index.html" target="_blank" rel="noopener">Android API</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ExoPlayer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Glide Android图片加载库</title>
      <link href="/2020/11/12/Glide-Android%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93/"/>
      <url>/2020/11/12/Glide-Android%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="下载-添加依赖"><a href="#下载-添加依赖" class="headerlink" title="下载 添加依赖"></a>下载 添加依赖</h1><p><strong>添加依赖</strong></p><blockquote><p>在 app 目录下打开 build.gradle</p></blockquote><pre><code class="kotlin">   // Glide    implementation &#39;com.github.bumptech.glide:glide:4.11.0&#39;    kapt &#39;com.github.bumptech.glide:compiler:4.11.0&#39;</code></pre><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><pre><code class="kotlin">Glide.with(context)    .load(url)    .into(imageView);</code></pre><blockquote><ul><li>with(context:Context) 需要上下文。</li><li>load(url:String) 字符串性质的网络图片Url。</li><li>into(imageView :ImageView) 你需要显示的图片的控件</li></ul></blockquote><p><strong>取消加载</strong></p><pre><code class="kotlin">Glide.with(context).clear(imageView);</code></pre><blockquote><p>Glide.with()中传入Activity或者Fragment时会跟随它们创建和销毁，所有手动取消是非必要的。</p></blockquote><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><blockquote><ul><li>setDefaultRequestOptions(RequestOptions requestOptions)</li></ul><p>用于配置加载图片时的默认选项，编码模式包含在其中，默认配置是RGB_565</p><p>参数：</p><ol><li>requestOptions:设置 RequestOptions 到加载的应用中。</li></ol></blockquote><h1 id="RequestOptions类"><a href="#RequestOptions类" class="headerlink" title="RequestOptions类"></a>RequestOptions类</h1><blockquote><p>提供选项来给 Glide 自定义加载。</p></blockquote><ul><li><strong>placeholder(Drawable drawable)</strong></li></ul><blockquote><p>设置加载时的默认图片。</p><p>参数：</p><ol><li>drawable，显示图片的占位符</li></ol></blockquote><ul><li><strong>onError(Drawable drawable)</strong></li></ul><blockquote><p>设置图片加载错误时的图片。</p><p>参数：</p><ol><li>drawable，显示图片的占位符</li></ol></blockquote><ul><li><strong>diskCacheStrategy(DiskCacheStrategy diskCacheStrategy)</strong></li></ul><blockquote><p>将 DiskCacheStrategy 类型应用到单独请求中。允许你加载过程中使用或者写入磁盘缓存，选择性的仅支持无修改的原声数据，或者变换过的缩略图，或者兼而有之。</p><p>参数：</p><ol><li>diskCacheStrategy：使用DiskCacheStrategy类的常量作为缓存策略。</li></ol></blockquote><h1 id="DiskCacheStrategy-类"><a href="#DiskCacheStrategy-类" class="headerlink" title="DiskCacheStrategy  类"></a>DiskCacheStrategy  类</h1><blockquote><p>缓存策略（Disk 、Cache 、Strategy）</p><p>允许你加载过程中使用或者写入磁盘缓存，选择性的仅支持无修改的原声数据，或者变换过的缩略图，或者兼而有之。</p><p>默认是<strong>AUTOMATIC</strong>，会尝试对本地和远程图片使用最佳策略。当你加载远程数据时，<strong>AUTOMATIC</strong>策略会存储维被你加载过程修改过的原始数据(例如，变换，裁剪)，因为下载远程数据相比调整磁盘上已经存在的数据要昂贵的多。对于本都数据，<strong>AUTOMATIC</strong> 策略会存储变换过的缩略图，因为即使你再次生成另一个尺寸或者类型的图片，取回原始数据也是很容易的。</p></blockquote><p><strong>类型介绍</strong></p><blockquote><p>DiskCacheStrategy.NONE: 表示不缓存任何内容。</p><p>DiskCacheStrategy.DATA: 只缓存原始图片。</p><p>DiskCacheStrategy.RESOURCE：表示只缓存转换过后的图片。</p><p>DiskCacheStrategy.ALL:表示既缓存原始图片，也缓存转换过后的图片。</p><p>DiskCacheStrategy.AUTOMATIC: 表示让Gilde根据图片资源智能的选择一种缓存策略（默认）。</p></blockquote><h2 id="CustomTarget-类"><a href="#CustomTarget-类" class="headerlink" title="CustomTarget 类"></a>CustomTarget<T> 类</h2><blockquote><p>用于加载图片资源。</p></blockquote><table><thead><tr><th align="center">方法名</th><th align="center">参数</th><th align="center">描述</th><th align="center">返回值</th></tr></thead><tbody><tr><td align="center">onResourceReady</td><td align="center">@NonNull  R resource, @Nullable Transition&lt;? super R&gt; transition</td><td align="center">资源加载完成后调用的方法</td><td align="center">void。返回加载的资源</td></tr><tr><td align="center">onLoadCleared</td><td align="center">@NonNull android.graphics.drawable.Drawable placeholder（可以选择的占位符，可为null）</td><td align="center">取消加载并释放资源的生命周期回调。（在重新绘制容器时，你必须确保onResourceReady()方法不接受任何当前的Drawable）</td><td align="center">void</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p><strong>引用</strong></p><p><a href="https://muyangmin.github.io/glide-docs-cn/doc/getting-started.html" target="_blank" rel="noopener">Glide</a></p><p><a href="https://www.jianshu.com/p/4f457a124d67" target="_blank" rel="noopener">Android图片加载框架——Glide（Glide v4）</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Glide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dagger-Hilt Android的依赖注入框架</title>
      <link href="/2020/11/11/Dagger-Hilt-Android%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6/"/>
      <url>/2020/11/11/Dagger-Hilt-Android%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Hilt-是干什么的？"><a href="#Hilt-是干什么的？" class="headerlink" title="Hilt 是干什么的？"></a>Hilt 是干什么的？</h1><p>它是 Google 为Android开发提供的场景化依赖库，皆在减少项目中进行的手动依赖注入。</p><p>Hilt 为项目中的每个 Android 类提供容器并自动管理它们的生命周期，为应用程序提供了 DI的标准方法。它是从 Dagger 库的基础上进行构建的，因为 Dagger提供的编译时正确性、运行时性能、可伸缩性并且从AndroidStudio支持Dagger中获益。</p><blockquote><p><strong>相比Dagger，Hilt有那些优化？</strong></p><p>Hilt的实现要比Dagger简单的多，使用Dagger实现依赖注入，需要去编写modules、components等等。每次去创建一个新的Android组件，比如 Activity、Fragment时，我们都需要将它们手动添加到modules中。</p></blockquote><h1 id="使用-Hilt-前的准备工作"><a href="#使用-Hilt-前的准备工作" class="headerlink" title="使用 Hilt 前的准备工作"></a>使用 Hilt 前的准备工作</h1><ul><li>添加依赖 在项目的根目录下 build.gradle 文件</li></ul><pre><code>buildscript {    ...    dependencies {        ...        classpath &quot;com.google.dagger:hilt-android-gradle-plugin:2.28.3-alpha&quot;    }}</code></pre><ul><li>在项目的应用级目录下 </li></ul><pre><code>...apply plugin: &#39;kotlin-kapt&#39;apply plugin: &#39;dagger.hilt.android.plugin&#39;android {    ...}dependencies {    implementation &quot;com.google.dagger:hilt-android:2.28-alpha&quot;    kapt &quot;com.google.dagger:hilt-android-compiler:2.28-alpha&quot;}</code></pre><p>Hilt 使用Java8的功能，所以我们在项目中启用它，应用模块下 build.gradle 文件添加代码。</p><pre><code class="groovy">android {  ...    compileOptions {        sourceCompatibility JavaVersion.VERSION_1_8        targetCompatibility JavaVersion.VERSION_1_8    }    // For Kotlin projects    kotlinOptions {        jvmTarget = &quot;1.8&quot;    }}</code></pre><blockquote><p><strong>注意</strong></p><p>在 Kotlin 项目中，需要添加 kotlinOptions，否则ViewModel会编译不通过。</p><p>需要注意使用hilt 和data binding，需要AndroidStudio的版本必须&gt;=4.0。</p></blockquote><p>Application 是 App 的入口，所有使用Hilt的App必须包含一个使用@HiltAndroidApp注解的Application</p><pre><code class="kotlin">@HiltAndroidAppclass HiltApplication : Application() {    /**     * 1. 所有使用 Hilt 的 App 必须包含一个使用 @HiltAndroidApp 注解的 Application     * 2. @HiltAndroidApp 将会触发 Hilt 代码的生成，包括用作应用程序依赖项容器的基类     * 3. 生成的 Hilt 组件依附于 Application 的生命周期，它也是 App 的父组件，提供其他组件访问的依赖     * 4. 在 Application 中设置好 @HiltAndroidApp 之后，就可以使用 Hilt 提供的组件了，     *    Hilt 提供的 @AndroidEntryPoint 注解用于提供 Android 类的依赖（Activity、Fragment、View、Service、BroadcastReceiver）等等     *    Application 使用 @HiltAndroidApp 注解     */}</code></pre><ol><li>@HiltAndroidApp会触发Hilt代码的生成，包括用作应用程序依赖容器的基类</li><li>生成的Hilt组件依附于Application的生命周期，它也是App的父组件，提供其他组件访问的依赖。</li></ol><h1 id="使用-Hilt-进行依赖注入"><a href="#使用-Hilt-进行依赖注入" class="headerlink" title="使用 Hilt 进行依赖注入"></a>使用 Hilt 进行依赖注入</h1><p>注入 HiltSimple 并在 Application 中调用它的doSomething方法。</p><pre><code class="kotlin">class HiltSimple @Inject constructor() {    fun doSomething() {        Log.e(TAG, &quot;----doSomething----&quot;)    }}@HiltAndroidAppclass HiltApplication : Application() {    @Inject    lateinit var mHiltSimple: HiltSimple    override fun onCreate() {        super.onCreate()        mHiltSimple.doSomething()    }}</code></pre><p>Hilt 需要知道如何从相对应的组件中提供必要的依赖实例。使用@Inject注解来告诉Hilt如何提供该类的实例，@Inject 常用于构造函数、非私有字段、方法。</p><h1 id="Hilt-常用注解的含义"><a href="#Hilt-常用注解的含义" class="headerlink" title="Hilt 常用注解的含义"></a>Hilt 常用注解的含义</h1><h4 id="HiltAndroidApp"><a href="#HiltAndroidApp" class="headerlink" title="@HiltAndroidApp"></a>@HiltAndroidApp</h4><blockquote><p>1 所有使用HIlt的App必须包含一个使用@HiltAndroidApp注解的Application。</p><p>2 @HiltAndroidApp注解将会触发Hilt代码的生成，作为应用程序依赖项容器的基类。</p><p>3 生成的Hilt组件依附于Application的生命周期，它也是App的父组件，提供其他组件访问的依赖。</p><p>4 在Application中设置号@HiltAndroidApp之后，就可以使用Hilt提供的组件了，组件包含Applicaiton、Activity、Fragment等。</p></blockquote><h4 id="AndroidEntryPoint"><a href="#AndroidEntryPoint" class="headerlink" title="@AndroidEntryPoint"></a>@AndroidEntryPoint</h4><blockquote><p>Hilt 提供的@AndroidEntryPoint注解用于提供Android类的依赖（Activity、Fragment、View、Service、BroadcastReceiver）</p><p>特殊的Application使用 @HiltAndroidApp注解。</p><ul><li><p>Activity：支持ComponentActivity的子类例如FragmentActivity、AppCompatActivity等。</p></li><li><p>Fragment：支持 androidx.Fragment包下的Fragment。</p></li><li><p>View</p></li><li><p>Service</p></li><li><p>BroadcastReceiver</p></li></ul></blockquote><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>在使用@AndroidEntryPoint在非ComponentActivity子类上注解，例如Activity则会抛出异常。</p><pre><code class="groovy">Activities annotated with @AndroidEntryPoint must be a subclass of androidx.activity.ComponentActivity. (e.g. FragmentActivity, AppCompatActivity, etc.)</code></pre><p>使用@AndroidEntryPoint注解时，必须在它的依赖的Android类添加同样的注解，<strong>例如Fragment中添加@AndroidEntryPoint注解，必须在Fragment依赖的Activity上也添加@AndroidEntryPoint注解，否则会抛出一样。</strong></p><pre><code class="kotlin">java.lang.IllegalStateException: Hilt Fragments must be attached to an @AndroidEntryPoint Activity. Found: class com.hi.dhl.hilt.MainActivity</code></pre><h4 id="Module"><a href="#Module" class="headerlink" title="@Module"></a>@Module</h4><p>常用于创建依赖类的对象（例如第三方库 OkHttp、Retrofit等等），使用@Module注解的类，需要使用@InstallIn注解指定范围module。</p><pre><code class="kotlin">@Module@InstallIn(ApplicationComponent::class)// 这里使用了 ApplicationComponent，因此 NetworkModule 绑定到 Application 的生命周期。object NetworkModule {}</code></pre><h4 id="InstallIn"><a href="#InstallIn" class="headerlink" title="@InstallIn"></a>@InstallIn</h4><p>使用@Module注入的类，使用@InstallIn注解指定module的范围，例如使用@InstallIn(ActivityComponent::class)注解的module会绑定到Activity的生命周期上。</p><p>Hilt 提供了以下组件来绑定依赖与对应的Android类的活动范围。</p><table><thead><tr><th align="center">Hilt 提供组件</th><th align="center">对应的Android类活动范围</th><th align="center">作用域</th></tr></thead><tbody><tr><td align="center">ApplicationComponent</td><td align="center">Application</td><td align="center">@Singleton</td></tr><tr><td align="center">ActivityRetainedComponent</td><td align="center">ViewModel</td><td align="center">@ActivityRetainedScope</td></tr><tr><td align="center">ActivityComponent</td><td align="center">Activity</td><td align="center">@ActivityScoped</td></tr><tr><td align="center">FragmentComponent</td><td align="center">Fragment</td><td align="center">@FragmentScoped</td></tr><tr><td align="center">ViewComponent</td><td align="center">View</td><td align="center">@ViewScoped</td></tr><tr><td align="center">ViewWithFragmentComponent</td><td align="center">View annotated with @WithFragmentBindings</td><td align="center">@ViewScoped</td></tr><tr><td align="center">ServiceComponent</td><td align="center">Service</td><td align="center">@ServiceScoped</td></tr></tbody></table><blockquote><p><strong>注意</strong></p><p>Hilt 没有为 broadcast receivers 提供组件，因为Hilt直接从ApplicationComponent注入broadcast receivers。</p></blockquote><p>Hilt 会根据相应的 Android 类生命周期自动创建和销毁生成的组件类的实例。如下。</p><table><thead><tr><th align="center">Hilt 提供的组件</th><th align="center">创建对应的生命周期</th><th>销毁对应的生命周期</th></tr></thead><tbody><tr><td align="center">ApplicationComponent</td><td align="center">Application#onCreate()</td><td>Application#onDestory()</td></tr><tr><td align="center">ActivityRetainedComponent</td><td align="center">Activity#onCreate()</td><td>Activity#onDestroy()</td></tr><tr><td align="center">ActivityComponent</td><td align="center">Activity#onCreate()</td><td>Activity#OnDestroy()</td></tr><tr><td align="center">FragmentComponent</td><td align="center">Fragment#OnAttach()</td><td>Fragment#onDestroy()</td></tr><tr><td align="center">ViewComponent</td><td align="center">View#super()</td><td>View destroyed</td></tr><tr><td align="center">ViewWithFragmentComponent</td><td align="center">View#super()</td><td>View destroyed</td></tr><tr><td align="center">ServiceComponent</td><td align="center">Service#onCreate()</td><td>Service#onDestroy()</td></tr></tbody></table><h4 id="Provides"><a href="#Provides" class="headerlink" title="@Provides"></a>@Provides</h4><p>常用于被 @Module 注解标记类的内部方法，并提供依赖项对象。</p><pre><code class="kotlin">@Module@InstallIn(ApplicationComponent::class)// 这里使用了 ApplicationComponent，因此 NetworkModule 绑定到 Application 的生命周期。object NetworkModule {    /**     * @Provides 常用于被 @Module 注解标记类的内部的方法，并提供依赖项对象。     * @Singleton 提供单例     */    @Provides    @Singleton    fun provideOkHttpClient(): OkHttpClient {        return OkHttpClient.Builder()            .build()    }}</code></pre><h1 id="Hilt-同-第三方组件一起使用"><a href="#Hilt-同-第三方组件一起使用" class="headerlink" title="Hilt 同 第三方组件一起使用"></a>Hilt 同 第三方组件一起使用</h1><p>如果你要在项目中添加第三方依赖，需要使用@Module注解，使用@Module注解的普通类，在其中创建第三方依赖的对象。</p><pre><code class="kotlin">@Module@InstallIn(ApplicationComponent::class)// 这里使用了 ApplicationComponent，因此 NetworkModule 绑定到 Application 的生命周期。object NetworkModule {    /**     * @Provides 常用于被 @Module 注解标记类的内部的方法，并提供依赖项对象。     * @Singleton 提供单例     */    @Provides    @Singleton    fun provideOkHttpClient(): OkHttpClient {        return OkHttpClient.Builder()            .build()    }    @Provides    @Singleton    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {        return Retrofit.Builder()            .client(okHttpClient)            .baseUrl(&quot;https://api.github.com/&quot;)            .addConverterFactory(GsonConverterFactory.create())            .build()    }    @Provides    @Singleton    fun provideGitHubService(retrofit: Retrofit): GitHubService {        return retrofit.create(GitHubService::class.java)    }}</code></pre><ul><li>@Module 常用于创建依赖类对象（如OkHttp、Retrofit等等）。</li><li>使用 @Module注入的类，需要使用@InstallIn注解指定module的范围，会绑定到Android类对应的生命周期上。</li><li>@Provides 常用于标记类的内部方法，并提供依赖项对象。</li></ul><h1 id="当需要上下文是使用的注解（预定义限定符）"><a href="#当需要上下文是使用的注解（预定义限定符）" class="headerlink" title="当需要上下文是使用的注解（预定义限定符）"></a>当需要上下文是使用的注解（预定义限定符）</h1><p>​    HIlt提供了预定义限定符。例如，当你需要使用应用或者Activity的Context类时，Hilt提供了<strong>@ApplicationContext</strong>和<strong>@ActivityContext</strong>限定符。</p><p>假如,当前这个类需要Activity的上下文。</p><pre><code class="kotlin">class Test @Inject constructor(    @ActivityContext private val context: Context,    private val service: AnalyticsService) { ... }</code></pre><h4 id="引用："><a href="#引用：" class="headerlink" title="引用："></a><strong>引用</strong>：</h4><p><a href="https://juejin.im/post/6844904198803292173?utm_source=gold_browser_extension#heading-13" target="_blank" rel="noopener">Jetpack 新成员 Hilt 实践（一）启程过坑记</a></p><p><a href="https://juejin.im/post/6845166890562617352" target="_blank" rel="noopener">Jetpack 新成员 Hilt 与 Dagger 大不同（三）落地篇</a></p><p><a href="https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn" target="_blank" rel="noopener">Hilt 中的预定义限定符</a></p><p><a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/index-all.html" target="_blank" rel="noopener">JavaDoc-Glide</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Dagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何让Firebase使用Kotlin协程</title>
      <link href="/2020/11/08/%E5%A6%82%E4%BD%95%E8%AE%A9Firebase%E4%BD%BF%E7%94%A8Kotlin%E5%8D%8F%E7%A8%8B/"/>
      <url>/2020/11/08/%E5%A6%82%E4%BD%95%E8%AE%A9Firebase%E4%BD%BF%E7%94%A8Kotlin%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>引用：</strong></p><p>​    <a href="https://medium.com/better-programming/how-to-use-kotlin-coroutines-with-firebase-6f8577a3e00f" target="_blank" rel="noopener">How to Use Kotlin Coroutines With Firebase</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Firebase 讲解</title>
      <link href="/2020/10/29/Firebase-%E8%AE%B2%E8%A7%A3/"/>
      <url>/2020/10/29/Firebase-%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="AndroidStudio-添加-Firebase-选项"><a href="#AndroidStudio-添加-Firebase-选项" class="headerlink" title="AndroidStudio 添加 Firebase 选项"></a>AndroidStudio 添加 Firebase 选项</h1><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201029230255.png" alt="使用时可能会没有 firebase 选项"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201029230927.png" alt="settings 添加 plug-in"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201029231529.png" alt="选择添加 Firebase Services"></p><h1 id="创建-Firebase-项目-添加到-Android-项目中"><a href="#创建-Firebase-项目-添加到-Android-项目中" class="headerlink" title="创建 Firebase 项目 添加到 Android 项目中"></a>创建 Firebase 项目 添加到 Android 项目中</h1><blockquote><p>准备好 google 账号</p></blockquote><p><strong>打开 Firebase</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-11-2-0.gif" alt=""></p><p><strong>进入控制台</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102004348.png" alt=""></p><p><strong>选择项目名称</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102004431.png" alt="create a firebase"></p><p><strong>继续</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102004513.png" alt=""></p><p><strong>选择默认账户或者创建</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102004549.png" alt=""></p><p><strong>稍等片刻</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102004649.png" alt=""></p><p><strong>完成</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102004812.png" alt=""></p><p><strong>根据提示在Android项目中添加各个SDK</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210702135922.png" alt=""></p><p><strong>使用 Cloud Storage的话需要添加SDK到应用</strong></p><pre><code class="groovy">dependencies {    // Import the BoM for the Firebase platform    implementation platform(&#39;com.google.firebase:firebase-bom:28.1.0&#39;)    // Declare the dependency for the Cloud Storage library    // When using the BoM, you don&#39;t specify versions in Firebase library dependencies    implementation &#39;com.google.firebase:firebase-storage-ktx&#39;}</code></pre><h1 id="删除-Firebase-项目"><a href="#删除-Firebase-项目" class="headerlink" title="删除 Firebase 项目"></a>删除 Firebase 项目</h1><p><strong>点击设置</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102004958.png" alt=""></p><p><strong>选择项目设置</strong></p><p><strong>翻到最底部</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102005205.png" alt=""></p><p><strong>删除项目。</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102005613.png" alt=""></p><h1 id="在-CloudFireStore中添加-元数据"><a href="#在-CloudFireStore中添加-元数据" class="headerlink" title="在 CloudFireStore中添加 元数据"></a>在 CloudFireStore中添加 元数据</h1><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201104131055.png" alt="选择Cloud Firestore"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201104131130.png" alt="点击 “开始收集”"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201104131210.png" alt="添加 集合名字"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201104131719.png" alt="添加 文档称呼"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201104131546.png" alt="点击添加字段 直接添加字段即可"></p><h1 id="将-Storage中的数据链接添加到元数据中"><a href="#将-Storage中的数据链接添加到元数据中" class="headerlink" title="将 Storage中的数据链接添加到元数据中"></a>将 Storage中的数据链接添加到元数据中</h1><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201104131958.png" alt="点击上传文件"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-11-4-2.gif" alt="选择要添加的元数据连接"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201104152013.png" alt="粘贴即可"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EC</title>
      <link href="/2020/10/29/EC/"/>
      <url>/2020/10/29/EC/</url>
      
        <content type="html"><![CDATA[<h3 id="基本的语法概念：词性-，一个单次的分类"><a href="#基本的语法概念：词性-，一个单次的分类" class="headerlink" title="基本的语法概念：词性 ，一个单次的分类"></a>基本的语法概念：词性 ，一个单次的分类</h3><p><strong>英语单词共分两类:</strong>虚词和实词</p><p>虚词：没有具体含义。</p><p>实词：有实际的意义。</p><h4 id="虚词"><a href="#虚词" class="headerlink" title="虚词"></a>虚词</h4><p>虚词共分两类： </p><blockquote><p>介词： in at on （可翻译为 在）</p><p>连词：end but or （和、但是、或者）</p></blockquote><h4 id="实词"><a href="#实词" class="headerlink" title="实词"></a>实词</h4><p>实词共分四大类：</p><blockquote><p>名词：用来表达一件东西的名称的词。（花、草、树木等都表示名词）</p><p>动词：表示运动的词。（跑、蹲下）</p><p>形容词：用来修饰名词的词。（美丽的女孩。美丽形容词）</p><p>副词：辅助作用的词。表行为或者状态。（修饰名词以外所有的词。<strong>大声</strong>的唱歌）</p></blockquote><h4 id="不定时"><a href="#不定时" class="headerlink" title="不定时"></a>不定时</h4><blockquote><p>to do</p></blockquote><h3 id="基本的语法概念：句子成分"><a href="#基本的语法概念：句子成分" class="headerlink" title="基本的语法概念：句子成分"></a>基本的语法概念：句子成分</h3><p><strong>注意：</strong>句子成分和词性是不一样的。</p><h1 id="英语的五大句型"><a href="#英语的五大句型" class="headerlink" title="英语的五大句型"></a>英语的五大句型</h1><h2 id="系动词-主语-系动词-表语"><a href="#系动词-主语-系动词-表语" class="headerlink" title="系动词 主语+系动词+表语"></a>系动词 主语+系动词+表语</h2><h3 id="什么是主系表？"><a href="#什么是主系表？" class="headerlink" title="什么是主系表？"></a>什么是<strong>主系表</strong>？</h3><ul><li>主：句子的主体。</li><li>系：系动词，特殊的动词（特殊的谓语属于动词的一种），<strong>在句子中做谓语的动词没有实际意义就属于系动词。</strong></li></ul><blockquote><p>汉语中表示 “是” “为”，英语中表示 am，is ，are。</p><p>在句子中起联系的作用就叫做系动词。</p><p>linking verb 联系动词</p></blockquote><ul><li>表：</li></ul><blockquote><p>表语。<strong>补充说明主语的性质叫做表语</strong>。</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201030150702.png" alt=""></p><p><strong>如何判断句子是否是主系表结构</strong></p><blockquote><p>用中文的方式判断句子里的谓语，可否使用“是”，或者“为”来翻译。</p></blockquote><p>列如：</p><blockquote><p>I am a good persion</p><p>am 可以理解为 “是”。这是主系表</p><p>I become a good persion</p><p>become 理解为 “成为”  “为”。也是主系表结构</p></blockquote><h3 id="系动词共分类四类"><a href="#系动词共分类四类" class="headerlink" title="系动词共分类四类"></a>系动词共分类四类</h3><h4 id="1-be-动词-（am、-is、-are、过去-was、were-、将来-will、be）"><a href="#1-be-动词-（am、-is、-are、过去-was、were-、将来-will、be）" class="headerlink" title="1.be 动词 （am、 is、 are、过去 was、were 、将来 will、be）"></a>1.be 动词 （am、 is、 are、过去 was、were 、将来 will、be）</h4><p>am、 is、 are</p><p>过去 was、were </p><p>将来 will、be</p><h5 id="Be动词后跟三大类-表语"><a href="#Be动词后跟三大类-表语" class="headerlink" title="Be动词后跟三大类 表语"></a>Be动词后跟三大类 表语</h5><ul><li><strong>名词</strong></li></ul><blockquote><p><strong>名词做表语</strong>，可以同汉语完全对应，<strong>be 动词翻译成汉语的是</strong>。</p></blockquote><p>Tim is an engineer</p><p>蒂姆是个工程师</p><p>The price is a £ 2000</p><p>价格是 2000 英镑</p><ul><li><strong>形容词</strong></li></ul><blockquote><p>和汉语不同，<strong>be 动词不会被翻译出来</strong>，<strong>直接被省略介词短语也相当于形容词。</strong></p></blockquote><p>The play was very interesting.</p><p>戏很有意思</p><blockquote><p>The play：戏剧、戏</p><p>was very interesting：很有意思</p></blockquote><p>The milk is in the refrigerator.</p><p>牛奶在冰箱里</p><blockquote><p>in the refrigerator：在冰箱里，用来形容 The milk （牛奶）。介词短语可以用来做形容词</p><p>这是<strong>主系表</strong>结构</p></blockquote><ul><li><strong>地点副词</strong>    </li></ul><blockquote><p>只能接<strong>地点动词</strong>。</p></blockquote><p>Your sister is here there days。</p><p>你姐姐这段在这儿。</p><h4 id="2-状态保持动词-（keep、remain、stay）"><a href="#2-状态保持动词-（keep、remain、stay）" class="headerlink" title="2.状态保持动词 （keep、remain、stay）"></a>2.状态保持动词 （keep、remain、stay）</h4><blockquote><p>这三个词后只能加<strong>形容词作表语</strong>，可以和 be 无限切换。</p></blockquote><p>you should <strong>keep</strong> quiet！（you should <strong>be</strong> quiet！）</p><p>你应该保持安静！</p><p>No one can <strong>remain</strong> youthful forever （No one can <strong>be</strong> youthful forever）</p><p>没有人能永葆青春</p><p>The weather <strong>stayed</strong> fine for a week （The weather <strong>was</strong> fine for a week 。was：过去式）</p><p>这个星期天气一直很好。</p><h4 id="3-状态转变类动词（become、get、go、come、grow、turn）"><a href="#3-状态转变类动词（become、get、go、come、grow、turn）" class="headerlink" title="3.状态转变类动词（become、get、go、come、grow、turn）"></a>3.状态转变类动词（become、get、go、come、grow、turn）</h4><ul><li><strong>become</strong>是一个万能词，既可以表示“变成”，这时候后面只能接名词。同时也可以表示“<strong>变得</strong>”，后面接形容词。</li></ul><p>He <strong>become</strong> a weather.</p><p>他成为了一名教师。</p><p>He <strong>become</strong> very nervous.</p><p>他变得很紧张。</p><ul><li><strong>get</strong>表示“变得怎样”,后边这能接形容词。</li></ul><p>He got very angry.</p><p>他变得非常生气</p><ul><li>come 这个词的本意是来，什么东西会来，当然是好的东西，所以一般come含有“变好”的意思。</li></ul><p>Thing will <strong>come</strong> right.</p><p>事情会变好。</p><ul><li><strong>go</strong> 表示走，你希望的东西你离而去？当然是坏的东西离你而去，所以表达“变坏”，可以用go</li></ul><p>The meat always <strong>goes</strong> bad in summer.</p><p>肉在夏天常常会变坏</p><ul><li>如果你要表示“慢慢变”，使用 <strong>grow</strong>，本意表示 grow 是生长的意思，慢慢长大。</li></ul><p>The weather <strong>grew</strong> cold in the night.</p><p>晚上天气慢慢变冷。</p><ul><li>要表达<strong>“快速变”</strong>，应该用turn。因为turn本意为转身，一下子转过去</li></ul><p>His face <strong>turned</strong> pale.</p><p>他脸色变得苍白</p><h4 id="4-感官动词（look、sound、smell、taste、feel）"><a href="#4-感官动词（look、sound、smell、taste、feel）" class="headerlink" title="4.感官动词（look、sound、smell、taste、feel）"></a>4.感官动词（look、sound、smell、taste、feel）</h4><blockquote><p>五个动词，一律翻译为 “…起来”，“看起来，听起来，闻起来，尝起来，感觉起来（感到）”，后面只能接形容词（相当于形容词的分词）作表语。</p></blockquote><p>I <strong>felt</strong> very nervous when I went into this office.</p><p>我走到他的办公室，感到非常紧张。</p><p>He <strong>looked</strong> very angry.</p><p>他看上去非常气愤。</p><p>They were all hungry and the food <strong>smelled</strong> good.（were：be动词过去式，可以不做翻译）</p><p>他们全都饿了，饭菜散发出阵阵香气。</p><p>The sun <strong>looks like</strong> an orange globe.</p><p>太阳看上去像橙色的球体。</p><blockquote><p>👆 感官动词后，绝不能直接加名词做表语，如果要加名词，必须用：<strong>感官动词+介词like+名词</strong>，此时翻译为“像…”。</p></blockquote><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201030230419.png" alt="句子"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201030230512.png" alt="答案"></p><h2 id="不及物动词-主语-谓语"><a href="#不及物动词-主语-谓语" class="headerlink" title="不及物动词 主语+谓语"></a>不及物动词 主语+谓语</h2><h3 id="什么是主-谓结构？"><a href="#什么是主-谓结构？" class="headerlink" title="什么是主+谓结构？"></a>什么是主+谓结构？</h3><blockquote><p>通常主谓后应该加宾语。当主谓加在一起也可以作为一个句子。</p><p>例如：我笑了 </p><p>“我”和动词“笑了”组成了句子，“我”是主语，“笑了”是谓语，“笑了”是不及物动词所以就组成了句子。</p><p>汉语：我跳舞她。</p><p>英语：I dance her.</p><p>主谓结构同汉语相同。在汉语中 我跳舞她 是不合理的同样英语这样表达也是不合理的。</p><p>I dance.</p></blockquote><h3 id="谓语"><a href="#谓语" class="headerlink" title="谓语"></a>谓语</h3><p><em>名词</em></p><ol><li>语法学中指对主语加以陈述的成分，表示主语「怎么样」或「是什么」。一般的句子都包括主语、谓语，汉语中谓语一般在主语后面。如「我是学生」中「是学生」是谓语。</li></ol><h3 id="出现主谓结构的原因！"><a href="#出现主谓结构的原因！" class="headerlink" title="出现主谓结构的原因！"></a>出现主谓结构的原因！</h3><blockquote><p>因为有不及物动词。</p><p>其中<strong>不及物动词组成主谓结构</strong>。</p></blockquote><h3 id="什么是不及物动词？"><a href="#什么是不及物动词？" class="headerlink" title="什么是不及物动词？"></a>什么是不及物动词？</h3><blockquote><p>intransitive verb，简称：vi.</p><p>它本身意义就是完全的，没有作用对象，<strong>不需要加宾语就能构成完整句子</strong>，例如：游泳、出生、笑、做梦。</p></blockquote><h3 id="如何判断不及物动词？"><a href="#如何判断不及物动词？" class="headerlink" title="如何判断不及物动词？"></a>如何判断不及物动词？</h3><blockquote><p>如何判断，<strong>把这个动词前加上“被”</strong>，看它的寓意是否合理。</p><p>正常则为及物动词，不正常则为不及物动词。</p><p>例如：被打、被喜欢、被处罚。如果说：被跳舞、被做梦、被笑，则为不及物动词。</p></blockquote><h4 id="状语"><a href="#状语" class="headerlink" title="状语"></a>状语</h4><blockquote><p>说明这个动作发生的时间、地点、目的、以及状态等。</p><p>表示 时间、地点和方式的句子成分就叫做状语。</p></blockquote><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul><li><strong>这个句式多带有状语，来进一步说明这个动作发生的时间，地点，目的。</strong></li></ul><p>Detectives were waiting at the airport all morning .</p><p>They were talking loudly.</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031170041.png" alt=""></p><ul><li><strong>很多动词，本身既可以作不及物动词，也可以做及物动词，除啦上述方法外，还要在语境中判断</strong></li></ul><h3 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031110943.png" alt="题目"></p><p>The birds         sing         happily.</p><p>The rain     will stop     in the afternoon.</p><p>The children     are playing         in the park</p><p>My teacher         passed away     in the hospital         yesterday.</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031162342.png" alt=""></p><h2 id="及物动词-主语-谓语-宾语"><a href="#及物动词-主语-谓语-宾语" class="headerlink" title="及物动词 主语+谓语+宾语"></a>及物动词 主语+谓语+宾语</h2><h3 id="什么是及物动词？"><a href="#什么是及物动词？" class="headerlink" title="什么是及物动词？"></a>什么是及物动词？</h3><blockquote><p><strong>及物动词</strong>（transitive verb 简称：vt）</p><p>意思为：加入宾语之后的完整动词，分为主动和被动语态。</p><p>短语相当于及物动词时为：<strong>及物动词短语</strong>。</p></blockquote><p>Yesterday ，    a pigeon         carried     the first     message     from Pinhurst to Slibury.</p><p>昨天，一只鸽子把第一封信从平赫特带到锡尔伯里.</p><p>The bird     covered     the distance     in three minutes.</p><p>这只鸟只用了三分钟就飞完了全程。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031163058.png" alt=""></p><p>The bride and the groom cur the wedding cake together.</p><p>新郎和新娘一起切下结婚蛋糕</p><p>I <strong>had</strong> an amusing experience last year.</p><p>去年我有一次有趣的经历。</p><p>This wonderful plane can <strong>carry</strong> seven passengers.</p><p>这架奇妙的飞机可以载七名乘客</p><h3 id="练习题-2"><a href="#练习题-2" class="headerlink" title="练习题"></a>练习题</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031171234.png" alt=""></p><p>The teacher put up some pictures on the wall in the classroom.</p><p>You should respect the old in public places.</p><p>He began his diet a week ago.</p><p>He set up a new world record in September 1935</p><p>Only very few people can realize their dreams.</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031173411.png" alt=""></p><h2 id="不完全及物动词-主语-谓语-宾语-宾语补语"><a href="#不完全及物动词-主语-谓语-宾语-宾语补语" class="headerlink" title="不完全及物动词 主语+谓语+宾语+宾语补语"></a>不完全及物动词 主语+谓语+宾语+宾语补语</h2><h3 id="什么是不完全及物动词？"><a href="#什么是不完全及物动词？" class="headerlink" title="什么是不完全及物动词？"></a>什么是不完全及物动词？</h3><blockquote><p>不完全及物动词 incomplete transitive verb，简称i.vt</p><p>这个动词加了宾语之后，<strong>意思仍然不完整，需要加上补语（complement）才能使句子完整。</strong></p><p>补语是 <strong>补充说明宾语的特征，或者补语的动作</strong></p></blockquote><ul><li><p>“她 使 我 爱上生活。” 这个 “使” 就是不完全及物动词 如果只说 “她使我” 意思是不完整的，要加上补语 “爱上生活”，才是完整的句子。</p></li><li><p>“他的表演让我 失望。”这个“让”，如果说“他的表演让我”，当然也不完全要加上补语“失望”</p></li></ul><h3 id="如何分别完全及物动词和不完全及物动词？"><a href="#如何分别完全及物动词和不完全及物动词？" class="headerlink" title="如何分别完全及物动词和不完全及物动词？"></a>如何分别完全及物动词和不完全及物动词？</h3><p>最常用的不完全及物动词： <strong>使役动词</strong></p><blockquote><p>在要使什么，做什么时使用使役动词</p></blockquote><ul><li>使…做…（make，have，let，get）</li></ul><p>make/have/let+宾语+动词原形（补语）</p><p>get+宾语+动词不定式（补语）</p><blockquote><p>has：have 的第三人称时态</p></blockquote><ul><li>I made him wash the car.</li></ul><p>我叫他洗车。</p><ul><li>I got him to wash the car.</li></ul><p>我叫他洗车。</p><p>综上所述，只要宾语发出动作，或宾语的状态，均可构成此类句型。</p><h3 id="练习题-3"><a href="#练习题-3" class="headerlink" title="练习题"></a>练习题</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031194550.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031194437.png" alt=""></p><h2 id="授予动词-主语-谓语-间接宾语-直接宾语"><a href="#授予动词-主语-谓语-间接宾语-直接宾语" class="headerlink" title="授予动词 主语+谓语+间接宾语+直接宾语"></a>授予动词 主语+谓语+间接宾语+直接宾语</h2><h3 id="什么是授予动词？"><a href="#什么是授予动词？" class="headerlink" title="什么是授予动词？"></a>什么是授予动词？</h3><p>dative verb，简称d.v</p><ul><li><strong>是及物动词的一种</strong>，当需要接两个宾语，<strong>第一个间接宾语表示授予对象</strong>，<strong>第二个宾语为直接宾语</strong>，<strong>表示授予的东西</strong></li><li>要注意的是，<strong>直接宾语和间接宾语，都是谓语动作的作用对象</strong>，这是与第四大句型的区别。在第四大句型中，补语说明宾语的性质，或者是宾语发出的动作。</li><li>那么在找间宾和直宾使直接找<strong>授予对象</strong>再找<strong>授予的东西</strong>。</li></ul><h3 id="常见的授予动词"><a href="#常见的授予动词" class="headerlink" title="常见的授予动词"></a>常见的授予动词</h3><blockquote><p><strong>give (授予动词)、send、tall、teach、pay、show、offer</strong></p></blockquote><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031215252.png" alt=""></p><ul><li>Richard Mattes <strong>gave</strong> the testers six different kinds of things.</li></ul><p>Richard Matter 给你这些测试者六种不同类型的东西。</p><blockquote><p>直接宾语 <strong>授予的东西</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031220027.png" alt=""></p><ul><li>I <strong>send</strong>     <u>him</u> a     <u>book</u> in reward for his help.</li></ul><p>我送给他一本书答谢他的帮助。</p><blockquote><p>间接宾语<strong>授予的对象</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031221559.png" alt=""></p><ul><li>The scientist <strong>told</strong> <u>us</u> many <u>stories</u> about birds.</li></ul><p>博物学家给我们讲述了许多有关鸟儿的故事。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031221956.png" alt=""></p><ul><li>A friendly waiter <strong>taught</strong> <u>me</u> a few <u>words</u> of Italian.Then he <strong>lent</strong> <u>me</u> a <u>book</u></li></ul><p>一个好客的服务员教我几句意大利语，之后还借给我一本书。</p><ul><li>Yesterday I <strong>paid</strong> <u>him</u> a <u>visit</u>.</li></ul><p>昨天我去看望了他。</p><ul><li>Then he <strong>showed</strong> <u>me</u> the <u>contents</u> of the parcel .</li></ul><p>接着他给我看了包里的东西。</p><ul><li>He <strong>offered</strong> <u>me</u> a lot of <u>money</u>.</li></ul><p>他给了我很多钱。</p><h2 id="主谓宾补与主谓间宾直宾区分（不完全及物动词和授予动词区分）"><a href="#主谓宾补与主谓间宾直宾区分（不完全及物动词和授予动词区分）" class="headerlink" title="主谓宾补与主谓间宾直宾区分（不完全及物动词和授予动词区分）"></a>主谓宾补与主谓间宾直宾区分（不完全及物动词和授予动词区分）</h2><blockquote><p>只要是 <strong>谓语的动作</strong>，<strong>作用于两个不同的名词，也就是两个宾语</strong>，就是第五大句型</p><p>而在第四大类句型中，补语是宾语的动作或状态。</p></blockquote><p>例子：</p><ol><li><p>他 让 <strong>我 学习</strong>。‘“学习” 是 “我” 发出的动作 （学习是在“我”这个宾语后做补充的）</p></li><li><p>他 给了 <strong>我一本书</strong>。 “书” 和 “我” 都是谓语“给”的作用对象所以，</p><p>第1句是第四大句式（主谓宾补），第2句式第五大句型（主谓间宾直宾）</p></li></ol><h3 id="练习题-4"><a href="#练习题-4" class="headerlink" title="练习题"></a>练习题</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031223426.png" alt=""></p><ol><li>题的主谓双宾结构</li></ol><p>He gave his girlfriend a bunch of flowers on Valentine’s Day.</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031225959.png" alt=""></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="谓语-1"><a href="#谓语-1" class="headerlink" title="谓语"></a>谓语</h2><p>名词</p><ol><li>语法学中指对主语加以陈述的成分，表示主语「怎么样」或「是什么」。一般的句子都包括主语、谓语，汉语中谓语一般在主语后面。如「我是学生」中「是学生」是谓语。</li></ol><h2 id="宾语"><a href="#宾语" class="headerlink" title="宾语"></a>宾语</h2><p>名词</p><ol><li>语法上指受动词支配、关涉或受介词引导的成分。在现代汉语中，宾语一般在动词或介词后面。如「尊敬师长」中的「师长」，「他写信」中的「信」，「对他很好」中的「他」。</li></ol><h2 id="表语"><a href="#表语" class="headerlink" title="表语"></a>表语</h2><p>​        属于主语补足语，语法名词，是指说明主语的身份、性质、品性、特征和状态的词或从句，表语常由名词、形容词、介词短语、动名词、不定式、副词来充当，<strong>它常位于系动词（be）之后。</strong></p><p><a href="https://www.bilibili.com/video/BV1sJ411M7Gb?p=3" target="_blank" rel="noopener">英语简单句的造词法则和基本语法概念</a></p><h2 id="介词"><a href="#介词" class="headerlink" title="介词"></a>介词</h2><p><em>名词</em></p><ol><li>虚词的一类。用在名词、代词或名词性短语前边，引进动作行为的时间、处所、方式、目的、涉及或比较的对象以及动作的施事者等。如「在」「从」「以」「为了」「把」「比」「被」等。</li></ol><h2 id="副词"><a href="#副词" class="headerlink" title="副词"></a>副词</h2><p><em>名词</em></p><ol><li>修饰或限制动词、形容词，表示范围、程度、情态、语气等的词，一般不能修饰或限制名词。如「都」「很」「竟然」「再三」等。</li></ol><h1 id="七大英语句子成分的概述"><a href="#七大英语句子成分的概述" class="headerlink" title="七大英语句子成分的概述"></a>七大英语句子成分的概述</h1><h2 id="定语"><a href="#定语" class="headerlink" title="定语"></a>定语</h2><p>一个句子用来界定，限定名词的部分。</p><blockquote><p>一个 <strong>高个子的</strong>，<strong>留着长头发的</strong>，<strong>穿着红色衣服的，喜欢学习英语的</strong>学生。</p><p>加黑部分为 定语。</p></blockquote><h4 id="什么语法成分能够作为定语呢？"><a href="#什么语法成分能够作为定语呢？" class="headerlink" title="什么语法成分能够作为定语呢？"></a>什么语法成分能够作为定语呢？</h4><p><strong>形容词以及相当于形容词性质的语法成分。</strong></p><blockquote><p>一般来说，一个句子，如果是“…的”，它就是形容词性质的，比如说穿着红色衣服的，喜欢学习英语的，都属于形容词短语或者形容词从句。</p></blockquote><p><strong>英语百分之九十五的定语遵循“前小后大”的规则</strong></p><blockquote><p>一个单词组成的定语（限定词，形容词，名词以及名词所有格），放在所修饰名词的前面。</p></blockquote><blockquote><p>两个以上单词组成的定语（of属格，形容词短语，介词短语，分词短语，不定时短语等），放在所修饰词后面。</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201105155015.png" alt="各种语法成分作定语的例子。黑体部分为定语修饰的名词"></p><blockquote><p>They were expecting a valuable parcel of diamonds from South Africa</p><p>他们正期待从南非来的一个装有钻石的贵重包裹。</p><p>定语共是个分别为：</p><p>限定词 a，作顶词修饰 parcel ，a parcel 的包裹。</p><p>形容词 valuable，作定语，贵重。of diamonds 作定语限定为钻石。from South Africa 作定语限制为来自南非。</p></blockquote><blockquote><p>Mrs.Rumbold was a large,unsmiling lady in a tight black dress.</p><p>兰博尔德夫人是一位身材高大、表情严肃的女人，穿一件紧身的黑衣服。</p><p>a large，定语作形容词，形容高大的。unsmiling，定语作形容词严肃的。in a tight black dress，定语作介词短语（形容词性质），形容穿紧身黑衣服。</p></blockquote><blockquote><p>First of all ,he wrote out a long list of all the foods.</p><p>首先，他开列了一张长长列了所有的食物的目录。</p><p>a，限定词定语，限定 list 为一个。</p><p>long，形容词定语，限定为长的list。</p><p>of all the foods ，of属格，限定为食物</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201105170800.png" alt="练习题"></p><blockquote><p>我喜欢课桌上那本英语书</p><p>主语：我。谓语：喜欢。宾语：英语书</p><p>the：定语形容那本书。English：定语形容词，形容book为英语书。on the table:定语介词短语，指桌子上的书。</p></blockquote><blockquote><p>他们正在研究一个关于贸易标准的复杂问题。</p><p>主语：他们。谓语：研究。宾语：问题、</p><p>a：定语限定为一个。complicated：定语形容词，复杂的。about trading standard：作定语 介词短语 关于贸易标准的。</p></blockquote><blockquote><p>我将告诉你们昨天老师给我讲的那个非常有趣的关于月亮的中国古代故事。</p><p>主谓宾补 句式</p><p>主语：我。谓语：将告诉。宾语：你们。补语：故事。</p><p>不加定语：I will tall you story.</p><p>a：定语限定为一个。very :定语 非常。interesting：定语有趣。old Chinese：定语作形容词，中国古老。</p><p>about the moon：介词短语作定语，关于月亮。my teacher told me yesterday：介词短语作定语，老师昨天告诉我。</p><p>that：定语从句。</p></blockquote><h2 id="状语-1"><a href="#状语-1" class="headerlink" title="状语"></a>状语</h2><h4 id="什么是状语？"><a href="#什么是状语？" class="headerlink" title="什么是状语？"></a>什么是状语？</h4><blockquote><p>状语：用来描述定制的细节特征的成分，汉语里常见的对应成，就是“…地”。</p><p>唱歌：</p><p>可以说：大声地唱歌，欢乐地唱歌，投入地唱歌，等等。表达时间、地点、方式的状语，也可以不带“地”字。</p><p>比如：在教室里唱歌，在三个星期的晚会上唱歌，用古典的方式唱歌。</p></blockquote><p>状语可以修饰除啦名词以外的任何词。</p><h4 id="什么语法成分能做状语？"><a href="#什么语法成分能做状语？" class="headerlink" title="什么语法成分能做状语？"></a>什么语法成分能做状语？</h4><p><strong>副词以及相当于副词的语法成分</strong></p><p>副词在句子中处于副手的位置，就是辅助地位</p><blockquote><p>where,when,how–时间，地点，方式，成都</p><p>表示时间的，now ，just now，</p><p>表示地点的介词短语，比如 in the house</p></blockquote><h5 id="小状语（单独的副词）"><a href="#小状语（单独的副词）" class="headerlink" title="小状语（单独的副词）"></a>小状语（单独的副词）</h5><blockquote><p>​    放在其所修饰的词语之前：修饰动词时，放在动词之前。修饰其他成分时，放在其他成分之气那。</p><p>如果需要小状语可以放在句子中的任何位置。</p></blockquote><p>we are <strong>now</strong> living in a beautiful new house in the country.</p><blockquote><p>now：副词（小状语） 修饰living 表示现在生活在。</p><p>我们<strong>现在</strong>住在先将的一栋漂亮的新住宅里。</p></blockquote><p>Letters will cost a little more, but they will <strong>certainly</strong> travel faster.</p><blockquote><p>certainly：小状语 ，表示当然。</p><p>这样会稍微花点钱，但是肯定是快得多了。</p></blockquote><h5 id="大状语"><a href="#大状语" class="headerlink" title="大状语"></a>大状语</h5><blockquote><p>指 （两个及以上单词构成的状语，如介词短语，不定式短语，状语从句），放在整个句子的两头。放在开头时，一半要加上逗号。</p></blockquote><p>On Wednesday evening, We went to the Town Hall.</p><blockquote><p>星期三的晚上，我们去了市政厅。</p><p>其中 On Wednesday evening, 可以放在开头和结尾。</p><p>to the Town Hall：不定式短语</p></blockquote><p>I was having dinner at a restaurant when Tony Steele came in.</p><blockquote><p>我正在一家餐馆吃饭，托尼.斯蒂尔走了进来。</p><p>at a restaurant ：状语</p></blockquote><h3 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h3><p>①句中同时出现几个时间或者地点状语时，从小打到。</p><blockquote><p>We landed in American at 8 o’ clock on June 15th，2012.</p><p>我们2012年6月15日八点在美国着陆。</p><p>We live at number 35.South Renmin Road，Chengdu.</p><p>我们住在成都市人民南路35号。</p></blockquote><p>②句子后面出现多种状语时，顺序是方式–地点–时间。</p><blockquote><p>He put his milk bottles carefully on the doorstep every morning.</p><p>他每天早上小心地把牛奶拼放在门口的台阶上。</p></blockquote><h2 id="同位语"><a href="#同位语" class="headerlink" title="同位语"></a>同位语</h2><blockquote><p>同位语：句子中指代同一事务的两个词、短语或从句，称同为关系。</p></blockquote><p>My sister，Helen Wilson，will travel with me.</p><blockquote><p>句中 My sister 和 Helen Wilson指的是同一个人，它们是同为成分，后一成分通常叫前一成分的同为语。</p></blockquote><p>英语里的同位语，不属于单独的七大句子成分，而是和英语里边的名词成分（主语，宾语，表语）成冰并列关系，相当于对该名词进一步的解释说明。名词或任何相当名词的成分，均可作同位语。</p><h5 id="练习题-5"><a href="#练习题-5" class="headerlink" title="练习题"></a>练习题</h5><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201105220614.png" alt=""></p><p>My English teacher ，Mr. Brent Peter, is a Canadian.</p><blockquote><p>My English teacher 同 Mr.Brent Peter 为同位语状态</p></blockquote><p>Yesterday I met Tom,a friend of my brother’s</p><blockquote><p>Tom 与 friend of my brother’s 同位语状态</p></blockquote><p>We Chinese people are brave and hardworking.</p><blockquote><p>We 同 Chinese people 是同位语状态。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> EC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVC、MVP、MVVM</title>
      <link href="/2020/10/28/MVC%E3%80%81MVP%E3%80%81MVVM/"/>
      <url>/2020/10/28/MVC%E3%80%81MVP%E3%80%81MVVM/</url>
      
        <content type="html"><![CDATA[<h1 id="MVC-MVP-MVVM-图示"><a href="#MVC-MVP-MVVM-图示" class="headerlink" title="MVC MVP MVVM 图示"></a>MVC MVP MVVM 图示</h1><h2 id="MVC（Model、View、Controller）"><a href="#MVC（Model、View、Controller）" class="headerlink" title="MVC（Model、View、Controller）"></a>MVC（Model、View、Controller）</h2><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201028113524.png" alt=""></p><blockquote><ul><li>视图（View）：用户界面</li><li>控制器（Controller）：业务逻辑</li><li>模型（Model）：数据保存</li></ul></blockquote><h5 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h5><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201028113611.png" alt=""></p><blockquote><ol><li>View 传送指令到 Controller</li><li>Controller 完成业务逻辑后，要求 Model 改变状态</li><li>Model 将新的数据发送到 View，用户得到反馈</li></ol></blockquote><p><strong>通信都是单向的</strong></p><h2 id="互动模式"><a href="#互动模式" class="headerlink" title="互动模式"></a>互动模式</h2><blockquote><p><strong>互动模式</strong>（models of interaction），指使用<a href="https://zh.wikipedia.org/wiki/電腦" target="_blank" rel="noopener">电脑</a>时<a href="https://zh.wikipedia.org/wiki/人機互動" target="_blank" rel="noopener">人机互动</a>的界面。好的界面应该是能够有效地让互动顺利进行。互动系统是要让使用者可以在已存在的应用范围中完成他们的目的。系统使用的语言是核语言（core language），使用者使用的语言是任务语言（task language）。</p><p>摘自<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E5%8B%95%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">维基百科</a></p></blockquote><p>接受用户指令时，MVC可分为两种模式。<strong>一种是通过View接受指令</strong>，<strong>传递给Controller。</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201028114024.png" alt=""></p><p><strong>另一种是直接通过controller接受指令。</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201028114109.png" alt=""></p><h2 id="MVP（Model、View、Presenter）"><a href="#MVP（Model、View、Presenter）" class="headerlink" title="MVP（Model、View、Presenter）"></a>MVP（Model、View、Presenter）</h2><p>MVP 模式将 Controller 改名为 <strong>Presenter</strong>，<strong>同时改变了通信方向</strong>。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015020109.png" alt=""></p><blockquote><ol><li><p>各部分之间的通信，是双向的。</p></li><li><p>View 与 Model 不发生联系，都通过 Presenter 传递。</p></li><li><p>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</p></li></ol></blockquote><h2 id="MVVM（Model、View、ViewModel）"><a href="#MVVM（Model、View、ViewModel）" class="headerlink" title="MVVM（Model、View、ViewModel）"></a>MVVM（Model、View、ViewModel）</h2><p>MVVM 模式将 <strong>Presenter</strong> 改名为 <strong>ViewModel</strong>。</p><p>唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。</p><p><strong>引用：</strong></p><p><a href="https://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">MVC，MVP 和 MVVM 的图示</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin 协程</title>
      <link href="/2020/10/14/Kotlin-%E5%8D%8F%E7%A8%8B/"/>
      <url>/2020/10/14/Kotlin-%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h1><blockquote><p><strong>用同步的方式写异步的代码</strong></p></blockquote><p>【协程 Coroutines】 源于Simula 和 Modula-2语言，术语来自于 1958 年的 <strong>Melvin Edward Conway</strong> 发明并且拥有构建汇编程序，说明 <strong>协程是一种编程思想</strong>， 并不局限于特定的语言。</p><h5 id="线程和协程的关系"><a href="#线程和协程的关系" class="headerlink" title="线程和协程的关系"></a>线程和协程的关系</h5><p>从 Android 开发者的角度去理解它们的关系：</p><ul><li>Android中我们所有的代码都跑在线程中的，<strong>而线程是跑在进程中的</strong>。</li><li><strong>协程没有直接和操作系统关联</strong>，它也是<strong>跑在线程中的</strong>，可以是单线程，也可以是多线程。</li><li>单线程中的协程总的<strong>执行时间</strong>并不会比不用协程少。</li><li>Android中，如果在主线程中进行网络访问，会抛出 <strong>NetworkOnMainThreadException</strong>，对于在主线程上的协程也不例外，所以在这种使用场景中也是要切换线程的。</li></ul><h4 id="协程的应用场景之一-线程控制"><a href="#协程的应用场景之一-线程控制" class="headerlink" title="协程的应用场景之一 线程控制"></a>协程的应用场景之一 线程控制</h4><blockquote><p>协程可以让我们在写<strong>代码时不用更多的关注多线程同时更方便的写出并发操作</strong>。</p></blockquote><p><strong>场景</strong></p><p>在Java中实现并发操作通常需要开启 Thread：</p><pre><code class="java">new Thread(new Runnable() {    @Override    public void run() {        ...    }}).start();</code></pre><p>Kotlin中</p><pre><code class="kotlin">Thread({    ...}).start()</code></pre><p><strong>Kotlin和Java使用线程同样存在的问题：</strong></p><ul><li>线程什么时候执行结束</li><li>线程间如何相互通信</li><li>多线程的管理</li></ul><p>可以用Java控制线程 Executor线程池来进行<strong>线程管理</strong>：</p><pre><code class="kotlin">val executor = Executors.newCachedThreadPool()executor.execute({    ...})</code></pre><p>用Android的<strong>AsyncTask</strong>来<strong>解决线程之间的通讯</strong></p><pre><code class="kotlin">object : AsyncTask&lt;T0, T1, T2&gt; {     override fun doInBackground(vararg args: T0): String { ... }    override fun onProgressUpdate(vararg args: T1) { ... }    override fun onPostExecute(t3: T3) { ... }}</code></pre><p>使用<strong>AsyncTask</strong>进行<strong>线程之间</strong>的<strong>通讯</strong>带来的<strong>缺点</strong>（<strong>AsyncTask</strong>是<strong>Android</strong>对<strong>线程池</strong>Executor的<strong>封装</strong>）：</p><ul><li>需要处理多个回调，容易陷入【回调地狱】。</li><li>将业务强行拆分到前台、中间更新、后台三个函数。</li></ul><p>使用 RxJava和协程都可以很好的解决上述的问题。</p><h5 id="例子-使用协程进行网络访问将请求到的数据显示到对应的控件上："><a href="#例子-使用协程进行网络访问将请求到的数据显示到对应的控件上：" class="headerlink" title="例子 使用协程进行网络访问将请求到的数据显示到对应的控件上："></a>例子 使用协程进行网络访问将请求到的数据显示到对应的控件上：</h5><pre><code class="kotlin">launch({    val user = api.getUser() // 👈 网络请求（IO 线程）    nameTv.text = user.name  // 👈 更新 UI（主线程）})</code></pre><p>无需关心 <strong>launch</strong> 它<strong>不是</strong>一个<strong>顶层函数</strong>，只需要关系它的业务逻辑：</p><p>launch <strong>函数</strong>加上实现在 {} 中的<strong>具体逻辑构成</strong>了<strong>协程</strong>。</p><p>通常我们进行网络请求，会传一个callback，或者在IO线程里进行阻塞式的同步调用，而在这段代码中，上下两个语句分别工作在两个线程里，并且写法上和普通单线程代码是一样的。</p><p>这里的 api.getUser是一个挂起函数，所以能够保证nameTv.text的正确赋值，这就涉及到了协程中最著名的【非阻塞式挂起】了。</p><h1 id="协程好在哪里"><a href="#协程好在哪里" class="headerlink" title="协程好在哪里"></a>协程好在哪里</h1><h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><h4 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h4><p><strong>闭包</strong>并<strong>不</strong>是<strong>kotlin</strong>中提出的新概念，在Java8中就已经支持。</p><p>以Thread为例，看看什么是闭包：</p><pre><code class="kotlin">// 创建一个 Thread 的完整写法Thread(object : Runnable {    override fun run() {        ...    }})// 满足 SAM，先简化为Thread({    ...})// 使用闭包，再简化为Thread {    ...}</code></pre><p>语法糖：当函数的最后一个参数是lambda表达式时，可以将<strong>lambda</strong>写在<strong>括号外</strong>。这就是它的<strong>闭包原则</strong>。</p><h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><p>需要一个类型为 Runnable 的参数，而 Runnable 是一个接口，且只定义了一个函数 run，这种情况满足了 Kotlin 的SAM，可以转换成一个传递的 lambda表达式（第二段），以为闭包原则直接写成 Thread{…}（第三段）。</p><p>通过<strong>闭包简化 launch 函数</strong></p><pre><code class="kotlin">launch {    ...}</code></pre><h2 id="基本使用协程"><a href="#基本使用协程" class="headerlink" title="基本使用协程"></a>基本使用协程</h2><p>说过<strong>launch函数不是顶层函数</strong> 并不能直接使用，我们通过下列方法来创建协程：</p><pre><code class="kotlin">// 方法一，使用 runBlocking 顶层函数runBlocking {    getImage(imageId)}// 方法二，使用 GlobalScope 单例对象//            👇 可以直接调用 launch 开启协程GlobalScope.launch {    getImage(imageId)}// 方法三，自行通过 CoroutineContext 创建一个 CoroutineScope 对象//                                    👇 需要一个类型为 CoroutineContext 的参数val coroutineScope = CoroutineScope(context)coroutineScope.launch {    getImage(imageId)}</code></pre><p>方法①，多用于单元测试，业务开发不会用到它，因为它是线程阻塞的。</p><p>方法②，在Android中不推荐这种用法，因为它的生命周期会和app一直，且不能够取消。和使用runBlocking不同它不会阻塞线程。</p><p>方法三，<strong>推荐用法</strong>，通过context参数去管理和控制协程的生命周期（这里的context和Android里的不是同一种东西，更像是一种概念，会有Android平台的封装配合使用）</p><p>其中 <strong>GlobaScope</strong>与<strong>CoroutineScope</strong> 的更多内容后面的文章再说。</p><p>协程<strong>最常用</strong>的<strong>功能</strong>是<strong>并发</strong>，而并发最常用的场景是多线程。可以使用<strong>Dispatchers</strong>.<strong>IO</strong>参数把<strong>任务切换到IO线程执行</strong>：</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.IO) {    ...}</code></pre><p>使用 <strong>Dispatchers.Main</strong> 参数切换到主线程：</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.Main) {    ...}</code></pre><p>所以【什么是协程】中说到的异步请求的完整例子是这样的：</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.Main) {   // 在主线程开启协程    val user = api.getUser() // IO 线程执行网络请求    nameTv.text = user.name  // 主线程更新 UI}</code></pre><p>在Java中回调式的写法是这样的：</p><pre><code class="kotlin">api.getUser(new Callback&lt;User&gt;() {    @Override    public void success(User user) {        runOnUiThread(new Runnable() {            @Override            public void run() {                nameTv.setText(user.name);            }        })    }    @Override    public void failure(Exception e) {        ...    }});</code></pre><h2 id="更为麻烦的并发场景"><a href="#更为麻烦的并发场景" class="headerlink" title="更为麻烦的并发场景"></a>更为麻烦的并发场景</h2><p>对于回调式的写法，如果并发场景再复杂一点，嵌套的可能够多。如果使用协程，多层网络请求。</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.Main) {       // 开始协程：主线程    val token = api.getToken()                  // 网络请求：IO 线程    val user = api.getUser(token)               // 网络请求：IO 线程    nameTv.text = user.name                     // 更新 UI：主线程}</code></pre><p>如果进行多个<strong>网络请求</strong>等待完成后<strong>再刷新UI</strong>。</p><pre><code class="kotlin">api.getAvatar(user, callback)api.getCompanyLogo(user, callback)</code></pre><p>如果使用回调式写法，我们可能会选择妥协，则使用先后请求代替同时请求。</p><pre><code class="kotlin">api.getAvatar(user) { avatar -&gt;    api.getCompanyLogo(user) { logo -&gt;        show(merge(avatar, logo))    }}</code></pre><p>使用窗帘方式去实现可能会导致等待时长了一倍，也相差了一倍的性能。</p><h5 id="协程并行请求网络"><a href="#协程并行请求网络" class="headerlink" title="协程并行请求网络"></a>协程并行请求网络</h5><p>使用协程可以直接并行请求上下两行，最后把结果合并即可：</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.Main) {    //            👇  async 函数之后再讲    val avatar = async { api.getAvatar(user) }    // 获取用户头像    val logo = async { api.getCompanyLogo(user) } // 获取用户所在公司的 logo    val merged = suspendingMerge(avatar, logo)    // 合并结果    //                  👆    show(merged) // 更新 UI}</code></pre><p>即便是比较复杂的并行网络请求，也可以使用并行写出结构清晰的代码。<strong>suspendingMerge</strong> 并不是协程API提供的方法，而是自定义挂起的结果合并方法。</p><h5 id="协程的优势"><a href="#协程的优势" class="headerlink" title="协程的优势"></a>协程的优势</h5><p>让复杂的并发代码，变得简单且清晰是协程的优势。</p><h1 id="协程如何在项目中使用"><a href="#协程如何在项目中使用" class="headerlink" title="协程如何在项目中使用"></a>协程如何在项目中使用</h1><h2 id="在项目中配置对Kotlin协程的支持"><a href="#在项目中配置对Kotlin协程的支持" class="headerlink" title="在项目中配置对Kotlin协程的支持"></a>在项目中配置对Kotlin协程的支持</h2><p>使用协程前，需要在 build.gradle 文件中增加 Kotlin 协程的依赖：</p><ul><li>项目目录下</li></ul><pre><code class="kotlin">buildscript {    ...    // 👇    ext.kotlin_coroutines = &#39;1.3.1&#39;    ...}</code></pre><ul><li>Module 目录下：</li></ul><pre><code class="kotlin">dependencies {    ...    //                                       👇 依赖协程核心库    implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:$kotlin_coroutines&quot;    //                                       👇 依赖当前平台所对应的平台库    implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:$kotlin_coroutines&quot;    ...}</code></pre><p>Kotlin 协程以官方扩展库的形式进行支持。其中【核心库】和【平台库】的版本应该保持一致。</p><ul><li><strong>核心库</strong>为协程的公共API部分。为拉在各个平台统一接口。</li><li><strong>平台库</strong>主要为协程在具体平台的具体实现方式。原因：多线程在各个平台的实现方式不同。</li></ul><h2 id="开始使用协程"><a href="#开始使用协程" class="headerlink" title="开始使用协程"></a>开始使用协程</h2><p><strong>协程最简单的使用</strong>。通过<strong>launch</strong>函数实现线程切换的功能：</p><pre><code class="kotlin">//               👇coroutineScope.launch(Dispatchers.IO) {    ...}</code></pre><h5 id="代码中协程的表现。"><a href="#代码中协程的表现。" class="headerlink" title="代码中协程的表现。"></a><strong>代码中协程的表现。</strong></h5><p><strong>launch</strong> 函数：我要创建协程，并在指定的线程中运行它。被创建的【协程】是谁？ 就是你传给 launch的代码，这段代码叫【协程】。</p><p>当你要切换线程或指定线程时。<strong>要在后台执行任务？</strong></p><pre><code class="kotlin">launch(Dispatchers.IO) {    val image = getImage(imageId)}</code></pre><p><strong>切换到前台刷新界面？</strong></p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.IO) {    val image = getImage(imageId)    launch(Dispatchers.Main) {        avatarIv.setImageBitmap(image)    }}</code></pre><p>发生了嵌套的代码。</p><h5 id="避免嵌套的样子使用协程"><a href="#避免嵌套的样子使用协程" class="headerlink" title="避免嵌套的样子使用协程"></a>避免嵌套的样子使用协程</h5><p>单单使用协程并不会比线程做更多的事情。使用更实用的函数：<strong>withContext</strong>。指定切换线程，并且在执行完内部逻辑后，自动线程切回执行。上述代码使用 withContext：</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.Main) {      // 👈 在 UI 线程开始    val image = withContext(Dispatchers.IO) {  // 👈 切换到 IO 线程，并在执行完成后切回 UI 线程        getImage(imageId)                      // 👈 将会运行在 IO 线程    }    avatarIv.setImageBitmap(image)             // 👈 回到 UI 线程更新 UI} </code></pre><h5 id="比较两种写法来体现-withContext的优势"><a href="#比较两种写法来体现-withContext的优势" class="headerlink" title="比较两种写法来体现 withContext的优势"></a>比较两种写法来体现 withContext的优势</h5><p>当要频繁切换线程时。通过下属代码对比：</p><pre><code class="kotlin">// 第一种写法coroutineScope.launch(Dispatchers.IO) {    ...    launch(Dispatchers.Main){        ...        launch(Dispatchers.IO) {            ...            launch(Dispatchers.Main) {                ...            }        }    }}// 通过第二种写法来实现相同的逻辑coroutineScope.launch(Dispatchers.Main) {    ...    withContext(Dispatchers.IO) {        ...    }    ...    withContext(Dispatchers.IO) {        ...    }    ...}</code></pre><p><strong>优势：</strong></p><p>由于它可以“来回切回来”消除了并发代码在协作时的嵌套。消除了嵌套关系，还可以将 <strong>withContext</strong> 放在单独的函数里：</p><pre><code class="kotlin">launch(Dispatchers.Main) {              // 👈 在 UI 线程开始    val image = getImage(imageId)    avatarIv.setImageBitmap(image)     // 👈 执行结束后，自动切换回 UI 线程}//                               👇fun getImage(imageId: Int) = withContext(Dispatchers.IO) {    ...}</code></pre><p>实现了【同步的方式写异步的代码】。</p><pre><code class="kotlin">launch(Dispatchers.Main) {              // 👈 在 UI 线程开始    val image = getImage(imageId)    avatarIv.setImageBitmap(image)     // 👈 执行结束后，自动切换回 UI 线程}//                               👇fun getImage(imageId: Int) = withContext(Dispatchers.IO) {    ...}</code></pre><p><strong>withContext 单独放在函数中要注意那些</strong></p><pre><code class="kotlin">fun getImage(imageId: Int) = withContext(Dispatchers.IO) {    // IDE 报错 Suspend function&#39;withContext&#39; should be called only from a coroutine or another suspend funcion}</code></pre><p><strong>需要在 suspend函数中调用</strong>。（<strong>withContext</strong> 是<strong>一个 suspend</strong> 函数，所以需要在<strong>协程</strong>或者<strong>suspend函数</strong>中调用。）</p><h2 id="什么是-suspend-函数"><a href="#什么是-suspend-函数" class="headerlink" title="什么是 suspend 函数"></a>什么是 suspend 函数</h2><p><strong>suspend</strong> 函数是<strong>kotlin协程</strong>最核心的关键字。中文意思为【暂停】、【可挂起】。</p><p>解释：</p><blockquote><p>代码执行到 <strong>suspend 函数</strong>的时候会【<strong>挂起</strong>】，并且这个<strong>【挂起】</strong>是<strong>非阻塞式</strong>的，不会阻塞当前线程。</p></blockquote><p>修改上述代码让它可以执行：</p><pre><code class="kotlin">//👇suspend fun getImage(imageId: Int) = withContext(Dispatchers.IO) {    ...}</code></pre><p>到底什么是 suspend ，什么是 【非阻塞】，如何【挂起】。下篇。</p><h1 id="【挂起的本质】"><a href="#【挂起的本质】" class="headerlink" title="【挂起的本质】"></a>【挂起的本质】</h1><p>协程中挂起的对象是什么？     <strong>挂起的对象是协程。</strong></p><p>协程是什么？</p><blockquote><p>启动一个协程可以使用 <strong>launch 或者 async 函数</strong>，协程就是<strong>这两个函数中闭包的代码块</strong>。<strong>launch，async 或者其他函数创建的协程，</strong>在执行到某个 suspend函数时，这个协程会被 【<strong>suspend</strong>】挂起。</p></blockquote><p>从哪里挂起？</p><blockquote><p>在当前线程挂起。就是说<strong>当前协程</strong>在执行的线程中脱离。注意 它只是脱离了，当前线程不再去管理这个协程要求做什么。</p></blockquote><p><strong>当线程执行到协程的suspend函数的时候，暂时不再执行协程中的代码了。</strong></p><p>分开来看，互相脱离的线程和协程接下来将发生什么事情。</p><h4 id="线程："><a href="#线程：" class="headerlink" title="线程："></a>线程：</h4><p>协程的代码块中，<strong>线程执行到了suspend函数这里的时候，就暂时不再执行剩余的协程代码，跳出协程的代码块。</strong></p><p>那线程接下来会做什么？</p><p>例如它是后台线程：</p><ul><li>无事可做，被系统回收</li><li>继续执行别的后台任务</li></ul><p>同Java线程池用到线程在工作结束后的完全一样：回收或者再利用。</p><p>如果是个Android的主线程，那么它会以一秒六十次的界面刷新任务。</p><p>常见的场景是，获取图片，显示出来：</p><pre><code class="kotlin">// 主线程中GlobalScope.launch(Dispatchers.Main) {  val image = suspendingGetImage(imageId)  // 获取图片  avatarIv.setImageBitmap(image)           // 显示出来}suspend fun suspendingGetImage(id: String) = withContext(Dispatchers.IO) {  ...}</code></pre><p>在主线程的协程，<strong>它实质上会往你的主线程 post 一个 Runnable，这个 Runnable 就是你的协程代码：</strong></p><pre><code class="kotlin">handler.post {  val image = suspendingGetImage(imageId)  avatarIv.setImageBitmap(image)}</code></pre><p>协程被挂起时，<strong>主线程的 post 的Runnable 提前结束，然后继续执行它界面的刷新任务。</strong></p><h4 id="协程："><a href="#协程：" class="headerlink" title="协程："></a>协程：</h4><p>线程的代码在到达 <strong>suspend</strong>函数时会被掐断，<strong>协程会从这个 suspend 函数开始继续往下执行，不过是在指定的线程</strong>。</p><p>谁指定的？</p><blockquote><p>suspend 函数指定的， 比如我们这个例子中， 函数内部的withContext传入的Dispatchers.IO所指定的IO线程。</p></blockquote><p><strong>Dispatchers 调度器，限制协程在特定的线程执行，或者分派的一个线程池，或者让它不受限制的运行。</strong></p><p>常用的 Dispatchers，共有那些：</p><ul><li><strong>Dispatchers.Main</strong>:Android的主线程</li><li><strong>DIspatchers.IO</strong>:针对磁盘和网络IO进行了优化，适合IO密集型的任务，例如：读写文件，操作数据库以及网络请求</li><li><strong>Dispatchers.Detault</strong>:适合GPU密集型任务，例如计算。</li></ul><p>协程从 <strong>suspend</strong> 函数开始脱离启动它的线程，继续执行在 <strong>Dispatchers</strong> 所指定的IO线程。</p><p>在 suspend 函数执行完成之后，协程为我们：<strong>自动将线程切回来</strong></p><p><strong>切回？什么意思？</strong></p><p>协程原本是在 <strong>主线程中运动的</strong>，在代码执到 <strong>suspend</strong> 函数的时候，发生线程切换，根据 <strong>Dispatchers</strong> 切换到了IO线程；</p><p>【<strong>切回</strong>】是协程会棒我再 post 一个 Runnable，让剩下的代码继续回到主线程去执行。</p><h4 id="本质："><a href="#本质：" class="headerlink" title="本质："></a>本质：</h4><p>协程再执行到标记有suspend标记的函数时，会被suspend也就是挂起，而所谓的挂起，就是切线程；不同在于，<strong>挂起函数在执行完成之后，协程会重新切回它的线程。</strong> 再简单来说：<strong>kotlin 中挂起，就是一个稍后会被自动切回的线程调度操作。</strong></p><blockquote><p>【切回】动作，在kotlin里叫做 resume，</p></blockquote><p>函数挂起后是需要恢复的。</p><p>而恢复这个功能是协程的，如果不在协程里调用，恢复这个功能是没法实现的，所以也就回答了这个问题：为什么挂起函数必须在协程或者另一个挂起函数中调用。</p><h1 id="如何挂起的？"><a href="#如何挂起的？" class="headerlink" title="如何挂起的？"></a>如何挂起的？</h1><p>【<strong>挂起</strong>】是如何做到的。</p><p>定义的任意函数：</p><pre><code class="kotlin">suspend fun suspendingPrint() {  println(&quot;Thread: ${Thread.currentThread().name}&quot;)}I/System.out: Thread: main</code></pre><p>输出结果还是为主线程。</p><p>为何没有切换线程了？因为它并不知道往哪里切，需要我们告诉它。</p><p>对比之前例子中的 suspendingGetImage函数代码：</p><pre><code class="kotlin">//                                               👇suspend fun suspendingGetImage(id: String) = withContext(Dispatchers.IO) {  ...}</code></pre><p>不同之处在于 <strong>withContext</strong> 函数</p><p><strong>withContext</strong>源码可知，<strong>它本身就是一个挂起函数，它接受一个Dispatcher 函数，依赖这个Dispatcher 函数的指示，你的协程被挂起，然后切换到别的线程。</strong></p><p>所以suspend，并不能起到挂起函数的作用。</p><p>而真正挂起协程的，kotlin协程框架帮助我们做的。</p><p>加上 suspend 关键词是不行的，还需要直接或者间接的调用到 kotlin 协程框架自带的 <strong>suspend</strong> 函数才行。</p><h1 id="suspend-的意义？"><a href="#suspend-的意义？" class="headerlink" title="suspend 的意义？"></a>suspend 的意义？</h1><p>这个关键词最重要的作用就是<strong>提醒</strong>。</p><p>提醒你这个函数是一个挂起操作，<strong>提醒它是个耗时函数，请在协程你调用它。</strong></p><pre><code class="kotlin">// 👇 redundant suspend modifiersuspend fun suspendingPrint() {  println(&quot;Thread: ${Thread.currentThread().name}&quot;)}</code></pre><p>如果你创建使用 <strong>suspend</strong> 函数但是它内部并没有包含真正的挂起逻辑时，<strong>编译器会给你提示</strong>：<strong>redundant suspend modigier</strong>，这个 <strong>suspend</strong> 关键词是多余的。</p><p>因为这个函数并没有发生真正的挂起，此时 suspend 关键词只有一个效果：<strong>限制这个函数只能在协程里被调用，在非协程的代码中是无法调用的。</strong></p><p>创建suspend函数，要在它内部直接或者间接的调用 kotlin 自带的suspend 函数，这是你的 suspend才有意义。</p><h1 id="如何自定义-suspend-函数？"><a href="#如何自定义-suspend-函数？" class="headerlink" title="如何自定义 suspend 函数？"></a>如何自定义 suspend 函数？</h1><p>先分为两个问题:</p><ul><li>什么时候需要自定义 suspend 函数？</li><li>具体应该怎么写?</li></ul><h4 id="什么时候需要自定义-suspend-函数？"><a href="#什么时候需要自定义-suspend-函数？" class="headerlink" title="什么时候需要自定义 suspend 函数？"></a><strong>什么时候需要自定义 suspend 函数？</strong></h4><p>某个函数需要耗时操作时，那就可以把它写成 suspend 函数。这是原则。</p><p>耗时操作共分为两类：IO操作和CPU计算工作，比如文件的读写、网络交付、图片的模糊处理，都是耗时的。</p><h4 id="具体操作："><a href="#具体操作：" class="headerlink" title="具体操作："></a>具体操作：</h4><p>给函数加上 <strong>suspend</strong> 关键字，然后 <strong>withContext</strong> 把函数的内容包住就可以了。</p><p>使用 <strong>withContext</strong> 是因为它在挂起函数中功能最简单直接：把线程自动切走或者切回。</p><p>当然并不是只有 <strong>withContext</strong> 这个函数来辅助我们自定义<strong>suspend</strong> 函数，比如挂起函数 <strong>delay</strong>，它的作用是等待指定时间再往下执行代码。</p><p><strong>使用delay执行等待耗时操作</strong></p><pre><code class="kotlin">suspend fun suspendUntilDone() {  while (!done) {    delay(5)  }}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>什么是挂起？</p><blockquote><p>挂起，就是一个稍后会被指定切回来的线程调度操作。</p></blockquote><p>疑惑：</p><p>协程中的非阻塞式是什么</p><p>协程和RxJava在切换线程方面功能是一样的，都能写出避免嵌套回调的复杂并发代码，协程相比有什么优势，或者让开发者使用的理由？</p><h1 id="协程-Job"><a href="#协程-Job" class="headerlink" title="协程 Job"></a>协程 Job</h1><p>Job 是标准库中启动协程后返回的对象，代表着协程本次作业。我们可以判断协程是否接受，是否取消，是否完成并且额可以取消当前协程以及嵌套子协程。</p><p>基本上每启动一个协程就会产生对应的Job。</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.IO) {    ...}</code></pre><p>launch 返回的就是一个Job，它可以用来管理协程，一个Job中可以关联多个子Job，同时它也提供了通过外部传入parent的实现。</p><p>Job 管理协程，那么它提供了六种状态表示协程的运行状态。</p><ol><li><strong>New</strong>：创建</li><li><strong>Active</strong>：运行</li><li><strong>Completing</strong>：已经完成等待自身的子协程</li><li><strong>Completed</strong>：完成</li><li><strong>Cancelling</strong>：正在进行取消或者失败</li><li><strong>Cancelled</strong>：取消或失败</li></ol><p>这六种状态 <strong>Job</strong>对外暴露了三种状态，它们可以随时通过Job来获取</p><pre><code class="java">public val isActive: Booleanpublic val isCompleted: Booleanpublic val isCancelled: Boolean</code></pre><p>在你需要手动管理协程时，通过下面的方法来判断当前协程是否在运行。</p><pre><code class="kotlin">while (job.isActive) {// 协程运行中            }</code></pre><p>一般协程创建的时候就处在 <strong>Active</strong>状态，但是也有特殊情况。</p><p><strong>引用：</strong></p><p><a href="https://kaixue.io/kotlin-coroutines-1/" target="_blank" rel="noopener">Kotlin 的协程用力瞥一眼 - 学不会协程？很可能因为你看过的教程都是错的</a></p><p><a href="https://kaixue.io/kotlin-coroutines-2/" target="_blank" rel="noopener">Kotlin 协程的挂起好神奇好难懂？今天我把它的皮给扒了</a></p><p><a href="https://blog.csdn.net/qfanmingyiq/article/details/105547092" target="_blank" rel="noopener">Kotlin协程核心库分析-2 Job简述</a></p><p><a href="https://zhuanlan.zhihu.com/p/297543508" target="_blank" rel="noopener">Kotlin协程实现原理:CoroutineScope&amp;Job</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lifecycle 讲解</title>
      <link href="/2020/10/11/Lifecycle/"/>
      <url>/2020/10/11/Lifecycle/</url>
      
        <content type="html"><![CDATA[<h1 id="Lifecycle使用详解"><a href="#Lifecycle使用详解" class="headerlink" title="Lifecycle使用详解"></a>Lifecycle使用详解</h1><h2 id="Lifecycle可以做什么"><a href="#Lifecycle可以做什么" class="headerlink" title="Lifecycle可以做什么"></a>Lifecycle可以做什么</h2><p><strong>Lifecycle 是具有生命周期感知能力的组件，也就是说，在Activity或者Fragment的生命周期发生变动的是否得到通知</strong>。我们往往会在Activity的各种生命周期方法里执行特定的方法。</p><pre><code class="java">public class TestActivity extends AppCompatActivity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_test);    }    @Override    protected void onStart() {        super.onStart();        EventBus.getDefault().register(this);    }    @Override    protected void onDestroy() {        EventBus.getDefault().unregister(this);        super.onDestroy();    }}</code></pre><p>如果我们把很多这种需要跟生命周期相关的逻辑代码直接放在Activity的生命周期方法中，Activity会变的很难以维护的。通过使用Lifecycle，来避免这种情况。</p><h2 id="Lifecycle使用"><a href="#Lifecycle使用" class="headerlink" title="Lifecycle使用"></a>Lifecycle使用</h2><p>导入Lifecycle依赖</p><p>AndroidX:</p><pre><code class="groovy">implementation &quot;androidx.lifecycle:lifecycle-runtime:2.0.0&quot;</code></pre><h3 id="Lifecycler-实现机制"><a href="#Lifecycler-实现机制" class="headerlink" title="Lifecycler 实现机制"></a>Lifecycler 实现机制</h3><ol><li><strong>需要一个构建Lifecycle对象</strong>（通过一个实现了LifecycleOwner接口的对象 getLifecycle() 方法返回），这个对象就是一个被观察者，具有生命感知能力。</li><li><strong>构建一个LifecycleObserver对象，</strong>对指定的Lifecycle对象进行监听（<strong>观察者</strong>）</li><li>通过将Lifecyc对象的addObserver()方法，将Lifecycle对象和LifecycleObserver对象进行绑定。</li></ol><h3 id="继承AppCompatActivity"><a href="#继承AppCompatActivity" class="headerlink" title="继承AppCompatActivity"></a>继承AppCompatActivity</h3><p>创建 MyObserver.java 让它实现LifeyclerObserver 接口（<strong>LifecycleObserver接口是一个空接口，主要给注解处理器使用</strong>):</p><pre><code class="kotlin">/** *   by:Thecara home *   date:2020/10/11 */class MyObserver : LifecycleObserver {    // 使用注解 @OnLifecycleEvent() 该方法需要监听指定的生命周期事件    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)    fun connectListener() {        Log.d(&quot;MyObserver&quot;, &quot;ON_RESUME&quot;)    }    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)    fun disconnectListener() {        Log.d(&quot;MyObserver&quot;, &quot;ON_PAUSE&quot;)    }}</code></pre><p>可以看到，通过在方法上使用 <strong>@onLifecycleEvent</strong> 注解使得方法具有生命感知能力。<strong>括号里的参数，表明需要监听的是什么生命周期事件。</strong>Lifecycle 主要<strong>通过Event和State者两个枚举类来追踪关联组件的生命周期状态</strong>。具体的Event和State之间的转换关系，可以参考如下：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1692ebbac5daa896" alt=""></p><p>让Activity继承自AppCompatActivity，然后再OnCreate()方法中通过 <strong>getLifecycle().addObserver(new MyObserver())</strong> 完成<strong>Lifecycle</strong>和<strong>LifecycleObser</strong>的绑定:</p><pre><code class="kotlin">class MainActivity : AppCompatActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        // 绑定        lifecycle.addObserver(MyObserver())    }}</code></pre><p>通过切换后台观察状态。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-10-11-0.gif" alt="切换"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-10-11-1.gif" alt="Log"></p><p>library 26.1.0 及之后的库中，<strong>AppCompatActivity的父类SupportActivity已经默认实现了LifecycleOwner接口，直接通过getLifecycle() 方法获得Lifecycle对象。</strong></p><p>之后通过 <strong>addObserver()</strong> 方法将Lifecycle 跟指定 LifecycleObserver 进行绑定。</p><p><strong>引用：</strong></p><p><a href="https://juejin.im/post/6844903784166998023" target="_blank" rel="noopener">Android生命周期组件Lifecycle使用详解</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Lifecycle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是BuildConfig</title>
      <link href="/2020/09/17/BuildConfig/"/>
      <url>/2020/09/17/BuildConfig/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-BuildConfig"><a href="#什么是-BuildConfig" class="headerlink" title="什么是 BuildConfig"></a>什么是 BuildConfig</h1><p><strong>在打包时自动生成的类。</strong>类似于R.class，生成后不能修改。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200917233605.png" alt="在项目中的位置"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Timber</title>
      <link href="/2020/09/17/Timber/"/>
      <url>/2020/09/17/Timber/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Timber"><a href="#使用-Timber" class="headerlink" title="使用 Timber"></a>使用 Timber</h1><ul><li>配置 timber</li></ul><pre><code class="groovy">implementation &#39;com.jakewharton.timber:timber:4.7.1&#39;</code></pre><ul><li><h5 id="准备Log输出的自定义格式"><a href="#准备Log输出的自定义格式" class="headerlink" title="准备Log输出的自定义格式"></a><strong>准备Log输出的自定义格式</strong></h5></li></ul><blockquote><p>可以直接在Application的onCreate()中调用<code>Timber.plant(new DebugTree())</code>实现Debug功能。但是功能有所欠缺，<strong>可以用来上传crash信息</strong>等。</p><p>ps：</p><p>Timber主要通过添加Tree实例来实现，添加Tree实例可以通过方法Timber.plant完成。</p><p>而使用DebugTree实现自动实例化</p></blockquote><ol><li>不会<strong>打印当前线程</strong></li><li>不会<strong>打印当前行号</strong></li></ol><p>自己创建一个继承类来实现这两个功能。</p><pre><code class="kotlin">class ThreadAwareDebugTree : Timber.DebugTree() {    //添加当前线程    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {        if (tag != null) {            val threadName = Thread.currentThread().name            tag != &quot;&lt;&quot; + threadName + &quot;&gt;&quot;        }        super.log(priority, tag, message, t)    }    // 添加行号    override fun createStackElementTag(element: StackTraceElement): String? {        return super.createStackElementTag(element) + &quot;Line(&quot; + element.lineNumber + &quot;)&quot;    }}</code></pre><p><strong>还有一个类在 release 版本时调用打印log信息</strong></p><blockquote><p>release 版本用来以一种跟踪日志的形式上报给 <strong>Bugly</strong>，它只会显示 w，e，wtf。</p></blockquote><pre><code class="kotlin">class ReleaseTree : ThreadAwareDebugTree() {    override fun isLoggable(tag: String?, priority: Int): Boolean {        return if (priority == Log.VERBOSE || priority == Log.DEBUG || priority == Log.INFO) {            false        } else true    }    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {        if (!isLoggable(tag, priority)) {            return        }        super.log(priority, tag, message, t)    }}</code></pre><ul><li>准备 Application</li></ul><pre><code class="kotlin">class TimberDemoApplication : Application() {    override fun onCreate() {        super.onCreate()        if (DEBUG)            Timber.plant(ThreadAwareDebugTree())    }}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200921111610.png" alt="添加Application"></p><ul><li>调用一个log</li></ul><pre><code class="kotlin">println(Timber.v(&quot;hello&quot;))</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200921112051.png" alt="通过自定义的类型输出了行号的信息"></p><h2 id="重写-Log-方法"><a href="#重写-Log-方法" class="headerlink" title="重写 Log 方法"></a>重写 Log 方法</h2><p><strong>参数</strong></p><blockquote><p>priority:Int 优先级</p><p>tag:String 打印时的标签</p><p>message:String 内容</p><p>t:Throwable 抛出的异常</p></blockquote><p>此方法可以用来根据发送来的 <strong>异常等信息</strong> 自定义接下来的动作。这些信息并不会被从log日志打印出来。</p><p><strong>调用</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201009123005.png" alt="调用log方法"></p><pre><code class="kotlin"> Timber.log(1, &quot;测试打印&quot;)</code></pre><h4 id="打印我们发送来的信息"><a href="#打印我们发送来的信息" class="headerlink" title="打印我们发送来的信息"></a>打印我们发送来的信息</h4><pre><code class="kotlin">class MyTimberFree : Timber.Tree() {    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {        super.log(priority, tag, message, t)        Timber.v(message)    }}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201009123216.png" alt="发送成功，我们可以根据这些信息上传到crash中。"></p><h1 id="为什么使用Timber"><a href="#为什么使用Timber" class="headerlink" title="为什么使用Timber"></a>为什么使用Timber</h1><ol><li><p>项目开发时，为了方便调试，需要输出log，但是发布后，log中包含很多项目信息，如果全部暴露可能会造成安全隐患，当完全删除也不利于后期调试，因此需要一个开关，关闭开关不能输出bug，打开开关则可以输出log。</p></li><li><p>每次需要打印 TAG</p></li><li><p>不会打印当前线程</p></li><li><p>不会打印当前行号</p></li></ol><p><a href="https://xiazdong.github.io/2017/05/17/Timber/" target="_blank" rel="noopener">Timber和Bugly使用入门</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Timber </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用gradle</title>
      <link href="/2020/09/09/%E4%BD%BF%E7%94%A8gradle/"/>
      <url>/2020/09/09/%E4%BD%BF%E7%94%A8gradle/</url>
      
        <content type="html"><![CDATA[<h1 id="创建-Gradle-项目"><a href="#创建-Gradle-项目" class="headerlink" title="创建 Gradle 项目"></a>创建 Gradle 项目</h1><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-9-9-0.gif" alt=""></p><p>👆 联网状态打开 IDEA</p><h1 id="项目结构介绍"><a href="#项目结构介绍" class="headerlink" title="项目结构介绍"></a>项目结构介绍</h1><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910110408.png" alt=""></p><p><strong>src/main/java</strong> 正式代码目录</p><p><strong>src/main/resources</strong> 正式配置文件目录</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910111041.png" alt=""></p><p><strong>src/test/java</strong> 放置单元测试代码目录</p><p><strong>src/test/resources</strong> 放置单元测试配置文件目录</p><p><strong>src/main/webapp</strong> 还有一个可放置的 web 目录（页面信息）</p><h4 id="src-build-gradle-文件"><a href="#src-build-gradle-文件" class="headerlink" title="src/build.gradle 文件"></a>src/build.gradle 文件</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910162235.png" alt=""></p><p><strong>plugins{}</strong></p><blockquote><p>指运行环境</p></blockquote><p><strong>repositories{}</strong></p><blockquote><p>mavenContral() 为中央仓库，在没有指定情况的下会直接从中央仓库下载 jar 包。</p></blockquote><p><strong>dependenciese{}</strong></p><blockquote><p>gradle工程所有的jar包的坐标都在dependencies属性内放置。</p><p>同时每个jar包的坐标都有三个基本元素构成，group，name，version 组成</p></blockquote><p><strong>group</strong>：多分为多段，第一段为 域，第二段公司名称。其中 org 为非盈利组织，con 为商业组织。例如：tomat：为 apache项目 groupid为org.apache。</p><p><strong>name</strong>：项目的全名称。</p><p><strong>version</strong>：版本号。</p><p><strong>testCompile</strong>：测试时所依赖的jar包，在dradle可由 implementation 代替。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910165023.png" alt=""></p><p>创建项目有提到 👆</p><h4 id="项目-build-gradle-文件"><a href="#项目-build-gradle-文件" class="headerlink" title="项目/build.gradle 文件"></a>项目/build.gradle 文件</h4><p><strong>buildscript{} 属性</strong></p><blockquote><p>gradle执行所需要的依赖，分别对应maven库和插件</p></blockquote><h1 id="通过-mevenCentral-引入-jar-包"><a href="#通过-mevenCentral-引入-jar-包" class="headerlink" title="通过 mevenCentral 引入 jar 包"></a>通过 <strong>mevenCentral</strong> 引入 jar 包</h1><p>使用 compile 添加 jar 包</p><blockquote><p>用来解析所需要的依赖在classpath中可用，并且将它们打包。</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-9-10-1.gif" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910180423.png" alt=""></p><p>依赖完成</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910182006.png" alt=""></p><p>在 用户的 user/用户名/.gradle/caches/modules-2/files-2.1 下有我们加载的 jar 包</p><h1 id="demo-引入一个spring包-并测试使用"><a href="#demo-引入一个spring包-并测试使用" class="headerlink" title="demo 引入一个spring包 并测试使用"></a>demo 引入一个spring包 并测试使用</h1><h3 id="在-mavenRepository-中引入jar-包"><a href="#在-mavenRepository-中引入jar-包" class="headerlink" title="在 mavenRepository 中引入jar 包"></a>在 mavenRepository 中引入jar 包</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200911162643.png" alt=""></p><pre><code class="groovy">// https://mvnrepository.com/artifact/org.springframework/spring-contextcompile group: &#39;org.springframework&#39;, name: &#39;spring-context&#39;, version: &#39;5.2.8.RELEASE&#39;</code></pre><h3 id="引入后的依赖包位置查看"><a href="#引入后的依赖包位置查看" class="headerlink" title="引入后的依赖包位置查看"></a>引入后的依赖包位置查看</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200911162549.png" alt=""></p><h3 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h3><p><strong>创建 接口 ”AccountDao“</strong></p><p>位置 ”com.gradlelearn.dao“</p><pre><code class="java">public interface AccountDao {    public List findAll();}</code></pre><p>作为接口，查询方法</p><p><strong>创建 ”AccountDaoImpl“</strong></p><p>位置 ”com.gradlelearn.dao.impl“</p><pre><code class="java">public class AccountDaoImpl implements AccountDao {    @Override    public List findAll() {        System.out.println(&quot;test&quot;);        return null;    }}</code></pre><p>实现查询功能</p><h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><p><strong>创建 ”AccountTest“</strong></p><p>位置 test 文件下 ”com.gradle.test“</p><p><strong>ClassPathXmlApplicationContext</strong> 类型</p><blockquote><p>获得当前 bean 容器</p><p>创建对象 ApplicationContext 类型</p></blockquote><p><strong>applicationContext.getBean</strong> 方法</p><blockquote><p>从容器中获得当前 Dao</p></blockquote><pre><code class="java">public class AccountTest {    @Test    public void acccountTest() {        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);        AccountDao bean = applicationContext.getBean(AccountDao.class);        bean.findAll();    }}</code></pre><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200911164758.png" alt=""></p><h3 id="打包-jar-包"><a href="#打包-jar-包" class="headerlink" title="打包 jar 包"></a>打包 jar 包</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-9-11-0.gif" alt=""></p><p><strong>jar 包的位置</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200911165345.png" alt=""></p><h1 id="创建-web-工程-demo"><a href="#创建-web-工程-demo" class="headerlink" title="创建 web 工程 demo"></a>创建 web 工程 demo</h1><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h5 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h5><p>使用 ext 扩展块可以一次添加多个属性。</p><p>声明多个属性。添加了键值对的属性集合。</p><pre><code class="groovy">ext.versions = [minSdk:21,targetSdk:29]</code></pre><h5 id="apply-plugin"><a href="#apply-plugin" class="headerlink" title="apply plugin"></a>apply plugin</h5><p>此方式用来引入 <strong>Gradle 官方插件库</strong>。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915181918.png" alt=""></p><h5 id="apply-from"><a href="#apply-from" class="headerlink" title="apply from"></a>apply from</h5><p>引用本地资源</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915182720.png" alt=""></p><h2 id="android"><a href="#android" class="headerlink" title="android"></a>android</h2><p>这个闭包主要为了配置项目结构的各种属性。</p><h5 id="compileSdkVersion"><a href="#compileSdkVersion" class="headerlink" title="compileSdkVersion"></a>compileSdkVersion</h5><p>设置编译时用的Android版本</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915183321.png" alt=""></p><h2 id="defaultConfig-闭包"><a href="#defaultConfig-闭包" class="headerlink" title="defaultConfig 闭包"></a>defaultConfig 闭包</h2><p>默认闭包</p><h5 id="applicationId"><a href="#applicationId" class="headerlink" title="applicationId"></a>applicationId</h5><p>项目的包名</p><h5 id="minSdkVersion"><a href="#minSdkVersion" class="headerlink" title="minSdkVersion"></a>minSdkVersion</h5><p>最低兼容版本</p><h5 id="targetSdkVersion"><a href="#targetSdkVersion" class="headerlink" title="targetSdkVersion"></a>targetSdkVersion</h5><p>目标兼容版本</p><h5 id="versionCode"><a href="#versionCode" class="headerlink" title="versionCode"></a>versionCode</h5><p>项目版本号</p><h5 id="versionName"><a href="#versionName" class="headerlink" title="versionName"></a>versionName</h5><p>版本名称</p><h5 id="testInstrumentationRunner"><a href="#testInstrumentationRunner" class="headerlink" title="testInstrumentationRunner"></a>testInstrumentationRunner</h5><p>用来进行 AndroidJUnitRunner 进行单元测试</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915183913.png" alt="detailtConfig闭包"></p><h2 id="buildTypes-闭包"><a href="#buildTypes-闭包" class="headerlink" title="buildTypes 闭包"></a>buildTypes 闭包</h2><p>生成安装文件的主要配置，多数为两个子闭包，    一个debug闭包，<strong>用于指定生成测试版安装文件的配置</strong>，可忽略。一个release闭包，<strong>用于指定生成正式版的配置</strong>。两者配置参数大多一致，区别为<strong>默认属性配置不一样</strong>。</p><h5 id="minifyEnabled"><a href="#minifyEnabled" class="headerlink" title="minifyEnabled"></a>minifyEnabled</h5><p>是否对代码进行混淆</p><h5 id="proguardFiles"><a href="#proguardFiles" class="headerlink" title="proguardFiles"></a>proguardFiles</h5><p>指定混淆的规则文件</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915185118.png" alt=""></p><h2 id="dependencies闭包"><a href="#dependencies闭包" class="headerlink" title="dependencies闭包"></a>dependencies闭包</h2><p>定义了项目的依赖关系，三种依赖方式：<strong>本地依赖，库依赖，和远程依赖</strong>。</p><blockquote><p>自AndroidStudio3.0后 compile 引入库不再使用，而通过api和implementation，api完全等同于先前的 compile</p><p>，通过 api 引入 整个项目是可以使用当前的依赖库的。<strong>implementation 引入的库只有对应的 Module 使用</strong>。</p><p>在使用 compile时导致模块之间的耦合过高，不利于项目的拆解，<strong>通过 implementation做到降低耦合提高安全性</strong>。</p></blockquote><p>Module：指项目中创建的不同Module。</p><h5 id="implementation"><a href="#implementation" class="headerlink" title="implementation"></a>implementation</h5><p>远程依赖</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915190215.png" alt=""></p><h5 id="testImplementation-和-androidTestImplementation"><a href="#testImplementation-和-androidTestImplementation" class="headerlink" title="testImplementation 和 androidTestImplementation"></a>testImplementation 和 androidTestImplementation</h5><p>测试用依赖库</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915190143.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915190127.png" alt=""></p><h1 id="groovy-快速使用"><a href="#groovy-快速使用" class="headerlink" title="groovy 快速使用"></a>groovy 快速使用</h1><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-9-10-0.gif" alt=""></p><p>打开 idea 的 groovy 编辑器</p><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p><strong>groovy hellow word！</strong></p><pre><code class="groovy">println(&quot;hello world!&quot;);</code></pre><p>groovy 更类似于 java 语言。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910113424.png" alt=""></p><p><strong>groovy 可以省略末尾 “;”号</strong></p><pre><code class="groovy">println(&quot;hello world!&quot;)</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910112155.png" alt=""></p><p><strong>groovy 可以 省略括号</strong></p><pre><code class="groovy">println &quot;hello world!&quot;</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910120309.png" alt=""></p><p><strong>定义变量</strong></p><pre><code class="groovy">def x = 15println x</code></pre><p>def 修饰符是 <strong>弱类型</strong> 声明，groovy会自动根据情况来给变量赋予对应的类型。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910150342.png" alt=""></p><p><strong>定义集合</strong></p><pre><code class="groovy">def x = [&#39;x&#39;, &#39;f&#39;, &#39;c&#39;]x &lt;&lt; &#39;y&#39;println x</code></pre><p>定义集合：通过 “[]” 中括号声明</p><p>集合添加数据，”&lt;&lt;” 双小于号即可</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910151126.png" alt=""></p><p><strong>提取元素</strong></p><pre><code class="groovy">x.get(2)</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910151255.png" alt=""></p><p>提取元素下标为 2 的元素</p><h4 id="定义map"><a href="#定义map" class="headerlink" title="定义map"></a><strong>定义map</strong></h4><p><strong>声明map</strong></p><pre><code class="groovy">def m = [&#39;key1&#39;: &#39;value1&#39;]</code></pre><p>在初始化时必须要有初始化的值，用来对弱类型进行修改。</p><p><strong>添加键值对</strong></p><pre><code class="groovy">m.key2 = &quot;value2&quot;</code></pre><p>打印键值对</p><pre><code class="groovy">println m.get(&#39;key2&#39;)println m</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910152935.png" alt=""></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="groovy-中的闭包"><a href="#groovy-中的闭包" class="headerlink" title="groovy 中的闭包"></a>groovy 中的闭包</h3><p><strong>什么是闭包？</strong></p><p>groovy中的一个代码块。用于在<strong>gradle中把闭包当作参数使用</strong>。</p><p><strong>定义闭包和携带参数的闭包</strong></p><pre><code class="groovy">def b = {    println &quot;hello world!&quot;}</code></pre><pre><code class="groovy">def b = {   v-&gt; println &quot;hello world! $v&quot;}</code></pre><p>花括号 “{}” 即为闭包的样式。</p><p>v 表示一个变量，通过 “$v” 引用变量。</p><p><strong>闭包作为方法的参数，为闭包添加参数</strong></p><pre><code class="groovy">def method(Closure closure) {    closure()}</code></pre><pre><code class="groovy">def method(Closure closure) {    closure(&quot;arguments&quot;)}</code></pre><p>Closure：为闭包的类型，位于 “groovy.lang” 包下。</p><p>字符“arguments”作为参数传递给了闭包，<strong>在使用时将对应闭包添加到方法中即可</strong>。</p><p><strong>使用闭包</strong></p><pre><code class="groovy">method (b)</code></pre><p>method 为自己创建的方法。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910155625.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> gradle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> gradle </tag>
            
            <tag> groovy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJava2 Android 中使用</title>
      <link href="/2020/08/21/Android-RxJava/"/>
      <url>/2020/08/21/Android-RxJava/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是RxJava"><a href="#什么是RxJava" class="headerlink" title="什么是RxJava"></a>什么是RxJava</h1><p>实现异步操作的库</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>RxJava 是基于<strong>事件流的、实现异步操作的库</strong></p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>实现异步操作</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><pre><code class="groovy">    implementation &quot;io.reactivex.rxjava2:rxjava:2.2.6&quot;    implementation &quot;io.reactivex.rxjava2:rxandroid:2.1.0&quot;</code></pre><h4 id="使用一次订阅并打印出来"><a href="#使用一次订阅并打印出来" class="headerlink" title="使用一次订阅并打印出来"></a>使用一次订阅并打印出来</h4><ul><li>需要 Observable.fromArray 方法</li></ul><blockquote><p>fromArray用来创建一个Observable（被观察者）对象，可以将一个数组转化为可被观察的序列并且将它的数据逐个发送。</p><p>返回值：Observable</p></blockquote><ul><li>需要 subscribe 方法</li></ul><blockquote><p>subscribe 只用于连接被观察者和观察者”“()”圆括号内为观察者”</p></blockquote><ul><li>需要 Consumber 类作为参数</li></ul><blockquote><p>当你只关心观察者的onNext方法时可以使用Consumer类</p></blockquote><ul><li>需要 Subscriber.onNext() 方法</li></ul><blockquote><p>被观察者执行Subscriber.onNext()方法时会在 观察者 订阅时复写该方法来进行发送数据</p></blockquote><p>启动它即可</p><pre><code class="kotlin">        Observable.fromArray(&quot;Ted&quot;, &quot;Ryan&quot;, &quot;Billy&quot;)            .subscribe { onNext -&gt; println(&quot;name: $onNext&quot;) </code></pre><p>观察者打印了字符</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200824012835.png" alt=""></p><p><a href="https://www.youtube.com/watch?v=v7drKJyxo10&list=PL8g0JDLEKun5cDCSkiLkZ1t4r0kE4j0sV" target="_blank" rel="noopener">Android Kotlin - RxJava Intro</a></p><h4 id="刷新一次界面控件"><a href="#刷新一次界面控件" class="headerlink" title="刷新一次界面控件"></a>刷新一次界面控件</h4><ul><li>需要 Obserbable.subscribeOn()</li></ul><blockquote><p>指定Observable（被观察者）自身在哪个调度器上执行</p></blockquote><ul><li>需要 Schedule() 线程控制器</li></ul><blockquote><p>作用：指定每一段代码在什么样的线程中执行</p></blockquote><ul><li>需要 filer() 过滤操作符号</li></ul><blockquote><p>作用：输出过滤条件后的结果项。</p></blockquote><ul><li>需要 Obserbable.observeOn() 方法</li></ul><blockquote><p>指定 Subscribe 所运行在的线程。或者事件消费的线程。</p><p>指定一个观察者在哪个调度器上观察这个Observable。</p><p><strong>observeOn()可以多次使用，可以随意变换线程</strong>。</p></blockquote><ul><li>使用 AndroidSchedulers.mainThread() 方法</li></ul><blockquote><p>切换至主线程</p></blockquote><pre><code class="kotlin">        Observable.fromArray(&quot;Ted&quot;, &quot;Ryan&quot;, &quot;Billy&quot;)            .subscribeOn(Schedulers.newThread())            .filter { item -&gt; item == &quot;Ted&quot; }            .observeOn(AndroidSchedulers.mainThread())            .subscribe { onNext -&gt; textView.text = onNext }</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200825112654.png" alt=""></p><h4 id="执行一次网络访问"><a href="#执行一次网络访问" class="headerlink" title="执行一次网络访问"></a>执行一次网络访问</h4><ul><li>使用 Observable.create() 方法</li></ul><blockquote><p>作用：创建一个被观察者。</p><p>可以通过泛型<String>指定发送数据的类型</p><p>参数：复写 ObservableOnSubscribe 类型，当被观察者被订阅时会执行 subscribe() 中的事件。</p></blockquote><ul><li>需要 onError() 方法</li></ul><blockquote><p>被观察者执行Subscriber.onError()方法时会在 观察者 订阅时复写该方法来进行发送数据</p><p>参数： 发送的泛型数据类型</p></blockquote><ul><li>需要 onComplate() 方法</li></ul><blockquote><p>被观察者执行Subscriber.onComplate()方法时会在 观察者 订阅时复写该方法来进行发送数据</p><p>参数： 发送的泛型数据类型</p></blockquote><p>创建 方法 getTextFromNetwork () </p><p>创建 Observable （被观察者）处理完成后发送事件，subscribeOn 让 subscribe 到一个新的线程中执行，observeOn 切换观察者的线程到主线程刷新UI，并不断接受被观察者发送来的事件。<strong>这是一个异步的操作。</strong></p><pre><code class="kotlin">    fun getTextFromNetwork() {        val task = Observable.create&lt;String&gt; { subscriber -&gt;            try {                subscriber.onNext(&quot;网络访问&quot;)            } catch (e: Exception) {                subscriber.onError(e)            }            subscriber.onComplete()        }        task.subscribeOn(Schedulers.newThread())        task.observeOn(AndroidSchedulers.mainThread())            .subscribe { onNext -&gt; textView.text = onNext }    }</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200825210344.png" alt=""></p><p>在调用 MainActivity </p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200825211048.png" alt=""></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="Observer-接口"><a href="#Observer-接口" class="headerlink" title="Observer 接口"></a>Observer 接口</h2><pre><code class="kotlin">        val observer = object: Observable&lt;String&gt;() {            //观察者接收事件前，默认最先调用复写 onSubscribe()            override fun subscribeActual(observer: Observer&lt;in String&gt;?) {                TODO(&quot;Not yet implemented&quot;)            }        }</code></pre><h2 id="Subscriber-接口"><a href="#Subscriber-接口" class="headerlink" title="Subscriber 接口"></a>Subscriber 接口</h2><p>Subscriber 接口对 Observer 接口进行了扩展</p><pre><code class="kotlin">        val subscribe= object : Subscriber&lt;String&gt;{            //被观察者调用 onSubscribe 时发送事件，观察者会调用此方法进行响应接受此事件            override fun onSubscribe(s: Subscription?) {                TODO(&quot;Not yet implemented&quot;)            }            //被观察者调用 onNext 时发送事件，观察者会调用此方法进行响应接受此事件            override fun onNext(t: String?) {                TODO(&quot;Not yet implemented&quot;)            }            //被观察者调用 onError 时发送事件，观察者会调用此方法进行响应接受此事件            override fun onError(t: Throwable?) {                TODO(&quot;Not yet implemented&quot;)            }            //被观察者调用 onComplete 时发送事件，观察者会调用此方法进行响应接受此事件            override fun onComplete() {                TODO(&quot;Not yet implemented&quot;)            }        }</code></pre><h2 id="Single与SingleObserver"><a href="#Single与SingleObserver" class="headerlink" title="Single与SingleObserver"></a>Single与SingleObserver</h2><p><strong>什么情况下使用 Single。</strong></p><p>如果你使用一个单一的连续事件流，既然只有一个onNext()事件，接着就触发onComplete或者onError，这样你使用Single。</p><p><strong>Single共包含那些</strong></p><p>一个正常处理成功的onSuccess，另一个处理失败的onError，当然它之发送一次信息，其中Single类似于Observable。</p><p><strong>被观察者</strong></p><pre><code class="kotlin">        val single: Single&lt;String&gt; = Single.create&lt;String&gt;(object : SingleOnSubscribe&lt;String&gt; {            override fun subscribe(emitter: SingleEmitter&lt;String&gt;) {                emitter.onSuccess(&quot;t&quot;)                emitter.onSuccess(&quot;c&quot;)                // 连续发送两次是不能成功的。            }        })</code></pre><p><strong>观察者</strong></p><pre><code class="kotlin">        single.subscribe(object : SingleObserver&lt;String&gt; {            // 在被观察者调用 onSubscribe 后，观察者回调到这里。            override fun onSubscribe(d: Disposable) {            }            // 在被观察者调用 onSuccess 后，观察者回调到这里。            override fun onSuccess(t: String) {                tv.text = t            }            // 在被观察者调用 onError 后，观察者回调到这里。            override fun onError(e: Throwable) {            }        })</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-10-10-0.gif" alt="并没有按照预期变成“c”"></p><p>所有 single只适合单次事件流。</p><h2 id="RxJava中关于-Disposable"><a href="#RxJava中关于-Disposable" class="headerlink" title="RxJava中关于 Disposable"></a>RxJava中关于 Disposable</h2><p>Disposable 类</p><ul><li><h5 id="dispose"><a href="#dispose" class="headerlink" title="dispose()"></a>dispose()</h5></li></ul><blockquote><p>主动解除订阅</p></blockquote><ul><li><h5 id="isDisposed"><a href="#isDisposed" class="headerlink" title="isDisposed()"></a>isDisposed()</h5></li></ul><blockquote><p>查询是否解除订阅 。（true 代表解除）</p></blockquote><h1 id="什么是同步"><a href="#什么是同步" class="headerlink" title="什么是同步"></a>什么是同步</h1><p>在执行功能前必须一件一件做完才能进行下一步。</p><h1 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h1><p>与同步是相对的，在我们执行完某个功能之后，我们并不需要立刻得到结果，我们可以正确的做其他的操作，这个功能可以在完成后通知或者回调告诉我们；</p><p>例如：后台下载的例子中，在执行下载功能后，我们无需关心它的下载过程，在它下载完毕之后通知我们就可以了。</p><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p><a href="https://www.runoob.com/design-pattern/observer-pattern.html" target="_blank" rel="noopener">观察者模式</a></p><p>当对象间存在一对多的关系时，则使用观察者模式（Observer Patterm）。    例如：当前对象被修改时这会通知依赖它的对象。观察者模式属于行为型模式。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图</strong>:定义对象之间的一种对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并且被自动更新。</p><p><strong>主要解决</strong>:一个对象状态改变给其他对象通知的问题，而且要考虑到易用性和低耦合，保证高度的协作。</p><p><strong>何时使用</strong>:一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象)都将得到通知，进行广播通知。</p><p>如何解决当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。</p><p><strong>如何解决</strong>：使用面向对象技术，可以将这种关系弱化。</p><p><strong>关键代码</strong>：在抽象类中有一个ArrayList存放观察者。</p><p><strong>应用实例</strong>：</p><ol><li>拍卖时，拍卖师观察最高标价，然后通知其他竞价者竞价。</li><li>菩萨通过洒水招来老乌龟，老乌龟就是观察者，观察菩萨的洒水动作</li></ol><p><strong>优点</strong>：</p><ol><li>观察者和被观察者是抽象耦合的。</li><li>建立一套触发机制</li></ol><p><strong>缺点</strong>：</p><ol><li>如果一个被观察者对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li><li>如果观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅知道观察目标发送变化。</li></ol><p><strong>使用场景</strong>：</p><p>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装到独立的对象中使它们可以各自独立的改变和复用。</p><p>一个对象的改变将导致一个或多个对象也发生改变，而不知道有多少对象改变，可以降低对象之间的耦合度。</p><p>一个对象必须通知其他对象，而不知道这个对象时谁。</p><p>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……。可以使用观察者模式创建一种链式触发机制。</p><h3 id="谁是观察者谁是被观察者？"><a href="#谁是观察者谁是被观察者？" class="headerlink" title="谁是观察者谁是被观察者？"></a>谁是观察者谁是被观察者？</h3><p>当你做出了某些动作另一个人根据你的动作做出某些行为，这时你就是被观察者，另一个人是观察者。</p><h1 id="订阅-发布模式"><a href="#订阅-发布模式" class="headerlink" title="订阅-发布模式"></a>订阅-发布模式</h1><p>订阅-发布模式是观察者模式的另一个别称。</p><p>但是随着时间的变化，已经独立于观察者模式，成为另一种的设计模式。</p><p>在现在的发布订阅模式中，成为发布者的消息发送者不会将信息直接发送给订阅者，这意味这发布者和订阅者不知道彼此的存在。在发布者和订阅者之间存在第三个组件，称为调度中心或事件通道，它维持着发布者和订阅者之间的联系，过滤所有发布者传入的信息并相应的分发给它的订阅者。</p><p>例子：</p><p>你在微博关注了A，同时其他很多人也关注了A，那么当A发布动态的时候，微博就会为你推送这条动态。A就是发布者，你是订阅者，微博就是调度中心，你和A之间没有直接的消息往来，全是通过微博来协调的。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-8-3-1.gif" alt="如果有些方法没有详细说明你可以自行搜索查看"></p><p><strong>引用：</strong></p><p><a href="(https://www.cnblogs.com/onepixel/p/10806891.html)">观察者模式与订阅发布模式的区别</a></p><p><a href="https://maxwell-nc.github.io/android/rxjava2-1.html#Single%E5%92%8CSingleObserver" target="_blank" rel="noopener"><strong>RxJava 2.x 使用详解(一) 快速入门</strong></a></p><p><a href="https://www.jianshu.com/p/2a882604bbe8" target="_blank" rel="noopener">Rxjava关于Disposable你应该知道的事</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> RxJava </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>koin依赖注入框架</title>
      <link href="/2020/08/13/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-koin/"/>
      <url>/2020/08/13/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-koin/</url>
      
        <content type="html"><![CDATA[<h2 id="koin的使用"><a href="#koin的使用" class="headerlink" title="koin的使用"></a>koin的使用</h2><h4 id="添加依赖库"><a href="#添加依赖库" class="headerlink" title="添加依赖库"></a>添加依赖库</h4><pre><code>    implementation &#39;org.koin:koin-androidx-viewmodel:2.0.1&#39;    implementation &#39;org.koin:koin-android:2.0.1&#39;</code></pre><h4 id="需要创建依赖对象"><a href="#需要创建依赖对象" class="headerlink" title="需要创建依赖对象"></a>需要创建依赖对象</h4><p>这里创建三个类，Student，SchoolCourse，Friend。</p><ul><li>Student类</li></ul><blockquote><p>依赖于SchoolCourse，Friend类的方法。</p></blockquote><pre><code class="kotlin">class Student(val course: SchoolCourse,val friend: Friend) {    fun beSmart() {        course.study()        friend.hangout()    }}</code></pre><ul><li>SchoolCourse类</li></ul><blockquote><p>提供方法 study 负责打印 “I am studying”</p></blockquote><pre><code>class SchoolCourse {    fun study() {        println(&quot;I am studying&quot;)    }}</code></pre><ul><li>Friend 类</li></ul><blockquote><p>提供方法 hangout 负责打印 “We’re hanging out”</p></blockquote><pre><code>class Friend {    fun hangout() {        println(&quot;We&#39;re hanging out&quot;)    }}</code></pre><h4 id="定义依赖集合"><a href="#定义依赖集合" class="headerlink" title="定义依赖集合"></a>定义依赖集合</h4><p>创建 Modeles 文件 </p><ul><li>需要使用 module 方法</li></ul><blockquote><p>提供所需要的依赖</p></blockquote><ul><li>需要 signle 方法</li></ul><blockquote><p>使当前依赖为一个单例的对象</p></blockquote><ul><li>需要 factory 方法</li></ul><blockquote><p>定义一个工场每次调用创建一个新的实例</p></blockquote><ul><li>需要 get() 方法</li></ul><blockquote><p>get 用于最终实现注入</p></blockquote><pre><code>val appModule: Module = module {    single { SchoolCourse() }    factory { Friend() }    factory { Student(get(), get()) }}</code></pre><h4 id="启动-Koin"><a href="#启动-Koin" class="headerlink" title="启动 Koin"></a>启动 Koin</h4><ul><li><p>需要系统在创建时第一个启动Application实例</p><blockquote><p>修改 application 中的 name 属性 使得应用第一个启动它</p></blockquote></li></ul><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200813224142.png" alt=""></p><ul><li>需要创建 MyApp</li></ul><blockquote><p>第一个启动的Application实例</p></blockquote><ul><li>需要 startKoin</li></ul><blockquote><p>用来启动Koin</p></blockquote><ul><li>需要 modules</li></ul><blockquote><p>注册声明的Module</p></blockquote><ul><li>需要 androidContext</li></ul><blockquote><p>向Koin中注入context</p></blockquote><pre><code>class MyApp : Application() {    override fun onCreate() {        super.onCreate()        startKoin {            androidContext(this@MyApp)            modules(listOf(appModule))        }    }}</code></pre><h4 id="使用-koin-实现注入"><a href="#使用-koin-实现注入" class="headerlink" title="使用 koin 实现注入"></a>使用 koin 实现注入</h4><p>在需要注入的地方使用</p><ul><li>需要使用 get()</li></ul><blockquote><p>非 懒加载，注入实例</p></blockquote><p>通过 注入依赖完成后的实例调用beSmart()方法</p><pre><code>        val student = get&lt;Student&gt;()        student.beSmart()        val student2 = get&lt;Student&gt;()        student2.beSmart()</code></pre><h4 id="完成注入"><a href="#完成注入" class="headerlink" title="完成注入"></a>完成注入</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/image-20200813233756977.png" alt=""></p><h4 id="什么是-koin？"><a href="#什么是-koin？" class="headerlink" title="什么是 koin？"></a>什么是 koin？</h4><p>一个轻量级的依赖注入组件。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><a href="https://zhuanlan.zhihu.com/p/188485918" target="_blank" rel="noopener">Koin in Android: 更简单的依赖注入</a></p><h4 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h4><p>get()用于实现注入。</p><p>当你所属类型不确定时，可以指定类型。get<Type>()</p><h4 id="声明：绑定一个接口"><a href="#声明：绑定一个接口" class="headerlink" title="声明：绑定一个接口"></a>声明：绑定一个接口</h4><p>一个  single 或者 factory 声明将会使用其给定的 lambda 表达式类型。比如 single{T}，该声明所匹配的类型就是表达式所声明的类型 T 让我们以一个类及其实现的接口为例：</p><pre><code class="java">// Service interfaceinterface Service{    fun doSomething()}// Service Implementationclass ServiceImp() : Service {    fun doSomething() { ... }}</code></pre><p>在koin模块(module)，我们可以使用Kotiln下的 as 操作符。如下所示：</p><pre><code class="java">val myModule = module {    // 只匹配 Service 类型    single { ServiceImp() }    // 只匹配 Service 类型    single { ServiceImp() as Service }}</code></pre><p>你也可以使用推断类型表达式</p><pre><code class="java">val myModule = module {    // 只匹配 Service 类型    single { ServiceImp() }    // 只匹配 Service 类型    single&lt;Service&gt; { ServiceImp() }}</code></pre><p>第二种风格是首选的，在接下来的文档中，也会使用该方法。</p><h4 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h4><ul><li><p><code>bind()</code> - 为给定的对象声明添加要绑定的类型</p><p>Bind 是一个中辍函数，可以用于把一个Service关联到多个类。例如现在有两个接口：Tool，Flammable，Stove实现了这两个接口。显然如果只定义1个Service是不能同时注入Stove和这两个接口的。</p><p>这是就可以发挥Bind的作用了</p><pre><code>val myModule = module{    factory { Stove() } bind Tool::class bind Flammable::class // &lt;- here!    factory { Chef(get()) }}</code></pre><p>这么一来，下面的三个注入都是合法的，并都会得到一个 Stove 实例：</p><pre><code>val chef: Chef = get()val tool:Tool = get()val flammable:Flammable = get()</code></pre></li></ul><h4 id="named"><a href="#named" class="headerlink" title="named"></a>named</h4><p>限定符，用来区别同一个类的不同实例</p><p>使用</p><pre><code class="java"> single(named(&quot;dev&quot;)) { DataRepository() } single(named(&quot;test&quot;)) { DataRepository() }</code></pre><h4 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h4><p>可通过name或者class检索到对应的实例</p><p>使用</p><pre><code class="kotlin">    factory(name = MAIN) {        AndroidSchedulers.mainThread()    }</code></pre><h2 id="依赖注入和控制反转"><a href="#依赖注入和控制反转" class="headerlink" title="依赖注入和控制反转"></a>依赖注入和控制反转</h2><h3 id="依赖注入（Dependency-Injection，简称-DI）"><a href="#依赖注入（Dependency-Injection，简称-DI）" class="headerlink" title="依赖注入（Dependency  Injection，简称 DI）"></a>依赖注入（Dependency  Injection，简称 DI）</h3><p>什么是依赖注入？</p><p>假设 A 是 耳机，B 是播放器。</p><p>当 A 依赖 B 时（也就是耳机想要播放以音乐时），A 要想播放音乐就必须要有B的实例，也就是</p><ol><li>通过A的接口，把B传入；</li><li>通过A的构造，把B传入；</li><li>通过A的属性，把B传入；</li></ol><p>这些过程叫做<strong>依赖注入（DI）</strong></p><h3 id="控制反转（Inversion-of-Control，简称-Ioc）"><a href="#控制反转（Inversion-of-Control，简称-Ioc）" class="headerlink" title="控制反转（Inversion of Control，简称 Ioc）"></a>控制反转（Inversion of Control，简称 Ioc）</h3><p>但是 A 并不能控制 B 何时播放(创建)或者关闭(销毁)，仅使用 B ，那么 B 的控制权交给 A 之外的事务处理，这些叫做 <strong>控制反转（Ioc）</strong></p><h3 id="为什么需要依赖注入"><a href="#为什么需要依赖注入" class="headerlink" title="为什么需要依赖注入"></a>为什么需要依赖注入</h3><p>降低耦合</p><p>什么是耦合</p><p>耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。两个或多个功能模块之间的关联程度。</p><p>什么是解耦</p><p>解除类（模块）之间的直接关系，将直接关系转换成间接关系</p><p><strong>引用：</strong></p><p><a href="https://www.youtube.com/watch?v=eH9UrAwKEcE&t=140s" target="_blank" rel="noopener">Dependency Injection with Koin - Android Kotlin tutorial</a></p><p><a href="https://github.com/AndyJennifer/koin_doc_zh" target="_blank" rel="noopener">koin 中文 DOC</a></p><p><a href="https://juejin.im/post/6844904202586554382" target="_blank" rel="noopener">Koin in Android: 更简单的依赖注入</a></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-8-3-1.gif" alt="如果有些方法没有详细说明你可以自行搜索查看"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> koin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BottomSheet、BottomShaeetDialog使用流程</title>
      <link href="/2020/08/06/BottomSheets/"/>
      <url>/2020/08/06/BottomSheets/</url>
      
        <content type="html"><![CDATA[<h1 id="BottomSheet"><a href="#BottomSheet" class="headerlink" title="BottomSheet"></a>BottomSheet</h1><p>Demo 代码 <a href="https://medium.com/@droidbyme/android-bottom-sheet-7e9cfcec6427" target="_blank" rel="noopener">https://medium.com/@droidbyme/android-bottom-sheet-7e9cfcec6427</a><br>使用 BottomSheet、BottomSheetDialog、BottomSheetDialogFragment</p><h4 id="BottomSheet使用流程"><a href="#BottomSheet使用流程" class="headerlink" title="BottomSheet使用流程"></a>BottomSheet使用流程</h4><p>BottomSheet实现按钮在点击之后滑动布局.不联动也是可以的只要不设置它就可以了。</p><p><strong>被联动的布局使用</strong></p><pre><code class="xml">app:layout_behavior=&quot;@string/bottom_sheet_behavior&quot;</code></pre><p><strong>联动按钮使用属性</strong></p><pre><code class="xml">app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-17_21-58-16.png" alt=""></p><p><strong>在初始化时被联动</strong></p><pre><code class="kotlin">          //  设置绑定动作        //  控件和它绑定        var buttomSheetBehavior = BottomSheetBehavior.from(bottom_sheet_layout)</code></pre><p><strong>设置按钮了</strong></p><p>也就是在现在监听按钮的时候才进行这个按钮的联动滑动</p><pre><code class="kotlin">     btnBottomSheet.setOnClickListener {            if (buttomSheetBehavior.getState() != BottomSheetBehavior.STATE_EXPANDED)                buttomSheetBehavior.state = BottomSheetBehavior.STATE_EXPANDED            else                buttomSheetBehavior.state = BottomSheetBehavior.STATE_COLLAPSED        }</code></pre><p>设置在显示时不显示,不显示时显示。</p><p>设置监听器在它被拖动、滑动、切换时产生提示。</p><pre><code class="kotlin">        buttomSheetBehavior.setBottomSheetCallback(object : BottomSheetCallback() {            //这里是拖拽中的回调，根据slideOffset可以做一些动画            override fun onSlide(bottomSheet: View, slideOffset: Float) {            }            //这里是bottomSheet状态的改变            override fun onStateChanged(bottomSheet: View, newState: Int) {                when (newState) {                    BottomSheetBehavior.STATE_EXPANDED -&gt; {                        Toast.makeText(this@MainActivity, &quot;展开&quot;, Toast.LENGTH_LONG).show()                    }                    BottomSheetBehavior.STATE_COLLAPSED -&gt; {                        Toast.makeText(this@MainActivity, &quot;关闭&quot;, Toast.LENGTH_LONG).show()                    }                    BottomSheetBehavior.STATE_DRAGGING -&gt; {                        Toast.makeText(this@MainActivity, &quot;拖拽状态&quot;, Toast.LENGTH_LONG).show()                    }                    BottomSheetBehavior.STATE_HIDDEN -&gt; {                        Toast.makeText(this@MainActivity, &quot;隐藏状态&quot;, Toast.LENGTH_LONG).show()                    }                    BottomSheetBehavior.STATE_SETTLING -&gt; {                        Toast.makeText(                            this@MainActivity,                            &quot; 拖拽松开之后到达终点位置（collapsed or expanded）前的状态&quot;,                            Toast.LENGTH_LONG                        ).show()                    }                }            }        })</code></pre><h4 id="BottomSheetDialog使用流程"><a href="#BottomSheetDialog使用流程" class="headerlink" title="BottomSheetDialog使用流程"></a>BottomSheetDialog使用流程</h4><p>点击按钮之后弹出Dialog提示(布局界面有且准备好的)</p><p><strong>设置按钮的监听器，点击之后直接弹出Dialog窗口。</strong></p><pre><code class="kotlin">  /*        * Java函数式接口        * 弹窗提示        * */        btnBottomSheetDialog.setOnClickListener {            //使用布局加载器layoutInflater            val view = layoutInflater.inflate(R.layout.fragment_bottom_sheet, null)            //实例话BottomSheetDialog():用来实现弹出提示功能            val dialog = BottomSheetDialog(this)            dialog.setContentView(view)            dialog.show()        }</code></pre><h4 id="BottomSheetDialogFragment在当前界面加载Dialog碎片"><a href="#BottomSheetDialogFragment在当前界面加载Dialog碎片" class="headerlink" title="BottomSheetDialogFragment在当前界面加载Dialog碎片"></a>BottomSheetDialogFragment在当前界面加载Dialog碎片</h4><pre><code class="kotlin">        /*        * 在当前界面加载碎片        * */        btnBottomSheetDialogFragment.setOnClickListener {            val bottomSHeetFragment = BottomSheetFragment()            bottomSHeetFragment.show(supportFragmentManager, bottomSHeetFragment.tag)        }</code></pre><p><strong>准备好要加载的碎片,它是要有bottom_sheet_dialog类型的界面</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MediaStore访问图片、视频</title>
      <link href="/2020/08/01/MediaStore%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/08/01/MediaStore%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="使用”MediaStore”访问图片、视频的缩略图"><a href="#使用”MediaStore”访问图片、视频的缩略图" class="headerlink" title="使用”MediaStore”访问图片、视频的缩略图"></a>使用”MediaStore”访问图片、视频的缩略图</h2><h3 id="需要动态申请权限"><a href="#需要动态申请权限" class="headerlink" title="需要动态申请权限"></a>需要动态申请权限</h3><p>需要配置文件中添加要 申请的权限 “AndroidManifest.xml”</p><pre><code class="xml">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</code></pre><h4 id="注册动态权限"><a href="#注册动态权限" class="headerlink" title="注册动态权限"></a>注册动态权限</h4><ul><li><p>需要自定义 “checkReadExternalStoragePermission()”方法</p></li><li><p>需要 “Build.VERSION.SDK_INT”方法获得当前系统的版本号</p></li><li><p>需要 “Build.VERSION_CODES.M”表示安卓6</p></li><li><p>需要 “ContextCompat.checkSelfPermission()”方法, 判断是否获得了权限.</p></li></ul><blockquote><p>参数1:上下文.参数2:要判断的权限. </p><p>返回值:PackageManager.<strong>PERMISSION_GRANTED</strong> <strong>表示授予权限</strong>,PackageManager.<strong>PERMISSION_DENIED</strong>  = -1    <strong>表示权限未开启</strong>；</p></blockquote><ul><li>需要 “shouldShowRequestPermissionRationale()”方法.</li></ul><blockquote><p>判断当前权限是否被拒绝,并且显示窗口,显示”运行”和”拒绝”选项.</p><p>第一次不显示”不再提醒”按钮,第二次窗口添加”不再显示选择框”。</p><p>返回值:拒绝返回 true ,允许返回 false 或者 不再提醒选中后 返回 false</p></blockquote><ul><li>需要 “requestPermission()”方法.</li></ul><blockquote><p>用来申请系统权限. <strong>每次被调用时都会回调”onRequestPermissionsResult()”方法。</strong></p><p>参数1:要申请的权限.</p><p>参数2:要申请权限的 code 以用来在申请方法回调时确定是当前的申请操作.</p></blockquote><p>在需要注册权限的活动上添加</p><pre><code>    private fun checkReadExternalStoragePermission() {        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {            if (ContextCompat.checkSelfPermission(                    this,                    permission.READ_EXTERNAL_STORAGE                ) == PackageManager.PERMISSION_GRANTED            ) {                   } else {                if (shouldShowRequestPermissionRationale(permission.READ_EXTERNAL_STORAGE)) {                    Toast.makeText(this, &quot;App needs to view thumbnails&quot;, Toast.LENGTH_LONG).show()                }                requestPermissions(                    arrayOf(permission.READ_EXTERNAL_STORAGE),                    READ_EXTERNAL_STORAGE_PERMISSION_RESULT                )            }        } else {        }    }</code></pre><pre><code>    private val READ_EXTERNAL_STORAGE_PERMISSION_RESULT: Int = 0</code></pre><ul><li>需要重写 “onRequestPermissionsResult()”方法</li></ul><blockquote><p>申请权限时会调用它(申请权限时的回调)</p><p>参数1:申请权限时的Code,表示申请权限的操作是否相同.</p><p>参数2:这是要申请的权限永远不为空.</p><p>参数3:表示权限授权的结果永远封装在grantResult数组中</p></blockquote><pre><code>override fun onRequestPermissionsResult(        requestCode: Int,        permissions: Array&lt;out String&gt;,        grantResults: IntArray    ) {        super.onRequestPermissionsResult(requestCode, permissions, grantResults)        when (requestCode) {            READ_EXTERNAL_STORAGE_PERMISSION_RESULT -&gt; {                if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {                    Toast.makeText(this, &quot;now have access to view thumbs&quot;, Toast.LENGTH_LONG).show()                }            }        }    }</code></pre><h3 id="需要RecyclerView的适配器"><a href="#需要RecyclerView的适配器" class="headerlink" title="需要RecyclerView的适配器"></a>需要RecyclerView的适配器</h3><p><a href="https://thecara.github.io/2020/07/26/RecyclerView%E5%9C%A8Kotlin%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/#toc-heading-7">使用此案例创建适配器</a></p><p>初始化控件不再复述了,</p><ul><li>需要变量”mMediaStoreCursor”</li></ul><blockquote><p>表示当前的Cursor</p></blockquote><pre><code>class MediaStoreAdapter(private val mActivity: Activity) :    RecyclerView.Adapter&lt;MediaStoreAdapter.ViewHolder&gt;() {    private var mMediaStoreCursor: Cursor? = null        }</code></pre><ul><li><strong>需要自定义”getBitmapFromMediaStore()”方法</strong></li></ul><blockquote><p>获得系统中图片和视频的缩略图.通过Cursor获得照片和Video的缩略图</p><p>参数1:移动到对应Cursor的行.</p></blockquote><ul><li>需要使用”Cursor.getColumnIndex()”方法</li></ul><blockquote><p>获得当前MediaStoreCursor的”参数1”的索引</p><p>参数1:要索引的位置</p><p>返回值: 返回在当前 Cursor 中的位置,没有返回 -1 </p></blockquote><ul><li>需要使用”Cursor.getInt()’方法</li></ul><blockquote><p>获得”Cursor”中索引(列)的数值.</p><p>参数1:你想要获得的列</p><p>返回值:返回指定列的数值</p></blockquote><ul><li>需要 “MediaStore.Images.Thumbnails.getThumbnail”方法</li></ul><blockquote><p>获得缩略图.</p><p>参数1:表示内容提供器. 参数2:当前”Cursor”缩略图的ID. </p><p>参数3:返回时的清晰度.MICRO_KIND,MINI_KIND字面意思为微型和迷你缩略模式,前者分辨率更低.</p><p>返回值:返回一个Bitmap格式</p></blockquote><p>在适配器中添加</p><pre><code>class MediaStoreAdapter(private val mActivity: Activity) :    RecyclerView.Adapter&lt;MediaStoreAdapter.ViewHolder&gt;() {              private fun getBitmapFromMediaStore(position: Int): Bitmap? {        val idIndex: Int = mMediaStoreCursor!!.getColumnIndex(MediaStore.Files.FileColumns._ID)        val mediaTypeIndex: Int =            mMediaStoreCursor!!.getColumnIndex(MediaStore.Files.FileColumns.MEDIA_TYPE)        mMediaStoreCursor!!.moveToPosition(position)        when (mMediaStoreCursor!!.getInt(mediaTypeIndex)) {            // 当前类型为 IMAGE 时            MediaStore.Files.FileColumns.MEDIA_TYPE_IMAGE -&gt; {                return MediaStore.Images.Thumbnails.getThumbnail(                    mActivity.contentResolver,                    mMediaStoreCursor!!.getLong(idIndex),                    MediaStore.Images.Thumbnails.MICRO_KIND, null                )            }            // 当前类型为 VIDEO            MediaStore.Files.FileColumns.MEDIA_TYPE_VIDEO -&gt; {                return MediaStore.Video.Thumbnails.getThumbnail(                    mActivity.contentResolver,                    mMediaStoreCursor!!.getLong(idIndex),                    MediaStore.Video.Thumbnails.MICRO_KIND, null                )            }        }        return null    }}</code></pre><ul><li><strong>需要自定义方法”swapCursor()”</strong></li></ul><blockquote><p>获得上一个Cursor.</p></blockquote><ul><li>需要 “notifyDataSetChanged()” 方法</li></ul><blockquote><p>检测当前UI线程,刷新UI</p></blockquote><pre><code>class MediaStoreAdapter(private val mActivity: Activity) :    RecyclerView.Adapter&lt;MediaStoreAdapter.ViewHolder&gt;() {   private fun swapCursor(cursor: Cursor): Cursor? {        if (mMediaStoreCursor == cursor) {            return null        }        val oldCursor: Cursor? = mMediaStoreCursor        this.mMediaStoreCursor = cursor        if (cursor != null) {            this.notifyDataSetChanged()        }        return oldCursor    }}</code></pre><ul><li><strong>需要 自定义方法”changeCursor()”</strong></li></ul><blockquote><p>检测上一个Cursor,用来关闭上个Cursor.</p></blockquote><pre><code>class MediaStoreAdapter(private val mActivity: Activity) :    RecyclerView.Adapter&lt;MediaStoreAdapter.ViewHolder&gt;() {        fun changeCursor(cursor: Cursor?) {        val oldCursor: Cursor? = swapCursor(cursor!!)        if (oldCursor != null)            oldCursor.close()    }}</code></pre><ul><li>需要重写 “onBindViewHolder()”方法</li></ul><pre><code>    override fun onBindViewHolder(holder: ViewHolder, position: Int) {        val bitmap: Bitmap? = getBitmapFromMediaStore(position)        if (bitmap != null) {            holder.mediastoreImageView.setImageBitmap(bitmap)        }    }</code></pre><ul><li>需要重写”getItemCount()”方法</li></ul><pre><code>    override fun getItemCount(): Int {        return if (mMediaStoreCursor == null) 0 else mMediaStoreCursor!!.count    }</code></pre><ul><li>需要重写”onCreateViewHolder()”方法</li></ul><pre><code>    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {        val view =            LayoutInflater.from(parent.context).inflate(R.layout.media_image_view, parent, false)        return ViewHolder(view)    }</code></pre><h3 id="需要”LoaderManager-LoaderCallbacks”"><a href="#需要”LoaderManager-LoaderCallbacks”" class="headerlink" title="需要”LoaderManager.LoaderCallbacks”"></a>需要”LoaderManager.LoaderCallbacks”</h3><ul><li>需要实现LoaderManager.LoaderCallbacks<cursor>.(在MediaMainActivity)</li></ul><blockquote><p>在需要的Fragment或Activity中实现它。</p></blockquote><pre><code>class MediaMainActivity : AppCompatActivity(), LoaderManager.LoaderCallbacks&lt;Cursor&gt; {}</code></pre><ul><li>需要重写”onCreateLoader”</li></ul><blockquote><p>在调用initLoader()返回时创建一个Loader.</p><p>根据传入的ID,初始化并返回一个新的加载器.</p></blockquote><ul><li>需要返回的列</li></ul><blockquote><p>MediaStore.Files.FileColums.ID 返回Id列</p><p>MediaStore.Files.FIleColums.DATE_ADDED 图片被添加的时间</p><p>MediaStore.Files.FileColums.MEDIA_TYPE 媒体类型</p><p>MediaStore.Files.FileColums.MEDIA_TYPE_IMAGE 图片列(索引)</p><p>MediaStore.Files.FileColums.MEDIA_TYPE_VIDEO 视频列(索引)</p></blockquote><ul><li>需要”CursorLoader()”匿名类</li></ul><blockquote><p>它查询ContentResolver然后返回一个Cursor.</p><p>参数1:上下文. 参数2:要操作的URI.当前表示所有图片的URI.</p><p>参数3:要返回的列. 参数4:一个过滤器,表明哪些行要被返回.当前返回类型为IMAGE 或 VIDEO</p><p>参数5:用作过滤器的参数. </p><p>参数6:设置排序.相当于SQL语句中Order by.这里使用 DATA_ADDED + DESC 表示按照时间进行排序.</p></blockquote><pre><code class="kotlin">    override fun onCreateLoader(p0: Int, p1: Bundle?): androidx.loader.content.Loader&lt;Cursor&gt; {        val projection = arrayOf&lt;String&gt;(            MediaStore.Files.FileColumns._ID,            MediaStore.Files.FileColumns.DATE_ADDED,            MediaStore.Files.FileColumns.MEDIA_TYPE        )        // SQL命令        val selection =            MediaStore.Files.FileColumns.MEDIA_TYPE +                    &quot; = &quot; + MediaStore.Files.FileColumns.MEDIA_TYPE_IMAGE + &quot; or &quot; + MediaStore.Files.FileColumns.MEDIA_TYPE +                    &quot; = &quot; + MediaStore.Files.FileColumns.MEDIA_TYPE_VIDEO        return object : CursorLoader(            this,            MediaStore.Files.getContentUri(&quot;external&quot;),            projection,            selection,            null,            MediaStore.Files.FileColumns.DATE_ADDED + &quot; DESC &quot;        ) {}    }</code></pre><ul><li>需要重写 “onLoadFinished()”方法</li></ul><blockquote><p>更新UI操作.当一个加载器完成了它的装载过程后被调用.</p></blockquote><ul><li>需要调用changeCursor()方法</li></ul><blockquote><p>刷新当前参数1,关闭上一个Cursor</p><p>参数1:当前的Cursor</p></blockquote><pre><code>class MediaMainActivity : AppCompatActivity(), LoaderManager.LoaderCallbacks&lt;Cursor&gt; {    override fun onLoadFinished(loader: androidx.loader.content.Loader&lt;Cursor&gt;, data: Cursor?) {        mMediaStoreAdapter?.changeCursor(data!!)    }}</code></pre><ul><li>需要重写”onLoaderReset()”方法</li></ul><blockquote><p>何时释放内存,当一个加载器完成了它的装载工作之后被调用</p></blockquote><pre><code>class MediaMainActivity : AppCompatActivity(), LoaderManager.LoaderCallbacks&lt;Cursor&gt; {   override fun onLoaderReset(loader: androidx.loader.content.Loader&lt;Cursor&gt;) {        mMediaStoreAdapter?.changeCursor(null)    }}</code></pre><ul><li><p>需要在用于权限和申请权限之后添加</p></li><li><p>需要在”onRequestPermissionsResult()”中调用”getSupportLoaderManager.initLoader()”</p></li></ul><blockquote><p>启动加载器</p><p>参数1:一个唯一的ID来标志加载器.</p><p>参数2:可选参数,用于加载初始化时(本例为null)</p><p>参数3:LoaderManager.LoaderCallbacks的实现.被LoaderManger调用以报告加载事件,在例子中是传递给自己”this”</p></blockquote><pre><code>when (requestCode) {            READ_EXTERNAL_STORAGE_PERMISSION_RESULT -&gt; {                if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {                //添加 supportLoaderManager.initLoader(MEDIASTORE_LODAR_ID, null, this)                }            }        }</code></pre><ul><li>需要在”checkReadExternalStoragePermission()”中调用</li><li>需要在拥有权限后调用,在”checkSelfPermission()”判断拥有权限后调用</li></ul><pre><code>        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {                  if (ContextCompat.checkSelfPermission(                    this,                    permission.READ_EXTERNAL_STORAGE                ) == PackageManager.PERMISSION_GRANTED            ) {              //添加  supportLoaderManager.initLoader(MEDIASTORE_LODAR_ID, null, this)            }         } else {            //添加  supportLoaderManager.initLoader(MEDIASTORE_LODAR_ID, null, this)        }</code></pre><p>ps:显示了在哪里添加其他的代码不用修改.</p><ul><li>需要添加唯一的ID标志加载器.</li></ul><pre><code>class MediaMainActivity : AppCompatActivity(), LoaderManager.LoaderCallbacks&lt;Cursor&gt; {    private val MEDIASTORE_LODAR_ID: Int = 0}</code></pre><ul><li>需要GridLayoutManger,在 “onCreate()” 中添加</li></ul><blockquote><p>设置RecyclerView的布局</p><p>参数1:上下文 . 参数2:多少列</p></blockquote><pre><code>val gridLayoutManager: GridLayoutManager = GridLayoutManager(this, 3)</code></pre><ul><li>需要RecyclerView的setLayoutManager</li></ul><blockquote><p>设置 GridLayoutManager</p></blockquote><pre><code>thumbnailRecyclerView.layoutManager = gridLayoutManager</code></pre><ul><li>需要设置适配器省略..</li></ul><h3 id="使用-“Glide”的方式加载图片"><a href="#使用-“Glide”的方式加载图片" class="headerlink" title="使用 “Glide”的方式加载图片"></a>使用 “Glide”的方式加载图片</h3><ul><li>需要添加依赖</li></ul><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200803180403.png" alt=""></p><ul><li>需要“MediaStore.Files.FileColumns.DATA”（需要在onCreateLoader的projection修改）</li></ul><blockquote><p>表述索引在磁盘中位置</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200803180843.png" alt=""></p><p>需要创建自定义返回“getUriFromMediaStore()”（在MediaStoreAdapter中添加）</p><blockquote><p>获得缩略图在ContentResolver中的uri</p><p>参数1：media的那个行</p></blockquote><p>需要“Uri.parse()” 方法</p><blockquote><p>将字符串解析成uri对象</p></blockquote><pre><code>    private fun getUriFromMediaStore(position: Int): Uri {        val dataIndex: Int = mMediaStoreCursor!!.getColumnIndex(MediaStore.Files.FileColumns.DATA)        mMediaStoreCursor!!.moveToPosition(position)        val mediaUri: Uri =            Uri.parse(&quot;file://&quot; + mMediaStoreCursor!!.getString(dataIndex).toString())        return mediaUri    }</code></pre><p>需要“Glide” - (在onBindViewHolder()中添加)</p><blockquote><p>with(content:Content) - 需要上下文</p><p>load(uri:String) - 图片的uri</p><p>centerCrop() - 将图片按比例缩放到足以填充ImageView的尺寸，但是图片可能会显示不完整。</p><p>override(width,height) 重新改变图片大小。</p><p>into() - 你需要显示图片的目标。</p></blockquote><pre><code>      Glide.with(mActivity).load(getUriFromMediaStore(position)).centerCrop().override(96, 96)            .into(holder.mediastoreImageView)</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200803184305.png" alt=""></p><h2 id="什么是Loader"><a href="#什么是Loader" class="headerlink" title="什么是Loader"></a>什么是Loader</h2><p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/developer/2014/0325/1602.html" target="_blank" rel="noopener">android 加载器loader详解</a></p><p>Loader简化了activity和Fragment中异步加载数据的步骤.</p><p>特点:适用于每个Activity和Fragment,提供异步加载的实现方式,监听数据源,在数据发生改变时自动返回新的结果。当由于配置改变后被重新创建后,它们自动重新链接上一个加载游标,所以不必重新查数据.</p><p>loader API 说明</p><table><thead><tr><th align="center">Class/Interface</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">LoaderManager</td><td align="center">一个与Activity和Fragment相关联的抽象类,它管理一个或者多个Loader实例,帮助一个应用管理哪些与Activity或Fragment的声明周期相关的长时间操作.常见方式是与CursorLoader一起使用,然后应用也可以自己写一个加载其他数据类型或者数据源的loader。<strong>每个Activity或者Fragment只有一个LoaderManager.但是一个LoaderManager可以拥有多个加载器</strong></td></tr><tr><td align="center">LoaderManager.LoaderCallbacks</td><td align="center">用于一个客户端与LoaderManager交互的会调接口.例如,你使用回调方法onCreateLoader()来创建一个新的加载器.</td></tr><tr><td align="center">Loader</td><td align="center">一个执行异步数据加载的抽象类,它是加载器的基础类.你可以使用经典的CursorLoader,但是你也可以实现你的子类.一旦加载器被激活,它们将监听它的数据源并且在数据改变时发送新的结果.</td></tr><tr><td align="center">AsyncTaskLoader</td><td align="center">提供一个AsyncTask来执行异步加载工作的抽象类</td></tr><tr><td align="center">CursorLoader</td><td align="center">AsyncTaskLoader的子类,它查询ContentResolver然后返回一个Cursor.这个类为查询Cursor以标准的方式实现了加载器协议,它的游标查询是通过AsyncTaskLoader在后台线程中执行,从而不会阻断线程</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-8-3-1.gif" alt="如果有些方法没有详细说明你可以自行搜索查看"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLite Database 使用</title>
      <link href="/2020/07/28/SQLite-Database-%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/07/28/SQLite-Database-%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><h5 id="需要-创建数据库-类-“MyHelper”"><a href="#需要-创建数据库-类-“MyHelper”" class="headerlink" title="需要 创建数据库 类 “MyHelper”"></a>需要 创建数据库 类 “MyHelper”</h5><pre><code class="kotlin">class MyHelper(    private val mContext: Context? = null,    private val dbname: String = &quot;mydb&quot;,    private val version: Int = 1) : SQLiteOpenHelper(mContext, dbname, null, version) {    /*    * 需要变量sql确定表的格式    * 需要 execSQL()执行创建表的动作    * */    override fun onCreate(p0: SQLiteDatabase?) {        // 创建数据库表        val sql: String =            &quot;CREATE TABLE PRODUCTS (_id INTEGER PRIMARY KEY AUTOINCREMENT, NAME TEXT, DESCRIPTION TEXT, PRICE READ)&quot;        // 执行创建表的动作        p0?.execSQL(sql)    }    /*    *    * */    override fun onUpgrade(p0: SQLiteDatabase?, p1: Int, p2: Int) {        TODO(&quot;Not yet implemented&quot;)    }}</code></pre><ul><li>创建数据库需要继承SQLiteOpenHelper()类型,需要四个参数进行初始化</li><li>(四个参数:mContext:上下文,dbname: 数据库名称,version:数据库版本,factory:null)</li><li>需要实现两个方法onCreate()和onUpgrade()方法</li></ul><h5 id="在需要创建数据库时调用"><a href="#在需要创建数据库时调用" class="headerlink" title="在需要创建数据库时调用"></a>在需要创建数据库时调用</h5><pre><code class="kotlin"> var myHelper: MyHelper = MyHelper(mContext = this) val sqlLiteDatabase: SQLiteDatabase = myHelper.readableDatabase</code></pre><p>这时数据库就创建完成了</p><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>创建仓库后插入数据</p><p>需要”ContentValues()”类型</p><p>需要”SQLiteDatabase的insert()”方法</p><p>在”自定义数据库中”中添加方法</p><pre><code>    private fun instertData(        name: String,        description: String,        price: Double,        database: SQLiteDatabase    ) {        // ContentValues() 类型负责存放键值的数据.你只需要记住它是往数据库中存放数据的.        val values: ContentValues = ContentValues()        values.put(&quot;NAME&quot;, name)        values.put(&quot;DESCRIPTION&quot;, description)        values.put(&quot;PRICE&quot;, price)        // 向当前数据库(database)插入数据(values)        database.insert(&quot;PRODUCTS&quot;, null, values)    }</code></pre><p>在<strong>外部要插入数据</strong>设置类型为 “public”即可。</p><p>插入数据在外部调用方法</p><pre><code>        // insert        instertData(&quot;Jam&quot;, &quot;Fruit Jam&quot;, 300.1, p0!!)        instertData(&quot;Yli&quot;, &quot;Te Jam&quot;, 305.13, p0!!)        instertData(&quot;Tom Li&quot;, &quot;Zhou Jam&quot;, 210.7, p0!!)</code></pre><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>需要”MyHelper”自定义<strong>数据库类的实例</strong></p><p>需要”MyHelper.readableDatabase”方法读取数据库方法<strong>返回一个可对数据库读写的对象</strong>.</p><p>需要”sqlLiteDatabase.rawQuery()”方法<strong>获得(数据库表)每行的集合</strong>(Cursor类型).</p><pre><code>  // 实例话自定义的数据类        var myHelper: MyHelper = MyHelper(mContext = this)        // 创建数据库        val sqlLiteDatabase: SQLiteDatabase = myHelper.readableDatabase        val cursor: Cursor =            sqlLiteDatabase.rawQuery(&quot;SELECT NAME, PRICE FROM PRODUCTS&quot;, arrayOf&lt;String&gt;())        if (cursor != null)            cursor.moveToFirst()        val builder: StringBuilder = StringBuilder()        do {            val name: String = cursor.getString(0)            val price: Double = cursor.getDouble(1)            builder.append(&quot;NAME - &quot; + name + &quot;PRICE - &quot; + price)        } while (cursor.moveToNext())        // 这是在界面上刷新了读取的数据        text_view.setText(builder.toString())</code></pre><p><img src="1595946627126.png" alt=""></p><h4 id="按照条件查询指定数据"><a href="#按照条件查询指定数据" class="headerlink" title="按照条件查询指定数据"></a>按照条件查询指定数据</h4><pre><code>   val cursor: Cursor =            sqlLiteDatabase.rawQuery(&quot;SELECT NAME, PRICE FROM PRODUCTS WHERE NAME = ?&quot;, arrayOf&lt;String&gt;(&quot;Tom Li&quot;))</code></pre><p>查询 列 “NAME,PRICE” 来自表 “PRODUCTS” 根据条件 “NAME = ?”</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200731132244.png" alt=""></p><p>查询完成</p><h2 id="什么是Cursor类型"><a href="#什么是Cursor类型" class="headerlink" title="什么是Cursor类型"></a>什么是Cursor类型</h2><p><a href="https://blog.csdn.net/android_zyf/article/details/53420267" target="_blank" rel="noopener">引用:Android中的Cursor到底是什么？如何理解Cursor的方法都在做什么事情？</a></p><blockquote><p>Cursor是每行的集合</p></blockquote><p>表中共有多行数据.</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200729122947.png" alt=""></p><p>假如:获得通过”select”语句”gender”获得符合这列的男性那么得到的是 “张三,赵六”这两行数据.也就是<strong>说 “Cursor”类型存放了两行数据。</strong></p><h4 id="如何获得Cursor类型"><a href="#如何获得Cursor类型" class="headerlink" title="如何获得Cursor类型"></a>如何获得Cursor类型</h4><p>通过数据库对象的方法获得。👇</p><pre><code>SQLiteDataBase db;Cursor cursor = db.query(各种参数);</code></pre><p>这些就是每一行的集合</p><h4 id="索引在Cursor中是什么"><a href="#索引在Cursor中是什么" class="headerlink" title="索引在Cursor中是什么"></a>索引在Cursor中是什么</h4><p>在Cursor中索引指的就是<strong>表中的列</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200731174701.png" alt=""></p><p>返回了”PRICE”列在表中的索引(位置)。</p><h4 id="关于为何要使用-“moveToFirst-”-方法"><a href="#关于为何要使用-“moveToFirst-”-方法" class="headerlink" title="关于为何要使用 “moveToFirst()” 方法"></a>关于为何要使用 “moveToFirst()” 方法</h4><p>利用反证法,<strong>不使用”moveToFirst()”方法,</strong>获得游标后,直接输出当前的”position”值</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200729210143.png" alt=""></p><p><strong>“position”的值会直接输出 “-1”</strong>,也就是说当我们不适用”moveToFirst()”方法时它会在坐标”position”(0)的<strong>上边</strong>。</p><p>所以我们应该使用方法”moveToFirst()”使”position”为”0”。</p><h4 id="源码分析-使用”moveToNext-”方法是如何得知遍历完成的"><a href="#源码分析-使用”moveToNext-”方法是如何得知遍历完成的" class="headerlink" title="源码分析 使用”moveToNext()”方法是如何得知遍历完成的?"></a>源码分析 使用”moveToNext()”方法是如何得知遍历完成的?</h4><p>先说明 <strong>调用”moveToNext()”方法最总会调用”moveToPosition()”方法</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200729212802.png" alt=""></p><p>👆界面在被初始化时,指当前页面的对象。这时源<strong>码中的”mPos=-1”会被在一个空参数构造方法里初始化</strong>。</p><p>仅理解的话: <strong>“moveToFirst()”调用的是”moveToPostion(0)”,”moveToNext()” 调用的是”moveToNext(mPos+1)”,所以说当首次调用的他们两个的结果是一样的。</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200729215028.png" alt=""></p><p>ps:个人理解:在使用”cursor.moveToFirst()”先进行判断可以更有效的避免空指针异常j</p><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>需要修改<strong>数据库返回的类型为可写入类型</strong></p><pre><code class="kotlin">        // 创建数据库        val sqlLiteDatabase: SQLiteDatabase = myHelper.writableDatabase</code></pre><p>需要 “ContentValues()” 类型存放更新的值</p><pre><code>        //更新数据        val values: ContentValues = ContentValues()        values.put(&quot;PRICE&quot;, 280)        // 参数1:表示更新的表.参数2:表示更新的数据.参数3:表示条件(表示通过那个条件更新值) 参数4:条件的值        sqlLiteDatabase.update(&quot;PRODUCTS&quot;, values, &quot;_id = ?&quot;, arrayOf&lt;String&gt;(&quot;1&quot;))</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200731130854.png" alt=""></p><p>“280”价格更新了</p><h4 id="多条件更新"><a href="#多条件更新" class="headerlink" title="多条件更新"></a>多条件更新</h4><p>更新表 “<strong>PRODUCTS</strong>“ 的值 “<strong>values</strong>“,根据 “<strong>NAME</strong>“为”<strong>Tom Li</strong>“ 和”<strong>DESCRIPTION</strong>“ 为 “<strong>Zhou Jam</strong>“ 的行中的数据.</p><pre><code>sqlLiteDatabase.update(&quot;PRODUCTS&quot;, values, &quot;NAME = ? AND DESCRIPTION = ?&quot;, arrayOf&lt;String&gt;(&quot;Tom Li&quot;,&quot;Zhou Jam&quot;))</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200731132831.png" alt=""></p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>在获得数据库的<strong>可写入类型后。</strong> 调用 “delete()”方法。</p><pre><code>        // 根据条件删除一行数据        // 参数1:要删除的表名字,参数2:选择删除的条件(根据这个条件删除),参数3:条件的值        sqlLiteDatabase.delete(&quot;PRODUCTS&quot;, &quot;_id=?&quot;, arrayOf&lt;String&gt;(&quot;1&quot;))</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200731131332.png" alt=""></p><p>删除成功了.</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> SQLite </tag>
            
            <tag> Cursor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库索引</title>
      <link href="/2020/07/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
      <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是数据库索引"><a href="#什么是数据库索引" class="headerlink" title="什么是数据库索引"></a>什么是数据库索引</h2><p>MySql官网的介绍,索引是帮助<code>MySQL</code>高效获得数据的结构。类似于书本的目录,从而提高查询速度。</p><p><a href="https://segmentfault.com/a/1190000022341554" target="_blank" rel="noopener">初探MySQL索引</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chocolatey的配置与应用的安装</title>
      <link href="/2020/07/26/choco%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2020/07/26/choco%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-Chocolatey安装7zip"><a href="#使用-Chocolatey安装7zip" class="headerlink" title="使用 Chocolatey安装7zip"></a>使用 Chocolatey安装7zip</h2><p>全程使用科学上网</p><pre><code>choco install 7zip</code></pre><h2 id="如何安装Chocolatey"><a href="#如何安装Chocolatey" class="headerlink" title="如何安装Chocolatey"></a>如何安装Chocolatey</h2><p><a href="https://chocolatey.org/install.ps1" target="_blank" rel="noopener">在桌面下载</a></p><p>使用管理员打开cmd访问到下载的目录中</p><p>输入👇.安装的同时要使用科学上网</p><pre><code>@powershell -NoProfile -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&#39;install.ps1&#39;))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin&quot;</code></pre><p>查看是否安装成功：</p><p>choco</p><p><img src="1595823753408.png" alt=""></p><h2 id="什么是Chocolatey"><a href="#什么是Chocolatey" class="headerlink" title="什么是Chocolatey"></a>什么是Chocolatey</h2><p>Chocolatey是一个Windows下的软件包管理器，你可以像在类Unix系统中使用Yum和APT一样使用它，在Windows中实现自动化轻松管理Windows软件的所有方面。</p><p> <a href="https://zh.wikipedia.org/zh-cn/Chocolatey" target="_blank" rel="noopener">维基百科</a></p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2>]]></content>
      
      
      <categories>
          
          <category> Chocolatey </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chocolatey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin in Action-Kotlin实战</title>
      <link href="/2020/07/26/kotlin-in-Action-Kotlin%E5%AE%9E%E6%88%98/"/>
      <url>/2020/07/26/kotlin-in-Action-Kotlin%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="2-Kotlin-基础"><a href="#2-Kotlin-基础" class="headerlink" title="2 Kotlin 基础"></a>2 Kotlin 基础</h1><h3 id="2-1-基本要素-函数变量"><a href="#2-1-基本要素-函数变量" class="headerlink" title="2.1 基本要素: 函数变量"></a>2.1 基本要素: 函数变量</h3><h4 id="2-1-3-变量"><a href="#2-1-3-变量" class="headerlink" title="2.1.3 变量"></a>2.1.3 变量</h4><p><strong>可变变量和不可变变量</strong></p><ul><li>val–不可变引用。使用val声明的变量不能在初始化之后再次赋值。它对应的是java中的final变量</li><li>var–可变引用。这种变量的值可以被改变。这种声明对应的是普通(非final)变量</li></ul><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595899792330.png" alt=""></p><p>👆在定义了val变量的代码块期间,<strong>val变量只能进行唯一一次初始化</strong>。但是,如果编译器能确保只有唯一一次初始化语句会被执行,可以根据条件使用不同的值来初始化它。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595899976491.png" alt=""></p><p>自身不可变(只可以执行一次,初始化一次)</p><p>注意,尽管val引用自身是不可变的,但是它指向的对象<strong>`可能</strong>`是可变的。列如</p><pre><code class="kotlin">val languages = arrayListOf(&quot;Java&quot;)lenguages.add(&quot;Kotlin&quot;)</code></pre><h3 id="2-3-表示和处理选择：枚举和“when”"><a href="#2-3-表示和处理选择：枚举和“when”" class="headerlink" title="2.3 表示和处理选择：枚举和“when”"></a>2.3 表示和处理选择：枚举和“when”</h3><h4 id="2-3-1-声明枚举类"><a href="#2-3-1-声明枚举类" class="headerlink" title="2.3.1 声明枚举类"></a>2.3.1 声明枚举类</h4><p><strong>什么是枚举</strong></p><p>为了让编译器能够自动检查某个值在枚举的集合中，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用 <strong>enum</strong> 来定义枚举类。</p><pre><code class="kotlin">enum class Color{    RED,ORANGE,YELLOW,GREEN,BLUE,INDIGO,VIOLET}</code></pre><p>kotlin 中 enum 是一个所谓的软关键词：只有当它出现在class前面时才会有特殊的意义，在其他地方可以把它当作普通的名称使用。</p><h4 id="2-3-5-智能转换：合并类型检查和转换"><a href="#2-3-5-智能转换：合并类型检查和转换" class="headerlink" title="2.3.5 智能转换：合并类型检查和转换"></a>2.3.5 智能转换：合并类型检查和转换</h4><h5 id="kotlin智能转换的案例"><a href="#kotlin智能转换的案例" class="headerlink" title="kotlin智能转换的案例"></a>kotlin智能转换的案例</h5><h6 id="表达式类型层次"><a href="#表达式类型层次" class="headerlink" title="表达式类型层次"></a>表达式类型层次</h6><pre><code class="kotlin">interface Exprclass Num(val value: Int) : Expr    // 简单的值对象类，只有一个属性value，实现了Expr接口class Sum(val left: Expr, val right: Expr) : Expr   // Sum运算的实参可以是任何Expr:Num 或者 Sum</code></pre><h6 id="对表达式求值"><a href="#对表达式求值" class="headerlink" title="对表达式求值"></a>对表达式求值</h6><pre><code class="kotlin">fun eval(e: Expr): Int {    if (e is Num) {//        val n = e.value as Num //显示的转换为Num类型多余的        return e.value    }    if (e is Sum) {        return eval(e.left) + eval(e.right) // 变量 e 被智能的转换了类型    }    throw IllegalArgumentException(&quot;test&quot;)}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200831171911.png" alt=""></p><p>结果</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200831171248.png" alt=""></p><h5 id="“is”-修饰符"><a href="#“is”-修饰符" class="headerlink" title="“is” 修饰符"></a>“is” 修饰符</h5><p>在 kotlin 中，你要使用 is 检查来判断一个变量是否是某个类型。</p><h5 id="什么时候进行智能转换？"><a href="#什么时候进行智能转换？" class="headerlink" title="什么时候进行智能转换？"></a>什么时候进行智能转换？</h5><p>如果你检查过一个变量是某种类型，后面就不再需要转换它了，可以就把它当作你检查过的类型使用。事实上编译器为你执行了类型转换，我们把这种行为称为 <strong>智能转换。</strong></p><h1 id="3-函数的订阅和调用"><a href="#3-函数的订阅和调用" class="headerlink" title="3 函数的订阅和调用"></a>3 函数的订阅和调用</h1><h2 id="3-3-给别人的类添加方法：扩展函数和属性"><a href="#3-3-给别人的类添加方法：扩展函数和属性" class="headerlink" title="3.3 给别人的类添加方法：扩展函数和属性"></a>3.3 给别人的类添加方法：扩展函数和属性</h2><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><blockquote><p>扩展函数非常简单，作为一个类的成员函数，不过它定义在类的外边。</p></blockquote><h1 id="4-类、对象和接口"><a href="#4-类、对象和接口" class="headerlink" title="4 类、对象和接口"></a>4 类、对象和接口</h1><h3 id="4-1-定义类继承结构"><a href="#4-1-定义类继承结构" class="headerlink" title="4.1 定义类继承结构"></a>4.1 定义类继承结构</h3><h4 id="4-1-1-Kotlin-中的接口"><a href="#4-1-1-Kotlin-中的接口" class="headerlink" title="4.1.1 Kotlin 中的接口"></a>4.1.1 Kotlin 中的接口</h4><h5 id="声明接口"><a href="#声明接口" class="headerlink" title="声明接口"></a>声明接口</h5><pre><code class="kotlin">interface Clickable{    fun click()}</code></pre><h5 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h5><pre><code>class Button : Clickble {    override fun click() {        println(&quot;I was clicked&quot;)    }}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200826205307.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200826205356.png" alt=""></p><h5 id="Kotlin实现接口与-Java-有那些不同"><a href="#Kotlin实现接口与-Java-有那些不同" class="headerlink" title="Kotlin实现接口与 Java 有那些不同"></a>Kotlin实现接口与 Java 有那些不同</h5><p>Kotlin 在类后面使用冒号来代替 <strong>Java</strong> 中的 extends 和 implements 关键词。 和 Java 一样，<strong>一个类可以实现任意多个接口</strong>，但<strong>只能继承一个类型</strong>。</p><h5 id="override-修饰符的作用"><a href="#override-修饰符的作用" class="headerlink" title="override 修饰符的作用"></a>override 修饰符的作用</h5><ul><li>相同</li></ul><p>与 Java 中的 @Override 注解类似，<strong>override 修饰符用来标注被重写的父类或者接口的方法和属性</strong>。</p><ul><li>不同</li></ul><p>在 Kotlin 中使用 override 修饰符是强制要求的。<strong>这会避免先写出实现方法再添加抽象方法造成的意外重写：</strong>你的代码将不能编译，除非你显式地将这个方法标注为 Override 或者重命名它。</p><h5 id="如何给接口添加一个默认实现的方法"><a href="#如何给接口添加一个默认实现的方法" class="headerlink" title="如何给接口添加一个默认实现的方法"></a>如何给接口添加一个默认实现的方法</h5><p>接口的方法可以有一个默认实现的方法。</p><pre><code class="kotlin">interface Clickable{    fun click() // 普通的方法声明    fun showOff() = println(&quot;I&#39;m clickable!&quot;) // 带默认实现的方法}</code></pre><h5 id="实现一个带有默认实现的方法的接口要注意什么"><a href="#实现一个带有默认实现的方法的接口要注意什么" class="headerlink" title="实现一个带有默认实现的方法的接口要注意什么"></a>实现一个带有默认实现的方法的接口要注意什么</h5><p>如果你实现了这个接口，你需要为 click 提供一个实现。可以重新定义 showOff() 方法的行为，或者如果你对默认行为感到满意也可以直接省略它。（默认实现的方法也可以被重写）</p><h5 id="定义实现了同样方法的接口"><a href="#定义实现了同样方法的接口" class="headerlink" title="定义实现了同样方法的接口"></a>定义实现了同样方法的接口</h5><pre><code class="kotlin">interface Focusable {    fun setFocus(b: Boolean) = println(&quot;I ${if (b) &quot;got&quot; else &quot;lost&quot;} focus.&quot;)    fun showOff() = println(&quot;I&#39;m focusable!&quot;)}</code></pre><h5 id="在类中实现两个有相同默认实现方法的接口会发生什么"><a href="#在类中实现两个有相同默认实现方法的接口会发生什么" class="headerlink" title="在类中实现两个有相同默认实现方法的接口会发生什么"></a>在类中实现两个有相同默认实现方法的接口会发生什么</h5><p>在这两个接口中都带有默认实现的 showOff() 方法：在没有显示的实现 showOff() ,会得到编译错误信息。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827000446.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827000526.png" alt=""></p><h6 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h6><p>必须显式的实现相同方法。</p><h5 id="调用继承-接口-的默认实现方法"><a href="#调用继承-接口-的默认实现方法" class="headerlink" title="调用继承(接口)的默认实现方法"></a>调用继承(接口)的默认实现方法</h5><pre><code class="kotlin">class Button : Clickable, Focusable {    override fun click() {        TODO(&quot;Not yet implemented&quot;)    }    //如果同样的继承成员不止一个实现，必须提供一个显示的实现。    override fun showOff() {        // 使用尖括号加上父类名字的“super”表明了你想要调用哪一个父类的方法        super&lt;Clickable&gt;.showOff()        super&lt;Focusable&gt;.showOff()    }}</code></pre><p>通过调用继承的两个父类型中的实现来实现 showOff() 。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827005257.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827005432.png" alt=""></p><h4 id="4-1-2-open、final-和-abstract-修饰符：默认为-final"><a href="#4-1-2-open、final-和-abstract-修饰符：默认为-final" class="headerlink" title="4.1.2 open、final 和 abstract 修饰符：默认为 final"></a>4.1.2 open、final 和 abstract 修饰符：默认为 final</h4><h5 id="kotlin-中如何继承一个类"><a href="#kotlin-中如何继承一个类" class="headerlink" title="kotlin 中如何继承一个类"></a>kotlin 中如何继承一个类</h5><p>如果你想要创建一个类的子类，需要使用 open 修饰符来标示这个类。此外<strong>需要给每个可以被重写的属性或者方法添加 open 属性</strong>。</p><h5 id="声明一个带open-方法的-open-类"><a href="#声明一个带open-方法的-open-类" class="headerlink" title="声明一个带open 方法的 open 类"></a>声明一个带open 方法的 open 类</h5><pre><code class="kotlin">open class RichButton : Clickable {    fun disable() {}    // 这个函数是 final 的： 不能在子类中重写它。    open fun animate() {} // 这个函数是 open 的： 可以在子类中重写它    // 这个函数重写了 open 函数并且它本身同样是 open 的    override fun click() {        TODO(&quot;Not yet implemented&quot;)    }}</code></pre><h5 id="默认-final-的好处"><a href="#默认-final-的好处" class="headerlink" title="默认 final 的好处"></a>默认 final 的好处</h5><p>类默认 final 带来了一个重要的好处就是这使得在大量的场景中的只能转换成为可能。</p><h5 id="智能转换的前提"><a href="#智能转换的前提" class="headerlink" title="智能转换的前提"></a>智能转换的前提</h5><p><strong>智能转换只能在进行类型检查后没有改变过的变量上起的作用。</strong>对于一个类来说，这意味着<strong>智能转换在val类型并且没有自定义访问器的类属性上使用</strong>。 这个前提意味着属性必须是 final 的，否则如果一个子类可以重写属性并且定义一个自定义的访问器将会打破智能转换的关键前提。</p><h5 id="抽象类的默认修饰符"><a href="#抽象类的默认修饰符" class="headerlink" title="抽象类的默认修饰符"></a>抽象类的默认修饰符</h5><p>抽象成员始终是open的，所以不需要显式地使用open修饰符。</p><h5 id="声明一个抽象类"><a href="#声明一个抽象类" class="headerlink" title="声明一个抽象类"></a>声明一个抽象类</h5><pre><code class="kotlin">abstract class Animated {    abstract fun animate()  // 这个函数是抽象的：它没有实现必须被子类重写    // 抽象类中的非抽象函数 并不是默认 open 的，但是可以标注为 open的    open fun stopAnimating() {    }    fun animateTwice() {}}</code></pre><h4 id="4-1-4-内部类和嵌套类：默认嵌套类"><a href="#4-1-4-内部类和嵌套类：默认嵌套类" class="headerlink" title="4.1.4 内部类和嵌套类：默认嵌套类"></a>4.1.4 内部类和嵌套类：默认嵌套类</h4><p>内部类：非静态嵌套类，也被成为内部类。</p><p>嵌套类：静态嵌套类，嵌套类多称为：静态嵌套类。</p><h5 id="Kotlin中嵌套类和Java中的不同"><a href="#Kotlin中嵌套类和Java中的不同" class="headerlink" title="Kotlin中嵌套类和Java中的不同"></a>Kotlin中嵌套类和Java中的不同</h5><p>在Kotlin中的嵌套类不能访问外部类的实例，除非你特别的做出要求。 </p><h5 id="在序列化时使用内部类"><a href="#在序列化时使用内部类" class="headerlink" title="在序列化时使用内部类"></a>在序列化时使用内部类</h5><p>在你定义一个 View 元素，它的状态时可序列化的。<strong>想要序列化一个视图可能并不容易，但是可以把所有需要的数据复制到另一个辅助类中去。</strong></p><pre><code class="kotlin">interface State : Serializableinterface View {    fun getCurrentState(): State    fun restoreState(state: State) {}}</code></pre><p>声明State接口去实现Serializable。View接口声明了可以用来保存视图状态的getCurrentState和restoreState方法。</p><h5 id="用内部类的java代码来实现View"><a href="#用内部类的java代码来实现View" class="headerlink" title="用内部类的java代码来实现View"></a>用内部类的java代码来实现View</h5><pre><code class="java">public class Button implements View{    @Override    public State getCurrentState(){        return new ButtonState();    }    @Override    public voiew restoreState(State state){        /**/    }    public class ButtonState implements State{        /**/    }}</code></pre><p>问题：在运行时你会得到 java.io.NotSerializable.Exception:Button 异常，在你序列化声明的按钮状态时。这个可能看起来会很奇怪：你序列化的变量是ButtonState类型，为什么会有Button异常呢？</p><h5 id="无法序列化的原因"><a href="#无法序列化的原因" class="headerlink" title="无法序列化的原因"></a>无法序列化的原因</h5><p>在java中，当你在另一个类中声明一个类时，它会默认变成内部类。案例中：ButtonState类隐示的存储了它的外部Button类的应用。从而解释了为什么ButtonState不能被序列化。</p><h5 id="修复无法序列化"><a href="#修复无法序列化" class="headerlink" title="修复无法序列化"></a>修复无法序列化</h5><p><strong>需要声明ButtonState类是static的</strong>。将嵌套类声明为static会冲这个类中删除包围它的类的隐式引用。</p><h5 id="在kotlin中使用嵌套类来实现-View"><a href="#在kotlin中使用嵌套类来实现-View" class="headerlink" title="在kotlin中使用嵌套类来实现 View"></a>在kotlin中使用嵌套类来实现 View</h5><pre><code class="kotlin">class Button : View {    override fun getCurrentState(): State {        TODO(&quot;Not yet implemented&quot;)    }    override fun restoreState(state: State) {        TODO(&quot;Not yet implemented&quot;)    }    // 这个类与Java中的静态潜逃类类似    class ButtonState : State {    }}</code></pre><p><strong>kotlin中默认行为是嵌套类。</strong></p><h5 id="如何让默认嵌套类的类型变为内部类！"><a href="#如何让默认嵌套类的类型变为内部类！" class="headerlink" title="如何让默认嵌套类的类型变为内部类！"></a>如何让默认嵌套类的类型变为内部类！</h5><p>要把它（嵌套类）变成为一个内部类来持有一个外部类的引用的话需要使用 <strong>inner</strong> 修饰符。</p><h5 id="kotlin中内部类访问外部类"><a href="#kotlin中内部类访问外部类" class="headerlink" title="kotlin中内部类访问外部类"></a>kotlin中内部类访问外部类</h5><p>在kotlin中引用外部类实例的语法与java不同。需要使用this@Outer从Inner类去访问Outer类。</p><h4 id="4-1-5-密封类：定义受限的类继承结构"><a href="#4-1-5-密封类：定义受限的类继承结构" class="headerlink" title="4.1.5 密封类：定义受限的类继承结构"></a>4.1.5 密封类：定义受限的类继承结构</h4><h5 id="什么是密封类”sealed“"><a href="#什么是密封类”sealed“" class="headerlink" title="什么是密封类”sealed“"></a>什么是密封类”sealed“</h5><p>sealed 类。为父类添加了一个新的 sealed 修饰符，可对创建的子类做出严格的限制。<strong>所有的子类必须嵌套在父类中。</strong></p><h5 id="为什么要使用密封类（定义受限的类继承结构）"><a href="#为什么要使用密封类（定义受限的类继承结构）" class="headerlink" title="为什么要使用密封类（定义受限的类继承结构）"></a>为什么要使用密封类（定义受限的类继承结构）</h5><p><strong>作为接口实现的表达式 👇</strong></p><pre><code class="kotlin">interface Exprclass Num(val value: Int) : Exprclass Sum(val left: Expr, val right: Expr):Exprfun eval(e: Expr): Int =    when (e) {        is Num -&gt; e.value        is Sum -&gt; eval(e.left) + eval(e.right)        else -&gt; // 必须检查 else 分支            throw  IllegalArgumentException(&quot;Unknown expression!&quot;)    }</code></pre><p><strong>当使用 when 结构来执行表达式的时候，Kotlin 编译器会强制检查默认选项</strong>。在这个例子中，<strong>不能返回一个有意义的值，所以直接返回异常状态。</strong></p><p>更重要的是，如果你添加了一个新的子类，编译器并不能发现你修改了。<strong>如果你忘记添加一个新的分支，就会选择默认选项，这又可能导致潜在的 bug。</strong></p><h5 id="如何使用密封类-“sealed”"><a href="#如何使用密封类-“sealed”" class="headerlink" title="如何使用密封类 “sealed”"></a>如何使用密封类 “sealed”</h5><pre><code class="kotlin">sealed class Expr { //将基类标记为封闭的    class Num(val value: Int) : Expr()    class Sum(val left: Expr, val right: Expr) : Expr() // 将所有可能的类作为嵌套类列出}fun eval(expr: Expr): Int =    // “when”表达式覆盖了所有的可能情况，所以不再需要 else 分支    when (expr) {        is Expr.Num -&gt; expr.value        is Expr.Sum -&gt; eval(expr.left) + eval(expr.right)    }</code></pre><p><strong>如果你在 when 表达式中处理了所有的 sealed 类的子类，你就不再需要提供默认分支。</strong>注意，sealed 修饰符隐含的这个类是一个 open 类，你不再需要显式地添加 open 修饰符。</p><h3 id="4-2-声明一个带默认构造方法或属性的类"><a href="#4-2-声明一个带默认构造方法或属性的类" class="headerlink" title="4.2 声明一个带默认构造方法或属性的类"></a>4.2 声明一个带默认构造方法或属性的类</h3><p><strong>kotlin中构造方法和java中有那些不同</strong></p><p>与java中一个类可以声明一个或多个构造方法。kotlin也是类似的，只是做出了一些修改：区分了主构造方法（通常是主要而简洁的初始化类的方法，并且在类体外部声明）和从构造方法。</p><h4 id="4-2-1-初始化类：主构造方法和初始化代码块"><a href="#4-2-1-初始化类：主构造方法和初始化代码块" class="headerlink" title="4.2.1 初始化类：主构造方法和初始化代码块"></a>4.2.1 初始化类：主构造方法和初始化代码块</h4><h5 id="什么是主构造方法。"><a href="#什么是主构造方法。" class="headerlink" title="什么是主构造方法。"></a>什么是主构造方法。</h5><pre><code class="kotlin">class User(val nickname:String)</code></pre><p>这段被括号围起来的代码块就叫<strong>做主构造方法</strong>。它有两个目的：表明构造方法的<strong>参数</strong>，以及定义使用这个<strong>参数</strong>的属性。</p><h5 id="明确的主构造方法声明"><a href="#明确的主构造方法声明" class="headerlink" title="明确的主构造方法声明"></a>明确的主构造方法声明</h5><pre><code class="kotlin">class User constructor(_nickname: String) {   // 带一个参数的主构造方法    val nickname: String    init {  // 初始化代码块        nickname = _nickname    }}</code></pre><p>现在来看看完成同样功能的代码具体是什么样子。</p><blockquote><p>两个关键词 <strong>construtor</strong> 和 <strong>init</strong>。 constructor 关键词用来开始一个<strong>构造方法</strong>或者<strong>从构造方法</strong>的声明。init 关键词用来引入初始化代码块。这种代码块包含了类在创建时执行的代码，并且会和主构造方法一起使用。<strong>因为主构造方法有语法限制，不能包含初始化代码，这就是需要初始化代码块（init）的原因。</strong>同时可以创建多个初始化代码块。</p></blockquote><h5 id="用参数来初始化属性"><a href="#用参数来初始化属性" class="headerlink" title="用参数来初始化属性"></a>用参数来初始化属性</h5><pre><code class="kotlin">class User(_nickname: String) { // 带一个参数的构造方法    val nickname: String = _nickname    // 用参数来初始化属性}</code></pre><blockquote><p>在例子中，不需要把初始化代码放在初始化代码块中，因为它可以与nickname属性声明结合。如果主构造方法没有注解或可见性修饰符，同样可以去除 constructor 关键词。</p></blockquote><h5 id="用最简洁的方法再次初始化类"><a href="#用最简洁的方法再次初始化类" class="headerlink" title="用最简洁的方法再次初始化类"></a>用最简洁的方法再次初始化类</h5><pre><code class="kotlin">class User(val nickname:String)    // “val” 意味相对应的属性会用构造方法的参数来初始化。</code></pre><p>前几个案例用 val 关键词声明了属性。如果属性用相对应的构造方法参数来初始化，<strong>代码可以通过把 val 关键词加载参数前的方法来简化它</strong>。可以用来代替类中的属性定义了。</p><h5 id="为构造方法提供默认值"><a href="#为构造方法提供默认值" class="headerlink" title="为构造方法提供默认值"></a>为构造方法提供默认值</h5><pre><code class="kotlin">class User(val nickname: String, val isSubscribed: Boolean = true) // 为构造方法提供一个默认值    </code></pre><p>可以像函数参数一样为构造方法声明默认值。</p><h5 id="如何让一个类不被其他代码实例化"><a href="#如何让一个类不被其他代码实例化" class="headerlink" title="如何让一个类不被其他代码实例化"></a>如何让一个类不被其他代码实例化</h5><p>如果想要你的类不被其他代码实例化，必须把构造方法标记为 private。</p><pre><code class="kotlin">class Secretive private constructor()   // 这个类有 private 构造方法</code></pre><h4 id="4-2-2-构造方法：用不同的方法来初始化方法"><a href="#4-2-2-构造方法：用不同的方法来初始化方法" class="headerlink" title="4.2.2 构造方法：用不同的方法来初始化方法"></a>4.2.2 构造方法：用不同的方法来初始化方法</h4><h5 id="为什么要使用多种方法初始化父类"><a href="#为什么要使用多种方法初始化父类" class="headerlink" title="为什么要使用多种方法初始化父类"></a><strong>为什么要使用多种方法初始化父类</strong></h5><p>最常见的一种就是当你需要扩展一个框架类来提供多个构造方法，以便于通过不同的方法来初始化类的时候。</p><h5 id="父类使用从构造方法"><a href="#父类使用从构造方法" class="headerlink" title="父类使用从构造方法"></a><strong>父类使用从构造方法</strong></h5><pre><code class="kotlin">open class View {    constructor(ctx: Context) { // 从构造方法        //some code    }    constructor(ctx: Context, attr: AttributeSet) { // 从构造方法        //some code    }}</code></pre><h5 id="扩展父类"><a href="#扩展父类" class="headerlink" title="扩展父类"></a>扩展父类</h5><pre><code class="kotlin">class MyButton : View {    constructor(ctx: Context) : super(ctx) {        // 调用父类构造方法    }    constructor(ctx: Context, attr: AttributeSet) : super(ctx, attr) {    }}</code></pre><h5 id="调用父类的另一个构造方法"><a href="#调用父类的另一个构造方法" class="headerlink" title="调用父类的另一个构造方法"></a>调用父类的另一个构造方法</h5><pre><code class="kotlin">class MyButton : View {    constructor(ctx: Context) : this(ctx, My_SYTLE) {        // 委托给这个类的另一个构造方法    }    constructor(ctx: Context, attr: AttributeSet) : super(ctx, attr) {    }}</code></pre><p>从<strong>构造方法</strong>中调用你自己类的另一个<strong>构造方法</strong>。</p><p>可以修改 MyButton类 <strong>使得一个构造方法委托给同一个类的另一个构造方法</strong>，为参数传入默认值，图下👇。第二个方法继续调用super()。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200906113216.png" alt=""></p><h4 id="4-2-3-实现在接口中声明的属性"><a href="#4-2-3-实现在接口中声明的属性" class="headerlink" title="4.2.3 实现在接口中声明的属性"></a>4.2.3 实现在接口中声明的属性</h4><h5 id="在接口中声明一个属性"><a href="#在接口中声明一个属性" class="headerlink" title="在接口中声明一个属性"></a>在接口中声明一个属性</h5><pre><code class="kotlin">interface User {    val nickname: String}</code></pre><p>接口可以包含抽象属性声明。</p><p>这意味这<strong>实现User接口的类需要</strong>提供一个取得nickname值的方式。</p><h5 id="实现接口中的属性-三种"><a href="#实现接口中的属性-三种" class="headerlink" title="实现接口中的属性 三种"></a>实现接口中的属性 三种</h5><p>第一种</p><pre><code class="kotlin">// 主构造方法属性class PrivateUser(override val nickname: String) : User {}</code></pre><p>对于 PrivateUser 来说，<strong>你是用了间接的语法直接在主构造方法中声明了一个属性</strong>。这个属性实现了来自于User的抽象属性，所以你将其标记为 override。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908100413.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908095819.png" alt=""></p><p>运行结果</p><p>第二种</p><pre><code class="kotlin">class SubscribingUser(val email: String) : User {    override val nickname: String get() = email.substringBefore(&#39;@&#39;)  // 自定义getter}</code></pre><p>对于 SubscribeingUser 来说，nikename属性通过一个自定义 getter 实现。<strong>这个属性没有一个支持字段来存储它的值，它只有一个 getter 在每次调用时从 email 中得到昵称。</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908100342.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908100257.png" alt=""></p><p>运行结果</p><p>第三种</p><pre><code class="kotlin">class FacebookUser(val accoundId: Int) : User {    override val nickname = getFacebookName(accoundId)  // 属性初始化    fun getFacebookName(text: String): String {        return text    }}</code></pre><p>nickname在SubscribingUser和FackbookUser中的不同实现。即使它们看起来很相似，第一个属性有一个自定义getter在每次访问时计算 subscringBefore，然后 FackbookUser中的属性有一个<strong>支持字段来存储在类初始化时计算得到数据</strong>。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908104646.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908111027.png" alt=""></p><p>运行结果</p><h4 id="4-2-4-通过-getter或setter访问支持字段"><a href="#4-2-4-通过-getter或setter访问支持字段" class="headerlink" title="4.2.4 通过 getter或setter访问支持字段"></a>4.2.4 通过 getter或setter访问支持字段</h4><p>关于两种属性的例子：存储值的属性和具有自定义访问器在每次访问时的属性。<strong>现在让我们来看看怎么结合这两种来实现一个既可以存储值又可以被值访问和修改时提供额外逻辑的属性。</strong>要支持这种情况，需要能够从属性的访问器中访问它的支持字段。</p><p>假设在任何适合对存储的属性中的数据进行修改时输出日志，你声明了一个可变属性并且在每次 setter 访问时执行额外的代码。</p><pre><code class="kotlin">/*    在 setter 中访问支持字段    */class User(val name:String) {    var address: String = &quot;unspecified&quot;        set(value: String){            println(&quot;&quot;&quot;                Address was changed for $name:&quot;$field&quot; -&gt; &quot;$value&quot;.&quot;&quot;&quot;.trinmIndent())    //读取支持字段的值                field = value    // 更新支持字段的值        }}</code></pre><pre><code class="kotlin">&gt;&gt;&gt; val user = User(&quot;Alice&quot;)&gt;&gt;&gt; user.address = &quot;Elasenheimerstrasse 47, 80687 Muenchen&quot;Address was changed for Alice:&quot;unspecified&quot; -&gt; &quot;Elsenheimerstrasse 47, 80687 Muenchen&quot;</code></pre><blockquote><p>可以像平常一样通过使用 user.address = “new value” 来修改一个属性的值，这其实在底层调用了setter。在这个例子中，setter 被重新定义了，所以额外的输出日志的代码被执行了（简单起见，这里直接将其打印出来）。</p><p>在 setter 的函数体中，使用了特殊的标识符 field来访问支持字段的值。在 getter 中，只能读取值：而在 setter 中，既能读取它也能修改它。</p></blockquote><h3 id="4-3-编译器生成的方法-数据类和委托"><a href="#4-3-编译器生成的方法-数据类和委托" class="headerlink" title="4.3 编译器生成的方法:数据类和委托"></a>4.3 编译器生成的方法:数据类和委托</h3><h4 id="4-3-2-数据类-自动生成通用方法的实现"><a href="#4-3-2-数据类-自动生成通用方法的实现" class="headerlink" title="4.3.2 数据类:自动生成通用方法的实现."></a>4.3.2 数据类:自动生成通用方法的实现.</h4><p>实现一个数据类需要重写方法:toString、equals和hashcode。</p><p><strong>数据类</strong></p><pre><code class="kotlin">data class Client(val name:String,val postalCode:Int)</code></pre><p>这是一个数据类,重写了所有标准的Java方法:</p><ul><li>equals 用来比较实例</li><li>hashCode用来作为例如HashMap这种基于哈希容器的键</li><li>toString用来为类生成按声明顺序排列的所有字段的字符串表达形式</li></ul><h3 id="4-4-“object”-关键字：-将声明一个类与创建一个实例结合起来"><a href="#4-4-“object”-关键字：-将声明一个类与创建一个实例结合起来" class="headerlink" title="4.4 “object” 关键字： 将声明一个类与创建一个实例结合起来"></a>4.4 “object” 关键字： 将声明一个类与创建一个实例结合起来</h3><p>这个关键词定义一个类并同时创建一个实例（换句话说就是一个对象）。</p><ul><li><strong>对象声明</strong>是定义一个单例的一种方式。</li><li><strong>伴生对象</strong>可以持有<strong>工场方法</strong>和其他与这个类的相关，但是在调用时并不依赖类实例方法。<strong>它们的成员可以通过类名来访问</strong>。</li><li><strong>对象表达式用来代替Java的匿名内部类</strong></li></ul><h4 id="4-4-1-对象声明：创建单例易如反掌"><a href="#4-4-1-对象声明：创建单例易如反掌" class="headerlink" title="4.4.1 对象声明：创建单例易如反掌"></a>4.4.1 对象声明：创建单例易如反掌</h4><h5 id="为什么使用对象声明？"><a href="#为什么使用对象声明？" class="headerlink" title="为什么使用对象声明？"></a>为什么使用对象声明？</h5><p>在面向对象系统中一个相当常见的情形就是只需要一个实例的类。例如，可以使用一个对象声明来表示一个组织的工资单。</p><h5 id="在Java中是如何实现单例模式？"><a href="#在Java中是如何实现单例模式？" class="headerlink" title="在Java中是如何实现单例模式？"></a>在Java中是如何实现单例模式？</h5><p>定义一个使用private构造方法并且用静态字段来持有这个类仅有的实例。</p><h5 id="什么是对象声明"><a href="#什么是对象声明" class="headerlink" title="什么是对象声明"></a>什么是对象声明</h5><p>Kotlin通过使用对象声明功能为这一切提供了最高级的语言支持。<strong>对象声明将类声明与该类的单一实例声明结合到了一起。</strong></p><h5 id="对象声明使用"><a href="#对象声明使用" class="headerlink" title="对象声明使用"></a>对象声明使用</h5><pre><code>object Payroll {    val allEmployees = arrayListOf&lt;Person&gt;()    fun calculateSalary() {        for (person in allEmployees){        }    }}</code></pre><p>对象声明通过 object 关键词引入。与类一样，一个对象声明也可以包含属性、方法、初始化语句块等的声明，唯一不允许的是构造方法。对象声明在定义时就创建了构造对象，不需要在代码的其他地方调用构造方法。对象声明同样可以继承类和接口。</p><h1 id="5-Lambda-编程"><a href="#5-Lambda-编程" class="headerlink" title="5 Lambda 编程"></a>5 Lambda 编程</h1><h2 id="5-1-Lambda表达式和成员引用"><a href="#5-1-Lambda表达式和成员引用" class="headerlink" title="5.1 Lambda表达式和成员引用"></a>5.1 Lambda表达式和成员引用</h2><h3 id="5-1-1-Lambda-简介：作为函数参数的代码块"><a href="#5-1-1-Lambda-简介：作为函数参数的代码块" class="headerlink" title="5.1.1 Lambda 简介：作为函数参数的代码块"></a>5.1.1 Lambda 简介：作为函数参数的代码块</h3><p>在代码中存储和传递一小段行为是常有的任务。例如，“当一个事件发生的时候运行这个事件处理器”又或是“把这个操作应用到这个数据结构的所有元素上”。在老版本的Java中可以使用匿名函数。</p><blockquote><p>使用函数式编程 提供了另外一种解决问题的方法：</p><p>把函数当作值来对待。可以直接传递函数，而不需要先声明一个类再传递一个类的实例。使用 lambda 表达式后代码会变的更加简洁。</p></blockquote><p>例子。假设你要定义一个点击按钮的行为，添加一个处理点击的监听器。监听器实现了想对应的接口 OnClickListener 和它的一个方法 onClick。</p><pre><code class="java">/*    用匿名内部类实现监听器    */button.setOnClickListener(new OnClickListener(){    @Override    public void onClick(View view){        /*点击之后执行的动作*/    }})</code></pre><p>使用匿名内部类的写法，更加冗余。接下来使用 lambda 写法</p><pre><code class="kotlin">/*    用 lambda 实现监听器    */button.setOnClickListener{    /*    点击后执行操作    */    }</code></pre><h3 id="5-1-2-Lamda-和-集合"><a href="#5-1-2-Lamda-和-集合" class="headerlink" title="5.1.2 Lamda 和 集合"></a>5.1.2 Lamda 和 集合</h3><p>良好的编程风格原则之一是避免代码的重复。我们对集合执行大部分任务都遵循这几个通用的模式，所以要实现这几个模式的代码应该放在一个库里。在没有 lambda 的帮助，很难为集合提供一个好用方便的库。</p><p>看个例子。</p><p>创建一个 Person 类，它包含了这个了的名字和年龄信息。</p><pre><code class="kotlin">data class Person(val name:String, val age :Int)</code></pre><p>假设你现在要在列表中找到年龄最大的那个人。</p><pre><code class="kotlin">/*    手动在集合中搜索    */fun findTheOldest(people:List&lt;Person&gt;){    var maxAge = 0    //存储最大年龄    var theOldest:Person ?= null //存储年龄最大的人    for (person in people){        if(person.age &gt; maxAge){    //如果下一个比现在年龄最大的人还要大，改变最大值            maxAge = person.age            theOldest = person        }    }    println(theOldest)}&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31))&gt;&gt;&gt; findTheOldest(people)Person(name = Bob,age = 31)</code></pre><pre><code class="kotlin">/*    用 lambda 在集合中搜索    */&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31))&gt;&gt;&gt; println(people.maxBy{it.age})    // 比较年龄最大的元素Person(name = Bob, age = 31)</code></pre><p>maxBy函数可以在任何集合上调用，且只需要一个参数：函数指定比较哪个值来找到最大元素。</p><p>花括号中的代码 <strong>{it.age}</strong>就是实现了这个逻辑的lmabda。 它接收一个集合中的元素作为实参(作用 it 引用它)并且返回用来比较的值。在这个例子中，集合元素是Person对象，用来比较的是存储在其age属性中的年龄。</p><pre><code class="kotlin">/*    用成员引用    */people.maxBy(Person:age)</code></pre><h3 id="5-1-3-Lambda-表达式的语法"><a href="#5-1-3-Lambda-表达式的语法" class="headerlink" title="5.1.3 Lambda 表达式的语法"></a>5.1.3 Lambda 表达式的语法</h3><p>概述 lambda</p><blockquote><p>一个 lambda 把一小段行为进行编码，你能把它当作值到处传递。它可以被独立地声明并储存一个变量。</p></blockquote><pre><code class="kotlin">/*    lambda 表达式的语法    */{x:Int,y:Int -&gt; x+y}/*    参数 -&gt; 函数体    */</code></pre><blockquote><p>Kotlin 的lambda 表达式始终用花括号包围。实参并没有用括号括起来。箭头把实参列表和lambda 函数体隔开了。</p></blockquote><p>可以把 lambda表达式存储在一个变量中，把这个变量当作普通函数对待（即通过相应实参调用它）</p><pre><code class="kotlin">&gt;&gt;&gt; val sum = {x:Int,y:int -&gt; x+y}&gt;&gt;&gt; println(sum(1,2))    // 调用保存在变量中的lambda3</code></pre><blockquote><p>Kotlin 中的语法约定，如果 lambda 表达式是函数调用的最后一个实参，它可以放到括号外边。在这个例子中lambda是唯一的实参，所以可以放到括号外边</p><pre><code class="kotlin">people.maxBy(){p:Person -&gt; p.age}</code></pre><p>当 lamdba 是函数的唯一实参时，还可以去除调用代码中的空括号。</p><pre><code class="kotlin">people.maxBy{p:Person -&gt; p.age}</code></pre><p>三种语法形式的含义都是一样的，但最后都是易读的。如果lambda是唯一的实参，你当然愿意在写代码的时候省掉这个括号。而当你有多个实参时，既可以把lambda留在括号内来强调它是一个实参，也可以把它放在括号外面，两种选择都是可行的。如果你想传递两个或多个lamdba，不能把超过一个的lamdba放在外面。这时使用常规语法来传递它们通常是更好的选择。</p></blockquote><p>回顾 joinToString 函数 （对元素添加分隔符）。 Kotlin 标准库中也有定义它，标准库中的这个版本的不同之处在于它可以接收一个附加的函数参数。这个函数可以使用 toString函数以外的方法把一个元素转换成字符串。</p><p><strong>打印出人的名字</strong></p><pre><code class="kotlin">/*    把 lambda 作为命名实参传递    */&gt;&gt;&gt;val people = listOf(Person(&quot;Alice&quot;,31),Person(&quot;Bob&quot;,29))&gt;&gt;&gt;val names = people.joinToString(separator = &quot;&quot;,transform = {p:Person -&gt; p.name})&gt;&gt;&gt;println(names)Alices Bob</code></pre><p><strong>用更简单的方法</strong></p><pre><code class="kotlin">/*    把 lambda 放在括号外传递    */people.joinToString(&quot; &quot;){p:Person -&gt; p.name}</code></pre><p><strong>简化语法，移除参数类型</strong></p><pre><code class="kotlin">/*    省略 lambda 参数类型    */people.maxBy{p:Person -&gt; p.age}    // 显式地写出参数类型people.maxBY{p-&gt;p.age}    // 推导出参数类型</code></pre><p>和局部变量一样，如果 lambda 参数的类型可以被推导出来，你就不需要显式地指定它。以这里的 maxBy 为例子，其参数类型始终和集合的元素类型相同。编译器知道你是对一个Person对象的集合调用maxBy函数，所以它能推断出 lambda参数也会是Person类型。<strong>也存在不能推断出的情况，先遵循：先不声明类型，等编译器报错后再指定它。</strong></p><p><strong>最后的简化是使用默认参数名称 it 代替命名参数</strong></p><pre><code class="kotlin">/*    使用默认参数名称    */people.maxBy(it.age)    //&quot;it&quot;是自动生成的参数名称</code></pre><p>仅在参数名称没有显式地指定时这个默认的名称才会生成。</p><p><strong>可以用变量存储 lambda 表达式</strong></p><pre><code class="kotlin">&gt;&gt;&gt; val getAge = {p:Person -&gt; p.age}&gt;&gt;&gt; people.maxBy(getAge)</code></pre><blockquote><p>lambda 并没有被限制在这样小的规模，它可以包含更多的语句。</p></blockquote><pre><code class="kotlin">&gt;&gt;&gt; val sum = {x:Int,y:Int -&gt;    println(&quot;Computing the sum of $x and $y...&quot;)    x + y}&gt;&gt;&gt; println(sum(1,2))Computing the sum of 1 and 2...3</code></pre><h3 id="5-1-4-在作用域中访问变量"><a href="#5-1-4-在作用域中访问变量" class="headerlink" title="5.1.4 在作用域中访问变量"></a>5.1.4 在作用域中访问变量</h3><blockquote><p>在声明一个匿名内部类的时候，能够在这个匿名类内部引用这个函数的参数和局部变量。</p><p>而在使用 lambda 声明的时候，也可以做同样的事情。如果在函数内部使用 lambda 也可以访问这个函数的参数，还有在 lambda 之前定义的局部变量。</p></blockquote><p><strong>forEach 函数</strong></p><p> 用 forEach 函数展示 上述行为。</p><p>它是最基本集合操作函数之一；它所作的全部事情就是在集合中的每个元素上都调用给定的 lambda。forEach 函数比普通for 函数循环更简洁，除此之外没有其它优势，所以并不急于把所有的循环更改为  lambda。</p><pre><code class="kotlin">/*    在 lambda 中使用函数参数    */fun printMessageWithPrefix(message : Collection&lt;String&gt;,prefix:String){    messages.forEach{    // 接受 lambda 作为实参指定对每个元素操作        println(&quot;$prefix $it&quot;)    // 在 lambda 中访问 “prefix”    }}&gt;&gt;&gt; val errors = listOf(&quot;433 Forbidden&quot;,&quot;404 Not Found&quot;)&gt;&gt;&gt; printMessagesWithPrefix(errors,&quot;Error:&quot;)Error:403 ForbiddenError:404 Not Found</code></pre><blockquote><p>Kotlin 和 Java的一个显著区别就是，在 Kotlin 中不会仅限于访问 final 变量，在 lambda 内部也可以修改变量。</p></blockquote><pre><code class="kotlin">/*    在lambda中改变局部变量    */fun printProblemCounts(responeses:Collection&lt;String&gt;){    var clientErrors = 0    var serverErrors = 0    responeses.forEach{        if(it.startsWith(&quot;4&quot;)){            clientErrors ++        }else if(it.startsWith(&quot;5&quot;)){            serverErrors++        }    }    println(&quot;$clientErrors client error,$serverErrors server errors&quot;)}&gt;&gt;&gt; val responses = listOf(&quot;200 OK&quot;,&quot;418 I&#39;m a teapot&quot;,&quot;500 Internal Server Error&quot;)...&gt;&gt;&gt; printProblemCounts(responses)1 client errors,1 server errors</code></pre><blockquote><p>于 Java 不同，Kotlin 允许在 lambda 内部访问非 final 变量甚至修改它们。从 lambda 内访问外部变量，我们称这个变量被 <strong>lambda捕捉</strong>，如同上述的案例中的 prefix，clientErrors，serverErrors一样。</p></blockquote><p><strong>默认情况下，局部变量的声明期被限制在声明这个变量的函数中。但是如果它被lambda捕捉了，使用这个变量的代码可以被存储并稍后执行。</strong></p><p><strong>如果 lambda 被用作 <em>事件处理器</em> 或者用在其他 <em>异步执行</em> 的情况下，对局部变量的修改只会在 lambda 执行的时候发生。</strong></p><blockquote><p>反面案例</p><pre><code class="kotlin">fun tryToCountButtonClicks(button:Button):Int{    var clicks = 0    button.onClick{clicks++}    return clicks}</code></pre><p>这个函数始终返回0。尽管 onClick 处理器可以修改clicks的值，你并不能观察到值发生了变化，因为onClick处理器是在函数返回之后调用的。<strong>这个函数正确的实现方法需要把点击次数存储在函数外依然可以访问到的地方–例如类的属性，而不是存储在函数的局部变量中。</strong></p></blockquote><h3 id="5-1-5-成员引用"><a href="#5-1-5-成员引用" class="headerlink" title="5.1.5 成员引用"></a>5.1.5 成员引用</h3><p>​    如果把函数转换成一个值，你就可以传递它。</p><pre><code class="kotlin">val getAge = Person::age    //引用 age</code></pre><blockquote><p>这种表达式称为 <strong>成员引用</strong>，它提供了简明语法，来创建一个调用单个方法或者访问单个属性的函数值。 <strong>双冒号把类名称与你要引用的成员（一个方法或者一个属性）名称隔开</strong></p><pre><code class="kotlin">Person::age //类::成员</code></pre></blockquote><p>等价于 </p><pre><code class="kotlin">val getAge = {person:Person -&gt;person.age}</code></pre><blockquote><p>注意，不管你引用的是函数还是属性，都不要在成员引用的名称后面添加括号。</p></blockquote><blockquote><p>成员引用和调用该函数的lambda具有一样的类型，所以可以互换使用：</p><pre><code class="kotlin">people.maxBy(Person::age)</code></pre><p>还可以引用顶层函数</p><pre><code class="kotlin">fun salute() = println(&quot;Salute!&quot;)&gt;&gt;&gt; run(::salute)    // 引用顶层函数Salute!</code></pre><p>这种情况下，你省略了类名称，直接以::开头。成员引用::salute被当作实参传递给库函数run，它会调用想对应的函数。</p><p>如果 lambda 要委托给一个接收多个参数的函数，提供成员引用代替它将会非常方便</p><pre><code class="kotlin">val action = {person:Person,message:String -&gt;    sendEmail(person,massage)    //这个lambda委托sendEmail函数    }val nextAction = :: sendEmail    //用成员引用代替</code></pre><pre><code class="kotlin">/*    用构造方法引用存储或者延期执行创建类实例的动作。 构造方法引用的形式在双冒号后指定类的名称：    */data class Person(val name:String,val age:Int)&gt;&gt;&gt; val createPerson = :：Person    //创建Person实例的动作被保存成了值&gt;&gt;&gt; val p = createPerson(&quot;Alice&quot;,29)&gt;&gt;&gt; println(p)Person(name = Alice,age = 29)</code></pre><p><strong>可以用同样的方法引用扩展函数</strong></p><pre><code class="kotlin">fun Person.isAdult() = age &gt;= 21val predicate = Person::isAdult</code></pre><p>尽管 isAdult 不同类的成员，还是可以通过引用访问它，这个访问的成员没有两样：person.isAdult()。</p></blockquote><p><strong>绑定引用</strong></p><blockquote><p>在 kotlin 1.0 中 ，当接受一个类的方法或者属性引用时，你始终需要提供一个该类的实例来调用这个引用。Kotlin1.1计划支持绑定成员引用，它允许你使用成员引用语法捕捉特定实例对象的方法引用。</p><pre><code class="kotlin">&gt;&gt;&gt; val p = Person(&quot;Dmitry&quot;,34)&gt;&gt;&gt; val personAgeFunction = Person::age&gt;&gt;&gt; println(personsAgeFunction(p))34 &gt;&gt;&gt; val dmitrysAgeFunction = p::age&gt;&gt;&gt; println(dmitryAgeFunction())34</code></pre><p>注意，personsAgeFunction是一个当参数函数（返回给定了的年龄），而dmitryAgeFunction是一个零参数的函数（返回已经指定好的人的年龄）。</p><p>在 Kotlin1.1之前，你需要显式地写出 lambda{p.age},而不是使用绑定成员引用p::age。</p></blockquote><h2 id="5-2-集合的函数式API"><a href="#5-2-集合的函数式API" class="headerlink" title="5.2 集合的函数式API"></a>5.2 集合的函数式API</h2><p>我们先从filter和map这类函数及它们背后的概念开始。</p><h3 id="5-2-1-基础：filter和map"><a href="#5-2-1-基础：filter和map" class="headerlink" title="5.2.1 基础：filter和map"></a>5.2.1 基础：filter和map</h3><p>filter和map函数形成了集合操作的基础，很多集合操作都是借助它们来表达的。</p><p>通过两种样子的例子帮助你来理解，一个纯数字形式一个使用<strong>自定义</strong>的Person类来实现。</p><pre><code class="kotlin">data class Person(val name:String,val age:Int)</code></pre><p><strong>filter函数</strong></p><blockquote><p>遍历集合并选出引用给定 lambda 条件 后会返回true的那些元素</p><pre><code class="kotlin">&gt;&gt;&gt; val list = listOf(1,2,3,4)&gt;&gt;&gt; println(list.filter{it%2==0})[2,4]</code></pre></blockquote><p><strong>map函数</strong></p><blockquote><p>对集合中每个元素应用给定的函数并把结果收集到一个新的集合中。</p><p>根据lambda参数作为判断生成新的集合。</p><pre><code class="kotlin">&gt;&gt;&gt; val list = listOf(1,2,3,4)&gt;&gt;&gt; println(list.map{it*it})[1,4,9,16]</code></pre></blockquote><blockquote><p>如果直想打印名字列表，而不是完整信息，可以用map变换列表：</p><pre><code class="kotlin">&gt;&gt;&gt; val people=listOf(Person(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31))&gt;&gt;&gt; println(people.map{it.name})[Alice,Bob]</code></pre><p>使用 <strong>成员引用</strong> 同样可以</p><pre><code class="kotlin">people.map(Person::name)</code></pre></blockquote><blockquote><p>当需要获得分组中最大人的名字时。</p><pre><code class="kotlin"> val maxAge = people.maxBy(Person::age).age people.filter{it.age == maxAge}</code></pre><p><strong>map 应用过滤和变换函数</strong></p><pre><code class="kotlin">&gt;&gt;&gt; val numbers = mapOf(0 to &quot;zero&quot;,1 to &quot;one&quot;)&gt;&gt;&gt; println(numbers.mapValues{it.value.toUppterCase()})    // 对map集合的值进行操作[0=ZERO,1=ONE]</code></pre><p>键和值分别由各自的函数来处理。<strong>filterKeys和mapKeys过滤和变换map的键，而另外的filterValues和mapValues过滤和变换对应的值。</strong></p></blockquote><h3 id="5-2-2-“all”“any”“count”和“find”：对集合引用判断式"><a href="#5-2-2-“all”“any”“count”和“find”：对集合引用判断式" class="headerlink" title="5.2.2 “all”“any”“count”和“find”：对集合引用判断式"></a>5.2.2 “all”“any”“count”和“find”：对集合引用判断式</h3><blockquote><p>这些方法作用</p><p>Kotlin中，它们是通过 all 和 any 函数表达式的（检查集合中的所有元素是否都符合某个条件）。count 函数检查由多少元素满足判断式，而find函数返回第一个符合条件的元素。</p><p>案例：</p><p>检查一个人是否还没有到28岁。</p><pre><code class="kotlin">val canBeInClub27 = {p:Person -&gt; p.age &lt;=27}</code></pre><p>如果是<strong>所有元素都满足判断式条件</strong>的应该使用 all 函数。（）</p><pre><code class="kotlin">&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,27),Person(&quot;Bob&quot;,31))&gt;&gt;&gt; println(people.all(canBeInClub27))false</code></pre><p>如果你<strong>检查集合中至少存在一个匹配的元素</strong>，则使用 any 函数</p><pre><code class="kotlin">&gt;&gt;&gt; println(people.any(canBeInClub27))</code></pre><p>true</p><p>如果<strong>你想知道有多少元素满足判断式</strong>，使用count：</p><pre><code class="kotlin">&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,27),Person(&quot;Bob&quot;,31))&gt;&gt;&gt; println(people.count(canBeInClub27))1</code></pre></blockquote><p><strong>使用正确的函数完成工作：”count” VS. “size”</strong></p><p>count 方法容易被遗忘，然后通过过滤集合之后再取大小来实现它：</p><pre><code class="kotlin">&gt;&gt;&gt; println(people.filter(canBeInClub27).size)1</code></pre><p>再这种情况下，一个集合中间会被创建并用来存储所有满足判断式的元素。</p><p>而另一方面，count 方法只是最终匹配元素的数量，不关心元素本身，所以更高效。</p><blockquote><p><strong>要找到一个满足判断式的元素，使用 find 函数</strong></p><pre><code class="kotlin">&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,27),Person(&quot;Bob&quot;,31))&gt;&gt;&gt; println(people.find(canBeInClub27))Person[name = Alice,age = 27]</code></pre><p>存在多个能够匹配的元素就返回其中第一个元素：或者返回 null，如果没有一个元素能满足判断式。find还有一个同义方法 firstOrNull，可以使用这个方法更加清楚的表达你的意图。</p></blockquote><h3 id="5-2-3-groupBy：把列表转换成分组的map"><a href="#5-2-3-groupBy：把列表转换成分组的map" class="headerlink" title="5.2.3 groupBy：把列表转换成分组的map"></a>5.2.3 groupBy：把列表转换成分组的map</h3><blockquote><p><strong>当你想把人按照年龄分组，相同年龄的人放在一组。</strong></p><p>groupBy: 按照表达式将几个进行分组并返回一个 map 集合</p><pre><code class="kotlin">&gt;&gt;&gt; val people = listOf(Perosn(&quot;Alice&quot;,31),Perosn(&quot;Bob&quot;,29),Person(&quot;Carol&quot;,31))&gt;&gt;&gt; println(people.groupBy{it.age})</code></pre><p>返回结果 map，是元素分组依据的键（这个例子中是age）和元素分组（persons）之间映射</p><pre><code class="kotlin">{29 = [Person(name = Bob,age = 29)],31 = [Person(name = Alice,age = 31),        Person(name = Carol,age = 31)]        }</code></pre><p>每个分组都是存储在一个列表中，<strong>结果的类型就是Map&lt;Int,List<Person>&gt;</strong>。</p><p>可以使用像 mapKeys 和 mapValues 这也的函数对这个map做进一步的修改。</p></blockquote><blockquote><p><strong>使用成员引用把字符串按照首字母分组：</strong></p><pre><code class="kotlin">&gt;&gt;&gt; val list = listOf(&quot;a&quot;,&quot;ab&quot;,b)&gt;&gt;&gt; println(list.groupBy(String::first)){a = [a,ab], b = [b]}</code></pre><p>first并不是String类的成员，而是一个扩展。然而，可以把它当作成员引用访问。</p></blockquote><h3 id="5-2-4-flatMap-和-flatten：处理嵌套集合和元素"><a href="#5-2-4-flatMap-和-flatten：处理嵌套集合和元素" class="headerlink" title="5.2.4 flatMap 和 flatten：处理嵌套集合和元素"></a>5.2.4 flatMap 和 flatten：处理嵌套集合和元素</h3><p><strong>例子</strong></p><blockquote><p>假设你有一堆藏书，使用Book表示：</p><pre><code class="kotlin">class Book(val title:String,val authors:List&lt;String&gt;)</code></pre><p>authors ：保存书的所有作者。</p><p>统计出图书馆中所有作者的set；</p><pre><code class="kotlin">books.flatMap{it.authros}.toSet()    //包含撰写 “books” 集合中书籍的所有作者 set</code></pre><p>flatMap:作用，1.首先根据作为实参给定的函数对集合中的每个元素做转换（或者说映射），然后把多个列表合并（或者说平铺）成一个列表。</p></blockquote><blockquote><p>说明：</p><pre><code class="kotlin">&gt;&gt;&gt; val strings = listOf(&quot;abc&quot;,&quot;def&quot;)&gt;&gt;&gt; pritnln(strings.flatMap{it.toList()})[a,b,c,d,e,f]</code></pre><p>字符串上的toList函数把它转换成字符列表。</p><p>使用 map 函数，你会得到一个字符列表的列表。</p><p>flatMap 函数：执行后面操作，并返回一个包含所有元素（字符）的列表</p><p>回到例子中：</p><pre><code class="kotlin">&gt;&gt;&gt; val books = listOf(Book(&quot;Thursday Next&quot;,listOf(&quot;Jasper Fforde&quot;)),                        Book(&quot;Mort&quot;,listOf(&quot;Terry Pratchett&quot;)),                        Book(&quot;Good Omens&quot;,listOf(&quot;Terry Pratchett&quot;,                                                &quot;Neil Gaiman&quot;)))&gt;&gt;&gt; println(books.flatMap{it.authors}.toSet)                                                [Jasper Fforde,Terry Pratchett,Neil Gaiman]</code></pre><p>book.authors 是存储了多个作者的集合。flatMap 函数把所有书籍的作者合并成变频的列表。</p><p><strong>toSet调用移除了结果集合中的所有重复元素。</strong></p><p>所以 Terry Pratchett 在输出中只出现了一次。</p><p><strong>如果你只需要平铺一个集合，可以使用 flatten 函数：listOfLists.flatten</strong></p></blockquote><h2 id="5-3-惰性集合操作：序列"><a href="#5-3-惰性集合操作：序列" class="headerlink" title="5.3 惰性集合操作：序列"></a>5.3 惰性集合操作：序列</h2><blockquote><p>你看到了关于许多链式调用的例子，例如 map 和 filter。这些函数会及早的创建中间集合，也就是说每一步的中间结果都被存储在一个临时列表。</p><pre><code class="kotlin">people.map(Person::name).filter{it.startsWith(&quot;A&quot;)}</code></pre><p>Kotlin 标准库参考文档说明，filter 和 map 都会返回一个列表。这意味这上面的例子中的链式调用会创建两个列表：一个保存filter函数的结果，另一个保存 map函数的结果。如果源列表只有两个元素，这不是什么问题，但是如果有一百万个元素，（链式）调用就会变得十分低效。</p><p>为了提高效率可以将操作变换成序列，而不是使用集合：</p><pre><code class="kotlin">people.asSequence()    //把初始集合转换成序列      .map(Person::name)          .filter{it.startsWith(&quot;A&quot;)}    //系列支持和集合一样的API      .toList()    // 把结果序列转换会列表</code></pre><p>这个例子没有创建任何一个存储元素的，所以元素数量巨大的情况下性能显著提升。</p><p>Kotlin 惰性集合操作的入口就是 Sequence 接口。这个接口表示可以诸葛列举的元素序列。Sequence 只提供了一个方法，iterator，用来从序列中获取值</p></blockquote><p>优势</p><blockquote><p>Sequence接口的强大之处在于其操作的实现方式。序列中的元素求值是惰性的，因此可以使用序列更高效地对集合元素执行链式操作，而不需要创建额外的集合来保存过程中产生的总结结果。</p></blockquote><p>为什么需要把序列转换回集合？把序列代替集合不是更方便吗？特别是它的这些优点。</p><blockquote><p>大多数是这样的。如果你需要迭代序列中的元素，可以直接使用。而要使用其他API方法，例如下标访问元素，那么你需要将序列转换成列表。</p></blockquote><blockquote><p>通常，对一个大型集合执行链式操作时要使用序列。在后面的章节中继续讨论Kotlin常规集合的及早操作高效的原因，尽管它会创建中间集合。当集合拥有数量巨大的元素，元素为中间结果进行重新分配开销巨大，所以惰性求值是更好的选择。</p></blockquote><h3 id="5-3-1-执行序列操作：中间和末端操作"><a href="#5-3-1-执行序列操作：中间和末端操作" class="headerlink" title="5.3.1 执行序列操作：中间和末端操作"></a>5.3.1 执行序列操作：中间和末端操作</h3><p><strong>序列操作共分两种</strong>：</p><blockquote><p>中间和末端。</p><p>一次中间操作返回的是另一个序列，这个序列知道如何变换原始序列中的元素。</p><p>而末端操作返回的是一个结果，这个结果可能是集合、元素、数字，或者其他的初始集合的变换序列中获得的任意对象。</p><pre><code class="kotlin">sequence.map{...}.filter{...}//中间操作        .toList()//末端操作</code></pre></blockquote><p><strong>没有末端操作的例子：</strong></p><pre><code class="kotlin">&gt;&gt;&gt; listOf(1,2,3,4).asSequence()    //序列化...        .map{print(&quot;map($it)&quot;);it*it}    // 转换成map集合并操作它...        .filter{ print(&quot;filter($it)&quot;);it%2==0}    //调用对象，然后根据条件过滤</code></pre><blockquote><p>执行这段代码并不会在控制台上输出任何内容。这意味着map和filter变换被延期了，它们只有在获取结果的是否才会被应用(即末端操作被调用的时候)：</p><pre><code class="kotlin">&gt;&gt;&gt;listOf(1,2,3,4).asSequence()...                .map{print(&quot;map($it);it*it&quot;)}...                .filter{print(filter(&quot;$it&quot;);it%2 == 0)}...                .toList()map(1) filter(1) map(2) filter(4) map(3) filter(9) map(4) filter(16)</code></pre><p>末端操作触发执行了所有的延期计算。</p></blockquote><p><strong>计算执行的顺序。</strong></p><blockquote><p>一个笨办法实在每个元素上调用map函数，然后再结果序列的每个元素上再调用filter函数。</p><p>map和filter对集合就是这样做的，而序列不一样。对序列来说，所有操作是按序列应用再每个元素上：处理完第一个元素（先映射再过滤），然后完成第二个元素的处理，以此类推。</p><p><strong>这种方法意味着部分元素根本不会发生任何转换</strong></p><p>如果在轮到它们之前就已经取得了结果。我们来看一个map和find的例子。首先一个数字映射成它的平方，然后找到第一个比数字3大的条目：</p><pre><code class="kotlin">&gt;&gt;&gt; println(listOf(1,2,3,4).asSequence()                           .map{it*it}                           .find{it &gt; 3}                           )4</code></pre><p>如果同样的操作被应用在集合而不是序列上时，那么 map 的结果首先被求出来。即变换初始集合中的所有元素。第二步，中间集合中满足判断式的一个元素会被找出来。而对于序列来说，惰性方法意味这你可以跳过处理部分元素。图 5.8 阐明了 这段代码两种求值方法之间的区别，一种是及早求值（使用集合），一种是惰性求值（使用序列）。</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210402111938.png" alt="及早求值在整个集合上执行每个操作；惰性求值则逐个处理元素"></p><p><strong>在集合上执行操作的顺序也会影响性能。</strong></p><p>假设你有一个人的集合，想要打印集合中那些长度小于某个限制的人名。</p><p>这时你需要做两件事：把每个人映射成他们的名字，然后过滤掉其中那些不够短的名字。</p><p><strong>这种情况可以用任何顺序应用map和filter操作。两种顺序得到的结果是一样的如下</strong></p><pre><code class="kotlin">&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31),Person(&quot;Charles&quot;,31),Person(&quot;Dan&quot;,21))&gt;&gt;&gt; println(people.asSequence().map(Person::name).filter{it.length &lt; 4}.toList()) // 先 “map” 后 “filter”[Bob,Dan]&gt;&gt;&gt; println(people.asSequence().filter{it.name.length &lt; 4}...            .map(Person::name).tolist())    // 先“filter”后 map[Bob,Dan]</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210402103856.png" alt="先应用filter有助于减少变换的总次数"></p><blockquote><p>如果 filter 在强，不适合的元素会被尽早地过滤掉且不会发生变换。</p></blockquote><h3 id="5-3-2-创建序列"><a href="#5-3-2-创建序列" class="headerlink" title="5.3.2 创建序列"></a>5.3.2 创建序列</h3><blockquote><p>asSequence()：函数用来在集合中创建序列</p><p>generateSequence()函数：给定序列中的前一个元素，这个函数会计算出下一个元素。</p><p><strong>案例 使用 generateSequence 计算 100 以内所有的自然数之和。</strong></p><pre><code>&gt;&gt;&gt; val naturalNumbers = generateSequence(0) {it +1}&gt;&gt;&gt; val numbersTo100 = naturalNumbers.takeWhile{it &lt;= 100}&gt;&gt;&gt; println(numbersTo100.sum())    //当获得结果 “sum” 时，所有被推迟的操作都被执行5050</code></pre><p>例子中 naturalNumbers 和 numbersTo100都有延期操作序列。这些序列中的实际数字知道你调用末端操作的时候才会求值。（sum）</p></blockquote><p><strong>创建父目录的序列</strong></p><blockquote><p>如果元素的父元素和它的类型相同（比如人类或者java文件），你可能会对它的所有祖先组成的序列的特质感兴趣。下列这个例子可以查询是否放在隐藏目录中，通过创建一个其父目录的序列并检查每个目录的属性来实现。</p><pre><code class="kotlin">/*    创建并使用父目录的序列    */fun File.isInsideHiddenDirectory() =         generateSequence(this){it.parentFile}.any{it.isHidden}    // 查询文件是否放在隐藏目录中。&gt;&gt;&gt; val file = File(&quot;/Users/svtk/.HiddenDir/a.txt&quot;)        &gt;&gt;&gt; println(file.IsInsideHiddenDirectory())true</code></pre><p>你生成了一个序列，通过提供第一个元素和获取每个后续元素的方式来实现。如果把any换成find，你还可以得到你想要的那个目录（对象）。注意，使用序列允许你找到需要的目录之后立即停止遍历父目录。</p></blockquote><h2 id="5-4-使用-Java-函数式接口"><a href="#5-4-使用-Java-函数式接口" class="headerlink" title="5.4  使用 Java 函数式接口"></a>5.4  使用 Java 函数式接口</h2><p>Kotlin 的 lambda 可以和 Java API 互操作。</p><p>在本章节开头处，有看过一个把 lambda 传递给 Java 方法的例子：</p><pre><code class="kotlin">button.setOnClickListener{/*    点击之后的动作     */}    //复习 作为方法的最后一个参数可以省略()。把lambda作为实参传递。</code></pre><p>Botton 通过接收类型为OnClickListener的实参的setOnClickListener方法给按钮设置一个新的监听器：</p><pre><code class="java">/*    Java    */public class Button{    public void setOnClickListener(OnClickListener l){...}}</code></pre><p>OnClickListener 接口声明了一个方法，onClick：</p><blockquote><p><em>接口可以被实现，但不能被实例化。</em></p></blockquote><pre><code class="java">public interface OnClickListener{    void onClick(View v)}</code></pre><p>在Java 8 之前你不得不创建一个匿名类的实例来作为实参传递给 setOnClickListener方法：</p><pre><code class="java">button.setOnClickListener(new OnClickListener(){    @Override    public void onClick(View v){        ...    }})</code></pre><p>在 kotlin 中 可以传递一个 lambda，代替这个实例：</p><pre><code class="kotlin">button.setOnClickListener{view -&gt; ...}</code></pre><p>lambda 用来实现 OnClickListener，它有一个类型为View的参数，和onClick一样。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210402121803.png" alt="Lmabda的参数和方法参数对应"></p><blockquote><p>这个方法可以工作的原因是OnClickListener接口只有一个方法。<strong>这种方法被称为函数式接口，或者 SAM 接口，SAM 代表单抽象方法。Java API随处可见像Runnable和Callable这样的函数式接口，以及支持它的方法。</strong>Kotlin允许你在调用接口函数式接口作为参数的方法时使用lambda，来保证你的Kotlin代码即整洁又符合习惯。</p></blockquote><p>​             </p><h3 id="5-4-1-把lambda-当作参数传递给Java方法"><a href="#5-4-1-把lambda-当作参数传递给Java方法" class="headerlink" title="5.4.1 把lambda 当作参数传递给Java方法"></a>5.4.1 把lambda 当作参数传递给Java方法</h3><p>可以把lambda传递给任何期望函数式接口的方法。</p><blockquote><p>例如，如下的方法 Runable类型的参数：</p><pre><code class="Java">/*    Java    */void postponeComputation(int delay,Runnable computation);</code></pre><p>在 Kotlin 中，可以调用它并把一个lambda作为实参传给它。编译器会<strong>自动</strong>把它转换成一个Runnable的实例：</p><p>postponeComputation(1000){ println(42) }</p><p>当我们说“一个Runnnable的实例”时，指的是“一个实现了Runnable接口的匿名类的实例”。编译器会帮你创建它，并使用lambda作为单抽象方法–这个例子中式run方法–的方法体。</p><p>如下：显式的创建一个Runnable的匿名对象也能达到同样的效果：</p><pre><code class="kotlin">postponeComputation(1000,object:Runnable{    //把对象表达式作为函数式接口的实现传递。    override fun run(){        println(42)    }})</code></pre><p>但是这里有点不一样。当你显式地声明对象时，每次调用都会创建一个新的实例。使用lambda的情况不同：如果lambda没有访问任何来自定义它的函数变量，相应的匿名类实例可以在多次调用之间重（chóng）用：</p><pre><code class="kotlin">postponeComputation(1000){println(42)}    //整个程序只会创建一个Runnable的实例</code></pre><p>想要完全等价的实现应该是下面这段代码中的显式object声明，它把Runnable实例存储在一个变量中，并且每次调用的时候都使用这个变量：</p><pre><code class="kotlin">val runnable = Runnable{println(42)}    //编译成全局变量：程序中仅此一个实例fun handleComputation(){    postponeComputation(1000,runnable)    //每次postponeComputation调用时用的是一个对象}</code></pre><p>如果lambda在包围它的作用域中捕捉到了变量，那么每次调用就不再可能重用同一个实例了。</p><p>这时，每次调用编译器都要创建一个新对象，其中存储着被捕捉的变量的值。</p><p>如下：每次调用都会使用一个新的Runnable实例，把id值存储在它的字段中：</p><pre><code class="kotlin">fun handleComputation(id:String){    //lambda会捕捉“id”这个变量    postponeComputation(1000){println(id)}    //每次handleComputation调用都创建一个Runnable的新实例。}</code></pre></blockquote><p>Lmabda的实现细节</p><blockquote><p>从 Kotlin1.0起，每次lambda表达式都会被编译成一个匿名类，除非它是内联lambda。（内联函数不会创建匿名类）。在后续版本支持生成java8字节码后，编译器就可以避免为每一个lambda表达式都生成一个独立的.class文件。如果lambda捕捉了变量，每个被捕捉的变量会在匿名类中有对应的字段，而且每次（对lambda）的调用都会创建一个这个匿名类的新实例。</p><p><em>否则，一个单例就会被创建。类的名称由lambda声明所在的函数名字称加上后缀衍生出来：这个例子中就是 HandleComputation$1。如果你反编译之前lambda表达式的代码，就会看到：</em> </p><pre><code class="kotlin">class HandleComputation$1(val id:String):Runnable{    override fun run(){        println(id)    }}fun handleComputation(id:String){    postponeComputation(1000,HandleComputation$1(id))    //底层创建一个特殊的实例，而不是lambda}</code></pre><p>编译器给每个被捕捉的变量生成了一个字段和一个构造方法参数。</p></blockquote><p><strong>把lambda传给标记成 inline 的Kotlin函数，是不会创建任何匿名类的。</strong></p><h3 id="5-4-2-SAM构造方法：显式地把lambda转换成函数式接口"><a href="#5-4-2-SAM构造方法：显式地把lambda转换成函数式接口" class="headerlink" title="5.4.2 SAM构造方法：显式地把lambda转换成函数式接口"></a>5.4.2 SAM构造方法：显式地把lambda转换成函数式接口</h3><blockquote><p>SAM<strong>构造方法</strong>是<strong>编译器生成的函数</strong>。用来让你执行从lambda到函数式接口实例的显式转换。</p><p>可以用在编译器不会自动应用转换的上下文中使用它。</p><p><strong>例如：如果有一个方法返回一个函数式接口（只有一个抽象方法的实例）的实例，不能直接返回一个lambda，要用SAM构造方法把它包装起来。</strong></p><p><strong>如下例子：</strong></p><pre><code class="kotlin">/*    使用SAM构造方法来返回值    */fun createAllDoneRunnable():Runnable{    return Runnable {println(&quot;All done!&quot;)}}&gt;&gt;&gt; createAllDoneRunnable().run()All done!</code></pre><p><strong>SAM（函数式接口）构造返回的名称和底层函数式接口的名称一样。</strong>SAM构造方法只接收一个参数— 一个被用作函数式接口单抽象方法的lambda – 并返回实现了这个接口类的一个实例。</p></blockquote><blockquote><p>除开返回值外，SAM构造方法还可以用在需要<strong>把从lambda生成的函数式接口实例存储在一个变量中的情况。**</strong>假设你要在多个按钮上重用同一个监听器**，就像下面的代码清单一样（在Android应用中，这段代码可以作为Activity.onCreate方法的一部分）</p><pre><code class="kotlin">/*    使用SAM构造方法来重用listener实例    */val listener =OnClickListener{    view -&gt;    val text = when (view.id){        R.id.button1 -&gt; &quot;First button&quot;        R.id.button2 -&gt; &quot;Second button&quot;        else -&gt; &quot;Unknown button&quot;    }    toast(text)}button1.setOnClickListener(listener)button2.setOnClickListener(listener)</code></pre><p>listener 会检查那个按钮是点击的事件源并作出对应的行为。可以使用实现了OnClickListener的对象声明来定义监听器，但是SAM构造方法提供了更简洁的方法。</p></blockquote><blockquote><p><strong>Lambda 和 添加/移除监听器</strong></p><p>lambda 内部类有匿名对象那样的this：没有办法应用lambda转换成的匿名类实例。<strong>从编译器的角度来看，lambda是一个代码块，而不是一个对象，而且也不能当作一个对象来引用</strong>。<strong>Lambda中的this引用指向的是包围它的类。</strong></p><ul><li><input disabled="" type="checkbox"> 如果你的事件监听器在处理事件时需要取消它自己，不能使用lambda这样做。<strong>这种情况使用实现了接口的匿名对象</strong>。<strong>在匿名对象内，this关键词指向该对象实例，可以把它传递给移除监听器的API</strong></li></ul></blockquote><p>尽管方法调用中的SAM转换一般都会自动发生，<strong>但是当把lambda作为参数传给一个重载方法</strong>，<strong>也有编译器不能选择正确的重载情况</strong>。这时显式的SAM构造方法时解决错误的好方法。</p><h2 id="5-5-带接收器的lambda：”with“-与-”apply“"><a href="#5-5-带接收器的lambda：”with“-与-”apply“" class="headerlink" title="5.5 带接收器的lambda：”with“ 与 ”apply“"></a>5.5 带接收器的lambda：”with“ 与 ”apply“</h2><p><strong>带接收者的lambda：</strong></p><p>此节将办理逐步熟悉Kotlin的lambda的独特功能：<strong>在lambda函数体类可以调用一个不同对象的方法，而却无需借助任何限定符</strong>；此方法在java中是不存在的。这样的lambda叫做带接收者的lambda</p><p><strong>什么是带接收者的 lambda？</strong></p><blockquote><p>Kotlin 中独特的 lambda 功能：在lambda函数体内可以调用一个不同的对象方法，而且无需借助任何额外的限定符。</p></blockquote><p><strong>接收者：</strong>调用者</p><h3 id="5-5-1-“with”-函数"><a href="#5-5-1-“with”-函数" class="headerlink" title="5.5.1 “with” 函数"></a>5.5.1 “with” 函数</h3><p>从 with 函数开始它用到了带接收者lambda。</p><p>with的库函数：</p><blockquote><p>它对同一个对象执行多次操作，而不需要反复把对象的名称写出来。</p></blockquote><p><strong>构建字母表</strong></p><pre><code class="kotlin">fun alphabet(): String {    val result = StringBuilder()    for (letter in &#39;A&#39;..&#39;Z&#39;) {        result.append(letter)    }    result.append(&quot;\n Now I know the alphbet!&quot;)    return result.toString()}</code></pre><pre><code class="kotlin">fun main() {    println(alphabet())}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201022214803.png" alt=""></p><p><strong>使用场景（为什么要用”with“）</strong></p><p>案例中多次调用到 “<strong>result</strong>“实例。使用”<strong>with</strong>“减少对实例的调用。</p><p><strong>如何使用 ”with“？</strong></p><pre><code class="kotlin">fun alphabet(): String {    val result = StringBuilder()    return with(result) {// 指定接收者的值        for (letter in &#39;A&#39;..&#39;Z&#39;) {            this.append(letter) // 显式的使用‘this’来调用接收者值的方法（result.appned()方法）        }        append(&quot;\n Now I know the alphabet!&quot;)   // 隐藏 ‘this’ 同样可以使用        this.toString()    }}</code></pre><pre><code class="kotlin">fun main() {    println(alphabet())}</code></pre><p><strong>”with“的结构</strong></p><blockquote><p>with 结构看上去像是一种特殊的语法结构，但它实际上是一个接收两个参数的函数：这个例子中两个参数分别是 stringBuilder 和 lambda 。</p></blockquote><p>with 函数把第一个参数转换为第二个参数传递给 lambda 的接收者。</p><p><strong>在普通函数中与扩展函数中带接收者的 lambda 有那些不同</strong></p><blockquote><p>在扩展函数体内部，this 指向了这个函数扩展的那个类型实例，而且也可以被省略掉，让你直接访问接收者的成员。</p></blockquote><blockquote><p>上面的代码中，this 指定了stringBuilder，这时传给with的第一个参数。可以通过显式的this引用来访问stringBuilder的方法，就像this，append(latter)这样：也可以像append（”\nNow…”)</p></blockquote><p><strong>重构初始的alphabet函数，去除stringBuilder变量。</strong></p><blockquote><pre><code class="kotlin">/*    使用with和一个表达式函数体来构造字母表    */fun alphabet() = with(StringBuilder){    for(letter in &#39;A&#39;...&#39;Z&#39;){        append(letter)    }    append(&quot;\n Now I know the alphabet!&quot;)    toString()}</code></pre><p>现在此函数只返回一个表达式，所有表达式函数体语法重写了它。</p><p>可以创建一个新的StringBuilder实例直接当作实例传递给这个函数，然后 lambda中不需要显式的this就可以引用到这个实例。</p></blockquote><h3 id="5-5-2-“apply”-函数"><a href="#5-5-2-“apply”-函数" class="headerlink" title="5.5.2 “apply” 函数"></a>5.5.2 “apply” 函数</h3><p><strong>apply 和 with 的不同</strong></p><blockquote><p>apply 函数同with 函数功能相同，区别在于 apply 始终会返回作为实参传递给它的对象。（返回本身作为实例）</p></blockquote><pre><code class="kotlin">fun alphabet() = StringBuilder().apply {    for (letter in &#39;A&#39;..&#39;Z&#39;) {        append(letter)    }    append(&quot;\n Now I know the alphbet!&quot;)}.toString()</code></pre><p>apply 被声明成一个扩展函数。它的<strong>接收者</strong>变成了作为实参的 lambda 的接收者。执行 apply 的结果是StringBuilder,所以接下来里可以调用 toString 把它转换成 String。</p><p><strong>使用apply初始化一个TextView</strong></p><pre><code class="kotlin">fun createViewWithCustomAttributes(context : Context) = {    TextView(context).apply{        text = &quot;Sample Text&quot;        textSize = 20.0        setPadding(10,0,0,0)    }}</code></pre><p><strong>apply函数允许里使用紧凑的表达式函数体风格</strong>。新的<strong>TextView</strong>实例<strong>创建</strong>之后立即被传给了<strong>apply</strong>。</p><p><strong>那个是接收者?</strong></p><p>TextView实例变成了 (lambda 的) 接收者，你可以调用它的属性和方法。</p><p>with 函数和 apply 函数是最基本和最通用的使用带接收者的 lambda 的例子。更多的函数也可以使用这种模式。例如，使用<strong>标准库函数buildString进一步简化alphbet函数</strong>，它会负责<strong>创建StringBuilder</strong>并<strong>调用toString</strong>。<strong>building实际是带接收者的lambda</strong>，<strong>接收者</strong>就是<strong>StringBuilder</strong>。</p><p><strong>使用buildString创建字母表</strong></p><pre><code class="kotlin">/*    使用bulderString创建字母表    */fun alphabet()=builderString{    for (letter in &#39;A&#39;...&#39;Z&#39;){        append(latter)    }    append(&quot;\n Now I know tha alphabet!&quot;)}</code></pre><p>buildString 函数完成了借助StringBuilder创建String的任务。</p><h2 id="5-6-小结"><a href="#5-6-小结" class="headerlink" title="5.6 小结"></a>5.6 小结</h2><ul><li><strong>Lambda 允许你将代码块当作参数传递给函数。</strong></li><li><strong>Kotlin可以把lambda放在括号括号外穿的给函数，而且可以使用it引用单个lambda参数</strong></li><li><strong>lambda中的代码可以访问和修改包括这个lambda调用的函数的变量（访问修改调用者的变量）</strong></li><li><strong>通过在函数名称前加上前戳::，可以创建方法、可以创建方法及属性的引用，并用这些引用代替lambda传递给函数。</strong></li><li><strong>使用像filter、map、all、any、等函数，大多数公共的集合操作不需要手动迭代元素就可以完成。</strong></li><li><strong>序列允许你合并一个集合上的多个操作，而不需要创建新的集合来保存中间结果。</strong></li><li><strong>可以把lambda作为实参传递给接收Java函数式接口（带单抽象方法的接口，也叫SAM接口）作为形参的方法。</strong></li><li><strong>with标准库函数允许你调用同一个对象的多个方法，而不需要反复写出这个对象的引用。apply函数让你使用构造者风格的API创建和初始化任何对象。</strong></li></ul><h1 id="6-Kotlin的类型系统"><a href="#6-Kotlin的类型系统" class="headerlink" title="6  Kotlin的类型系统"></a>6  Kotlin的类型系统</h1><h2 id="6-1-可空性"><a href="#6-1-可空性" class="headerlink" title="6.1 可空性"></a>6.1 可空性</h2><p><strong>可空性是Kotlin类型系统中帮助你避免NullPointerException错误的特性。</strong></p><p>现代编程语言包括Kotlin解决这类问题的方法是把运行时的错误转变成编译期的错误。通过支持作为类型系统的一部分的可空性，编译器就能在编译器发现很多潜在的错误，从而减少运行时抛出异常的可能性。</p><p>我们会讨论Kotlin中的可空类型：Kotlin怎样表示允许null的值，以及Kotlin提供的处理这些值的工具。除此之外，我们还要讨论混合使用Kotlin和Java代码时关于可空类型的细节。</p><h3 id="6-1-1-可空类型"><a href="#6-1-1-可空类型" class="headerlink" title="6.1.1 可空类型"></a>6.1.1 可空类型</h3><p>Kotlin  和 Java 的类型系统之间第一条也可能是最重要的一条区别是，Kotlin对可空类型的显式的支持。</p><blockquote><p>这意味着，这是一种指出你程序中那些变量和属性允许为null的方式。如果一个变量可以为null，对变量的方法的调用就是不安全的，因为这样会导致NullPointerException。Kotlin不允许这样的调用因而可以阻止许多可能的异常。</p></blockquote><p><strong>在实践时它是如果工作的</strong></p><pre><code class="kotlin">int strLen(String s){    return s.length();}</code></pre><blockquote><p>这个函数被调用的时候，传给它的是一个null实参，它会抛出NullPointerException。是否需要在方法中增加对null的检查，这取决于使用该函数的意图。</p></blockquote><p><strong>用Kotlin重写这个函数</strong></p><blockquote><p>不希望在调用时传递一个 null 进来</p><pre><code class="kotlin">fun strLen(s:String) = s.length</code></pre><p>使用可能为null的参数调用strLen是不允许的，在编译期就会被标记成错误：</p><pre><code class="kotlin">&gt;&gt;&gt; strLen(null)ERROR:Null can not be a value of a non-null type String</code></pre><p>这个函数中的参数被声明成String类型，在Kotlin中这个表示它必须包含一个String实例。这一边由编译器强制实施，所以你不能传递一个包含null的参数。</p><blockquote><p>如果你允许调用这个方法的时候传递给它可能所有的实参，包含那些可以为null的实参，需要显式地在类型名称后面加上问号来标记它：</p><pre><code class="kotlin">fun strLenSafe(s:String?) = ... //允许为空</code></pre><p>问号可以加载任何类型的后面来表示这个类型的变量可以存储null引用：String?、Int?、MyCustomType?等等</p></blockquote></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210404144208.png" alt="可空类型的变量可以存储null引用"></p><p><strong>所有类型在没有问号的类型声明的情况下是不能存储null引用的，也就是说常见类型默认都是非空的。</strong></p><blockquote><p><strong>在拥有一个可空类型的值，能对它进行操作也是有限制的。</strong></p><p>例如，不能再调用它的方法：</p><pre><code class="kotlin">&gt;&gt;&gt; fun strLenSafe(s:String?) = s.length()ERROR:only safe(?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type kotlin.String?</code></pre><p>也不能再把它赋值给非空类型的变量：</p><pre><code class="kotlin">&gt;&gt;&gt; val x:String ?= null&gt;&gt;&gt; var y:String =xERROR:Type mismatch:inferred type is String? but String was expected</code></pre><p>也不能把可空类型的值传递给拥有非空类型参数的函数：</p><pre><code class="kotlin">&gt;&gt;&gt; strLen(x)ERROR:Type mismatch:inferred type is String? but String was expected</code></pre><p><strong>可以进行的操作</strong></p><p>最重要的操作就是和null进行比较。而且一旦你进行了比较操作，编译器就会记住，并且在这次比较发生的作用域内把这个值当作非空来对待。</p><p>例如，下列代码是合法的：</p><pre><code class="kotlin">/*    使用 if 检查处理null    */fun strLenSafe(s:String?):Int =     if (s != null) s.length else 0    // 增加了null 检查后，这段代码就可以编译了&gt;&gt;&gt; val x:String?= null&gt;&gt;&gt; println(strLenSafe(x))0&gt;&gt;&gt; println(strLenSafe(&quot;abc&quot;))3</code></pre><p>if 检查并不是唯一处理可空性的工具，稍后会有其他工具来帮助我们处理可空值。</p></blockquote><h3 id="6-1-2-类型的含义"><a href="#6-1-2-类型的含义" class="headerlink" title="6.1.2 类型的含义"></a>6.1.2 类型的含义</h3><p><strong>什么是类型，为什么变量拥有类型？</strong></p><blockquote><p>类型就是数据的分类，决定了该类型可能的值，以及该类型的值上可能完成的操作（维基百科）。</p></blockquote><p>试试在Java的一些类型上套用如上的定义，从double类型开始。double类型是64位的双精度浮点数。可以对double类型的值进行标准的算术运算，所有的功能都可以一视同仁的运用到所有double类型的值上。因此如果你有一个类型为double的变量，那么你就能确定编译器允许在该值上进行任意操作，都可以被成功的执行。</p><p>现在我们把它和String类型的变量对比一下。在Java中，这样的变量可以持有两种值，分别是String实例和null。这两种完全不一样：就连Java自己的instanceof运算符都会告诉你null不是String。这两种值的操作也完全不一样：真实的String实例允许你调用它的任何方法，而null值只允许非常有限的操作。</p><p>上述表明在Java中类型系统不能很好的工作。<strong>即使变量拥有声明类型String你依然无法知道能对该变量的值做些什么，除非做额外的检查。你往往跳过这些检查，因为你觉得你了解程序中大概的数据流动，并确定在某个点上的值不可能为null。有时候你想错了，而你的程序就会因为NullPointerException而崩溃。</strong></p><p>Kotlin的可空类型为这类问题提供了全面的解决方案。区分开可空类型和非空类型使事情变得明朗：那些对值的操作使允许的，哪些操作有会导致运行时异常并因此被禁止。</p><blockquote><p><strong>注意</strong>：</p><p>可空的和非空的对象在运行时没有什么区别；可空类型并不是非空类型的包装。所有的检查都发生在编译期。这意味Kotlin的可空类型并不会在运行时带来额外的开销。</p></blockquote><h3 id="6-1-3-安全调用运算符：“-”"><a href="#6-1-3-安全调用运算符：“-”" class="headerlink" title="6.1.3 安全调用运算符：“?.”"></a>6.1.3 安全调用运算符：“?.”</h3><p><strong>安全调用运算符</strong>：“?.”，它允许你把null检查和一次方法复用合并成一次操作。</p><p>例如：表达式 s?.toUpperCase() 等用于下面这种繁琐的写法： if (s!=null) s.toUpperCase() else null。</p><blockquote><p>也就是说在你调用一个非空值的方法，这次方法调用会被正常的调用。如果是null值的话，这次调用不会发生，而整个表达式的值为null。</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210409163831.png" alt="安全调用运算符只会调用非空值的方法"></p><p>注意，这次调用的结果类型也是可空的。尽管String.toUppferCase()会返回String类型的值，但s是可空的时候，表达式s?.toUpperCase()的结果类型是String?:</p><pre><code class="kotlin">fun printAllCaps(s:String?){    val allCaps:String? = s?.toUppperCase()    // allCaps可能是null    println(allCaps)}&gt;&gt;&gt; printAllCaps(&quot;abc&quot;)ABC&gt;&gt;&gt; printAllCaps(null)null</code></pre><p><strong>安全调用不光可以调用方法，可能用来访问属性。</strong></p><pre><code class="kotlin">/*    使用安全调用处理可控属性    */class Employee(val name:String,val manager:Employee?)fun managerName(employee:Employee):String?= employee.maneger?.name&gt;&gt;&gt; val ceo = Employee(&quot;Da Boss&quot;,null)&gt;&gt;&gt; val developer = Employee(&quot;Bob Smith&quot;,ceo)&gt;&gt;&gt; println(managerName(developer))Da Boss&gt;&gt;&gt; println(managerName(ceo))</code></pre><p>如果你的对象途中又多个可空类型的属性，通常可以在同一表达式中方便地使用多个安全调用。加入你要使用不同的类型来保存关于个人的信息、他们的公司，以及公司的地址，而公司和地址都可以省略。使用?.运算符，不需要任何额外的检查，就可以在以放代码中访问到Person的country属性。</p><pre><code class="kotlin">/*    链接多个安全调用    */class Address(val streetAddress:String,val zipCode:Int,val city:String,val country:String)class Company(val name:String, val address:Address?)class Person(val name:String,val company:Company?)fun Person.countryName():String{    val country = this.company?.address?.country    // 多个安全调用链接在一起    return if (country!=null) contry else &quot;Unknown&quot;}&gt;&gt;&gt; val person = Person(&quot;Dmitry&quot;,null)&gt;&gt;&gt; println(person.countryName())Unknown</code></pre><h3 id="6-1-4-Elvis-运算符：“-”"><a href="#6-1-4-Elvis-运算符：“-”" class="headerlink" title="6.1.4 Elvis 运算符：“?:”"></a>6.1.4 Elvis 运算符：“?:”</h3><p>Kotlin有方便的运算符来提供代替null的默认值。它被称为Elvis运算符。（或者null合并运算符）</p><pre><code class="kotlin">fun foo(s:String?){    val t:String = s?:&quot;&quot;    //如果“s”为null，结果为空字符串}</code></pre><blockquote><p>Elvis运算符接收两个运算数，如果第一个运算数不为null，或者结果就是第一个运算数；如果第一个运算数为null，运算结果就是第二个运算数。</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210411235620.png" alt="Elvis运算符用其他值代替null"></p><blockquote><p>Elvis 运算符经常和安全调用运算符一起使用，<strong>用一个值代替null对象调用返回时返回null。</strong></p><pre><code class="kotlin">fun strLenSafe(s:String?):Int = s?.length?:0&gt;&gt;&gt; println(strLenSafe(&quot;abc&quot;))3&gt;&gt;&gt; pritnln(strLenSafe(null))0</code></pre></blockquote><blockquote><p>在 6.1.3 “链接多个安全调用” 的函数 countryName现在也可以使用一行代码来完成。</p><pre><code class="kotlin">fun Person.countryName()=conpany?.address?.country?:=&quot;Unknown&quot;**</code></pre></blockquote><p><strong>在Kotlin中有种场景下Elvis运算符会特别顺手，想return和throw这样的操作其实是表达式，因此可以把它们写在Elvis运算符的右边。这种情况下，如果Elvis运算符左边的值为null，函数就会立即返回一个值或者抛出一个异常，如果函数中需要检查先决条件，这个方式会很有用。</strong></p><p><strong>实现一个打印包含个人公司地址的出货标签函数。</strong></p><pre><code class="kotlin">/*    同时使用throw和Elvis运算符    */class Address(val streetAddress:String,val zipCOde:Int,val city:String,val country:String)class Company(val name:String,val address:Address?)class Person(val name:String,val company:Company?)fun pritnlnShippingLabel(person:Person){    val address = person.company?.address                ?: throw IllegalArgumentException(&quot;No address&quot;)    //如果缺少addres就抛出异常    with(address){    //address 不为空        println(streetAddress        println(&quot;$zipCode $city,$country&quot;)    }}&gt;&gt;&gt; val address = Address(&quot;Elsestr. 47&quot;,80687,&quot;Munich&quot;,&quot;Germany&quot;)               &gt;&gt;&gt; val jetbrains = Company(&quot;JetBrains&quot;,address)                &gt;&gt;&gt; val person = Person(&quot;Dmitry&quot;,jetbrains)                &gt;&gt;&gt; printShippingLabel(person)Elsestr.4780687 Munich.Germany&gt;&gt;&gt; printShippingLable(Person(&quot;Alexey&quot;,null))java.lang.IllegalArgumentException:No address</code></pre><p><strong>如果一切正常，函数printShippingLable会打印出标签。如果地址不存在，它不会只是抛出一个带行号的NullPointerException，相反，它会报告一个有意义的错误。</strong>如果地址存在，标签会包含街道地址、邮编、城市和国家。留意之前说过的with函数是如何被用来避免在一行中重复四次address的。</p><h3 id="6-1-5-安全转换-“as-”"><a href="#6-1-5-安全转换-“as-”" class="headerlink" title="6.1.5 安全转换 “as?”"></a>6.1.5 安全转换 “as?”</h3><p>“as”用来转换类型的常规Kotlin运算符，<strong>和常规的Java类型转换一样，如果被转换的值不是你试图转换的类型，就会抛出ClassCastException异常。</strong></p><p><strong>“as?”运算符尝试把值转换成指定的类型，如果值不是合适的类型就返回null</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210414230332.png" alt="安全转换运算符尝试把值转换成给定的类型。如果类型不合适就返回null"></p><p><strong>一种常见的模式是把安全转换和Elvis运算符结合使用。</strong></p><pre><code class="kotlin">/*    使用安全转换实现equals    */class Person(val firstName:String,val lastName:String){    override fun equals(o:Any?):Boolean{        val otherPerson = o as? Person ?: return false    // 检查类型，如果不匹配就返回false        return otherPerson.firstName == firstName &amp;&amp; otherPerson.lastName == lastName    //在安全转换之后，变量otherPerson被智能地转换为 Person 类型    }    override fun hashCode():Int = firstName.hashCode() * 37 + lastName.hashCode()}&gt;&gt;&gt; val p1 = Person(&quot;Dmitry&quot;,&quot;Jemerov&quot;)&gt;&gt;&gt; val p2 = Person(&quot;Dmitry&quot;,&quot;Jemerov&quot;)&gt;&gt;&gt; println(p1 == p2)true&gt;&gt;&gt; println(p1.equals(42))false</code></pre><p><strong>使用这种模式，可以非常容易地检查实参是否是适当的类型，转换它，并在它的类型不能确定是返回false，而且这些操作全部在同一个表达式中。</strong>当然，这种场景下智能转换也会生效：当你检查过类型并拒绝了null值，编译器就确定了变量otherPerson值的类型是Person并当你能够相应的使用它。</p><h3 id="6-1-6-非空断言：“-”"><a href="#6-1-6-非空断言：“-”" class="headerlink" title="6.1.6 非空断言：“!!”"></a>6.1.6 非空断言：“!!”</h3><p>非空断言：</p><p><strong>它使用双感叹号表示，可以把任何值转换成非空类型。如果对null值做非空断言，则会抛出异常。</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210414234748.png" alt="通过使用非空断言，如果值为null，可以显式地抛出异常"></p><p><strong>使用非空断言来吧可空的实参转换成非空。</strong></p><pre><code class="kotlin">/*    使用非空断言    */fun ignoreNulls(s:String?){    val sNotNull:String = s!!    // 异常指向这一行    println(sNotNull.length)}&gt;&gt;&gt; igoreNulls(null)Exceptin in thread &quot;main&quot; kotlin.KotlinNullPointerException    at &lt;...&gt;.ignoreNulls(07_NotnullAssertions.kt:2)</code></pre><blockquote><p>如果上面函数中s为null会发生什么？Kotlin没有其他选择，它会在运行时抛出一个异常（一种特殊的NullPointerException）。但是注意异常抛出的位置是非空断言所在的哪一行，而不是接下来试图使用那个值的一行。本质上，你在告诉编译器：“我知道这个字不为null，如果我错了我准备好啦接收这个异常。”</p><blockquote><p>注意：Kotlin的设计者试图说服你思考更好的解决方案，这些方案不会使用断言这种编译器无法验证的方法。</p></blockquote><p>但是确实存在这种情况，某些问题适合使用非空断言来解决。当你在一个函数中检测一个值是否为null，而在另一个函数中使用这个值时，这种情况下编译器无法识别这种用法是否安全。（也就是使用前检查他是否为null）</p></blockquote><h3 id="6-1-7-“let”-函数"><a href="#6-1-7-“let”-函数" class="headerlink" title="6.1.7 “let” 函数"></a>6.1.7 “let” 函数</h3><p><strong>用来处理可空表达式。和安全调用运算符一起使用，允许你对表达式求值，检查求值结果是否null，并把结果保存为一个变量。</strong></p><pre><code class="kotlin">/*    使用let调用一个接收非空参数的函数    */fun sendEmailTo(email : String){    println(&quot;Sending emaill to $emaill&quot;)}&gt;&gt;&gt; var email:String ? = &quot;yole@example.com&quot;&gt;&gt;&gt; email?.let{sendEmailTo(it)}Sending email to yole@example.com&gt;&gt;&gt; emaill = null&gt;&gt;&gt; emaill?.let{    sendEmailTo(it)        }</code></pre><blockquote><p>所以说只有这段表达式不为空时才会执行代码块里的代码</p></blockquote><h3 id="6-1-8-延迟初始化的属性"><a href="#6-1-8-延迟初始化的属性" class="headerlink" title="6.1.8 延迟初始化的属性"></a>6.1.8 延迟初始化的属性</h3><p><strong>使用延迟初始化属性的原因</strong></p><blockquote><p>Kotlin 通常要求你在构造方法中初始化所有属性，如果某个属性是可空类型，你就必须提供一个非空的初始化值。否则，你就必须使用可空类型。如果你这样做，该属性的每一次访问都需要null检查或者”!!”运算符</p></blockquote><p><strong>使用非空断言访问可控属性</strong></p><pre><code class="kotlin">/*    使用非空断言访问可空属性    */class MyService{    fun performAction():String = &quot;foo&quot;}class MyText{    private var myService : MyService ?= null    // 声明了一个可空类型初始化为 null    @Before fun setUp(){    // 在 setUp方法中提供真正的初始化器        myService = MyService()    }    @Test fun testAction(){        Assert.assertEquals(&quot;foo&quot;,myService!!.performAction())    // 必须注意可空性：要么用&quot;!!&quot;，要么用&quot;?.&quot;    }}</code></pre><pre><code class="kotlin">/*    使用延迟初始化属性    */class MyService{    fun performAction():String = &quot;foo&quot;}class MyText{    private lateinit var myService : MyService    // 声明了一个不需要初始化器的非空类型属性    @Before fun setUp(){    // 在 setUp 方法中初始化 myService        myService = MyService()    }    @Test fun testAction(){        Assert.assertEquals(&quot;foo&quot;,myService.performAction())    // 不需要 null 检查直接访问属性    }}</code></pre><p>注意</p><blockquote><p>初始化的属性必须为var，因为需要在构造方法外修改它的值，使用val属性被编译时必须在构造方法中初始化final片段。</p><p>尽管 myService 属性是非空的，你不需要在构造方法中初始化它。在属性没有被初始化之前调用会得到异常 “lateinit property myService has not been initialized”。</p><blockquote><p>lateinit 属性常见的一种用法是在依赖注入。在某种情况下，lateinit 属性的值是被依赖注入框架从外部设置的。为了保证和各种依赖注入框架的兼容性</p><p>，Kotlin 会自动生成一个和 lateinit 属性具有相同可见性的字段。如果属性的可见性是public，生成字段也是可见性public</p></blockquote></blockquote><h3 id="6-1-9可空类型的扩展"><a href="#6-1-9可空类型的扩展" class="headerlink" title="6.1.9可空类型的扩展"></a>6.1.9可空类型的扩展</h3><blockquote><p>为可空类型定义扩展函数。可以允许接收者（调用者）为空null 的（扩展函数）调用，并在该函数中处理null，而不是在确保变量不为null之后再调用它的方法。</p><p><strong>只有扩展函数才能做到这一点，普通成员方法的调用是通过对象实例来分发的，因此实例为null时（成员方法）永远不能被执行。</strong></p></blockquote><p>Kotlin标准库中定义的String的两个扩展函数isEmpty和isBlanck就是这样的例子。第一个函数判断字符串是否是一个空的字符串“”。第二个函数则判断它是否是空的或者它只包含空白字符。通常用这些函数来检查字符串中是否有价值的，以确保对它的操作是由意义的。</p><p><strong>像这种无意义的空字符串和空白字符串这样处理null也很有用。事实上，你的确可以这样做：函数isEmptyOrNull和isNullOrBlank就可以由String?类型的接收者调用（用于可空类型接收者调用）。</strong></p><pre><code class="kotlin">/*    用可空接收者调用扩展函数    */fun verifyUserInput(input:String?){    if (input.isNullOrBlank()){    //不需要安全调用        println(&quot;Please fill in the requied fileds&quot;)    }}&gt;&gt;&gt; verifyUserInput(&quot; &quot;)    //可空类型的扩展函数在接收者为空时也可以调用Please fill in the required fields&gt;&gt;&gt; verifyUserInput(null)Please fill in the required fields</code></pre><p>不需要安全访问，就可以直接为可控接收者声明扩展函数</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210417170332.png" alt="不需要安全调用就可以访问可空类型的扩展"></p><p><strong>函数isNullOrBlank显式地检查了null，这种情况下返回true，然后调用isBlank，它只能在非空String上调用：</strong></p><pre><code class="kotlin">fun String?.isNullOrBlank():Boolean =    //可空字符串的扩展        this == null || this.isBlank    //第二个“this”使用了智能转换</code></pre><blockquote><p>当你为一个可空类型（以?结尾）定义扩展函数时，这意味着你可以对可空的值调用这个函数；并且函数体中的this可能为null，所以你必须显式地价差。在Java中，this永远是非空的，因为它引用的时当前你所在这个类的实例。而在Kotlin中，这并不永远成立：在可空类型的扩展函数中，this可以是null的。</p><p>let函数也能被可空的接收者调用，但它并不检查值是否为null。如果你在一个可空类型上调用let函数，而没有使用安全调用运算符，lambda的实参将会是可空的：</p><p>（let检查是否为null，并把结果保存为一个变量）</p><pre><code class="kotlin">&gt;&gt;&gt; val person:Person?=...    // 可空类型的非空属性&gt;&gt;&gt; person.let{ sendEmailTo(it) }    // 没有安全调用，所以“it”是可空类型ERROR:Type mismatch:inferred type is Person? but Person was expected</code></pre><p><strong>使用let来检查非空的实参，必须使用安全调用运算符“?.”，就像代码：person?.let{ sendEmailTo(it) }。</strong></p><blockquote><p>当你定义自己的扩展函数时，需要考虑该扩展是否需要为可空类型定义。默认情况下，应该把它定义成会空类型的扩展函数。在发现大部分情况下需要在可空类型上使用这个函数，再安全的修改它。</p></blockquote></blockquote><h3 id="6-1-10-类型参数的可空性"><a href="#6-1-10-类型参数的可空性" class="headerlink" title="6.1.10 类型参数的可空性"></a>6.1.10 类型参数的可空性</h3><p>Kotlin 中<strong>所有泛型类和泛型函数的类型参数默认</strong>都是可空的。</p><p>任何类型，包括可空类型在内，都可以替换类型参数。这种情况下，使用类型参数作为类型的声明都允许为null，尽管类型参数T并没有用问号结尾。</p><p>例子：</p><pre><code class="kotlin">/*    处理可空的类型参数    */fun &lt;T&gt; printHashCode(t:T){    println(t?.hashCode())    //因为”T“ 可能为null，所以必须使用安全调用}&gt;&gt;&gt; printHashCode(null)    //”T“被推导为”Any?“null</code></pre><p>在printHashCode调用中，类型参数T推导出的类型是可空类型Any?。    因此，尽管没有用问号结尾，实参t依然允许持有null。</p><p><strong>要使类型参数非空（不为空）必须要为它指定一个非空的上界，那样泛型就会拒绝可空值作为实参。</strong></p><pre><code class="kotlin">/*    为类型参数声明非空三界    */fun &lt;T:Any&gt; printHashCode(t:T){    //现在”T“就不是可空的    println(t.hashCode())}&gt;&gt;&gt; printHashCode(null)    //这段代码是无法编译的：你不能传递null，因为期望值是非空值。Error:Type paramater bound for &#39;T&#39; is not asthisfied&gt;&gt;&gt; printHashCode(42)42</code></pre><p>注意必须使用问号结尾来标记类型为可空的，没有问号就是非空的。类型参数是这个规则唯一的例外。（在使用三界后，想使用可空类型就要加问号来标记可空。）</p><h3 id="6-1-11-可空性和Java"><a href="#6-1-11-可空性和Java" class="headerlink" title="6.1.11 可空性和Java"></a>6.1.11 可空性和Java</h3><p>Kotlin 引以为傲的是和Java的互操作性，而你知道Java类型系统是不支持可空性的。在你混合使用Kotlin和Java时会发生什么？会不会失去所有的安全性？或者每个值都必须检查是否为null？</p><blockquote><p>有些时候Java代码包含了可空性的信息，这些信息用注解来表达。</p><p><strong>当代码中出现了这些信息时，Kotlin就会使用。因此Java中@Nullable string 被Kotlin当作String?(可空类型)，而@NotNull String就是String(不为空类型)</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210419170543.png" alt="根据Java类型识别的注解，Java类型回在Kotlin中表示为可空类型和非空类型"></p><p>Kotlin 可以识别多种不同风格的可空性注解，包括JSR-305标准的注解（在javax.annotation包之中）、Android的注解（android.support.annotation包之中）和JetBrains工具支持的注解（org.jetbrains.annotation）。</p><p><strong>如果这些注解不存在会发生什么？</strong></p><p><strong>Java 类型会变成Kotlin中的平台类型</strong></p><p><strong>平台类型</strong></p><blockquote><p><strong>平台类型本质上就是Kotlin不知道可空性信息的类型</strong>。<strong>即可以把它当作可空类型处理，也可以当作会空类型处理</strong>。</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210420145256.png" alt="Java类型在Kotlin中表示为平台类型，既可以把它当作可空类型也可以当作会空类型来处理"></p><blockquote><p>这意味着，你要像在Java中意义，对你在这个类型上做的操作负全部责任。编译器将会允许所有的操作，它不会把对这些字的空安全操作高亮多余的，但它平时确实这样对待会空类型值上的空安全操作。<strong>如果你认为这个字为null，在使用它之前可以用它和null进行比较。如果你认位它不为null，就直接使用它。就像在Java中一样，如果你错误地理解了这个值，使用的时候就会遇到NullPointerException。</strong></p></blockquote><p><strong>例子</strong></p><pre><code class="java">/*    没有可空性注解的Java类    */public class Person{    private final String name;    public Person(String name){        this.name = name    }    public String getName(){        return name    }}</code></pre><blockquote><p>getName能不能返回null?这种情况下Kotlin编译器完全不知道String类型的可空性，所以你必须处理它。<strong>如果你确定name不为null，就可以像Java中一样按照通常的方式对它解引用，不需要额外的检查。但是这种情况下请准备好接受异常。</strong></p></blockquote><pre><code class="kotlin">/*    不使用null检查访问Java类    */fun yellAt(person:Person){    println(person.name.toUpperCase()+ &quot;!!!&quot; )    //toUpperCase()调用的函数接收者person.name为null，所以这里会抛出异常}&gt;&gt;&gt; yellAt(Person(null))java.lang.IllegalArgumentException:Paramater specified as non-null is null: method toUpperCase, parameter $receiver</code></pre><blockquote><p>注意，这里你看到的不是一个NullPointerException，而是一条更详细的错误信息，告诉你方法toUpperCase不能在null的接收者上调用。</p><p><strong>对于公有的Kotlin函数，编译器生成对每个非空类型的参数（和接收者）的检查和，所以使用不正确的参数的调用尝试都立即被报告为异常。（在使用参数前会检查非空的参数。）</strong></p><p>这种值检查在函数调用的时候就执行，而不是等到这些参数被使用的时候。这确保了不正确的调用会被尽早的发现，那些由于null值被传给代码不同层次的多个函数之后，并被这些函数访问时而产生的难以理解的异常就能被避免。</p></blockquote><p>把getName()的返回类型解释为可空的并安全的访问它。</p><pre><code>/*    使用null检查来访问的Java类    */fun yellAtSafe(person:Person){    println((person.name?:&quot;Anyone&quot;).toUpperCase()+&quot;!!!&quot;)}&gt;&gt;&gt; yellAtSafe(null)ANYONE!!!</code></pre><blockquote><p>Java API 中大部分库没有（可空性）注解，所以可以把所有类型都解释为非空，但是会导致错误。为了避免错误，你应该阅读Java方法的文档（必要时还要查看它的实现），并知道它上面时候返回null，并给那些返回加上检查。</p><blockquote><p>为什么需要平台类型？</p><p>对 Kotlin 来说，把来自Java的所有值都当成可空的是不是更安全？这种设计也许可行，但是这需要对永远不为空的值做大量冗余的null检查，因为Kotlin编译器无法了解到这样的信息。</p><p>涉及泛型的话这种新款就更加糟糕了。例如，在Kotlin中，每次来自Java的ArrayList<String>都被当作ArrayList&lt;String?&gt;?，每次访问或者转换类型都需要检查这些值是否为null，这样抵消掉安全性带来的好处。编写这样的检查非常令人厌烦，所以Kotlin的设计者做出了更实用的选择，让开发者负责正确处理来自Java的值</p></blockquote></blockquote><p>在<strong>Kotiln中不能声明一个平台类型（不知道可空信息的）的变量</strong>，这些信息只能来自Java代码，但你可能会在IDE的错误信息中见到它们。</p><pre><code class="kotlin">&gt;&gt;&gt; val i:Ine = person.nameERROR:Type mismatch: inferred type is String! but Int was expected</code></pre><blockquote><p>String! 表示法被Kotlin编译器用来表示来自<strong>Java代码的平台类型</strong>。你不能在自己的代码中使用这种语法。而且感叹号通常与问题的来源无关，所以通常可以忽略它。<strong>这只是在强调类型的可空性是未知的。</strong></p></blockquote><p><strong>你可以用你喜欢的方式来解释平台类型，既可以是可控的也可以是非空的。</strong></p><pre><code class="kotlin">&gt;&gt;&gt; val s:String?=person.name    //可空&gt;&gt;&gt; val s1:String = person.name    //非空</code></pre><p><strong>如果你用来自Java的null值给一个非空的Kotlin变量赋值，在赋值的瞬间你就会得到异常。</strong>你需要正确的理解可空性。</p><p><strong>继承</strong></p><p>Kotlin 重写Java的方法时，<strong>可以选择把参数和返回类型定义成可空的，也可以选择把它们定义成非空的。</strong></p><p><strong>例子</strong></p><pre><code class="java">/*    Java中的StringProcessor接口    */interfece StringProcessor{    void process(String value);}</code></pre><p>Kotlin 中下面的两种实现编译器都可以接收。</p><pre><code class="kotlin">/*    实现Java接口时使用不同的参数可空性    */class StringPrinter:StringProcessor{    override fun process(value:String){        pritlin(value)    }}class NullableStringPrinter:StringProcessor{    override fun process(value:String?){    // 参数可空        if(value != null){            println(value)        }    }}</code></pre><blockquote><p>在实现Java类或者接口的方法时一定要搞清楚它的可空性。<strong>因为方法实现可在非Kotlin的代码中被调用，Kotlin编译器会为你声明的每个非空的参数生成非空断言。</strong>如果Java代码传给这个方法一个null值，断言就会触发，你就会得到一个异常，即便你从来没有在你的实现中访问过这个参数的值。</p></blockquote><h2 id="6-2-基本数据类型和其他基本类型"><a href="#6-2-基本数据类型和其他基本类型" class="headerlink" title="6.2 基本数据类型和其他基本类型"></a>6.2 基本数据类型和其他基本类型</h2><p>描述程序中的基本数据类型，例如Int、Boolean和Any。</p><p>与Java不同，Kotlin并不区分基本数据类型和它们的包装类。</p><h3 id="6-2-1-基本数据类型：Int、Boolean及其他"><a href="#6-2-1-基本数据类型：Int、Boolean及其他" class="headerlink" title="6.2.1 基本数据类型：Int、Boolean及其他"></a>6.2.1 基本数据类型：Int、Boolean及其他</h3><blockquote><p><strong>Java把基本数据类型和引用类型做了区分。</strong></p><p>一个基本数据类型（如int）的变量直接存储了它的值，而一个引用类型（如String）的变量存储的时指向包含该对象的内存地址的引用。</p></blockquote><blockquote><p>基本数据类型的只能够更高效地存储和传递，但你不能对这些值调用方法，或是它们存放在集合中。</p><p><strong>Java提供了特殊的包装类型（比如java.lang.Integer),在你需要对象的是否对基本数据类型进行封装。因此，你不能用Collection<int>来定义一个整数的集合，而必须用Collection<integer>来定义。</strong></p></blockquote><blockquote><p><strong>Kotlin 并不区分基本数据类型和包装类型，</strong>永远是同一个类型（比如int）</p><pre><code class="kotlin">val i:Int = 1val list:List&lt;Int&gt; = listOf(1,2,3)</code></pre><p>同时还能对数字类型的值调用方法。</p><pre><code class="kotlin">/*    使用标准库的函数coerceIn来把值限制在特定范围内    */fun showProgress(progress:Int){    val percent = progress.coerceIn(0,100)    println(&quot;We&#39;re ${percent}% done!&quot;)}&gt;&gt;&gt; showProgress(146)We&#39;re 100% done!</code></pre><p>虽然没有区分基本数据类型和包装类型，但是这不意味着Kotlin使用对象来表示所有数组！</p><p><strong>在运行时，数字类型会尽可能地使用最高效的方式来表示。大多数形况下——对于变量、属性、参数和返回类型——Kotlin的Int类型会被编译成Java基本类型int。唯一不可行的例外是泛型类，例如集合。用作泛型参数的基本数据类型会被编译成对应的包装类。例如，Int类被用作集合类型的类型参数时，集合类将会保存对应包换类型java.lang.Integer的实例。</strong></p></blockquote><p><strong>Java基本数据类型完整列表</strong></p><ul><li>整数类型——Byte、Short、Int、Long</li><li>浮点整数类型——Float、Double</li><li>字符类型——Char</li><li>布尔类型——Boolean</li></ul><p><strong>就像Int 这样的Kotlin类型在底层可以轻易的编译成对应的Java基本类型，因为两种类型都不能存储null引用。当你在Kotlin中使用Java声明时，Java基本数据类型就会变成非空类型（而不是平台类型），因为它们不能持有null值。</strong></p><h3 id="6-2-2-可空基本数据类型：Int-、Boolean？及其他"><a href="#6-2-2-可空基本数据类型：Int-、Boolean？及其他" class="headerlink" title="6.2.2 可空基本数据类型：Int?、Boolean？及其他"></a>6.2.2 可空基本数据类型：Int?、Boolean？及其他</h3><blockquote><p>Kotlin中的可空类型不能用Java的基本数据类型表示，因为null只能被存储在Java的引用类型的变量中。这意味着任何时候使用了基本数据类型的可空版本，它就会被编译成对应的包装类。</p></blockquote><pre><code class="kotlin">/*    名字永远已知的Person类，但是年龄可能未知或者未指定。添加函数检查一个人是否比另一个人年长    */class Person(val name:String,val age:Int ?= null){        fun isOlderThan(other:Person):Boolean?{            if(age == null ||other.age == null)                return null            return age &gt; other.age        }}&gt;&gt;&gt; println(Person(&quot;Sam&quot;,35).isOlderThan(Person(&quot;Amy&quot;,42)))false&gt;&gt;&gt; println(Person(&quot;Sam&quot;,34).isOlderThan(Person(&quot;Jane&quot;)))null</code></pre><p><strong>注意，普通的可空性规则如何在这里引用。</strong>你不能就这样比较两个值，因为它们当中任何一个都可能为null。你必须检查两个值都不为null。</p><p>Person类声明的age属性的值被当作java.lang.Integer存储（包装类）。但是只有在你使用来自Java的类时这些细节才有意义。为了在Kotlin中选出正确的类型，你只需要考虑对变量或者属性来说，null是否是它们可能的值。</p><p><strong>泛型类（ArrayList<Integer>)是包装类型应用的另一种情况。如果你用基本数据类型作为泛型类的参数类型，那么Kotlin会使用该类型的包装形式（Int ==&gt; Integer）</strong></p><p>创建一个Integer包装类的列表，<strong>尽管没有指定过可空类型或者用过null值</strong></p><pre><code class="kotlin">val listOfInts = listOf(1,2,3)</code></pre><p>这是由Java虚拟机实现泛型的方式决定的。JVM不支持用基本数据类型作为类型参数，所以泛型类（Java和Kotlin一样）必须始终使用类型的包装表示。<strong>因此，你要高效的存储基本数据类型元素的大型集合，要么使用支持这种集合的第三方库（如Trove4J）要么使用数组来存储。</strong></p><h3 id="6-2-3-数字转换"><a href="#6-2-3-数字转换" class="headerlink" title="6.2.3 数字转换"></a>6.2.3 数字转换</h3><p>Kotlin和Java<strong>之间一条重要的区别就是处理数字转换的方式。</strong>Kotlin不会自动的把数字从一种类型转换成另一种，即便是转换范围更大的类型。</p><pre><code class="kotlin">val i = 1val i : Long = i    //错误：类型不匹配</code></pre><p>正确的转换</p><pre><code class="kotlin">val i = 1val l:Long = i.toLang()</code></pre><blockquote><p>基本数据类型类型（Boolean除外）都定义有转换函数：toByte()、toShort()、toChar()等。这些函数支持双向转换：既可以把 小范围的类型扩展到大范围，比如Int.toLong(),也可以把大范围的类型截取到小范围，比如Long.toInt()。</p><p>Kotlin 要求转换必须是显式的，尤其是在比较<strong>装箱值</strong>的时候。比较两个装箱值的equals方法不仅会检查它们存储的值，还会比较装箱类型。所以，在Java中new Integer(42).equals(new Long(42)) 会返回false。</p><blockquote><p>Java中的装箱和拆箱</p><p><strong>装箱和拆箱是从Java1.5开始引入的，它的目的是将原始类型值自动地转换成对应的对象。</strong>自动装箱机制可以让我们在Java的变量赋值或者其他方法调用等情况下使用原始类型或者对象类型更加简单直接。</p></blockquote></blockquote><p>假如 Kotlin 支持隐式转换，</p><pre><code class="kotlin">val x = 1    // Int变量val list = listOf(1L,2L,3L)    //Long值列表x in list //假如支持隐式转换它仍然是 false</code></pre><blockquote><p>因此，上列中 x in list 根本不会编译。Kotlin要求你显式的转换类型，这样只有类型相同的值才比较：</p><pre><code class="kotlin">&gt;&gt;&gt; val x = 1&gt;&gt;&gt; println(x.toLong() in listOf(1L,2L,3L))true</code></pre><p>在代码中用到不同的数据类型，你必须显式的转换这些变量，来避免意想不到的结果。</p></blockquote><blockquote><p><strong>基本数据类型字面值</strong></p><ul><li>使用后戳L表示Long类型(长整型)字面值:123L.</li><li>使用标准浮点数表示Double(双浮点精度)字面值:0.12、2.0、1.2e10、1.2e-10。</li><li>使用F表示Float类型（浮点数）字面值：123.4f、.345F、1e3f。</li><li>使用前戳0x或者0X表示十六进制字面值：0xCAFEBABE或者0xbcdL。</li><li>使用前戳0b或者0B表示二进制字面值：0b000000101.</li></ul><p>在Kotlin1.1才开始支持数字字面值中的下划线。对字符字面值来说，可以使用和Java几乎一样的语法。把字符卸载单引号中，必要时还可以使用转义序列。有效的Kotlin字符字面值：‘1’、‘/t’（制表符）、‘\u0009’（使用Unicode转义序列表示的制表符）。</p></blockquote><blockquote><p>当你在书写数字字面值的时候，一般不需要使用转换函数。这种（字面值）特殊的语法来显示地标记常量类型，例如42L或者42.0f。即使你没有使用这种语法，数字字面值去初始化一个类型已知的变量是（Ine 类型已知，初始化为Long），又或是把字面值当作实参传递给函数时，必要的转换会自动发生。  算数运算符也会被重载，它们可以接收所有适当的数字类型。</p><pre><code class="kotlin">/*    如下的代码并没有任何显式的转换却可以正常工作过    */fun foo(l:Long) = println(l)&gt;&gt;&gt; val b:Byte = 1    //常量有正确的类型&gt;&gt;&gt; val l = b+1L    //+可以进行直接类型和长整型参数的计算&gt;&gt;&gt; foo(42)    // 编译器认为42是一个长整型42</code></pre><blockquote><p>Koylin算术运算符关于数值范围溢出的行为和Java完全一直；Kotlin并没有引入由溢出检查带来的额外开销。</p></blockquote></blockquote><p><strong>字符串转换</strong></p><blockquote><p>Kotlin 标准库提供了一套相似的扩展方法，用来把字符串转换成基本数据类型（toInt、toByte、toBoolean、等）。</p><pre><code class="kotlin">&gt;&gt;&gt; println(&quot;42&quot;.toInt())42</code></pre><p>函数会尝试把字符串的内容解析成对应的函数，如果解析失败抛出NumberFormatException。</p></blockquote><h3 id="6-2-4-“Any”和“Ant？”：根类型"><a href="#6-2-4-“Any”和“Ant？”：根类型" class="headerlink" title="6.2.4 “Any”和“Ant？”：根类型"></a>6.2.4 “Any”和“Ant？”：根类型</h3><blockquote><p><strong>和Ojbect作为Java类层级结构的根差不多，Any类型是Kotlin所有非空类型的超类型（非空类型的根）。</strong>而在Java中，Object只是所有应用类型的超类型（引用类型的的根），而基本数据类型并不是类层级结构的一部分。这意味着当你需要Object的时候，不得不使用java.long.Integer这样的包装类型来表示基本数据类型的值。<strong>而在Kotlin中，Any是所有类型的超类型（所有类型的根），包括像Int这样的基本数据类型。</strong></p></blockquote><p>基本数据类型的值赋给Any类型的变量时会自动装箱：</p><pre><code class="kotlin">val answer:Any = 42    \\Any是引用类型，所以值42会被装箱</code></pre><p><strong>Any是非空类型，所以Any类型的变量不可以持有null值。Kotlin中想要持有任何可能的变量，包括null在内，必须使用Any?类型。</strong></p><blockquote><p>在底层，Any类型对应java.lang.Object。Kotlin把Java方法参数和返回类型中用到的Object类型看作Any（更确切的说是当作平台类型，因为其可空性是位置的）。当Kotlin函数使用Any时，它会被编译成Java字节码中的Object。</p></blockquote><h3 id="6-2-5-Unit-类型：Kotlin的“void”"><a href="#6-2-5-Unit-类型：Kotlin的“void”" class="headerlink" title="6.2.5 Unit 类型：Kotlin的“void”"></a>6.2.5 Unit 类型：Kotlin的“void”</h3><p><strong>Kotlin中的Unit类型和Java中void是一样的功能</strong>。在函数没有什么需要返回的时候，Unit可以用作函数的返回类型：</p><pre><code class="kotlin">fun f(): Unit{...}fun f(){...}    //省略Unit声明</code></pre><p>两个代码块的结果是相同的。</p><p>大多数情况下你不会留意到void和Unit之间的区别。<strong>如果你的Kotlin函数使用Unit作为返回类型并且没有重写泛型函数，在底层它会被编译成旧的void函数。如果你要在Java中重写这个函数，新的Java函数需要返回void。</strong></p><p><strong>Kotlin中的Unit和Java中的void到底有那些不同？</strong></p><blockquote><p>Unit是一个完整的类型，可以作为类型参数，而void却不行。只存在值是Unit类型，这个值也叫Unit，并且会被隐式地返回。当你在重写返回泛型参数的函数</p><p>时会非常有用只需要让方法返回Unit类型的值：</p><pre><code class="kotlin">interface Processor&lt;T&gt;{    fun process():T}class NoResultProcessor:Processor&lt;Unit&gt;{    override fun process(){    // 返回 Unit ，这里可以省略类型说明        // do stuff    }    // 这里不需要显式的return}</code></pre><p>接口签名要求process函数返回一个值；而且，因为Unit类型确实有值，所以从方法中返回它并没有问题。然而你不需要在NoResultProcessor.process函数中写上显式的return语句，因为编译器会隐式地加上return Unit.</p></blockquote><p>在与Java对比中，Java中为了解决使用“没有值”作为类型参数的任何一个可能解法，都没有Kotlin好用。一种是分开接口定义来表示需要和不需要返回值的接口（如Callable和Runnable）。另一种使用特殊的java.lang.Void类型作为类型参数。即便你使用了后面这种方法，你还是需要加入return null；语句来返回唯一能匹配这个类型的值，因为只要返回类型不是void，你就必须始终有显式的return语句。</p><p>在函数式编程语言中，Unit这个名字习惯上被用来表示“只有一个实例”，这正是Kotlin和Java的void的区别。</p><h3 id="6-2-6-Nothing类型：“这个函数永不返回”"><a href="#6-2-6-Nothing类型：“这个函数永不返回”" class="headerlink" title="6.2.6 Nothing类型：“这个函数永不返回”"></a>6.2.6 Nothing类型：“这个函数永不返回”</h3><p><strong>解释了为什么要创建Nothing类型</strong></p><blockquote><p>对于某些Kotlin函数来说，“返回类型的概念没有任何意义，因为它从来不会成功地结束。例如，许多测试库都有一个叫fail的函数，它通过抛出带有特定信息的异常来让当前测试失败。一个包含无限循环的函数也永远不会成功地结束。</p></blockquote><p>分析调用函数代码时，知道函数永远不会正常结束是很有帮助的。Kotlin 使用Nothing这种特殊的返回类型来表示:</p><pre><code class="kotlin">fun fail(message:String):Nothing{    throw IllegalStateException(message)}&gt;&gt;&gt; fail(&quot;Error occurred&quot;)java.lang.IllegalStateException:Error occurred</code></pre><p>Nothing 类型没有任何值，只有被当作函数返回值使用，或者被当作泛型函数返回值的类型参数使用才会有意义。在其他情况下，声明一个不能存储任何值的变量是没有意义的。</p><p>Nothing函数可以放在Elvis运算符的右边来做先决条件检查：</p><pre><code class="kotlin">val address = company.address?:fail(&quot;No address&quot;)println(address.city)</code></pre><p><strong>编译器知道这种返回类型的函数从不终止，然后在分析调用这些函数的代码时利用这个信息。</strong>上例，编译器会把address的类型推断成非空，因为它为null时的分支处理会始终抛出异常。</p><h2 id="6-3-集合与数组"><a href="#6-3-集合与数组" class="headerlink" title="6.3 集合与数组"></a>6.3 集合与数组</h2><p>Kotlin以Java集合库为基础构建，并通过扩展函数增加的特性来增强它。</p><h3 id="6-3-1-可空性和集合"><a href="#6-3-1-可空性和集合" class="headerlink" title="6.3.1 可空性和集合"></a>6.3.1 可空性和集合</h3><p>我们讨论了可空类型的概念，但仅仅简略的谈到类型参数的可空性。对前后一致的类型系统来说十分关键<strong>：知道集合是否可以持有null元素，和知道变量值是否可以为null同等重要。Kotlin完全支持类型参数的可空性。就像变量的类型可以加上？字符来表示变量可以持有null一样，类型在被当作类型参数时也可以用同样的方式标记。</strong></p><p>这个函数从一个文件中读取文本行的列表，并尝试把每一行文本解析成数字。</p><pre><code class="kotlin">/*    创建一个可以包含可空值的集合    */fun readNumbers(reader: BufferedReader): List&lt;Int?&gt;{    var result = ArratList&lt;Int?&gt;()    //创建包含可空Int值的列表    for (line in reader.lineSequence()){        try{            val number = line.toInt()            result.add(number)    // 向列表中添加整数（非空）        }        catch(e: NumberFormatException){            result.add(null)    //向列表添加 null，因为当前行不能被解析成整数。        }    }    return result}</code></pre><blockquote><p><strong>如果这一行文本被解析，那么就向result列表中添加一个整数，否则添加null。List&lt;Int?&gt;是能持有Int?类型值的列表：换句话说，可以持有Int或者null。（集合中可以存放null值）。从Kotlin1.1中，可以使用函数String.toIntOrNull来简化例子，字符串不能被解析的时候会返回null。</strong></p></blockquote><p><strong>变量自己的可空性</strong>和用<strong>作类型参数的类型的可空性是有区别的。</strong>包含<strong>可空Int</strong>的列表和<strong>包含Int的可空列表</strong>之间是有区别的。如下：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210426224838.png" alt="要小心决定什么是可空的：集合的元素还是集合本身？"></p><p>第一种情况，列表本身始终不为null，列表中的每个值都可以为null。第二种类型的变量可能包含空引用而不是列表实例，<strong>但列表中的元素始终保持非空的。</strong></p><p>在另一种上下文中，<strong>你可能需要声明一个持有可空的列表，并且包含可空的数字。</strong>Kotlin中的写法是List&lt;Int?&gt;?，有两个问号。在使用变量自己值的时候，<strong>以及使用列表中每个元素的时候，需要使用null检查。（因为内容可能为空，所以在使用时需要做null检查）</strong></p><p><strong>如何使用可空值的列表，</strong>如下函数计算列表中有效数字之和，并单独的对无效数字计数。</p><pre><code class="kotlin">/*    使用可空值集合    */fun addValidNumbers(numbers:List&lt;Int?&gt;){    var sumOfValidNumbers = 0    var invalidNumbers = 0    for (number in numbers){    //从列表中读取可空值        if (number != null){    //检查值是否为null            sumOfValidNumbers +=number        }else {            invalidNumbers++        }    }    println(&quot;Sum of valid numbers: $sumOfValidNumbers&quot;)    println(&quot;Invalid numbers: $invalidNumbers&quot;)} &gt;&gt;&gt; val reader = BufferedReader(StringReader(&quot;1\nabc\n42&quot;)) &gt;&gt;&gt; val numbers = readNumber(reader) &gt;&gt;&gt; addValidNumbers(numbers) Sum of valid numbers: 43 Invalid numbers:1</code></pre><p>当你访问一个列表中的元素时，你得到的是一个类型为Int?的值，并且要在用它进行算数运算之前检查它是否为null。</p><p><strong>Kotlin 提供了标准库函数filterNotNull函数，用来遍历一个包含可空值的集合并过滤掉null的操作。</strong></p><pre><code class="kotlin">fun addValidNumbers(numbers:List&lt;Int?&gt;){    val validNumbers = numbers.filterNotNull()    println(&quot;Sum of valid numbers:${validNumbers.sum()}&quot;)    println(&quot;Invalid numbers:${numbers.size - validNUmbers.size}&quot;)}</code></pre><p>过滤影响了集合的类型。validNumbers的类型是List<Int>，因此过滤保证了集合不会再包含任何为null的元素。</p><h3 id="6-3-2-只读集合与可变集合"><a href="#6-3-2-只读集合与可变集合" class="headerlink" title="6.3.2 只读集合与可变集合"></a>6.3.2 只读集合与可变集合</h3><p><strong>集合分为两种：只读集合和可变集合</strong></p><p>Kotlin 的集合设计和Java不同的另一个重要特质是，<strong>它把访问集合数据的接口和修改集合数据的接口分开了。</strong>这种区别存在于最基础的使用集合之中：kotlin.collection.Collection。使用这个接口，可以遍历集合中的元素、获得集合的大小、判断集合中是否包含某个元素，以及执行其他从集合中读取数据的操作。<strong>但这个接口没有任何添加或移除元素的返回</strong>。</p><p><strong>使用kotlin.collection.MutableCollection接口可以修改接口中的数据。</strong>它继承了普通的kotlin.collections.Collection接口，并提供了方法来添加和移除、清空集合等。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210510115136.png" alt="MutableCollection继承了Collection并增加了修改集合内容的方法。"></p><p>通常规则是在代码的任何地方都应该使用只读接口，只在代码需要修改集合的地方使用可变接口的变体。</p><p>就像 val 和 var 之间的分离一样，只读集合接口和可变集合接口的分离能让程序中的数据发生的事情更容易理解。如果函数接收Collection而不是MutableCollection作为形参，你就知道它不会修改集合，而只是读取集合中的数据。如果函数要求你传递给它MutableCollection，可以认为它将会修改数据。如果你使用了集合作为组件部状态的一部分，可能需要把集合先拷贝一份传递给这个函数（这种模式通常称为 <strong>防御式拷贝</strong>）。</p><pre><code class="kotlin">/*    使用只读集合接口与可变集合接口    */fun &lt;T&gt; copyElemets(source: Collection&lt;T&gt;,                    target: MutableCollection&lt;T&gt;){    for (item in source){    // 在source集合中的所有元素中循环        target.add(item)    // 向可变的target集合中添加元素    }}&gt;&gt;&gt; val source:Collection&lt;Int&gt; = arrayListOf(3,5,7)&gt;&gt;&gt; val target:MutableCollection&lt;Int&gt; = arratListOf(1)&gt;&gt;&gt; copyElements(source,target)&gt;&gt;&gt; println(target)[1,3,5,7]</code></pre><p><strong>只读集合类型不能作为可变集合的参数。</strong>不能把只读集合类型的变量作为target参数传给函数，即便它的值是一个可变集合：</p><pre><code class="kotlin">&gt;&gt;&gt; val source:Collection&lt;Int&gt; = arrayListOf(3,5,7)&gt;&gt;&gt; val target:Collection&lt;Int&gt; = arratListOf(1)&gt;&gt;&gt; copyElements(source,target)Error: Type mismatch:inferred type is Collection&lt;Int&gt;    but MutableCollection&lt;Int&gt; was expected</code></pre><p>使用集合接口时需要牢记的关键点是 <strong>只读集合是不一定可变的。</strong>如果你使用的变量只有一个只读接口类型，它可能只是同一个集合的众多引用中的一个。任何其他的引用都可能拥有一个可变接口类型。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210516151639.png" alt="两种不同的引用，一个只读，另一个可变，指向同一个集合对象"></p><p>如果你调用了这样的代码，它<strong>持有其他指向你集合的引用</strong>，或者并行的运行了这样的代码。你依然会遇到这种状况，你正在使用集合的时候它被其他代码修改了，则会导致concurrentModificationException错误和其他一些问题。因此，<strong>必须了解只读集合并不总是线程安全的。如果你在多线程环境下处理数据，你需要保证代码正确的同步的对数据的访问，或者使用支持并发访问的数据结构。</strong></p><h3 id="6-3-3-Kotlin集合和Java"><a href="#6-3-3-Kotlin集合和Java" class="headerlink" title="6.3.3 Kotlin集合和Java"></a>6.3.3 Kotlin集合和Java</h3><p><strong>Kotlin接口是Java接口的实例</strong>。每一个Kotlin接口都是其对应Java集合接口的一个实例。在Kotlin和Java之间转移并不需要转换；不需要包装器也不需要拷贝数据。但每个Kotlin中都有两种表示：一种是只读一种是可变的。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210516154303.png" alt="Kotlin集合接口的层级结构，Java类ArrayList和HashSet都继承了Kotlin可变接口"></p><p>Kotlin中只读接口和可变接口的基本构造与 Java.util中的Java集合接口的构造是平行的。可变接口直接对应java.util中的接口，而它们的只读版本缺少了所有产生改变的方法。</p><p>Kotlin中Map类（并没有继承Collection或是Interable）也被表示成了两种不同的版本：Map和MutableMap。表中展示了不同集合的函数。</p><table><thead><tr><th>集合类型</th><th>只读</th><th>可变</th></tr></thead><tbody><tr><td><strong>List</strong></td><td>listOf</td><td>mutableListOf、arrayListOf</td></tr><tr><td><strong>Set</strong></td><td>setOf</td><td>mutableSet、hashSetOf、linkedSetOf、sortedSetOf</td></tr><tr><td><strong>Map</strong></td><td>mapOf</td><td>mutableMapOf、hashMapOf、linkedMapOf、sortedMapOf</td></tr></tbody></table><p><strong>注意，setOf()和mapOf()返回的是Java标准库中类的实例（至少在Kotlin1.0版本中是这样），在底层它们都是可变的。但你不能完全信赖这一点：Kotlin的未来版本可能会使用真正不可变的实现类作为setOf和mapOf的返回值。</strong></p><p><strong>当你需要调用Java方法并把集合作为参数时。例如：使用java.util.Collection做为形参，你可以使用Collection或MutableCollection（只读集合或可变集合）的值作为实参传递给形参。</strong></p><p><strong>这时的操作对可变性有重要影响。因为Java并不会区分只读集合与可变集合，即使Kotlin中把集合声明成只读的，Java代码也可以修改这个集合。Kotlin编译器不能完全的分析Java代码到底对集合做了什么，因此Kotlin无法拒绝向可以修改集合的Java代码传递只读Colleciton。</strong>例如，如下代码组成了一个多语言兼容的Kotlin/Java程序：</p><pre><code class="java">/*    Java    *///    ColletionUtils.Javapublic class ColletionUtils{    public static List&lt;String&gt; uppercaseAll(List&lt;String&gt; items){        for(int i = 0 ;i &lt; items.size(); i++){            items.set(i,items.get(i).toUpperCase());        }        return items    }}</code></pre><pre><code class="kotlin">/*    Kotlin    */// collections.ktfun printInUppercase(list:List&lt;String&gt;){    // 声明只读的参数    println(CollectionUtils.uppercaseAll(list))    //调用可以修改集合的Java函数    println(list.first())    //打印被修改过的集合}&gt;&gt;&gt; val list = listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)&gt;&gt;&gt; printInUpppercase(list)[A,B,C]A</code></pre><p><strong>如果你写了Kotlin函数，使用集合并传递给了Java，这时你要确认使用了正确的参数类型，同时取决于你调用的Java代码是否会修改集合。</strong></p><p>注意，<strong>这些也适用于包含非空类型元素的集合类。</strong>如果你向Java方法传递了这样的集合，该方法就可能在其中写入null值；Kotlin没有办法再不影响性能的情况下，禁止它的发生，或者察觉到已经发生的改变。因此，当你向可以修改集合的Java代码传递集合的时，你需要采取特别的预防措施，来确保Kotlin类型正确的反映出集合上所有可能的修改。</p><h3 id="6-3-4-作为平台类型的集合"><a href="#6-3-4-作为平台类型的集合" class="headerlink" title="6.3.4 作为平台类型的集合"></a>6.3.4 作为平台类型的集合</h3><p><strong>Kotlin集合作为平台类型的集合</strong></p><p><strong>平台类型不会理会可空或者非空，所以在Kotlin重写或实现平台类型时需要选择集合是否可空。</strong></p><p><strong>Kotlin 把定义在java代码中的类型看成平台类型。</strong>Kotlin没有任何关于平台类型的可空性信息，所以编译器允许Kotlin代码将其视为可空或者非空的。同样，Java中声明的集合类型的变量也被视为平台类型。<strong>一个平台类型集合本质上就是可变性未知的集合——Kotlin代码将其视为只读的或者可变的。</strong>实际上你想要执行的所有操作都不受影响。</p><p><strong>当你重写或者实现签名中有集合类型的Java方法时这种差异才变的重要。</strong>这里像平台类型的可空性一样，你需要决定使用那种 <strong>Kotlin类型 *<em>来表示这个Java类型， *</em>它来自你要重写或实现的方法。</strong></p><p>在重写或者实现时，你要做出多种选择，<strong>它们都会反映在产生的Kotlin代码类型中:</strong></p><ul><li>集合是否可空？</li><li>集合的元素是否可空？</li><li>你的方法会不会修改集合？</li></ul><p>代码中直观的表示。一个Java接口表示一个能处理文件中的文本对象。</p><pre><code class="java">/*    使用集合参数的Java接口    */interface FileContentProcessor{    void processContents(File path,        byte[] binaryContents,        List&lt;String&gt; textContents);}</code></pre><p>这个接口的Kotlin实现需要做出如下选择：</p><ul><li>列表将是可空的，因为有些文件是二进制格式，它们的内容不能被表示成文本。</li><li>列表中的元素将会是非空的，因为文件中每一行都永远不为null。</li><li>列表将是可读的，因为它表示的文本内容，而且这些内容不会被修改。</li></ul><p>实现的样子</p><pre><code class="kotlin">/*    FileContentProcessor 的Kotlin实现    */class FileIndexer:FileContentProcessor{    override fun processContents(path:File,        binaryContents:ByteArray?,        textContents:List&lt;String&gt;?){            ....        }}</code></pre><p>与另一个接口对比。这里接口的实现从文本表单中解析出的数据并放大一个对象列表中，再把这些对象附加到输出列表中。当发现解析失败时，就把错误信息添加到另一个单独的列表中，作为错误日志。</p><pre><code class="java">/*    另一个集合参数的Java接口    Java*/interface DataParser&lt;T&gt;{    void parseData(String input,        List&lt;T&gt; output,        List&lt;String&gt; errors);}</code></pre><p>这种情况下的选择：</p><ul><li>List<String> 将是非空的，因为调用者总是需要接收错误的信息。</li><li>列表的元素将是可空的，因为不是每个输出列表中的条目都有关联的错误信息。</li><li>List<String> 将是可变的，因为代码实现需要向其中添加元素。</li></ul><p>实现这个接口</p><pre><code class="kotlin">/*    DataParser的Kotlin实现    */class PersonParser: DataParser&lt;Person&gt;{    override fun parseData(input:String,        output:MutableList&lt;Person&gt;,        error:MutableList&lt;String?&gt;){            //...        }}</code></pre><p>注意，同样为Java类型——List<String>——如何表示成了两种不同的Kotlin类型：一种是List<String>?（包含字符串的可空列表），另一个是MutableList&lt;String?&gt;（包含可空字符串的可变列表）。你必须知道Java接口或类必须遵守的确切契约。基于你的实现要做的事情通常很容易理解。</p><h3 id="6-3-5-对象和基本数据类型的数组"><a href="#6-3-5-对象和基本数据类型的数组" class="headerlink" title="6.3.5 对象和基本数据类型的数组"></a>6.3.5 对象和基本数据类型的数组</h3><p>默认情况下，你应该优先使用集合而不是数组。但是因为有大量JavaAPI仍然在使用数组，所以来介绍它们在Kotlin中如何使用。</p><p>Kotlin 数组的语法出现在了每个例子中， <strong>因为数组是 Java main 函数标准签名的一部分。</strong></p><blockquote><p>方法签名：</p><p>方法签名由方法名+形参列表组成，目的是让此方法确定为唯一的。</p></blockquote><pre><code class="kotlin">/*    使用数组    */fun main(args:Array[String]){    for (i in args.indices){    // 使扩展属性array.indeces在下标的访问内迭代        pritnl(&quot;Argument $i is :${args[i]}&quot;)    //通过下标使用 array[index] 访问元素    }}</code></pre><p> Kotlin中的数组是一个带有类型参数的类，其元素类型被指定为相应的类型参数。</p><p><strong>要在Kotlin中创建数组，如下方法供你选择</strong></p><blockquote><ul><li>arrayOf函数创建数组，它包含元素是指定为该函数的实参。</li><li>arrayOfNulls创建一个给定大小的数组，包含为null元素。当然，它只能用来创建包含元素类型的可空数组。</li><li>Array构造方法接收数组大小和一个lambda表达式，使用lambda表达式来创建每一个数组元素。这就是使用元素类型来初始化数组，当不用显式地传递每个元素的方式。</li></ul></blockquote><p>展示如何使用Array函数来创建“a”到”z”的字符串数组。</p><pre><code class="kotlin">/*    创建字符数组    */&gt;&gt;&gt; val letters = Array&lt;String&gt;(26){i-&gt;(&#39;a&#39;+i).toString()}&gt;&gt;&gt; pritnln(letters.joinToString(&quot;&quot;))abcdefghijklmnoprstuvwxyz</code></pre><p>为了清楚起见，这里显示了数组元素的类型，但在真实的代码中可以省略。因为编译器会推导出它的类型。</p><blockquote><p>Kotlin <strong>代码中最常见的创建数组的情况之一是需要调用参数为数组的Java方法</strong>，或是在调用带有vararg参数的Kotlin函数时。这种情况下，通常已经将数据存储在集合中，只需要将其转换为数组即可。可以使用toTypedArray方法来执行此操作。</p><pre><code class="kotlin">/*    向vararg方法传递集合    */&gt;&gt;&gt; val string = listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)&gt;&gt;&gt; pritnln(&quot;%s/%s/%s&quot;.format(*strings.toTypedArray()))    // 期望vararg参数时使用展开运算符(*)传递数组a/b/c</code></pre></blockquote><blockquote><p>数组类型的类型参数始终会变成对象类型。<strong>因此，如果你声明了一个Array<Int>,它将会是一个包含装箱整型的数组（它的Java类型将是java.lang.Integer[])。如果你需要创建没有装箱的基本数据类型的数组，必须使用一个基本数据类型数组的特殊类。</strong></p></blockquote><p>为表示基本数据类型的数组，Kotlin提供了若干独立的类，每一个基本数据类型都对应一个。例如，Int类型值的数组叫做IntArray。</p><p>要创建一个基本数据类型的数组，你有如下选择：</p><ul><li><strong>该类型的构造方法接收size参数并返回一个使用对应基本数据类型默认值（通常是0）初始化好滴数组。</strong></li><li><strong>工厂函数（IntArray的intArrayOf，以及其他数组类型的函数）接收边长参数的值并创建存储这些的数组。</strong></li><li><strong>另一个构造方法，接受一个大小和一个用来初始化元素的lambda</strong></li></ul><p>例子</p><pre><code class="kotlin">/*    下面创建存储了5个0的整形数组的两种选择    */&gt;&gt;&gt; val fiveZeros = IntArray(5)    //默认值 0&gt;&gt;&gt; val fiveZerosToo = intArrayOf(0,0,0,0,0)</code></pre><pre><code class="kotlin">/*    下面接收lambda的构造方法的例子    */&gt;&gt;&gt; val squares = IntArray(5){i-&gt;(i+1)*(i+1)}&gt;&gt;&gt; println(squares.joinToString())1,4,9,16,25</code></pre><blockquote><p><strong>假如你有一个持有基本数据类型装箱后的值的数组或者集合，</strong>可以使用对应的转换函数把它们转换成基本数据类型的数组，例如toIntArray。</p></blockquote><blockquote><p><strong>我们来看看你可是对数组做的事情。</strong>处理基本操作外（获得数组长度，获取或者设置元素），Kotlin标准库支持一套和集合相同的用于数组的扩展函数。其中（filter，map等）也适用于数组，包括基本数据类型的数组（注意这些返回值返回的是列表不是数组）。</p><pre><code class="kotlin">/*    使用forEachIndexed函数加上lambda来重写”使用数组“例子    */fun main(args:Array&lt;String&gt;){    atgs.forEachIndexed{index,elemnt -&gt;        println(&quot;Argument $index is: $element&quot;)}}</code></pre></blockquote><h3 id="6-4-小结"><a href="#6-4-小结" class="headerlink" title="6.4 小结"></a>6.4 小结</h3><ul><li></li></ul><h1 id="8-高阶函数：Lambda作为形参和返回值"><a href="#8-高阶函数：Lambda作为形参和返回值" class="headerlink" title="8 高阶函数：Lambda作为形参和返回值"></a>8 高阶函数：Lambda作为形参和返回值</h1><p><strong>内联函数作用</strong></p><p>能够消除lambda带来的性能开销，还能够使lambda内的控制流更加灵活。</p><h2 id="8-1-声明高阶函数"><a href="#8-1-声明高阶函数" class="headerlink" title="8.1 声明高阶函数"></a>8.1 声明高阶函数</h2><p>定义</p><blockquote><p>高阶函数就是以另一个函数作为参数或者返回值的函数。在kotlin中，函数可以用lambda或者函数引用来表示。因此，<strong>任何以lambda或者函数引用作为参数的函数，或者返回值为lambda或函数引用的函数</strong>，或者两者都有满足的函数都是高阶函数。</p></blockquote><p>标准库中的filter函数将一个判断式函数作为参数，因此它是一个高阶函数：</p><pre><code class="kotlin">list.filter{x&gt;0}</code></pre><h3 id="8-1-1-函数类型"><a href="#8-1-1-函数类型" class="headerlink" title="8.1.1 函数类型"></a>8.1.1 函数类型</h3><p>在变量中我们有<strong>Int类型</strong>，<strong>String类型</strong>等那么也有属于函数的<strong>函数类型</strong>。</p><p>声明一个lambda作为实参的函数，你需要知道如何声明对应形参的类型。在那之前，看接下来的例子，把 lambda 表达式保存在局部变量中。在不声明类型的情况下，这些就依赖于Kotlin的类型推导。</p><pre><code class="kotlin">val sum = {x:Int,y:Int -&gt; x+y}val action = {println(42)}</code></pre><p>编译器推导出sum和action两个变量具有<strong>函数类型</strong>。</p><p>显式声明<strong>函数类型的变量</strong></p><pre><code class="kotlin">val sum:(Int ,Int) -&gt; Int = {x,y-&gt;x+y}    // 有两个Int类型参数和Int类型返回值val action:() - &gt; Unit = { println(42) }    //没有参数和返回值</code></pre><p>声明函数类型，需要将函数参数类型放在括号中，紧接着是一个箭头和函数的返回值类型。</p><pre><code class="kotlin">(Int,String) -&gt; Unit// ↑参数类型    ↑返回类型</code></pre><p>在声明函数类型时Unit是不能省略的，其他情况下可以。</p><p>函数类型的返回值标记为可空类型：</p><pre><code class="kotlin">val canReturnNull: (Int,Int) -&gt; Int?={null}</code></pre><p>定义函数类型的可空变量。</p><blockquote><p>为了明确表示是变量本身可空，而不是函数类型的返回类型可空，你需要将整个函数类型的定义包含在括号内并在括号后添加问号。</p><pre><code class="kotlin">val funOrNull:((Int,Int) -&gt; Int) ?= null</code></pre></blockquote><h3 id="8-1-2-调用作为参数的函数"><a href="#8-1-2-调用作为参数的函数" class="headerlink" title="8.1.2 调用作为参数的函数"></a>8.1.2 调用作为参数的函数</h3><p>实现一个高阶函数。</p><p>实现2，3两个数字的任意操作。</p><blockquote><p>函数类型作为参数，形参和实参更像是接口，形参是接口实参则用来具体的实现。</p></blockquote><p>定义一个简单的高阶函数</p><pre><code class="kotlin">//    定义一个函数类型的参数fun twoAndThree(operation: (Int,Int) -&gt; Int){    val result = opration(2,3)    // 调用参数（函数类型）    println(&quot;The result is $result&quot;)}&gt;&gt;&gt; twoAndThree{a,b -&gt; a+b}The result is 5&gt;&gt;&gt; twoAndThree(a,b -&gt; a*b)The result is 6</code></pre><p>实现最常用的标准库函数：filter函数。为了更让事情更简单一些，将实现基于String类型的filter函数，但和作用于泛型的版本原理是显示的。</p><pre><code class="kotlin">/* &quot;String&quot;:接收者类型。    “predicate”：参数类型    “(Char) -&gt; Boolean”：函数类型参数    “Char”:函数类型参数的参数类型    “Boolean”：函数类型的参数返回类型    */fun String.filter(predicate:(Char) -&gt; Boolean):String</code></pre><blockquote><p>filter 函数的声明，以一个判断式作为参数</p></blockquote><p>判断式的类型是一个函数，以字符作为参数并返回boolean类型的值。如果要让传递给判断式的字符出现在最终返回的字符串中，判断式需要返回ture，反之false。</p><pre><code class="kotlin">//    实现一个简单版本的filer函数fun String.filter(predicate: (Char) -&gt; Boolean):String{    val sb = StringBuilder()    for (index in 0 until length){        val element = get(index)        if (predicate(element)) sb.append(element)    // 调用引用的String类型参数给predicate函数进行判断    }    return sb.toString()}&gt;&gt;&gt; println(&quot;ab1c&quot;.filter{it in &#39;a&#39;..&#39;z&#39;})    //传递 lambda 作为 &#39;predicate&#39;参数abc</code></pre><blockquote><p>filter 函数的实现非常简单明了。它检查每个字符时候满足判断式，如果满足就将字符添加到包含结果的StringBuilder中。</p></blockquote><h3 id="8-1-3-在Java中使用函数类"><a href="#8-1-3-在Java中使用函数类" class="headerlink" title="8.1.3 在Java中使用函数类"></a>8.1.3 在Java中使用函数类</h3><p><strong>原理</strong></p><blockquote><p>函数类型被声明为普通的接口：一个函数类型的变量是<strong>FunctionN接口的实现</strong>。</p><p>Kotlin 标准库定义了一系列的接口，这些接口对应于不同的参数数量的函数：<strong>Function0<R>(没有参数的函数)、Function&lt;P1,R&gt;(一个参数的函数)</strong>。</p><p>每个接口定义了一个 invoke 方法，调用这个方法就会执行函数。</p><p>一个函数类型的变量就是实现了对应的Function接口的实现类的实力，实现类的invoke方法包含了lambda函数体。</p></blockquote><p><strong>在 Java 中调用使用了函数类型的 Kotlin 函数。</strong></p><pre><code class="kotlin">/*    kotlin声明    */fun processTheAnswer(f:(Int) -&gt;){    println(f(42))}</code></pre><pre><code class="kotlin">/*    Java    */&gt;&gt;&gt; processTheAnswe(number -&gt; number+1);43</code></pre><p>在旧版 Java 中，可以传递一个实现了函数接口中 invoke 方法的匿名类的实例：</p><pre><code class="java">/*    Java    */&gt;&gt;&gt; processTheAnswer(...        new Function1&lt;Integer,Integer&gt;(){    // 在Java 8 以前使用函数类型...            @Override...            public Integer invoke(Integer number){...                System.out.println(number);...                return number+1;...                }...        });43</code></pre><p>在 Java 中使用函数类型必须显示地传递一个接收者对象作为第一个参数。</p><p>在Java中可以很容易地使用 Kotlin 标准库中以lambda作为参数的扩展函数。</p><pre><code class="java">/*    Java    */&gt;&gt;&gt; List&lt;String&gt; strings = new ArrayList()；&gt;&gt;&gt; strings.add(&quot;42&quot;)&gt;&gt;&gt; CollectionKt.forEach(strings, s -&gt;{    //可以在Java中使用Kotlin标准库中的函数...        System.out.println(a);...        return unit.INSTANCE;    // 必须显示的返回一个Unit类型的值。...})</code></pre><blockquote><p>在 Java 中 ，函数或许lambda可以返回Unit。因为在 Kotlin 中 Unit 类型是有值的，所以需要显示的返回它。</p><p>一个返回 void 的lambda 不能作为返回 Unit 的函数类型的实参，就像之前的例子中的(String) -&gt;Unit.</p></blockquote><h3 id="8-1-4-函数类型的参数默认值和null值"><a href="#8-1-4-函数类型的参数默认值和null值" class="headerlink" title="8.1.4 函数类型的参数默认值和null值"></a>8.1.4 函数类型的参数默认值和null值</h3><p>声明函数类型的参数时可以指定参数的默认值。</p><p><strong>用来理解参数默认值的关键作用</strong></p><pre><code class="kotlin">/*    使用了硬编码toString转换的joinToString函数    */fun &lt;T&gt; Collection&lt;T&gt;.joinToString(        separator: String = &quot;,&quot;,        prefix: String = &quot;&quot;,        postfix: String = &quot;&quot;): String{        val result = StringBuilder(prefix)        for ((index,element) in this.withIndex()){            if(index &gt;0) result.append(separator)            result.append(element)    // 使用默认toString方法将对象转换成字符串        }        result.append(postfix)        return result.toString()}</code></pre><blockquote><p>这里的实现很灵活但是并没有让你控制转换的关键点： 集合中的原始是如何转换成字符串的。</p></blockquote><blockquote><p>这里使用 StringBuilder.append(o:Any?) (result.append(element)),他总是使用toString方法将对象转换成字符串。在大多数情况下这样是可以的，但是不总是这样。</p></blockquote><blockquote><p>现在可以传递一个lambda去指定如何将对象转换成字符串。</p></blockquote><blockquote><p>但是要求所有调用者都传递lambda是比较烦人的，因为大部分调用者使用默认的行为就可以了。为了解决这个问题，可以定义一个函数类型的参数并用一个lambda作为它的默认值。</p></blockquote><pre><code class="kotlin">/*    给函数类型的参数指定默认值    */fun &lt;T&gt; Collection&lt;T&gt;.joinToString(        separator: String = &quot;,&quot;,        prefix: String = &quot;&quot;,        postfix: String = &quot;&quot;,        transform: (T) -&gt; String = {it.toString()}    //声明一个lambda为默认值的函数类型的参数): String {        val result = StringBuilder(prefix)        for ((index,element) in this.withIndex()){            if(index &gt; 0 ) result.append(separator)            result.append(transform(element))    // 调用作为实参的element传递给 “transform”形参的函数        }        result.append(postfix)        return result.toString()}&gt;&gt;&gt; val letters = listOf(&quot;Alpha&quot;,&quot;Beta&quot;)&gt;&gt;&gt;  println(letters.joinToString())    // 使用默认的转换函数Alpha, Beta&gt;&gt;&gt; println(letters.joinToString{it.toLowerCase()})    // 传递一个 lambda 作为参数alpha,beta&gt;&gt;&gt; println(letters.joinToString(separator = &quot;!&quot;,postifx = &quot;!&quot;, transform = {it.ToUpperCase()}))    // 使用命名参数参数语法几个参数，包括lambda。ALPHA,BETA</code></pre><blockquote><p>这个带默认值的函数类型是一个泛型参数T表示集合中的元素类型。 Lambda transform 将接收这个类型的参数。</p></blockquote><blockquote><p>声明函数类型的默认值并不需要特殊的语法，只需要把 lambda 作为值放在 = 号后。上述例子展示了多种方式调用函数类型。</p></blockquote><p><strong>声明函数类型其参数是可空的</strong></p><pre><code class="kotlin">/*    案例1    一般情况*/fun foo(callback: (() -&gt;Unit)?){    if(callback != null){        callback()    }}</code></pre><blockquote><p>这里不能直接调用作为参数传递进行的函数：Kotlin 会因为检查到潜在的空指针异常而导致编译失败。<strong>这里可选的办法是显式地检查null</strong>。</p></blockquote><pre><code class="kotlin">/*    使用函数类型的可空参数    */fun &lt;T&gt; Collection&lt;T&gt;.joinToString(        separator: String = &quot;,&quot;,        prefix: String = &quot;&quot;,        postfix: String = &quot;&quot;,        transform:    ((T) -&gt; String ) ?=null    // 声明一个函数类型的可空参数): String{    val result = StringBuilder(prefix)    for ((index,element) in this.withIndex()){        if (index &gt; 0) result.append(separator)        val str = transform?.invoke(element)    // 使用安全调用语法，调用函数            ?: element.toString()    //使用 Elvis 运算符处理回调没有被指定的情况        result.append(str)    }    result.append(postfix)    return result.toString()}</code></pre><blockquote><p>这是一个更简单的版本，它利用了一个事实 ，函数类型是包含 invoke 方法的接口具体实现。作为一个普通方法，invoke可以通过安全调用语法被调用：callback?.invoke()方法</p></blockquote><h3 id="8-1-5-返回函数的函数"><a href="#8-1-5-返回函数的函数" class="headerlink" title="8.1.5 返回函数的函数"></a>8.1.5 返回函数的函数</h3><pre><code class="kotlin">/*    定义一个返回函数的函数    */enum class Delivery {STANDARD, EXPEDITED}class Order(val itemCount:Int)fun getShippingCostCalculator(delivery:Delivery):(Order)-&gt;Double{    // 声明返回函数的函数    if (delivery == Delivery.EXPEDITEM){    // 返回 lambda        return {order -&gt; 6+2.1 * order.itemCount}    }    return {order -&gt;1.2*order.itemCount}}&gt;&gt;&gt; val calculator = getShippingCostCalculator(Delivery.EXPEDITEM)    // 将返回的函数保存在变量中&gt;&gt;&gt; println(&quot;Shapping costs ${calculator(Order(3))}&quot;)    // 调用返回的函数Shipping costs 12.3</code></pre><blockquote><p><strong>使用场景</strong></p><p>例如，运输费用的计算依赖于选择恰当的逻辑变体并将它作为另一个函数返回。<strong>声明一个 返回另一个函数的函数，需要指定一个函数类型作为返回类型。</strong></p><p>函数 getShippingCostCalculator返回一个函数，这个函数以Order最为参数并返回一个Double类型的值。</p><p><strong>要返回一个函数，需要写一个return表达式，跟上一个lambda、一个成员引用，或者其他的函数类型的表达式，比如一个函数的局部变量。</strong></p></blockquote><p><strong>另一个返回函数的例子</strong></p><blockquote><p>例如，你可以在 UI 上输入一个字符串，然后只显示那些名字以这个字符串开头的联系人；还可以隐藏没有电话号码的联系人。用ContactListFilters这个类来保存这个选项的状态。</p></blockquote><pre><code class="kotlin">class ContactListFilters{    var prefix: String = &quot;&quot;    var onlyWithPhoneNumber: Boolean = false}</code></pre><blockquote><p>当用户输入 D 来查看姓或者名以 D 开头的联系人时，prefix的值会被更新。</p></blockquote><pre><code class="kotlin">/*    在UI代码中定义一个返回函数的函数    */data class Persion(    val firstName:String,    val lastName:String,    val phoneNumber:String?)class ContactListFilters{    val prefix:String = &quot;&quot;    val onlyWithPhoneNumber: Boolean = false    fun getPredicate():(Person) -&gt; Boolean{    //声明一个返回函数的函数        val    startWithPrefix  = {p:Persion -&gt; p.firstName.startsWith(prefix) || p.lastName.startsWith(prefix)        }        if (!onlyWithPhoneNumber){            return startWithPrefix    // 返回一个函数类型的变量        }        return { startsWithPrefix(it)&amp;&amp;it.phoneNumber != null }    //从函数返回一个lambda    }}&gt;&gt;&gt; val contacts = listOf(Persion(&quot;Dmitry&quot;,&quot;Jemeroy&quot;,&quot;123-4567&quot;),...                          Persion(&quot;Svetlane&quot;,&quot;Isakova&quot;,null))&gt;&gt;&gt; val contactListFilters = ContactListFilters()&gt;&gt;&gt; with (contactListFilters){&gt;&gt;&gt;        prefix = &quot;Dm&quot;&gt;&gt;&gt;     onlyWithPhoneNumber = true&gt;&gt;&gt; }&gt;&gt;&gt; println(contacts.filter(...        contactListFilters.getPredicate()))        // 将 getPredicate 返回的函数作为参数传递给 “filter” 函数[Persion (firstName = Dmitry,lastName = Jemetov,phoneNumber = 123-4567)]</code></pre><blockquote><p>为了让展示联系人列表的逻辑代码和输入的过滤条件的UI条件解耦，可以定义一个函数来创建一个判断式，用来过滤联系人列表。判断式检查前戳，如果有需要也检查电话号码时候存在。</p></blockquote><blockquote><p>getPredicate 函数返回一个函数（类型）的值，这个值被传递给filter作为参数。</p></blockquote><h3 id="8-1-6-通过lambda-去除重复代码"><a href="#8-1-6-通过lambda-去除重复代码" class="headerlink" title="8.1.6 通过lambda 去除重复代码"></a>8.1.6 通过lambda 去除重复代码</h3><p>例子</p><blockquote><p>这是一个分析网站访问的例子。SiteVisit类用来保存每次访问的路径、持续时间和用户的操作系统。不同的操作系统使用枚举来表示。</p></blockquote><pre><code class="kotlin">/*    定义站点访问数据    */data calss SiteVisit(    val path: String,    val dutation: Double,    val os: OS    )enum class OS{ WINDOWS,LINUX,MAC,IOS,ANDROID}val log = listOf(    SiteVisit(&quot;/&quot;,34.0,OS.WINDOWS),    SiteVisit(&quot;/&quot;,22.0,OS.MAC),    SiteVisit(&quot;/login&quot;,12.0,OS.WINDOWS),    SiteVisit(&quot;/signup&quot;,8.0,OS.IOS),    SiteVisit(&quot;/&quot;,16.3.OS.ANDROID))</code></pre><blockquote><p>需要显示来自 Windows 的平均访问时间，可以使用 average 函数来完成这个任务。</p></blockquote><pre><code class="kotlin">/*    使用硬编码的过滤器分析站点访问数据    */val averageWindowsDutation = log    .filter {it.os == OS.WINDOWS}    .map(SiteVisit::dutation)    .avaerage()&gt;&gt;&gt;println(averageWindowsDutaion)23.0</code></pre><blockquote><p>显示来自于Windows机器的平均访问时间，用 average 函数来完成任务。</p></blockquote><pre><code class="kotlin">/*    使用普通的方法去除重复代码    */fun List&lt;SiteVisit&gt;.averageDurationFor(os:OS) = filter{it.os == os}.map(SiteVisit::dutation).average()    // 将重复代码抽取到函数中&gt;&gt;&gt; println(log.averageDurationFor(OS.WINDOWS))23.0&gt;&gt;&gt; println(log.averageDurationFor(OS.MAC))22.0</code></pre><blockquote><p>现在你要计算一个来自MAC用户的相同数据，为了避免重复，可以将平台类型抽象成一个参数.</p><p>注意这个函数作为扩展函数增强了可读性。如果它值在局部的上下文中有用，你甚至可以将这个函数声明为局部的扩展函数。</p></blockquote><pre><code class="kotlin">/*    用一个重复的硬编码函数分析站点访问数据    */val averageMobileDutation = log    .filter{it.os == setOf(OS.IOS,OS.ANDROID)}    .map(SiteVisit::duration)    .average()&gt;&gt;&gt; println(averageMobileDuration)12.15</code></pre><blockquote><p>如果你对移动平台的访问的平均时间感兴趣。</p><p>这时已经不能再再用简单的参数表示不同的平台了。可能还需要使用更加复杂的条件查询日志，比如，“来自IOS平台对注册页面的访问平均时间是多少？”</p><p><strong>可以使用函数类型将需要的条件抽象到一个参数中</strong></p></blockquote><pre><code class="kotlin">/*    用高阶函数去除重复代码    */fun List&lt;SiteVisit&gt;.averageDutationFor(predicate:(SiteVisit) -&gt; Boolean) = filter(predicate).map(SiteVisit::duration).average()&gt;&gt;&gt; println(log.averageDurationFor{...        it.os in setOf(OS.ANDROID,OS.IOS)})12.15&gt;&gt;&gt; println(log.averageDurationFor{...        it.os == OS.IOS &amp;&amp; it.path == &quot;/signup&quot;    // 满足系统为IOS，访问地址为 注册界面的条件})8.0</code></pre><blockquote><p>函数类型可以帮助去除重复代码。使用lambda，不仅可以去除重复的数据，也可以去除重复的行为。</p></blockquote><h2 id="8-2-内联函数：消除lambda带来的运行时开销"><a href="#8-2-内联函数：消除lambda带来的运行时开销" class="headerlink" title="8.2 内联函数：消除lambda带来的运行时开销"></a>8.2 内联函数：消除lambda带来的运行时开销</h2><blockquote><p>Kotlin 中传递 lambda 作为函数参数的简明语法与普通的表达式语法很相似。</p><p><strong>lambda 表达式会被正常地编译成匿名类。这表示每调用一次 lambda 表达式，就会额外的创建一个类。并且如果 lambda 捕捉了某个变量，那么每次调用的时候都会创建一个新的对象。这会带来运行时的额外开销，导致使用 lambda 比使用一个直接执行相同代码的函数效率更低。</strong></p><p>有没有可能让编译器生成跟 Java 语句相同高效的代码，但还是能把重复的逻辑抽取到库函数中呢？（作用）</p><p>如果使用 <strong>inline</strong> 修饰符标记一个函数，在函数被使用的时候编译器并不会生成函数调用的代码，而是使用函数实现的真实代码替换每一次的函数调用。</p></blockquote><p><strong>内联函数简介</strong></p><blockquote><p>在<a href="https://baike.baidu.com/item/计算机科学" target="_blank" rel="noopener">计算机科学</a>中，<strong>内联函数</strong>（有时称作<strong>在线函数</strong>或<strong>编译时期展开函数</strong>）是一种<a href="https://baike.baidu.com/item/编程语言" target="_blank" rel="noopener">编程语言</a>结构，用来建议<a href="https://baike.baidu.com/item/编译器" target="_blank" rel="noopener">编译器</a>对一些特殊<a href="https://baike.baidu.com/item/函数" target="_blank" rel="noopener">函数</a>进行内联扩展（有时称作<strong>在线扩展</strong>）；也就是说建议编译器将指定的函数体插入并取代每一处调用该函数的地方（<a href="https://baike.baidu.com/item/上下文" target="_blank" rel="noopener">上下文</a>），从而节省了每次调用函数带来的额外时间开支。但在选择使用内联函数时，必须在程序占用空间和程序执行效率之间进行权衡，因为过多的比较复杂的函数进行内联扩展将带来很大的存储资源开支。另外还需要特别注意的是对<a href="https://baike.baidu.com/item/递归函数" target="_blank" rel="noopener">递归函数</a>的内联扩展可能引起部分编译器的无穷编译。</p></blockquote><h3 id="8-2-1-内联函数如何运作"><a href="#8-2-1-内联函数如何运作" class="headerlink" title="8.2.1 内联函数如何运作"></a>8.2.1 内联函数如何运作</h3><blockquote><p><strong>内联函数！</strong></p><p>当一个函数被声明为 inline 时，它的函数体是内联的–换句话说，函数体会被直接替换到函数被调用的地方，而不是被正常调用。</p></blockquote><pre><code class="kotlin">/*    定义一个内联函数    */inline fun &lt;T&gt; sysnchronized(lock:Lock,action : () -&gt; T):T{    lock.lock()    try{        return action()    }    finally    {        lock.unlock()    }}val l = Lock()synchronized(1){    //...}</code></pre><blockquote><p>函数用于确保一个共享资源不会并发地被多个线程访问。函数锁住一个Lock对象，执行代码块。</p></blockquote><blockquote><p>调用这个函数的语法跟Java中使用 synchronized 语法完全一直。<strong>区别</strong>，Java 的 synchronized 语法可以用于<strong>任何对象</strong>，这个函数则要求传入一个Lock实例。</p><p>同时，Kotlin 标准库中定义了一个可以接受<strong>任何对象</strong>作为参数的 synchronized 函数版本。</p><p>这里使用同步操作时显式的对象锁能够提升代码的可读性和维护性。</p></blockquote><blockquote><p><strong>使用 inline 的效果！</strong></p><p>因为已经将 synchronized 函数声明为 inline，所以每次调用它所生成的代码跟 Java 的synchronized 语句都是一样的。</p></blockquote><p><strong>使用 synchronized 的例子。</strong></p><pre><code class="kotlin">fun foo(l:Lock){    println(&quot;Before sync&quot;)    synchronized(1){        println(&quot;Action&quot;)    //内联函数    }    println(&quot;After sync&quot;)}</code></pre><pre><code class="kotlin">/*    编译后的 foo 函数    */fun _foo_(l:Lock){    println(&quot;Before sync&quot;)    //这是调用者 foo 的代码    l.lock()    // 这是被内联的 synchronized 函数代码    try(        println(&quot;Action&quot;)    //被内联的lmabda题代码    )finally{        l.unlock()        //这是调用者 foo 的代码    }    println(&quot;After sync&quot;)    //这是调用者 foo 的代码}</code></pre><blockquote><p>展示的是作用相同的代码，将会被编译成同样的字节码。</p></blockquote><blockquote><p>这里 lambda 表达式 和 synchronized 函数实现了内联。</p><p>由于lambda 生成的字节码成为了函数调用这定义的部分，而不是被包含在一个实现了函数接口的匿名类中</p></blockquote><pre><code class="kotlin">/*    调用内联函数的时候可以传递函数类型的变量作为参数    */class LockOwner(val lock:Lock){    fun runUnderLock(body:() -&gt; Unit){        synchronized(lock,body)    //作为函数类型的变量作为参数，而不是lambda    }}</code></pre><blockquote><p>使用函数类型的变量作为参数，不会被内联。</p></blockquote><blockquote><p>只有synchronized 函数体被内联了，lambda 才会被正确调用。</p></blockquote><pre><code>/*    runUnderLock 的函数字节码    */class LockOwner(val lock:Lock){    fun runUnderLock(body:() -&gt; Unit){    //函数类似于真正的runUnberLock被编译成的字节码        lock.lock()        try{            body() // body 没有被内联，因为在调用到地方换没有 lambda        }finally{            lock.unlock()        }    }}</code></pre><h3 id="8-2-2-内联函数的限制"><a href="#8-2-2-内联函数的限制" class="headerlink" title="8.2.2 内联函数的限制"></a>8.2.2 内联函数的限制</h3><blockquote><p>鉴于内联的运作方式，不是所有使用lambda的函数都可以被内联的。</p></blockquote><blockquote><p>当函数被内联的时候，作为参数的lambda表达式函数体会被直接替换成最终生成的代码中。这会限制函数体中对应的（lambda）参数使用。如果（lambda）参数被调用，这样的代码能被容易的内联。<strong>但是如果（lambda）参数在某个地方被保存起来，一遍后边可以继续使用，lambda表达式的代码将不能被内联，因为必须要有一个包含这些代码的对象存在。</strong></p></blockquote><blockquote><p>一般来说，参数如果被直接调用或者作为参数传递给另外一个inline函数，它是可以被内联的。否则，编译器会禁止参数被内联并给出错误信息“Illeal usage of inline-parameter”</p></blockquote><blockquote><p>例如，许多作用域序列的函数会返回一些类的实例，这些类代表对应的序列操作并接受lambda作为构造参数。 这是 Sequence.map函数的定义：</p></blockquote><pre><code class="kotlin">fun &lt;T,R&gt; Sequence&lt;T&gt;.map(transform:(T) -&gt; R):Sequence&lt;R&gt;{    return TransformingSequence(this,transform)}</code></pre><blockquote><p>map 函数没有直接调用作为 transform参数传递进来的函数。而是将这个函数传递给类的构造方法，构造方法将它保存在一个属性中。</p><p>这时为了支持这一点，作为transform参数传递的lambda需要被编译成标准的非内联的表达式，即实现了一个函数接口的匿名类。</p></blockquote><blockquote><p> 当函数期望两个或多个 lambda 参数，可以选择只内联其中一些参数。这是有道理的，因为一个lambda可能会包含很多代码或者不允许内联的方式使用。接受这样的非内联lambda的参数，可以用 noinline 修饰符来标记它：</p><pre><code class="kotlin">inline fun foo(inlined:() -&gt; Unit,noinlune notInlined:() -&gt; Unit){    //...}</code></pre></blockquote><h3 id="8-2-3-内联集合操作"><a href="#8-2-3-内联集合操作" class="headerlink" title="8.2.3 内联集合操作"></a>8.2.3 内联集合操作</h3><p>Kotlin 标准库中操作集合函数的性能。大部分标准库中的集合函数都带有lambda参数。<strong>不管使用标准库函数，还是直接实现这些操作效率都是一样的。</strong></p><p>我们来比较一下。</p><pre><code class="kotlin">/*    使用lambda过滤一个集合    */data class Person(val name:String,val age:Int)val people = listOf(Persion(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31))&gt;&gt;&gt; println(people.filter(it.age&lt;30))[Person(name = Alice,age = 29)]</code></pre><pre><code class="kotlin">/*    手动过滤一个集合 不用lambda表达式来实现*/&gt;&gt;&gt; val result = mutableListOf&lt;Person&gt;()&gt;&gt;&gt; for (person in people){&gt;&gt;&gt;         if(person.age &lt; 30) result.add(person)&gt;&gt;&gt;}&gt;&gt;&gt; println(result)[Person(name = &quot;Alice&quot;, age = 29)]</code></pre><blockquote><p>Kotlin 对内联函数的支持让你不必担心性能问题。</p></blockquote><blockquote><p>在Kotlin中，filter 函数被声明为内联函数。这意味着 filter 函数，以及传递给它的lambda的字节码会被一起内联到filter被调用的地方。最终，第一种实现所产生的字节码和第二种实现所产生的字节码大致是一样的。你可以很安全地使用符合语言习惯的集合操作。</p></blockquote><blockquote><p>现象你在连续使用 filter 和 map 两个操作。</p><pre><code class="kotlin">&gt;&gt;&gt; println(people.filter{it.age &gt; 30}...                .map (Persion::name))[Bob]</code></pre><p><strong>这个例子使用了 lambda 表达式和一个成员引用。</strong></p><p>这里 filter 和 map 都被声明为了 inline 函数，所以他们的函数体会被内联，因此不会产生额外的类和对象。上述的代码却创建了一个中间集合来把偶出来列表过滤的结果，由 filter 函数生成的代码会向这个集合种添加元素，而由 map 函数生成的代码会读取这个几个。</p><p><strong>如果有大量的元素需要处理，中间集合的运行开销将成为不可忽视的问题，这时可以在调用链后加上一个asSequence调用，用序列代替集合。</strong></p><p>同时如同上一节看到的一样，用于处理序列的 lambda 不能够被内联，每个中间序列被表示成lambda保存在其字段中的对象，<strong>而末端操作会导致由每个中间序列调用组成的链被执行</strong>。因此，即便序列上的操作是惰性的，你不应该总是试图在集合操作的链后<strong>asSequence</strong>。只有在处理大量数据时有用，小的集合可以用普通集合处理。</p></blockquote><h3 id="8-2-4-决定何时将函数声明成内联"><a href="#8-2-4-决定何时将函数声明成内联" class="headerlink" title="8.2.4 决定何时将函数声明成内联"></a>8.2.4 决定何时将函数声明成内联</h3><p>使用 inline 关键词只能提高 lambda 参数的函数性能，其他情况需要额外的度量和研究。</p><p><strong>将带有 lambda 参数的函数内联能够带来什么好处。</strong></p><blockquote><p>首先， 通过内联避免运行时开销更加明显了。毕竟节约了函数运行时的开销，而且节约了 lambda 创建匿名类，以及创建 lambda 实例对象的开销。其次，JVM 还没有聪明到总是能将函数调用内联。内联可以使用一些不可能被普通 lambda 使用的特征，比如非局部返回。</p></blockquote><p><strong>注意</strong></p><blockquote><p><strong>在使用 inline 关键字的时候，你还是应该注意代码的长度。如果你要内联的函数不大，将它的字节码拷贝到每一个调用点将会极大地增加字节码的长度。在这种情况下，你应该将那些与 lambda 参数无关的代码抽取到一个独立的非内联函数中。在 Kotlin 中内联函数总是很小的。</strong></p></blockquote><h3 id="8-2-5-使用-内联-lambda-管理资源"><a href="#8-2-5-使用-内联-lambda-管理资源" class="headerlink" title="8.2.5  使用 内联 lambda 管理资源"></a>8.2.5  使用 内联 lambda 管理资源</h3><p><strong>Lambda 可以去除重复代码的一个常见模式是资源模式</strong></p><blockquote><p>先获取资源，完成一个操作，释放资源。</p><p>这里资源表示多种不同的东西：一个文件、一个锁、一个数据库事务等。</p><p>实现这个模式的标准做法是使用 try/finally 语句。资源在 try 代码块之前被获取，在 finally 代码块中释放。</p></blockquote><p><strong>synchronization</strong></p><blockquote><p>前部分讲到将 try/finally的逻辑封装在一个函数中，然后将使用资源的代码作为 lambda 传递给这个方法。</p><p>synchronization将一个锁对象作为参数。</p></blockquote><p>代替 <strong>synchronization</strong></p><blockquote><p>Kotlin 标准库定义了一个叫 withLock的函数，它提供了实现同样功能的更符合语言习惯的API：它是 Lock 接口的扩展函数。</p><p>如何使用。</p><pre><code class="kotlin">val l:Lock = ...l.withLock{    // access the resource protected by this lock 在加锁的情况下执行指定的操作。}/*    在Kotlin标准库中的定义    */fun &lt;T&gt; Lock.withLock(action : () -&gt; T):T{    //需要加锁的代码被抽取到一个独立的方法中    lock()    try{        return action()    } finally{        unlock()    }}</code></pre></blockquote><p><strong>文件是另一种可以使用这种模式的常见资源类型。（文件使用 资源模式）</strong></p><blockquote><p>Java 7 为这种模式引入了特殊的语法：try-with-resource 语句。</p><pre><code class="kotlin">/*    下述代码来读取文件的第一行Java方法    *//*    在Java中使用try-with-resource语句    */static String readFirstLineFromFile(String path) throws IOException{    try(BufferedReader br = new BufferedReader(new FileReader(path))){        return br.readLine();    }}</code></pre><p>Kotlin 中并没有等价的语法，因为通过使用一个带有函数类型参数的函数可以无缝地完成相同的事情。这个函数叫use()</p><p><strong>使用 use 函数 重写上述代码</strong></p><pre><code class="kotlin">/*    使用use函数作为资源管理    */fun readFirstLineFromFile (path:String):String{    BufferedReader(FileReader(path)).use{    // 构成 BufferedReader，调用 “use” 函数，传递一个lambda执行文件操作        br -&gt; return br.readLine()    // 从函数中返回文件的一行    }}</code></pre><p>use 函数是一个扩展函数，被用来操作可关闭的资源，它接受一个lambda作为参数。这个返回调用lambda并且确保资源被关闭，无论lambda正常执行饭是抛出了异常。当然使用use函数是内联函数，所以使用它并不会引发任何性能开销。</p></blockquote><h2 id="8-3-高阶函数中的控制流"><a href="#8-3-高阶函数中的控制流" class="headerlink" title="8.3 高阶函数中的控制流"></a>8.3 高阶函数中的控制流</h2><p>把 return 语句放在循环的中间是很简单的事情，但是如果将循环转换成一个类似于 <strong>filter （filter 是内联函数）</strong> 的函数呢？这种情况下 return 会如何工作。</p><h3 id="8-3-1-lambda-中的返回语句：从一个封闭的函数返回"><a href="#8-3-1-lambda-中的返回语句：从一个封闭的函数返回" class="headerlink" title="8.3.1 lambda 中的返回语句：从一个封闭的函数返回"></a>8.3.1 lambda 中的返回语句：从一个封闭的函数返回</h3><p>比较两种不同的 遍历集合的返回： 在下面的代码清单中，如果一个人的名字是 “Alice” ，就应该从函数lookForAlice 返回。</p><pre><code class="kotlin">/*    在一个普通循环中使用return    */data class Person(val neme:String, val age:Int)val people = listOf(Person (&quot;Alice&quot;,29),Person(&quot;Bob&quot;,11))fun lookForAlice(people:List&lt;Person&gt;){    for (person in people){        if (person.name == &quot;Alice&quot;){            println(&quot;Found!&quot;)            return        }    }    println(&quot;Alice is not found&quot;)     //如果“people”中没用Alice，这一行就会被打印出来}&gt;&gt;&gt; lookForAlice(people)Found!</code></pre><blockquote><p>使用 forEach迭代重写这段代码安全吗？</p><pre><code class="kotlin">/*    在传递给 forEach 的lambda 中使用 return    */fun lookForAlice(people:List&lt;Person&gt;){    people.forEach{        if (it.name == &quot;Alice&quot;){            println(&quot;Found!&quot;)            return        }    }    println(&quot;Alice is not found&quot;)    //和上一个代码清单中的效果是一样的}</code></pre><p>这是安全的</p></blockquote><blockquote><p>当你在 lambda 中使用 return 关键字，它会从调用 lambda 的函数中返回，并不是从 lambda 中返回。这个叫做<strong>非局部返回</strong>。<strong>因为它从一个比包含 return 的代码块更大的代码块中返回了。</strong></p></blockquote><blockquote><p>为了理解这条规则背后的逻辑，从Java函数中在for循环或者synchronized 代码块中使用 return 关键字。显然这会从函数中返回，而不是从循环或者代码块中返回。使用以 lambda 作为参数的函数的时候 kotlin 保留了同样的行为。</p></blockquote><blockquote><p>需要注意的是，<strong><em>只有在以 lambda 作为参数的函数是内联函数的时候才能从跟外层的函数返回。</em></strong>在上述代码中，forEach 的函数体和lambda的函数体一起被内联了，所以在编译的时候能很容易做到从包含它的函数中返回。在 非内联函数的lambda 中使用 return 表达式是不允许的。一个非内联函数可以把传给它的lambda保存在变量中，以便在函数返回以后可以继续使用，这个时候lambda先去影响函数的返回已经太晚了。</p></blockquote><h3 id="8-3-2-从-lambda-返回：使用标签返回"><a href="#8-3-2-从-lambda-返回：使用标签返回" class="headerlink" title="8.3.2 从 lambda 返回：使用标签返回"></a>8.3.2 从 lambda 返回：使用标签返回</h3><p><strong>标签返回</strong></p><blockquote><p>可以在lambda表达式总使用<strong>局部返回</strong>。</p><p>lambda 中的局部返回跟 for 循环中的 break 表达式显示。它会终止 lambda 的执行，并接着从调用 lambda 的代码处执行。</p></blockquote><p><strong>区分 局部返回和非局部返回</strong></p><blockquote><p>要区分局部返回和非局部返回，要用到<strong>标签</strong>。</p><p><strong>如何区分。</strong></p><p>想从 lambda 表达式处返回你可以标记它，然后在 return 关键字后面引用这个标签。</p></blockquote><pre><code class="kotlin">/*    用一个标签实现局部返回    */fun lookForAlice(people:List&lt;Person&gt;){    people.forEach lable@{    // ←给lambda表达式加上标签        if (it.name == &quot;Alice&quot;) return@label    //← return@label 引用了这个标签    }    println(&quot;Alice might be somewhere&quot;)    //这里总被打印}&gt;&gt;&gt; lookForAlice(people)Alice might be somewhere!</code></pre><blockquote><p><strong>如何使用标签</strong></p><p>要标记一个lambda表达式，在 lambda 的花括号之前放一个标签名，接着放一个 @ 符号。（标签名可以是任意的）、</p><p>要从一个lambda返回，在return关键词后放一个@符号，接着放标签名。</p><pre><code class="kotlin">// “label@” lambda标签people.forEach label@{    if (it.name == &quot;Alice&quot;) return@label //返回表达式标签}/*    用 “@” 符号标记一个标签从一个lambda返回    */</code></pre></blockquote><blockquote><p><strong>另一种方式，使用 lambda 作为参数的函数的函数名可以作为标签</strong></p><pre><code class="kotlin">/*    用函数名 return 标签    */fun lookForAlice(people:List&lt;Person&gt;) {    people.forEach{        if(it.name == &quot;Alice&quot;)    return@forEach    // ←return@forEach从 lambda 表达式返回    }    println(&quot;Alice might be somewhere&quot;)}</code></pre><p>当里显式的<strong>指定了 lambda 表达式的标签</strong>，再使用函数名作为标签没有任何效果。</p><p>一个 lambda 表达式的标签数量不能多于一个。</p></blockquote><blockquote><p><strong>带标签的 “this” 表达式</strong></p><p>同样的规则也适用于this表达式。在带接收者的lambda中–包含一个隐式上下文对象的lamdba也有通过一个this去访问。</p><p>如果你给带接收者 lambda 指定标签，就可以通过对应的带有标签的this表达式访问它的隐式接收者。</p><pre><code class="kotlin">&gt;&gt;&gt; println(StringBuilder().apply sb@{    // 这个 lambda 隐式接收者可以通过 this@sb 访问...        listOf(1,2,3).apply{    // ”this”指定作用域内最近的隐式接收者...            this@sb.append(this.toString())    // 所以隐式接收者都可以被访问，外层的接收者通过显式的标签访问...        }...    })     [1,2,3]</code></pre><p>局部返回的语法相当冗长，如果一个 lambda 包含多个返回语句会变得更加笨重。所以这里可以使用 <strong>匿名函数。</strong></p></blockquote><h1 id="9-泛型"><a href="#9-泛型" class="headerlink" title="9 泛型"></a>9 泛型</h1><p><strong>Kotlin中引入了新的概念，例如实化类型参数和声明点变型。</strong></p><p><strong>实化类型参数允许你在运行时的内联函数调用中引用作为类型实参的具体类型（对普通的类和函数来说，这样行不通，因为类型实参在运行时会被消除）</strong></p><p><strong>声明点变型可以说明一个带类型参数的泛型类型，时候是另一个泛型类型的之类或者超类型，它们的基础类型相同但类型参数不同。</strong>例如它可以调节是否可以把List<Int>类型的参数传给期望List<Any>的函数。<strong>使用点变型在具体使用一个泛型时做同样的事，达到和Java通配符一样的效果。</strong></p><blockquote><p>类型参数：</p><p>在计算机编程语言中，TypeParameter是用于泛型编程的通用标签，用于引用未知的数据类型，数据结构或类。TypeParameter最常用于C ++模板和Java泛型。TypeParameter与元语法变量相似，但有所不同。</p><p>引用：维基百科</p></blockquote><h2 id="9-1-泛型类型参数"><a href="#9-1-泛型类型参数" class="headerlink" title="9.1 泛型类型参数"></a>9.1 泛型类型参数</h2><blockquote><p>泛型允许你定义带类型形参的类型。当这种类型的实例被创建出来的时候，类型形参被替换成称为类型实参的具体类型。</p><p>类型形参：声明定义时的参数，作用域仅本身。</p></blockquote><p><strong>Kotlin编译器能推导出类型实参：</strong></p><pre><code class="kotlin">val authors = listOf(&quot;Dmitry&quot;,&quot;Svetlane&quot;)</code></pre><p>因为传给listOf函数的两个值都是字符串，编译器推导出你正在创建一个List<String>。另一方面，如果你想创建一个空的列表，这样就没有任何可以推导处类型实参的线索，你就得显式指定它（类型形参）。就创建列表来说，即可以选择在变量声明中说明泛型的类型，也可以选择在创建列表的函数中说明类型实参。例子：</p><pre><code class="kotlin">val readers :MutableList&lt;String&gt; = mutableListOf()val reader = mutableListOf&lt;String&gt;()</code></pre><h3 id="9-1-1-泛型函数和属性"><a href="#9-1-1-泛型函数和属性" class="headerlink" title="9.1.1 泛型函数和属性"></a>9.1.1 泛型函数和属性</h3><p>如果你在编写一个使用列表的函数，希望它可以在任何列表上使用，而不是某个具体类型的元素列表，那么编写一个 <strong>泛型函数</strong>。</p><blockquote><p>泛型函数有它自己的类型形参。类型形参在每次函数调用时都必须替换成具体的类型实参。</p></blockquote><p>大部分使用集合的库函数都是泛型的。下面这个函数就返回一个只包含在指定下标区间内的元素。</p><pre><code class="kotlin">fun &lt;T&gt; List&lt;T&gt;.slice(indeces: IntRange):List&lt;T&gt;    //接收者和返回类型使用了类型形参// &lt;T&gt;:类型形参声明</code></pre><p>接收者和返回类型用到了函数的类型形参T，它们的类型都是List<T>。当你在一个具体的列表上调用这个函数时，可以显式地指定类型实参。</p><blockquote><p>多数情况下，编译器会推导出类型。</p></blockquote><pre><code class="kotlin">//调用泛型函数&gt;&gt;&gt; val letter = (&#39;a&#39;..&#39;z&#39;).toList()&gt;&gt;&gt; println(letter.slice&lt;Char&gt;(0..2))    //显式地指定类型实参[a, b, c]&gt;&gt;&gt; println(letter.slice&lt;Char&gt;(10..13))    [k, l, m, n]</code></pre><p>调用的结果都是List<Char>。编译器把函数返回类型List<T>总的T替换成推导出来的类型Char</p><h3 id="9-1-2-声明泛型类"><a href="#9-1-2-声明泛型类" class="headerlink" title="9.1.2 声明泛型类"></a>9.1.2 声明泛型类</h3><blockquote><p><strong>和Java一样，Kotlin通过在内名称后加上一对尖括号，并把类型参数放在尖括号内来声明泛型类及接口。</strong></p><p>一旦声明以后，就可以在类的主体内像其他类型一样使用类型参数。</p></blockquote><pre><code class="kotlin">interface List&lt;T&gt;{    //List 接口顶类类型参数T    operator fun get(index:Int):T    //在接口或类的内部，T可以当作普通类型使用。}</code></pre><blockquote><p><strong>如果你的类继承了泛型类（或者实现了泛型接口），你就得为<em>基础类型</em>的泛型形参提供一个类型实参。它可以是具体类型或一个类型形参：</strong></p><pre><code class="kotlin">class StringList(override val size: Int) : List&lt;String&gt; {   //这个类实现了List，提供了具体类型实参：String    override fun get(index: Int): String {  //注意T被String替代        TODO(&quot;Not yet implemented&quot;)    }}class ArratList&lt;T&gt; : List&lt;T&gt; {  // 现在ArrayList泛型类型形参T就是List的类型实参。    override fun get(index: Int): T {        TODO(&quot;Not yet implemented&quot;)    }}</code></pre><p>StringList类被声明成只能 <strong>只能包含String元素，所以它使用String作为基础类型的类型实参。</strong>之类中的任何函数都要用这个正确的类型换掉T，所以在StringList中你会得到函数签名get(Int):String ，而不是fun get(Int):T。</p><p><strong>而类ArrayList定义了它自己的类型参数T并把它指定为父类的类型实参。</strong>注意ArrayList<T>中的T和LIst<T>中的T不一样，它是全新的类型形参，不必保留一样的名称。</p><p><strong>一个类甚至可以把它自己作为类型实参应用。</strong>实现Comparable接口的类就是这种模式的经典例子。任何可以比较的元素都必须定义它如何与同样类型的对象进行比较：</p><pre><code class="kotlin">interface Comparable&lt;T&gt; {    fun comparableTo(other: T): Int}class String : Comparable&lt;String&gt; {    override fun comparableTo(other: String): Int {        TODO(&quot;Not yet implemented&quot;)    }}</code></pre><p>String 实现了Comparable接口的泛型接口，提供类型String给类型实参T。</p></blockquote><h3 id="9-1-3-类型参数约束"><a href="#9-1-3-类型参数约束" class="headerlink" title="9.1.3 类型参数约束"></a>9.1.3 类型参数约束</h3><blockquote><p><strong>类型参数约束可以限制作为类和函数的类型实参的类型。</strong> 以计算列表元素之和的函数为例。它们可以在List<Int>和List<Double>上，当不可以用在LIst<String>这样的列表上。可以定义一个类型参数的约束，说明sum的类型形参必须是数字，来表达这个限制。</p></blockquote><blockquote><p><strong>如果你把一个类型指定为泛型类型形参的上街约束</strong>，在泛型类型具体的初始化中，其对应的类型实参就必须这个具体类型或它的子类型（暂时子类型和子类的一样相同）。</p></blockquote><blockquote><p><strong>你是这样定义约束的，把冒号放到类型参数名称之后，作为类型形参上界的类型紧跟其后，在Java中，用的关键词extends来表达一样的概念：<T extends Number> T sum(List<T> list)。</strong></p><pre><code class="kotlin">// &lt;T: 类型参数// Number&gt; ：上界fun &lt;T:Number&gt; List&lt;T&gt;.sum():T</code></pre></blockquote><blockquote><p><strong>一旦指定了类型形参T的上界，你就可以把类型T的值作为它的上界（类型）的值使用。</strong></p><pre><code class="kotlin">fun &lt;T : Number&gt; oneHalf(value: T): Double {    //指定Number为类型形参上界    return value.toDouble() / 2.0}&gt;&gt;&gt; println(oneHalf(3))1.5</code></pre></blockquote><blockquote><pre><code class="kotlin">// 声明带类型参数约束的函数fun &lt;T : Comparable&lt;T&gt;&gt; max(first: T, second: T): T {   //这个函数的实参必须是可比较元素    return if (first &gt; second) first else second}&gt;&gt;&gt; println(max(&quot;kotlin&quot;, &quot;java&quot;)) // 字符串按照字母表顺序比较</code></pre><p><strong>T的上界是泛型类型Comparable<T> 。前面已经看到了，String累继承了Comparable<String> 这样使得String变成了max函数的有效类型实参。</strong></p><p>记住，first&gt;second的简写形式会根据Kotlin的运算符约定被编译成first.compareTo(second) &gt; 0。这种比较之所以可行，是因为first的类型T继承自Comparable<T>,这样你就可以比较first和另外一个类型T的元素。</p><p><strong>极少数情况下，需要在类型参数上指定多个约束</strong>。例如下面这个代码清单用泛型的饭是保证给定的CharSequence以句号结尾。</p><pre><code class="kotlin">//为一个类型参数指定多个约束fun &lt;T&gt; ensureTrailingPeriod(seq: T) where T : CharSequence, T : Appendable {    //类型参数约束的列表    if (!seq.endsWith(&quot;.&quot;)) {    //调用为CharSequence接口定义的扩展函数        seq.append(&quot;.&quot;)    //调用Appendable接口的方法    }}&gt;&gt;&gt; val helloWorld = StringBuilder(&quot;Hello World&quot;)&gt;&gt;&gt; ensureTrailingPeriod(helloWorld)&gt;&gt;&gt; println(helloWorld)</code></pre><p>这种情况下，可以说明作为类型实参的类型必须实现CharSequence和Appendable接口。这意味着该类型的值可以使用访问数据(endsWith)和修改数据(append) 两种操作。</p></blockquote><h3 id="9-1-4-让类型形参非空"><a href="#9-1-4-让类型形参非空" class="headerlink" title="9.1.4 让类型形参非空"></a>9.1.4 让类型形参非空</h3><blockquote><pre><code class="kotlin">class Processor&lt;T&gt;{    fun process(value:T){        value?.hashCode()    //“value“是可空的，所以要安全调用    }}</code></pre><p>如果你声明的是泛型类或者泛型函数，任何类型实参，包括哪些可空的类型实参，都可以替换它的类型形参。<strong>没有指定上界的类型形参将会使用Any?这个默认上界。</strong></p><p>process函数中，参数value是可空的，尽管T并没有使用问好标记。下面这种情况是因为Processor类具体初始化T能使用可空类型。</p></blockquote><blockquote><pre><code class="kotlin">val nullableStringProcessor = Processor&lt;String?&gt;()    //可空类型替换为String?被用来替换TnullableStringProcessor.process(null)    //使用“null”作为“value”实参的代码可以编译</code></pre><p>如果你想保证替换类型形参的始终是非空类型，可以通过指定一个约定来实现。如果你除啦可空性之外没有任何限制，可以使用Any代替默认的Any?作为上界：</p><pre><code class="kotlin">class Processor&lt;T:Any&gt;{    //指定非空上界。    fun process(value:T){        value.hashCode()    //类型T的值现在是非“空”的。    }}</code></pre><p><strong>约束&lt;T:Any&gt;确保了类型T永远都是非空类型。编译器不会接收代码Processor&lt;String?&gt;,因为类型实参String?不是Any的子类型。（它是 Any? 的子类型）</strong></p><p>可以通过指定任意非空类型作为上界，来让类型参数非空，不光是类型Any。</p></blockquote><h2 id="9-2-运行时的泛型：擦除和实例化参数"><a href="#9-2-运行时的泛型：擦除和实例化参数" class="headerlink" title="9.2 运行时的泛型：擦除和实例化参数"></a>9.2 运行时的泛型：擦除和实例化参数</h2><p>JVM上的泛型一般是通过<strong>类型擦除</strong>实现，就是说泛型类实例的类型实参在运行时是不保留的。可以声明一个inline函数，使其类型实参不被擦除（或者，Kotlin术语称为实化）。</p><h3 id="9-2-1-运行时的泛型：类型检查和转换"><a href="#9-2-1-运行时的泛型：类型检查和转换" class="headerlink" title="9.2.1 运行时的泛型：类型检查和转换"></a>9.2.1 运行时的泛型：类型检查和转换</h3><p>和Java一样，Kotlin的泛型在运行时也被 <strong>擦除</strong> 了。这意味着泛型类实例不会携带用于创建它的类型实参的信息。例如，如果你创建了一个List<String>并将一堆字符串放到其中，在运行时你只能看到它是一个List，不能识别出列表本打算包含的是那种类型元素（当然，你可以获取一个元素然后检查它的类型，但即便检查通过了也不会有任何保证，因为其他元素可能拥有不同类型）。</p><pre><code class="kotlin">val list1:List&lt;String&gt; = listOf(&quot;a&quot;,&quot;b&quot;)val list2:List&lt;Int&gt; = listOf(1,2,3)</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210905153004.png" alt="在运行时，你不会知道list1和list2时候声明成字符串或者整数列表。它们每个都只是List    "></p><p>即使编译器看到的是两种完全不同类型的列表，在执行的时候它们看起来却完全一样。即便如此，你通常可以确信List<String>在包含字符串，而List<Int>只包含整数。因为编译器知道类型实参，并确保每个列表只存储正确的元素。</p><p><strong>因为类型实参没有被保留下来，你不能检查它们。</strong>例如，你不能判断一个列表是只包含字符串的列表还是包含其它对象的列表。一般而言，在is检查中不可能使用类型实参中的类型。</p><pre><code class="kotlin">&gt;&gt;&gt; if (value is List&lt;String&gt;){...}ERROR:Cannot check for instance of erased type</code></pre><p><strong>为什么擦除了泛型类型信息？</strong></p><p>尽管在运行时可以完全断定这个值是一个List，但你依然无法判断它是一个含有字符串的列表，还是含有人，或者含有其他什么：这些信息被擦除了。<strong>注意擦除泛型类型信息是有好处的：应用程序使用的内存总量较小，因为要保存在内存中的类型信息更少。</strong></p><p><strong>检查类型是否是个列表？</strong></p><p>路上所述，Kotlin不允许使用没有指定类型实参的泛型类型。那么你可能想知道如何检查一个值是否是列表，而不是set或者其他对象。可以使用特殊的<strong>星号投影</strong>语法来做这种检查：</p><pre><code class="kotlin">if (value is List&lt;*&gt;){... ...}</code></pre><p>这里检查了value是否是一个List，而且并没有得到关于它的任何信息。</p><blockquote><p>注意，在as 和 as? 转换中仍然可以使用一般的泛型类型。但如果该类有正确的<strong>基础类型</strong>但<strong>类型实参</strong>是错误的，转换也不会失败，因为在运行时转换发生的时候类型实参是未知的。因此这样的转换会导致编译器发出“unchecked cast”（未受检转换）的警告。这仅仅是个警告，你仍然可以继续使用这个值，但它拥有必要的类型。</p><pre><code class="kotlin">    // 对泛型类型做类型转换fun printSum(c: Collection&lt;*&gt;) {    val initList = c as? List&lt;Int&gt;        ?: throw IllegalArgumentException(&quot;List is expected&quot;)    //这里警告。Unchecked cast:List&lt;*&gt;to List&lt;Int&gt;    println(initList.sum())}&gt;&gt;&gt; printSum(listOf(1, 2, 3))6</code></pre><p>编译一切正常：编译器只是发出了一个警告，这意味着代码是合法的。如果一个整型的列表或者set上调用printSum函数，一切都会如预期发生：一种情况会打印出元素之和，而第二种情况则会IllegalArgumentException。但如果你传递了一个错误类型的值，运行时会得到一个ClassCastException：</p><pre><code class="kotlin">&gt;&gt;&gt; printSum(setOf(1,2,3))    //Set不是列表所以抛出了异常IllegalArgumentException:List is expected&gt;&gt;&gt; printSum(listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;))    //类型转换成功，但后面抛出了另外的异常ClassCastException:String cannot be cast to Number    </code></pre><p>我们来讨论一下字符串列表上调用printSum函数时抛出的异常。你得到的并不是IllegalArgumentException，因为你没有办法判断实参是不是一个List<Int>。因此类型转换成功，无论如何函数sum都会在这个列表上调用。在这个函数执行期间，异常抛出了。这是因为sum函数试着从列表中读取Number值然后把它们加在一起。把String但Number用的尝试会导致运行时ClassCastException。</p></blockquote><blockquote><pre><code class="kotlin">/*    对已知类型实参做类型转换    */fun printSum(c: Collection&lt;Int&gt;) {    if (c is List&lt;Int&gt;) {        println(c.sum())    //这次检查是合法的    }}&gt;&gt;&gt; printSum(listOf(1, 2, 3))6</code></pre><p>c 时候拥有类型List<Int>的检查是否可行，因为在编译期就确定了集合（不管它是列表还是其他类型的集合）包含的都是整型数字。</p><p>Kotlin有特殊的语法结构可以允许你在函数体中使用具体的类型实参，但是又inline函数可以。</p></blockquote><h3 id="9-2-2-声明带实化类型参数的函数"><a href="#9-2-2-声明带实化类型参数的函数" class="headerlink" title="9.2.2 声明带实化类型参数的函数"></a>9.2.2 声明带实化类型参数的函数</h3><blockquote><p>Kotlin泛型在运行时会被擦除，这意味着如果你有一个泛型类的实例，你无法弄清楚在这个实例创建时你究竟用的是那个类型的实参。泛型类型的类型实参也是这样。在调用泛型函数的时候，在函数体中你不能决定函数调用它用的类型实参：</p><pre><code class="kotlin">&gt;&gt;&gt; fun &lt;T&gt; isA(value:Any)=value is T    //表达式Error:Cannot check for instance of erased type:T</code></pre><p>这种情况下只有<strong>内联函数</strong>能够使用，内联函数的类型形参能够被实化，意味着你可以在运行时应用实际的类型实参。</p><p><strong>如果使用inline函数标记函数，编译器会把每次函数调用都换成函数实际的代码实现。使用内联函数还可以提升性能，如果该函数使用了lambda实参：lambda的代码会被内敛，所以不会创建任何匿名类。</strong>  <strong>inline函数使用时的另一种场景：它们的类型参数可以被实化。</strong></p><p>把前面列子中的isA函数声明成inlie并且用reified标记类型参数，你能够用该函数检查value是不是T的实例。</p><pre><code class="kotlin">/*  声明带实化类型参数的函数   */inline fun &lt;reified T&gt; isA(value: Any) = value is T&gt;&gt;&gt; println(isA&lt;String&gt;(&quot;abc&quot;))true&gt;&gt;&gt; println(isA&lt;String&gt;(123))false</code></pre></blockquote><blockquote><p>一个实化类型参数能够发挥作用最简单的例子就是标准库函数filterIsInstance。<strong>这个函数接收一个集合，选择其中哪些指定类的实例，然后返回这些被选中的实例。</strong></p><pre><code class="kotlin">/*  使用标准库函数filterIsInstance */&gt;&gt;&gt; val items = listOf(&quot;one&quot;, 2, &quot;three&quot;)&gt;&gt;&gt; println(items.filterIsInstance&lt;String&gt;())[one,three]</code></pre><p>通过指定<String>作为函数的类型参数，你表明感兴趣的只是字符串。<strong>因此函数的返回类型时List<String>。这种情况下，<em>类型实参在运行时是已知的</em>函数filterIsInstance使用它来检查列表中的值是不是指定为该类型实参的类的实例。</strong></p><pre><code class="kotlin">/*  filterIsTance声明的简化版本    */inline fun &lt;reified T&gt; Iterable&lt;*&gt;.filterIsTance(): List&lt;T&gt; {    //“reified”声明了类型参数不会在运行时被擦除    val destination = mutableListOf&lt;T&gt;()    for (element in this) {        if (element is T) {        //可以检查元素是不是指定为类型实参的类的实例            destination.add(element)        }    }    return destination}</code></pre></blockquote><p><strong>为什么实化只对内联函数有效？</strong></p><p>为什么在inline函数中允许这样写 element is T ，而普通的类或者函数却不行？</p><p>编译器把实现内联函数的字节码插入每一次调用发生的地方。每次你调用带实化类型参数的函数时，编译器都知道这次特定调用中用作实参的确切类型。因此，编译器可以生成应用作为类型实参的具体类的字节码。上述 filterIsInstance<String>调用来说，生成的代码和下面这段代码是等价的：</p><pre><code class="kotlin">for (element in this){    if(element is String){    //引用具体类        destination.add(element)    }}</code></pre><p>因为生成的字节码引用了具体类型，而不是类型参数，它不会被运行时发生的类型参数擦除影响。</p><p><strong>注意reified类型参数的inline函数不能在java中调用。</strong>普通的内联函数可以像常规函数那样在Java中调用–它们可以被调用而不能被内联。带实化类型参数的函数需要额外的处理，来吧类型实参的值替换到字节码中，所以它们必须永远是内联的。所以不能在java中调用。</p><p><strong>内联函数在什么情况下性能有势最有效？</strong></p><p><strong>一个内联函数可以有多个实化类型参数，也可以同时拥有飞实化类型参数和实化类型参数。注意，filterIsInstance函数虽然被标记成了inline，而他并不期望lamdba作为实参。（决定何时将函数声明为内联函数）中，我们提到函数把函数标记成内联只有在一种情况下有性能优势，即函数拥有函数类型的形参并且其对应的实参–lambda–和函数一起被内联的实化。</strong></p><p>为了保证良好的性能，你仍然需要追踪了解标记为inline的函数的大小。如果函数变的庞大，最好把不依赖实化类型参数的代码抽取到非内联函数中。</p><h3 id="9-2-3-使用实化类型参数代替类引用"><a href="#9-2-3-使用实化类型参数代替类引用" class="headerlink" title="9.2.3 使用实化类型参数代替类引用"></a>9.2.3 使用实化类型参数代替类引用</h3><p>实化类型参数的常见使用场景是为接收java.lang.Class 类型参数的API构造适配器。这个API的例子是JDK中ServiceLoader，它接收一个代表接口或抽象类的java.long.Class，并返回实现了该接口（或继承了该抽象类）java.lang.Class，并返回实现了该接口（或继承了该抽象类）的类的实例。如何利用实化类型参数更容易地调用这些API。</p><pre><code class="kotlin">/*    通过类引用 加载ServiceLoader    */val serviceImpl = ServiceLoader.load(Service::class.java)</code></pre><p>::class.java 的语法展示了如何获取java.lang.Class对应的Kotlin类。</p><p>这和Java中的Service.class是完全等同的。</p><p><strong>使用实化类型参数的函数重写这个例子：</strong></p><pre><code class="kotlin">val serviceImpl = loadService&lt;Service&gt;()</code></pre><p>代码短了许多。</p><p><strong>那么如何定义实化函数？</strong></p><p>要加载的服务类现在被指定成了loadService函数的类型实参。把一个类要指定成类型实参要容易理解的多，因为它的代码比使用::class.java语法更短。</p><p>看看loadService函数是如何定义的：</p><pre><code class="kotlin">inline fun &lt;reified T&gt; loadService(){    //类型参数标记成了“reified”    return ServiceLoader.load(T::Class.java)    //把T::Class当成类型形参的类访问。}</code></pre><p>这种用在类型上的::Class.java语法也可以用在实化类型参数上。使用这种语法会产生对应到指定为类型参数的类的java.lang.Class,你可以正常使用它。</p><p><strong>简化 Android上的startActivity 函数</strong></p><p>如果你是Android开发者，可以使用实化类型参数简化startActivity函数。实化类型参数用来代替传递作为java.lang.Class的Activity类。</p><pre><code class="kotlin">inline fun &lt;reified T: Activity&gt; Context.startActivity(){    //类型参数标记为“reified”    val intent = Intent(this,T::Class.java)    //把T::Class当成类型参数的类访问    startActivity(intent)}startActivity(intent)    //调用方法显式Activity</code></pre><h3 id="9-2-4-实化类型参数的限制"><a href="#9-2-4-实化类型参数的限制" class="headerlink" title="9.2.4 实化类型参数的限制"></a>9.2.4 实化类型参数的限制</h3><p>实化类型参数是有一些限制的。有一些实化是与生俱来的，另一些是现有的实现决定的，</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h3 id="字段和属性"><a href="#字段和属性" class="headerlink" title="字段和属性"></a>字段和属性</h3><p><a href="https://blog.csdn.net/chenchunlin526/article/details/71424844" target="_blank" rel="noopener">深入理解Java中的字段与属性的区别</a></p><h4 id="属性和字段的区别"><a href="#属性和字段的区别" class="headerlink" title="属性和字段的区别"></a>属性和字段的区别</h4><p>属性（property），通常可以理解为get 和 set 方法。</p><p>字段（field），通常叫做 <strong>类成员</strong>，或者 <strong>类变量</strong> ，有时也叫 域 ，理解为 数据成员，用来承担数据的。</p><h4 id="属性和字段详解"><a href="#属性和字段详解" class="headerlink" title="属性和字段详解"></a>属性和字段详解</h4><p><strong>字段（field）</strong></p><p>类成员（字段field），通常在类中定义成员变量例如：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200909213136.png" alt=""></p><p>解释为：<strong>FacebookUser类拥有成员变量nickname，有一个字段 nickname。</strong></p><p>字段一般用于承担数据，所以为了数据的安全性，一般设置为私有的。</p><p>字段和常量描述的类的数据（域），当这些数据的某些部分不运行外界访问时，<strong>根据”对象封装“原则，应该尽量避免将类的字段以公有方式提供给外部</strong>。除啦final修饰的常量。</p><p><strong>属性（property）</strong></p><p><strong>属性只局限于类中方法的声明，并不与类中其它成员相关</strong>，数据JavaBean范畴：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200909220317.png" alt=""></p><p>这是一个属性，一个字段。</p><p>总结：属性是对字段的封装，供外部访问。通常<strong>属性</strong>将对应的<strong>私有字段</strong>通过封装成公共属性，以便于外界访问和修改。</p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>是指可以被求值的代码。</p><p>例如</p><pre><code class="c">int result = add(x + 1,y)</code></pre><blockquote><p>x + 1 作为表达式传递了数值</p></blockquote><pre><code class="c">int result = add（if(x==1),y）</code></pre><blockquote><p>这段语句在 c 中是没有办法作为表达式的。</p></blockquote><h3 id="Kotlin-this表达式"><a href="#Kotlin-this表达式" class="headerlink" title="Kotlin this表达式"></a>Kotlin this表达式</h3><p>为了表示当前的 <strong>接收者</strong> 使用 this{:.keyword} 表达式：</p><ul><li>在类的成员中，this{:.keyword}指的是当前对象</li><li>在扩展函数或者带接受者的函数字面值中，this{:.keyword}表示在点左侧的接收者参数。</li></ul><h3 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h3><p>函数引用 是kotlin引入的一个功能。使用(::)表示对函数的引用</p><p>代码</p><pre><code class="kotlin">val sum:(Int,Int) -&gt; Int = {x,y -&gt; x +y}</code></pre><blockquote><p>sum 是一个函数类型的变量，lambda表达式执行了相加的操作。</p></blockquote><pre><code class="kotlin">fun applyOp(x: Int, y: Int, op: (Int, Int) -&gt; Int): Int = op(x, y)</code></pre><p>applyOp 是一个接受三个参数的函数，第三个参数是lambda类型。可以用下面的返回调用这个函数：</p><pre><code class="kotlin">applyOp(2,3,sum)</code></pre><p>即高阶函数可以作为一个类型赋值给变量，也可以作为另一个函数的参数。</p><h4 id="函数引用：函数可以是一个-lambda"><a href="#函数引用：函数可以是一个-lambda" class="headerlink" title="函数引用：函数可以是一个 lambda"></a>函数引用：函数可以是一个 lambda</h4><p>上述的lambda表达式，可以用纯函数的形式：</p><pre><code class="kotlin">fun sum(x: Int, y: Int) = x + y</code></pre><p>实现效果是一样的，区别在于不再需要使用变量来保持对函数的引用，但是这样需要对applOp函数要做一些修改，原来的</p><p><strong>applOp(2,3,sum)</strong>写法会报类型不匹配的语法错误。需要修改为使用<strong>函数引用</strong>代码如下：</p><pre><code class="kotlin">applOp(2,3,::sum)</code></pre><p>这些算是 函数引用 的大致概念。同时<strong>函数引用</strong>也是可以赋值给变量的。</p><pre><code class="kotlin">val sumLambda: (Int, Int) -&gt; Int = ::sumapplyOp(2, 3, sumLambda)</code></pre><h3 id="lamnda-表达式-与-匿名内部类的区别"><a href="#lamnda-表达式-与-匿名内部类的区别" class="headerlink" title="lamnda 表达式 与 匿名内部类的区别"></a>lamnda 表达式 与 匿名内部类的区别</h3><blockquote><ul><li>lambda 表达式只能为函数式接口创建实例；匿名内部类可以为任意接口创建实例 – 不管接口包含多少抽象方法，只要匿名内部类是实现所有的抽象方法即可。</li><li>lambda 表达式只能为函数式接口创建实例；匿名内部类可以为抽象类甚至普通话类创建实例；</li><li>lambda 表达式的代码不允许调用接口中定义的默认方法；匿名内部类实现的抽象方法的方法体允许调用接口中定义的默认方法。</li></ul></blockquote><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><h2 id="Reified实化类型参数"><a href="#Reified实化类型参数" class="headerlink" title="Reified实化类型参数"></a>Reified实化类型参数</h2><p>背景：</p><blockquote><p>Java中泛型是在JDK1.5版本后引入的，但集合Collection实在JDK1.2版本时引入的，现在看到的List，是在泛型出现后加入的，那么JDK1.2之前就直接用LIst（java中俗称原生态类型）表示。在为了兼容之前的版本Java采用所谓的伪泛型，伪泛型有一个特征就是<strong>泛型擦除</strong>，表示泛型类型信息在编译时期会被抹除掉，包括你是List还是List在运行时它们都是一样，那都是List类型，泛型类型信息已经被抹除掉了。</p></blockquote><h2 id="Kotlin中的形参和实参"><a href="#Kotlin中的形参和实参" class="headerlink" title="Kotlin中的形参和实参"></a>Kotlin中的形参和实参</h2><p>ps：</p><p><a href="https://juejin.cn/post/6844903694119485447#heading-6" target="_blank" rel="noopener">一个简单方式教你记住Kotlin的形参和实参</a></p><h2 id="什么才是泛型擦除"><a href="#什么才是泛型擦除" class="headerlink" title="什么才是泛型擦除"></a>什么才是泛型擦除</h2><p>ps:</p><p><a href="https://juejin.cn/post/6844904083199918093" target="_blank" rel="noopener">面试官问我：“泛型擦除是什么，会带来什么问题？”</a></p><p><strong>引用：</strong></p><p><a href="https://www.web3.xin/code/2606.html" target="_blank" rel="noopener">Kotlin this表达式</a></p><p><a href="https://www.jianshu.com/p/10358883455c" target="_blank" rel="noopener">kotlin中的函数引用详解</a>    </p><p><a href="http://c.biancheng.net/view/6559.html" target="_blank" rel="noopener">Lambda表达式与匿名内部类的联系和区别</a></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-8-3-1.gif" alt="如果有些方法没有详细说明你可以自行搜索查看"></p>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RecyclerView在Kotlin中的使用</title>
      <link href="/2020/07/26/RecyclerView%E5%9C%A8Kotlin%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/07/26/RecyclerView%E5%9C%A8Kotlin%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="创建项目RecyclerExample项目"><a href="#创建项目RecyclerExample项目" class="headerlink" title="创建项目RecyclerExample项目"></a>创建项目RecyclerExample项目</h2><h3 id="需要引入依赖"><a href="#需要引入依赖" class="headerlink" title="需要引入依赖"></a>需要引入依赖</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595735673809.png" alt=""></p><h3 id="需要子项布局"><a href="#需要子项布局" class="headerlink" title="需要子项布局"></a>需要子项布局</h3><p>在 “RecyclerViewExample\app\src\main\res\layout”下创建 “example_item.xml” 👇</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.cardview.widget.CardView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;&gt;    &lt;RelativeLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:padding=&quot;8dp&quot;&gt;        &lt;ImageView            android:id=&quot;@+id/image_view&quot;            android:layout_width=&quot;50dp&quot;            android:layout_height=&quot;50dp&quot;            android:layout_marginEnd=&quot;8dp&quot;            android:src=&quot;@drawable/ic_baseline_android_24&quot; /&gt;        &lt;TextView            android:id=&quot;@+id/text_view_1&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_toEndOf=&quot;@+id/image_view&quot;            android:text=&quot;Line 1&quot;            android:textColor=&quot;@color/cardview_dark_background&quot;            android:textSize=&quot;18sp&quot; /&gt;        &lt;TextView            android:id=&quot;@+id/text_view_2&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_below=&quot;@+id/text_view_1&quot;            android:layout_toEndOf=&quot;@+id/image_view&quot;            android:text=&quot;Line 2&quot; /&gt;    &lt;/RelativeLayout&gt;&lt;/androidx.cardview.widget.CardView&gt;</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595735521036.png" alt=""></p><p>需要自定义的图片 ↓</p><p>选中”drawable”文件夹,选中”New”,选中”Vactor Asset”</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915232142.png" alt=""></p><p>选中”Clip Art” 选中喜欢的图形就可以了。点击 “Next”,再点击 Finish。 创建三个。</p><h3 id="需要-数据类👇"><a href="#需要-数据类👇" class="headerlink" title="需要 数据类👇"></a>需要 数据类👇</h3><p>在 “recyclerviewexample” 包下</p><pre><code>/** *   @DATE : 2020/7/26 *   @Time : 11:42 *   @By : TheCara *   &quot;data&quot; 数据类 */data class Exampleitem(val imageResource: Int, val text1: String, val text2: String)</code></pre><h3 id="需要适配器"><a href="#需要适配器" class="headerlink" title="需要适配器"></a>需要适配器</h3><p>需要适配器”ExampleAdapter”</p><pre><code>/** *   @DATE : 2020/7/27 *   @Time : 15:54 *   @By : TheCara *   需要继承RecyclerView.Adapter类型 *   需要内嵌类继承RecyclerView.ViewHolder类型 */class ExampleAdapter(private val exampleList: List&lt;ExampleItem&gt;) :    RecyclerView.Adapter&lt;ExampleAdapter.ExampleViewHolder&gt;() {    // 关键方法，用于确定列表项    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ExampleViewHolder {        val view = LayoutInflater.from(parent.context).inflate(R.layout.example_item, parent, false)        return ExampleViewHolder(view)    }    override fun getItemCount() = exampleList.size    // 将数据和容器绑定    override fun onBindViewHolder(holder: ExampleViewHolder, position: Int) {        val currenItem = exampleList[position]        holder.imageView.setImageResource(currenItem.imageResource)        holder.textView1.setText(currenItem.text1)        holder.textView2.setText(currenItem.text1)    }    // 获得每个控件的实例,需要ExampleViewHolder的参数(子项布局)作为RecyclerView.ViewHolder()用作实例化    class ExampleViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {        val imageView: ImageView = itemView.image_view        val textView1: TextView = itemView.text_view_1        val textView2: TextView = itemView.text_view_2    }}</code></pre><p>在”MainActivity”修改</p><pre><code>class MainActivity : AppCompatActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        val listExample = generateDummyList(500)        recycler_view.adapter = ExampleAdapter(listExample)        // 设置RecyclerView的布局管理器        recycler_view.layoutManager = LinearLayoutManager(this)        // 确保RecyclerView的尺寸是一个常数        recycler_view.setHasFixedSize(true)    }    // 获得布局中的数据    private fun generateDummyList(size: Int): List&lt;ExampleItem&gt; {        val list = ArrayList&lt;ExampleItem&gt;()        // 使⽤区间&quot;until&quot;        for (i in 0 until size) {            val drawable = when (i % 4) {                0 -&gt; R.drawable.ic_baseline_add_to_home_screen_24                1 -&gt; R.drawable.ic_baseline_airline_seat_flat_angled_24                2 -&gt; R.drawable.ic_baseline_airline_seat_recline_extra_24                else -&gt; R.drawable.ic_baseline_android_24            }            val item = ExampleItem(drawable, &quot;Line $i&quot;, &quot;Line 2&quot;)            list += item        }        return list    }}</code></pre><p>👆”setHasFixedSize()”方法:当我们确定Item的改变不会影响RecyclerView的宽高时,可以<strong>设置这个方法</strong>,并且Adapter的增删方法去刷新RecyclerView,而不是通过notifyDataSetChanged()。(其实可以直接设置为true，当需要改变宽高的时候就用notifyDataSetChanged()去整体刷新一下)</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595841353310.png" alt=""></p><h2 id="添加-增删-功能"><a href="#添加-增删-功能" class="headerlink" title="添加 增删 功能"></a>添加 增删 功能</h2><h2 id="使用RecyclerView在案例中需要什么"><a href="#使用RecyclerView在案例中需要什么" class="headerlink" title="使用RecyclerView在案例中需要什么"></a>使用RecyclerView在案例中需要什么</h2><ul><li>需要引入依赖</li><li>需要适配器</li><li>需要ItemLayout</li><li>需要数据类</li><li>控制器需要初始化</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
            <tag> RecyclerView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataBinding的使用</title>
      <link href="/2020/07/24/DataBinding%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/07/24/DataBinding%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="DataBinding-配合-LiveData-和-ViewModel-使用"><a href="#DataBinding-配合-LiveData-和-ViewModel-使用" class="headerlink" title="DataBinding 配合 LiveData 和 ViewModel 使用"></a>DataBinding 配合 LiveData 和 ViewModel 使用</h2><ol><li>需要创建MyViewModel类,继承ViewModel</li><li>需要添加DataBinding的gradle(app)配置信息</li></ol><p>添加配置信息 在gradle(app)中添加 ↓</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-25_10-40-29.png" alt=""></p><h4 id="创建MyViewModel-↓"><a href="#创建MyViewModel-↓" class="headerlink" title="创建MyViewModel ↓"></a>创建MyViewModel ↓</h4><pre><code>/** *   @DATE : 2020/7/24 *   @Time : 21:10 *   @By : TheCara *  负责处理界面数据 *  需要 LiveData 来观察数据刷新UI */class MyViewModel : ViewModel() {    var numberLiveData = MutableLiveData&lt;Int&gt;()    init {        numberLiveData.value = 0    }    // 加值    fun add() {        numberLiveData?.value = numberLiveData?.value?.plus(1)    }}</code></pre><h4 id="修改MainActivity-↓"><a href="#修改MainActivity-↓" class="headerlink" title="修改MainActivity ↓"></a>修改MainActivity ↓</h4><pre><code>/** 需要 ActivityMainBinding 类用来绑定数据* 需要 MyViewModel 来和 ActivityMainBinding 绑定数据* */class MainActivity : AppCompatActivity() {    var myViewModel: MyViewModel? = null    // 设置类型为可空类型    var activityMainBinding: ActivityMainBinding? = null    //ActivityMainBinding 是在DataBingding配置完成之后自动生成的    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        // 初始化DataBindingUtil,用来绑定布局        activityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main)        // 初始化数据类        var myViewModel = ViewModelProviders.of(this).get(MyViewModel::class.java)        activityMainBinding?.myViewModel=myViewModel        activityMainBinding?.lifecycleOwner = this    }}</code></pre><h4 id="布局-使用-“data”-标签-↓"><a href="#布局-使用-“data”-标签-↓" class="headerlink" title="布局 使用 “data” 标签 ↓"></a>布局 使用 “data” 标签 ↓</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595645673021.png" alt=""></p><p>需要 layout 布局保存布局,需要 “data “标签保存绑定来的数据,需要 “variable” 标签设置变量。</p><h4 id="需要使用-“-”-方式访问变量-↓"><a href="#需要使用-“-”-方式访问变量-↓" class="headerlink" title="需要使用 “@{}” 方式访问变量 ↓"></a>需要使用 “@{}” 方式访问变量 ↓</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595645903565.png" alt=""></p><h4 id="需要使用-“-参数-gt-方法-参数-”访问方法-↓"><a href="#需要使用-“-参数-gt-方法-参数-”访问方法-↓" class="headerlink" title="需要使用 “@{(参数)-&gt;方法(参数)}”访问方法 ↓"></a>需要使用 “@{(参数)-&gt;方法(参数)}”访问方法 ↓</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595645888188.png" alt=""></p><p>demo ↓</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595646636793.png" alt=""></p><h2 id="什么是DataBinding"><a href="#什么是DataBinding" class="headerlink" title="什么是DataBinding"></a>什么是DataBinding</h2><p>DataBinding是谷歌在2015年I/O开发者大会上发布的一个数据绑定框架,也就是把数据捆绑到UI上,DataBinding可以让Activity和Fragment减少逻辑,使其方便维护。同时也能提高性能,避免空指针异常,同时DataBinding也支持双向绑定,使UI的改变同时同步到数据上,DataBinding不是MVVM架构的必需品。</p><h2 id="DataBinding有哪些优缺点"><a href="#DataBinding有哪些优缺点" class="headerlink" title="DataBinding有哪些优缺点"></a>DataBinding有哪些优缺点</h2><p><strong>优点</strong></p><ol><li>减少Activity和Fragment的逻辑处理,使Activity和Fragment逻辑更加清晰。</li><li>提高性能,避免内存泄漏以及空指针</li><li>支持双向绑定,当View改变的时候会通知Model,当Model改变时会通知View</li></ol><p><strong>缺点</strong></p><ol><li>bug难定位,出现bug时无法定位到是View中的bug还是Model中的bug,又或是编写的逻辑bug。</li><li>双向绑定不利于View的复用</li></ol><p>引用:<a href="https://juejin.im/post/5edb12346fb9a047da364349#heading-2" target="_blank" rel="noopener">https://juejin.im/post/5edb12346fb9a047da364349#heading-2</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> DataBinding </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LiveData与ViewModel</title>
      <link href="/2020/07/20/LiveData/"/>
      <url>/2020/07/20/LiveData/</url>
      
        <content type="html"><![CDATA[<h4 id="单独使用LiveData"><a href="#单独使用LiveData" class="headerlink" title="单独使用LiveData"></a>单独使用LiveData</h4><ol><li>创建LiveData实例。持有特定的数据类型，例如 int ,String。</li><li>创建一个Observer对象,并且实现onChanged()方法。在onChanged()方法类可以进行UI的刷新等。</li><li>使用LiveData实例的observe(…,…)方法,将Observer对象添加到LiveData中。方法原型为 <strong>observe(LifecycleOwner owner,Observer observer)</strong>,第一个参数是LifecycleOwner对象，为LiveData能够监听生命周期的能力来源。第二个参数为我们的监听对象。</li></ol><p>添加LiveData和ViewModel的依赖 ↓</p><pre><code>// 添加LiveData和ViewModel的依赖implementation &#39;android.arch.lifecycle:extensions:1.1.1&#39;</code></pre><p>界面准备按钮用来开启,使得UI刷新 ↓</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-20_15-48-40.png" alt=""></p><p> MainActivity中的代码 ↓</p><pre><code>class MainActivity : AppCompatActivity() {    val TAG = &quot;MainActivity&quot;    val btnStart = btn_start    val mTvNumber = tv_number    var mNumberLiveData: MutableLiveData&lt;Int&gt;? = null // 声明变量    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        mNumberLiveData = MutableLiveData()        btnStart.setOnClickListener { view: View? -&gt;            thread {                var number = 0                while (number &lt; 5) {                    mNumberLiveData?.postValue(number)                    Log.d(TAG, &quot;setOnClickListener&quot; + number)                    Thread.sleep(3000)                    number++                }            }        }        mNumberLiveData?.observe(this, object : Observer&lt;Int&gt; {            override fun onChanged(t: Int?) {                mTvNumber.setText(&quot;&quot; + t)                Log.d(TAG, &quot;onChanged&quot; + t)            }        })    }}</code></pre><p>界面的TextView会根据数据进行刷新。</p><h4 id="单独使用ViewModel"><a href="#单独使用ViewModel" class="headerlink" title="单独使用ViewModel"></a>单独使用ViewModel</h4><ol><li>创建ViewModel的继承类</li><li>在控制器中实例化继承类</li></ol><p>创建ViewModel继承类 ↓</p><pre><code>class MyViewModel() : ViewModel() {    var number = 0}</code></pre><p>修改控制器 ↓</p><pre><code>class MainActivity : AppCompatActivity() {    val TAG = &quot;MainActivity&quot;    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        // ViewModelProvider.of() 获得MyViewModel持久类用来保存UI数据        // &quot;MyViewModel::class.java&quot; 反射引用类型        var myViewModel = ViewModelProviders.of(this).get(MyViewModel::class.java)        tv_number.setText(myViewModel.number.toString())        btn_start.setOnClickListener {            myViewModel.number++            tv_number.setText(myViewModel.number.toString())        }    }}</code></pre><p>简单的界面样式 ↓</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-21_19-16-39.png" alt=""></p><h4 id="LiveData和ViewModel配合使用"><a href="#LiveData和ViewModel配合使用" class="headerlink" title="LiveData和ViewModel配合使用"></a>LiveData和ViewModel配合使用</h4><ol><li>需要有ViewModel的继承类</li><li>需要在ViewModel的继承类中实例化LiveData类型</li><li>需要在控制器中初始化ViewModel的继承类</li><li>需要调用LiveData的observe的方法</li></ol><pre><code>class MyViewModel : ViewModel() {    var mutableLiveData = MutableLiveData&lt;Int&gt;()    init {        mutableLiveData.value=0    }    fun getLive(): MutableLiveData&lt;Int&gt; {        return mutableLiveData    }    fun addNumber(number: Int) {        mutableLiveData?.value=number+ mutableLiveData.value!!    }}</code></pre><pre><code>class MainActivity : AppCompatActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        // 获得MyViewModel实例        var myViewModel = ViewModelProviders.of(this).get(MyViewModel::class.java)        btn_addone.setOnClickListener {            myViewModel?.addNumber(1)        }        myViewModel?.getLive()?.observe(this, object : Observer&lt;Int&gt; {            override fun onChanged(t: Int?) {                tv_number.setText(t.toString())            }        })    }}</code></pre><h4 id="什么是LiveData"><a href="#什么是LiveData" class="headerlink" title="什么是LiveData"></a>什么是LiveData</h4><p>LiveData是一个可以观察的数据持有类,但是不同于通常的观察者,它具有声明周期的感知能力。通俗些讲,它所持有的数据发生改变时,并且Lifecycle对象还处于活跃状态,LiveData将立即通知观察者数据发生了变化。相比于不同的观察者它多了生命周期和感知能力。</p><h4 id="什么是ViewModel"><a href="#什么是ViewModel" class="headerlink" title="什么是ViewModel"></a>什么是ViewModel</h4><p>简单说ViewModel是一种用来存储和管理UI相关数据的类。但是与其他的Model不同的是,他支持在系统改变时保存数据。</p><p>当屏幕发生改变时,会导致Activity/Fragment重新绘制,会导致我们之前的数据丢失。比如,在EditText中输入了内容,但是当屏幕扭转时,会发现editText中的文本被清空了。</p><p>当对于一下简单的数据,我们可以通过Activity的onSaveInstanceState()方法中储存,然后通过onCreate()中进行恢复,但是这种方式只适合存储少量的数据，并且是能被序列化和反序列的数据。而对那些大量的数据则不适用。</p><p>此外,它也使View的数据持有者和Viewcontroller逻辑更加分离，便于解耦和测试。</p><p>引用:<a href="https://juejin.im/post/5ca9f9156fb9a05e3d0a8aea#heading-6" target="_blank" rel="noopener">https://juejin.im/post/5ca9f9156fb9a05e3d0a8aea#heading-6</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
            <tag> LiveData </tag>
            
            <tag> ViewModel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 讲解</title>
      <link href="/2020/07/19/git%20%E8%AE%B2%E8%A7%A3/"/>
      <url>/2020/07/19/git%20%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="修改提交文件大小"><a href="#修改提交文件大小" class="headerlink" title="修改提交文件大小"></a>修改提交文件大小</h1><p>在要提交的项目根目录下使用。</p><pre><code>$ git config --local http.postBuffer 524288000</code></pre><p>设置为500MB。</p><h1 id="查看本地分支"><a href="#查看本地分支" class="headerlink" title="查看本地分支"></a>查看本地分支</h1><pre><code>git branch</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923155804.png" alt="本地的两个分支"></p><h1 id="查看远程仓库所有分支"><a href="#查看远程仓库所有分支" class="headerlink" title="查看远程仓库所有分支"></a>查看远程仓库所有分支</h1><pre><code>git branch -r</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923155838.png" alt="远程仓库的分支"></p><h1 id="查看本地仓库和远程仓库"><a href="#查看本地仓库和远程仓库" class="headerlink" title="查看本地仓库和远程仓库"></a>查看本地仓库和远程仓库</h1><pre><code>git branch -a</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923160933.png" alt="本地和远程共有仓库"></p><h1 id="创建本地分支"><a href="#创建本地分支" class="headerlink" title="创建本地分支"></a>创建本地分支</h1><pre><code>git branch annotationVersion</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923120947.png" alt="创建了本地分支"></p><h1 id="切换到创建的分支"><a href="#切换到创建的分支" class="headerlink" title="切换到创建的分支"></a>切换到创建的分支</h1><pre><code>git checkout 分支</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923121359.png" alt="切换到创建的 annotationVersion 分支"></p><h1 id="本地分支提交到远程分支"><a href="#本地分支提交到远程分支" class="headerlink" title="本地分支提交到远程分支"></a>本地分支提交到远程分支</h1><p><strong>切换到创建的分支</strong>（annotationVersion）。</p><pre><code>git push origin annotationVersion</code></pre><p>如果<strong>远程仓库</strong>没有这个分支，那么也会创建一个该分支。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923153643.png" alt="由于远程仓库没有本地的分支在push时自动创建了annotationVersion分支"></p><h1 id="本地获得一个远程分支"><a href="#本地获得一个远程分支" class="headerlink" title="本地获得一个远程分支"></a>本地获得一个远程分支</h1><p>使用命令</p><pre><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;例如git pull origin v1.0:v1.0</code></pre><p>pull 了<strong>远程仓库的v1.0分支</strong>本地命名<strong>为v1.0</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923172540.png" alt="pull 完成"></p><h1 id="合并本地两个分支"><a href="#合并本地两个分支" class="headerlink" title="合并本地两个分支"></a>合并本地两个分支</h1><p>如果当前分支（annotationVersion）分支，想与远程分支 master 合并（merge），可以使用如下命令：</p><p>切换到 master 分支：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923161205.png" alt="master分支"></p><p>在 master 分支合并另一个分支（annotationVersion）：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923161241.png" alt="合并完成"></p><p>随后可以将master分支 push 掉（用来提交两个合并了仓库）：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923161838.png" alt="push完成"></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-theme-matery使用手册</title>
      <link href="/2020/07/19/hexo-theme-%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
      <url>/2020/07/19/hexo-theme-%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h4 id="修改头部的渐变颜色"><a href="#修改头部的渐变颜色" class="headerlink" title="修改头部的渐变颜色"></a>修改头部的渐变颜色</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-19_18-44-57.png" alt=""></p><p>修改跟目录下的 themes\hexo-theme-matery\source\css\matery.css 文件。修改”bg-color”即可。</p><h4 id="修改底部的加载进度条"><a href="#修改底部的加载进度条" class="headerlink" title="修改底部的加载进度条"></a>修改底部的加载进度条</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-19_18-47-15.png" alt=""></p><p>修改”progress-bar”即可。</p><h4 id="修改-top-按钮颜色"><a href="#修改-top-按钮颜色" class="headerlink" title="修改 top 按钮颜色"></a>修改 top 按钮颜色</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210302145826.png" alt=""></p><p>修改”.top-scroll .btn-floating”即可</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210302145848.png" alt=""></p><h4 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h4><p>下载插件,修改配置即可。</p><pre><code>npm install hexo-generator-search --save</code></pre><p>在根目录下安装插件。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-20_08-57-52.png" alt=""></p><p>修改配置信息。</p><p>打开根目录下的 “_config.yml”文件,添加配置信息。</p><pre><code>search:  path: search.xml  field: post</code></pre><h4 id="修改友情链接"><a href="#修改友情链接" class="headerlink" title="修改友情链接"></a>修改友情链接</h4><p>在 “Blog\source\data\friends.json” 目录下修改配置文件</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595649945373.png" alt=""></p><h4 id="自动添加文章的名称、时间等信息"><a href="#自动添加文章的名称、时间等信息" class="headerlink" title="自动添加文章的名称、时间等信息"></a>自动添加文章的名称、时间等信息</h4><p>需要创建文件 “scaffolds\post.md”</p><pre><code class="yaml">---title: {{ title }}date: {{ date }}tags: [标签]author: 用户名top: falsecover: falsetoc: truemathjax: truecategories: &quot;分类&quot;---</code></pre><h4 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a>完整实例</h4><p>👇修改文章封面,修改文章轮播图等</p><pre><code class="yaml">---title: {{title}}date: {{data}}author: 作者名字img: /source/images/xxx.jpg &quot;文章特征图,路径在source中&quot;top: true &quot;推荐文章&quot;cover: true &quot;表示该文章是否需要加入到首页轮播封面中&quot;coverImg: /images/1.jpg &quot;轮播图中的封面,访问的是&quot;source&quot;下的&quot;images&quot;&quot;password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: false &quot;是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项&quot;mathjax: false &quot;是否开启数学公式支持,本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行&quot;summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---</code></pre><h4 id="banner-图片的轮播数量"><a href="#banner-图片的轮播数量" class="headerlink" title="banner 图片的轮播数量"></a>banner 图片的轮播数量</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210313183222.png" alt=""></p><p>选择主题下的 <strong>hexo-theme-matery\layout_partial\bg-cover-content.ejs</strong> 文件</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210313183501.png" alt=""></p><h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><h2 id="修改各种标题"><a href="#修改各种标题" class="headerlink" title="修改各种标题"></a>修改各种标题</h2><h3 id="修改副标题和短句"><a href="#修改副标题和短句" class="headerlink" title="修改副标题和短句"></a>修改副标题和短句</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031160424.png" alt="副标题"></p><p>修改根目录下的 “<strong>_config.xml</strong>”</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031160741.png" alt="修改副标题"></p><p>根目录下“<strong>themes\hexo-theme-matery\_config.xml</strong>”</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031161025.png" alt=""></p><p>subtitle标签负责副标题的短句。</p><h3 id="修改-“梦想”短句"><a href="#修改-“梦想”短句" class="headerlink" title="修改 “梦想”短句"></a>修改 “梦想”短句</h3><p>根目录下“<strong>themes\hexo-theme-matery\_config.xml</strong>”</p><p>dream标签负责梦想短句。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031161233.png" alt=""></p><h2 id="备份和还原Blog"><a href="#备份和还原Blog" class="headerlink" title="备份和还原Blog"></a>备份和还原Blog</h2><h3 id="备份github创建私有仓库"><a href="#备份github创建私有仓库" class="headerlink" title="备份github创建私有仓库"></a>备份github创建私有仓库</h3><p>私有仓库设置为名字Blog(与文件夹名字相同即可),将文件下载到Blog的根目录下,将”.git”文件和”.gitignore”文件拖拽到Blog目录下。</p><p>‘’.gitignore’文件内添加要忽视的文件夹</p><pre><code>.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/</code></pre><p>正常提交即可</p><p>ps:可能会出现文件夹过大的原因 </p><p><a href="https://thecara.github.io/2020/07/19/git%E8%AE%BE%E7%BD%AE%E6%8F%90%E4%BA%A4%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F/">办法</a></p><h3 id="还原Blog"><a href="#还原Blog" class="headerlink" title="还原Blog"></a>还原Blog</h3><p>建议:使用新的电脑或者使用虚拟机来测试</p><p>安装git,配置git </p><p>使用”git Bash” 输入👇.</p><pre><code>$ git config --global user.name &quot;your name&quot;$ git config --global user.email &quot;your_email@youremail.com&quot;ssh-keygen -t rsa -C &quot;自己的邮箱&quot;</code></pre><p><a href="https://github.com/settings/ssh/new" target="_blank" rel="noopener">设置SHH</a></p><p>完成后会出现shh文件的目录,打开”.pub”类型文件将内容复制到这里。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595819104102.png" alt=""></p><p>完成后克隆我们的”Blog”</p><h3 id="安装nove-js"><a href="#安装nove-js" class="headerlink" title="安装nove.js"></a>安装nove.js</h3><p>在Blog目录下使用”git Bash”</p><p>直接安装 hexo,如果网络过慢建议配置仓库.</p><pre><code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p><a href="https://developer.aliyun.com/mirror/NPM" target="_blank" rel="noopener">更多</a></p><pre><code>npm i hexo-cli -g 或者 npm install hexo --save</code></pre><p>搭建</p><pre><code class="g">hexo ghexo shexo d</code></pre><p>ps:</p><p>如果出现 “ERROR Plugin load failed: hexo-prism-plugin”错误 直接删除”node_modules\hexo-prism-plugin”下的文件夹。</p><p>安装 nove.js 自动安装choco<a href="https://thecara.github.io/2020/07/26/choco%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%89%E8%A3%85/">可能会报错使用</a></p><p>引用:<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md</a></p><h2 id="Hexo-让文章按照最新的提交时间进行排序"><a href="#Hexo-让文章按照最新的提交时间进行排序" class="headerlink" title="Hexo 让文章按照最新的提交时间进行排序"></a>Hexo 让文章按照最新的提交时间进行排序</h2><p>让我们最新提交或者更新的文章在界面的首个位置。</p><p>在主配置文件 <strong>_config.ym</strong>l, 查找 <strong>index_generator</strong> 标签 <strong>order_by</strong> 属性修改为 <strong>-updated</strong> 即可。</p><pre><code class="yaml">index_generator:  path: &#39;&#39;  per_page: 18  order_by: -updated </code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201212171501.png" alt=""></p><p>之后 </p><pre><code>hexo g</code></pre><p>完成。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在使用 目录导航时不建议 “标题” 配合 “无序列表” 使用（hexo-version:4.2）</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-8-19-0.gif" alt=""></p><p>会出现无法跳转到指定目录。</p>]]></content>
      
      
      <categories>
          
          <category> hexo-theme-matery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo-theme-matery </tag>
            
            <tag> git </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
