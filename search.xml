<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>design_pattern</title>
      <link href="/2022/08/03/design-pattern/"/>
      <url>/2022/08/03/design-pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p><a href="https://www.runoob.com/design-pattern/observer-pattern.html" target="_blank" rel="noopener">观察者模式</a></p><p>当对象间存在一对多的关系时，则使用观察者模式（Observer Patterm）。    例如：当前对象被修改时这会通知依赖它的对象。观察者模式属于行为型模式。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图</strong>:定义对象之间的一种对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并且被自动更新。</p><p><strong>主要解决</strong>:一个对象状态改变给其他对象通知的问题，而且要考虑到易用性和低耦合，保证高度的协作。</p><p><strong>何时使用</strong>:一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象)都将得到通知，进行广播通知。</p><p>如何解决当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。</p><p><strong>如何解决</strong>：使用面向对象技术，可以将这种关系弱化。</p><p><strong>关键代码</strong>：在抽象类中有一个ArrayList存放观察者。</p><p><strong>应用实例</strong>：</p><ol><li>拍卖时，拍卖师观察最高标价，然后通知其他竞价者竞价。</li><li>菩萨通过洒水招来老乌龟，老乌龟就是观察者，观察菩萨的洒水动作</li></ol><p><strong>优点</strong>：</p><ol><li>观察者和被观察者是抽象耦合的。</li><li>建立一套触发机制</li></ol><p><strong>缺点</strong>：</p><ol><li>如果一个被观察者对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li><li>如果观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅知道观察目标发送变化。</li></ol><p><strong>使用场景</strong>：</p><p>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装到独立的对象中使它们可以各自独立的改变和复用。</p><p>一个对象的改变将导致一个或多个对象也发生改变，而不知道有多少对象改变，可以降低对象之间的耦合度。</p><p>一个对象必须通知其他对象，而不知道这个对象时谁。</p><p>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……。可以使用观察者模式创建一种链式触发机制。</p><h3 id="谁是观察者谁是被观察者？"><a href="#谁是观察者谁是被观察者？" class="headerlink" title="谁是观察者谁是被观察者？"></a>谁是观察者谁是被观察者？</h3><p>当你做出了某些动作另一个人根据你的动作做出某些行为，这时你就是被观察者，另一个人是观察者。</p><h1 id="订阅-发布模式"><a href="#订阅-发布模式" class="headerlink" title="订阅-发布模式"></a>订阅-发布模式</h1><p>订阅-发布模式是观察者模式的另一个别称。</p><p>但是随着时间的变化，已经独立于观察者模式，成为另一种的设计模式。</p><p>在现在的发布订阅模式中，成为发布者的消息发送者不会将信息直接发送给订阅者，这意味这发布者和订阅者不知道彼此的存在。在发布者和订阅者之间存在第三个组件，称为调度中心或事件通道，它维持着发布者和订阅者之间的联系，过滤所有发布者传入的信息并相应的分发给它的订阅者。</p><p>例子：</p><p>你在微博关注了A，同时其他很多人也关注了A，那么当A发布动态的时候，微博就会为你推送这条动态。A就是发布者，你是订阅者，微博就是调度中心，你和A之间没有直接的消息往来，全是通过微博来协调的。</p><h1 id="委托模式"><a href="#委托模式" class="headerlink" title="委托模式"></a>委托模式</h1><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p><strong>委托模式（delegation pattern）</strong>是<a href="https://zh.wikipedia.org/wiki/软件设计模式" target="_blank" rel="noopener">软件设计模式</a>中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。</p></blockquote><h2 id="简单的Java例子"><a href="#简单的Java例子" class="headerlink" title="简单的Java例子"></a>简单的Java例子</h2><p>在这个例子里，<a href="https://zh.wikipedia.org/wiki/类" target="_blank" rel="noopener">类</a>模拟打印机Printer拥有针式打印机RealPrinter的实例，Printer拥有的<a href="https://zh.wikipedia.org/wiki/方法_(计算机科学)" target="_blank" rel="noopener">方法</a>print()将处理转交给RealPrinter的方法print()。</p><pre><code class="java"> class RealPrinter { // the &quot;delegate&quot;     void print() {        System.out.print(&quot;something&quot;);      } } class Printer { // the &quot;delegator&quot;     RealPrinter p = new RealPrinter(); // create the delegate      void print() {        p.print(); // delegation     }  } public class Main {     // to the outside world it looks like Printer actually prints.     public static void main(String[] args) {         Printer printer = new Printer();         printer.print();     } }</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-8-3-1.gif" alt="如果有些方法没有详细说明你可以自行搜索查看"></p><p><strong>参考</strong></p><p><a href="https://zh.wikipedia.org/zh-hans/%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">委托模式</a></p><p><a href="(https://www.cnblogs.com/onepixel/p/10806891.html)">观察者模式与订阅发布模式的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日遇到的问题</title>
      <link href="/2022/02/12/all-bug/"/>
      <url>/2022/02/12/all-bug/</url>
      
        <content type="html"><![CDATA[<p>💘</p>]]></content>
      
      
      <categories>
          
          <category> bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DASH协议</title>
      <link href="/2021/06/25/DASH/"/>
      <url>/2021/06/25/DASH/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-DASH"><a href="#什么是-DASH" class="headerlink" title="什么是 DASH"></a>什么是 DASH</h1><p>DASH（MPEG-DASH)是Dynamic Adaptive Straming over HTTP 的缩写，在国际标准MPEG 2014年份中推出的技术标准，目的是形成IP网络承载单一格式的流媒体并提供高效与高质量服务的统一方案，解决多制式传输方案（HTTP Live Streaming，Microsoft Smooth Streaming，HTTP Dynamic Streaming）并存格局下的存储与服务能力浪费、运营高成本与复杂度、系统间互操作弱等问题。</p><blockquote></blockquote><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://www.cnblogs.com/lidabo/p/13223961.html" target="_blank" rel="noopener">前端要懂的视频知识DASH协议</a></p>]]></content>
      
      
      <categories>
          
          <category> 流媒体 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Internet </tag>
            
            <tag> 流媒体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用shh推送文件</title>
      <link href="/2021/06/21/%E4%BD%BF%E7%94%A8shh%E6%8E%A8%E9%80%81%E6%96%87%E4%BB%B6/"/>
      <url>/2021/06/21/%E4%BD%BF%E7%94%A8shh%E6%8E%A8%E9%80%81%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="配置-SSH"><a href="#配置-SSH" class="headerlink" title="配置 SSH"></a>配置 SSH</h1><p>安装好 git 后生成SSH密钥对</p><pre><code class="sh">ssh-keygen -t rea -c &quot;你的邮箱@example.com&quot;</code></pre><p>默认（Windows）会在“用户/.ssh”文件下生成一对密钥，分别为 公钥，私钥。</p><p>私钥：id_rsa</p><p>公钥：id_rsa.pub</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210621185244.png" alt=""></p><p>打开获取<strong>公钥</strong></p><h1 id="在-github-上配置SSH"><a href="#在-github-上配置SSH" class="headerlink" title="在 github 上配置SSH"></a>在 github 上配置SSH</h1><p>登录你的 github 账号</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210621185412.png" alt="选择 Settings"></p><p>进入后点击 SSH and GPG kays</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210621185639.png" alt=""></p><p>选择 title 和 key</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210621185745.png" alt=""></p><p>添加完成后配对完成了。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210621185959.png" alt=""></p><p>输入</p><pre><code class="sh">ssh git@github.com</code></pre><p>其他操作和正常 推送，拉取一样更多的是少了验证密码。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络协议</title>
      <link href="/2021/06/05/network/"/>
      <url>/2021/06/05/network/</url>
      
        <content type="html"><![CDATA[<h1 id="网络层次划分"><a href="#网络层次划分" class="headerlink" title="网络层次划分"></a>网络层次划分</h1><p>为促使不同计算机厂家生产的计算机能够相互通信，以便建立更大范围的计算机网络，国际标准化组织（ISO）于 1978 年提出了“开放系统互联参考模型”，即OSI/RM模型（Open System Interconnection/Reference Model）。将计算机网络结构的通讯协议划分为七层，由：物理层（Physics Layer）、数据链路层（Data Link Layer）、网络层（Network Layer）、传输层（Transport Layer）、会话层（Session Layer）、表示层（Presentation Layer）、应用层（Application Layer）。其中传输层完成数据传送服务。</p><table><thead><tr><th>OSI 七层网络模型</th><th>TCP/IP四层概念模型</th><th>对应网络协议</th></tr></thead><tbody><tr><td>应用层（Application）</td><td>应用层</td><td>HTTP、TFTP、FTP、NFS、WAIS、SMTP</td></tr><tr><td>表示层（Presentation）</td><td>应用层</td><td>Telent、Rlogin、SNMP、Gopher</td></tr><tr><td>会话层（Session）</td><td>应用层</td><td>SMTP、DNS</td></tr><tr><td>传输层（Transport）</td><td>传输层</td><td>TCP、UDP、</td></tr><tr><td>网络层（Network）</td><td>网络层</td><td>IP、ICMP、ARP、RARP、AKP、UUCP</td></tr><tr><td>数据链路层（Data Link）</td><td>数据链路层</td><td>FDDI、Ethernet、Arpanet、PDN、SLIP、PPP</td></tr><tr><td>物理层（Physical）</td><td>数据链路层</td><td>IEEE 802.1A，IEEE 802.2 到 IEEE802.11</td></tr></tbody></table><p>1.<strong>物理层（Physical Layer）</strong></p><p><strong>物理层确保原始的数据可在各种物理媒体上传输。</strong></p><p>2.<strong>数据链路层（Data Link Layer）</strong></p><ul><li>数据链路层为网络层提供可靠的数据传输；</li><li>基本数据单位为帧</li><li>主要的协议：以太网协议；</li><li>两个重要设备名称：网桥和交换机。</li></ul><p>3.<strong>网络层（Network Layer）</strong></p><p>网络层的目的是实现两个端系统之间的数据同名传输，具体功能包括寻址和路由选择、链接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。</p><ul><li><p>网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网络互连等功能；</p></li><li><p>基本数据单位IP数据包；</p></li><li><p>包含主要协议：</p><p>IP协议（Internet Protocol，因特网互联协议）；</p><p>ICMP 协议（Internet Control Message Protocal，因特网控制报文协议）；</p><p>ARP 协议 （Address Resolution Protocal ，地址解析协议）；</p><p>RARP协议 （Reverse Address Resolution Protocal，逆地址解析协议）。</p></li><li><p>重要设备：路由器。</p></li></ul><h1 id="Socket-编程"><a href="#Socket-编程" class="headerlink" title="Socket 编程"></a>Socket 编程</h1><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>socket 意为“插座”，计算机领域称为“套接字”，它是计算机之间进行通讯的一种约定或一种方式，一台计算机可以接收其他计算机的数据，也可以向其它计算机发送数据。</strong></p><p>Socket 是网络编程的一个抽象概念。通常一个Socket表示“打开一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再选择协议类型。</p><p>在 socket 的案例中，服务器与浏览器：在浏览器获取用户的URL后，向服务器发送请求，服务器分析接收到的URL，将对应的网页内容返回到浏览器（客户端），浏览器再解析和渲染，将文字、图片、视频等元素呈现给用户。</p><h4 id="UNIX-Linux-中的socket！"><a href="#UNIX-Linux-中的socket！" class="headerlink" title="UNIX/Linux 中的socket！"></a>UNIX/Linux 中的socket！</h4><p>在系统中，为了统一各种硬件的操作，并简化接口，不同的硬件设备也被看成一个文件。对这些文件的操作，等同于对磁盘上普通文件的操作。</p><p>在UNIX/和Linux中会给每个文件分配一个ID，这个ID就是一个整数，被称为 文件描述符（File Descriptor）。例如：</p><ul><li>0表示一个标准输入文件（stdin），它对应的硬件设备就是键盘；</li><li>1表示一个标准输出文件（stdout），它对应的设备就是显示器；</li></ul><p>UNIX/Linux程序在执行任何形式的I/O操作时，都是在读取或者写入一个文件描述符。文件描述符是一个和打开文件相关联的整数，它背后可能是一个硬盘上的普通文件、FIFO、管道、终端、键盘、显示且等，或者网络连接。</p><p><strong>网络连接也是一个文件，它也有文件描述符！</strong></p><p>可以通过socket()函数来创建一个网络连接，或者说打开一个网络文件，socket()的返回值就是文件描述，我们可以通过普通的文件操作函数来传输数据了。</p><ul><li>用read()读取从远程计算机传来的数据；</li><li>用write()向远程计算机写入数据；</li></ul><p>使用socket()创建连接后，剩下的就是文件操作了。</p><h4 id="WIndows系统中的Socket"><a href="#WIndows系统中的Socket" class="headerlink" title="WIndows系统中的Socket()!"></a>WIndows系统中的Socket()!</h4><p>Windows 中的“文件描述符”被称为“文件句柄”。</p><p>Windows不会把Socket当作文件，会把它当作一个网络连接来对待，因此需要调用专门针对socket而设计的数据传输函数，这里就用不到针对文件操作的函数了。</p><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>在创建 TCP 连接时主动发起的叫客户端，被动响应的叫服务器。</p><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><p>服务器编程需要服务器进程绑定一个端口来监听来自其他客户端的连接。当某个客户端连接时，服务器就与该客户端建立Socket连接，随后的通讯就靠这个Socket连接。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a><strong>引用</strong></h1><p><a href="https://www.runoob.com/w3cnote/summary-of-network.html" target="_blank" rel="noopener">计算机网络基础知识总结</a> </p><p><a href="http://c.biancheng.net/view/2123.html" target="_blank" rel="noopener">socket是什么？套接字是什么？</a></p>]]></content>
      
      
      <categories>
          
          <category> Internet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Internet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于链式调用</title>
      <link href="/2021/03/19/%E5%85%B3%E4%BA%8E%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/"/>
      <url>/2021/03/19/%E5%85%B3%E4%BA%8E%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是链式调用"><a href="#什么是链式调用" class="headerlink" title="什么是链式调用"></a>什么是链式调用</h1><p>当调用的样式为这样时。</p><blockquote><p>可以不受限制的通过”.”操作符调用方法。</p><pre><code class="java">a.b().c()</code></pre><p>此方法起源于 java8</p></blockquote><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><blockquote><p>每个方法返回对象本身即可</p><pre><code class="java">public class Book{    private String name;    private String author;    public static create(){        return new Student();    }    public void setName(String name){        this.name = name;     }    public void setAuthor(String author){        this.age = age;     }    public Student name(String name){        this.name = name;         return this;    }    public Student author(String author){        this.author = author;         return this;    }}</code></pre><pre><code class="java">/*    调用    */public class Main{    public static void main(String[] ages){        Book b = new Book()        b.setName(&quot;链式调用&quot;)        b.setAuthor(&quot;TheCara&quot;)        Book b2 = Book.create().name(&quot;集合&quot;).author(&quot;网友&quot;)    }}</code></pre><p><strong>优缺点</strong></p><p>优：方法关系联系紧密，简洁。</p><p>缺：方法之间依赖于上一个方法，返回空指针会报错。</p></blockquote><h1 id="静态使用"><a href="#静态使用" class="headerlink" title="静态使用"></a>静态使用</h1><p>引用：</p><p><a href="https://blog.ahao.moe//posts/what_is_Methods_Chaining_in_Java.html" target="_blank" rel="noopener"><strong>什么是链式调用</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android PendingIntent</title>
      <link href="/2020/12/07/Android-PendingIntent/"/>
      <url>/2020/12/07/Android-PendingIntent/</url>
      
        <content type="html"><![CDATA[<h1 id="PendingIntent"><a href="#PendingIntent" class="headerlink" title="PendingIntent"></a>PendingIntent</h1><blockquote><p>描述</p><p>A description of an Intent and target action to perform with it. Instances of this class are created with <code>getActivity</code>, <code>getActivities</code>, <code>getBroadcast</code>, and <code>getService</code>; the returned object can be handed to other applications so that they can perform the action you described on your behalf at a later time.</p><p>它由getActivity，getService，getBroadcast来创建对象。</p><p>用于一种特殊的异步处理机制。可归结为 “异步激发”，这种异步激发常常是要跨进程执行的。比如说 A进程作为发起段，它可以从系统获得一个PendingIntent，然后A进程可以将PendingIntent对象通过binder机制“传递“给B进程，再通过B进程在未来的某个合适时机，”回调“PendingIntent对象的send()动作，完成激发。</p><p>PendingIntent的生命周期不与主进程相关。外部程序只能调用上述三个组件。</p></blockquote><h4 id="getActivity"><a href="#getActivity" class="headerlink" title="getActivity"></a>getActivity</h4><pre><code class="kotlin">static fun getActivity(    context: Context!,     requestCode: Int,     intent: Intent!,     flags: Int): PendingIntent!</code></pre><blockquote><p>Retrieve a PendingIntent that will start a new activity, like calling <code>Context#startActivity(Intent)</code>. Note that the activity will be started outside of the context of an existing activity, so you must use the <code>Intent#FLAG_ACTIVITY_NEW_TASK</code> launch flag in the Intent.</p><p>获得一个用于启动特定Activity的PendingIntent。</p></blockquote><h4 id="三个返回需要用到的参数"><a href="#三个返回需要用到的参数" class="headerlink" title="三个返回需要用到的参数"></a>三个返回需要用到的参数</h4><ul><li>context：上下文对象</li><li>requstCode：请求码，发件人的私人请求代码（当前未使用）</li><li>intent：请求意图。用于要指明要启动的类以及数据的传递</li><li>flags：这是一个关键的标志位</li></ul><h4 id="flags常量"><a href="#flags常量" class="headerlink" title="flags常量"></a>flags常量</h4><p>FLAG_CANCEL_CURRENT</p><pre><code class="kotlin">static val FLAG_CANCEL_CURRENT: Int</code></pre><blockquote><p>Flag indicating that if the described PendingIntent already exists, the current one should be canceled before generating a new one. For use with <code>getActivity</code>, <code>getBroadcast</code>, and <code>getService</code>.</p><p>如果新请求的 PendingIntent 发现已经存在时，取消已存在的，用新的 PendingInent 替换</p></blockquote><p>FLAG_IMMUTABLE</p><pre><code class="kotlin">static val FLAG_IMMUTABLE: Int</code></pre><blockquote><p>Flag indicating that the created PendingIntent should be immutable. This means that the additional intent argument passed to the send methods to fill in unpopulated properties of this intent will be ignored.</p><p>表示这是一个不可变的 PendingIntent。</p></blockquote><p>FLAG_NO_CREATE</p><pre><code>static val FLAG_NO_CREATE: Int</code></pre><blockquote><p>Flag indicating that if the described PendingIntent does not already exist, then simply return null instead of creating it. For use with <code>getActivity</code>, <code>getBroadcast</code>, and <code>getService</code>.</p><p>如果新请求的 PendingIntent 发现已经存在时，忽视新请求的，继续使用已经存在的请求。较少使用。</p></blockquote><p>FLAG_ONE_SHOT</p><pre><code class="kotlin">static val FLAG_ONE_SHOT: Int</code></pre><blockquote><p>Flag indicating that this PendingIntent can be used only once. For use with <code>getActivity</code>, <code>getBroadcast</code>, and <code>getService</code>.</p><p>表示 PendingIntent 只能使用一次，如果已经使用过，那么 getxxx方法时会返回为NULL，也就是说同类通知只能使用一次，后续的通知单独后无法打开。</p></blockquote><p>FLAG_UPDATE_CURRENT</p><pre><code>static val FLAG_UPDATE_CURRENT: Int</code></pre><blockquote><p>Flag indicating that if the described PendingIntent already exists, then keep it but replace its extra data with what is in this new Intent. For use with <code>getActivity</code>, <code>getBroadcast</code>, and <code>getService</code>.</p><p>如果新的请求的PendingIntent 发现已经存在时，如果 Intent 有字段改变了，则更新已存在的 PendingIntent</p></blockquote><h4 id="引用"><a href="#引用" class="headerlink" title="引用:"></a>引用:</h4><p><a href="https://developer.android.com/reference/kotlin/android/app/PendingIntent" target="_blank" rel="noopener">PendingIntent</a></p><p><a href="https://www.jianshu.com/p/a37f0ce2da2e" target="_blank" rel="noopener">PendingIntent的基本理解</a></p><p><a href="https://www.jianshu.com/p/4a8fc0b78094" target="_blank" rel="noopener">Android PendingIntent</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android-PackageManager</title>
      <link href="/2020/12/07/PackageManager/"/>
      <url>/2020/12/07/PackageManager/</url>
      
        <content type="html"><![CDATA[<h1 id="PackageManager"><a href="#PackageManager" class="headerlink" title="PackageManager"></a>PackageManager</h1><blockquote><p>Class for retrieving various kinds of information related to the application packages that are currently installed on the device. You can find this class through <code>Context#getPackageManager</code>.</p><p>PackageManager 负责管理应用程序安装、卸载和升级的API。</p></blockquote><h4 id="getLaunchIntentForPackage"><a href="#getLaunchIntentForPackage" class="headerlink" title="getLaunchIntentForPackage"></a>getLaunchIntentForPackage</h4><pre><code class="kotlin">abstract fun getLaunchIntentForPackage(packageName: String): Intent?</code></pre><blockquote><p>Returns a “good” intent to launch a front-door activity in a package. This is used, for example, to implement an “open” button when browsing through packages. The current implementation looks first for a main activity in the category <code>Intent#CATEGORY_INFO</code>, and next for a main activity in the category <code>Intent#CATEGORY_LAUNCHER</code>. Returns <code>null</code> if neither are found.</p><p>负责获得应用程序Launch的Intent。</p><p>返回一个“包”中的入口Activity的Intent，例如，这个类似于在浏览包的“打开”按钮。这个当前的安装启动第一步在category(CATEGORY_INFO)中寻找main Activity，然后category(CATEGORY_LAUNCHER)寻找main Activity。如果找不到返回 null。</p></blockquote><h5 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h5><p><a href="https://developer.android.com/reference/kotlin/android/content/pm/PackageManager" target="_blank" rel="noopener">PackageManager</a></p><p><a href="https://www.jianshu.com/p/c56376916d5e" target="_blank" rel="noopener">APK安装流程详解2——PackageManager简介</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Docs</title>
      <link href="/2020/12/02/AndroidDocs/"/>
      <url>/2020/12/02/AndroidDocs/</url>
      
        <content type="html"><![CDATA[<h1 id="android-support-v4-media"><a href="#android-support-v4-media" class="headerlink" title="android.support.v4.media"></a>android.support.v4.media</h1><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><h2 id="MediaControllerCompat-类"><a href="#MediaControllerCompat-类" class="headerlink" title="MediaControllerCompat 类"></a>MediaControllerCompat 类</h2><blockquote><p>属于 media.session 包下。</p><p>允许应用与正在进行的媒体会话进行互动。</p></blockquote><table><thead><tr><th align="center">方法名</th><th align="center">参数</th><th align="center">描述</th><th align="center">返回值</th></tr></thead><tbody><tr><td align="center">getMetadata</td><td align="center">无</td><td align="center">获取此会话的当前元数据。</td><td align="center">返回MediadataCompat类</td></tr><tr><td align="center">getSessionActivity</td><td align="center">无</td><td align="center">获得与启动会话关联的用户界面的意图（如果存在的话）</td><td align="center">PendingIntent意图或者null</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h4 id="playFromMediaId"><a href="#playFromMediaId" class="headerlink" title="playFromMediaId"></a>playFromMediaId</h4><blockquote><p>请求播放器开始播放一个特定的URI连接</p><p>@param mediaId 请求媒体的uri。</p><p>@param extras可选附加项，可以包含额外的信息</p><p>关于要播放的媒体项目。</p></blockquote><pre><code class="java">public abstract void playFromMediaId(String mediaId, Bundle extras);</code></pre><h2 id="MediaSessionCompat-类"><a href="#MediaSessionCompat-类" class="headerlink" title="MediaSessionCompat 类"></a>MediaSessionCompat 类</h2><blockquote><p>Allows interaction with media controllers, volume keys, media buttons, and transport controls.</p><p>允许与媒体控制器，音量键，媒体按钮和传输控件进行交互。</p><p>当应用程序想要发布媒体播放信息或处理媒体密钥时，应创建MediaSession。 一般来说，一个应用程序只需要一个会话进行所有播放，但可创建多个会话来提供更精细的媒体控制。</p><p>一旦创建会话，会话的所有者可以将其 <code>session token</code>传递给其他进程，以允许他们创建 <code>MediaControllerCompat</code>与会话进行交互。</p><p>要接收命令，媒体密钥和其他事件， <code>MediaSessionCompat.Callback</code>必须使用 <code>setCallback(Callback)</code>进行设置。</p><p>当应用程序完成播放时，它必须调用 <code>release()</code>来清理会话并通知任何控制器。</p><p>MediaSessionCompat对象不是线程安全的，所有调用都应该使用同一个线程。</p><p>这是帮助您以向后兼容的方式访问API级别4之后引入的 <code>MediaSession</code>功能。</p><p>ps:摘自 <a href="https://www.apiref.com/android-zh/android/support/v4/media/session/MediaSessionCompat.html" target="_blank" rel="noopener">apiref</a></p></blockquote><p><strong>构造方法</strong></p><p><strong>MediaSessionCompat</strong></p><pre><code>MediaSessionCompat(@NonNull context: Context, @NonNull tag: String)</code></pre><blockquote><p>Creates a new session. You must call <code>release()</code> when finished with the session.</p><p>创建对象。在完成时要调用release()释放。</p><p>参数1：创建Session的上下文</p><p>参数2：调试时所用的 tag。</p></blockquote><p><strong>MediaSessionCompat</strong></p><pre><code>MediaSessionCompat(@NonNull context: Context, @NonNull tag: String, @Nullable mbrComponent: ComponentName?, @Nullable mbrIntent: PendingIntent?)</code></pre><blockquote><p>Creates a new session with a specified media button receiver (a component name and/or a pending intent). You must call <code>release()</code> when finished with the session.</p><p>指定一个媒体接收器来创建对象。在完成时要调用release()释放。</p><p>参数1：创建Session的上下文</p><p>参数2：调试时所用的 tag。</p><p>参数3：指定媒体接收器的名称</p><p>参数4：处理媒体按钮事件的接收器组件。可选选项。</p></blockquote><p><strong>setSessionToken</strong></p><pre><code>open fun setSessionToken(token: MediaSessionCompat.Token!): Unit</code></pre><blockquote><p>Call to set the media session.</p><p>This should be called as soon as possible during the service’s startup. It may only be called once.</p><p>呼叫设置媒体会话。</p><p>这应该在服务启动期间尽快调用。 它只能被调用一次。</p></blockquote><p><strong>getSessionToken</strong></p><pre><code>@Nullable open fun getSessionToken(): MediaSessionCompat.Token?</code></pre><blockquote><p>Gets the session token, or null if it has not yet been created or if it has been destroyed.</p><p>获取会话标记，如果尚未创建或已销毁它，则为null。</p></blockquote><p><strong>setSessionActivity</strong></p><p>PendingInten pi：启动到这个会话。</p><pre><code>void setSessionActivity (PendingIntent pi)    </code></pre><blockquote><p>为此会话设置启动用户界面的意图。 这可以用作到正在进行的媒体屏幕的快速链接。 意图应该是针对可能使用<code>startActivity(Intent)</code>开始的活动。</p></blockquote><h2 id="媒体浏览器服务-MediaBrowserService"><a href="#媒体浏览器服务-MediaBrowserService" class="headerlink" title="媒体浏览器服务 MediaBrowserService"></a>媒体浏览器服务 MediaBrowserService</h2><h4 id="关键类型"><a href="#关键类型" class="headerlink" title="关键类型"></a>关键类型</h4><ol><li>MediaBrowserServiceCompat 媒体浏览器服务</li><li>MediaBrowserCompat 媒体浏览器</li><li>MediaControllerCompat 媒体控制器</li><li>MediaSessionCompat 媒体会话</li></ol><h2 id="MediaBrowserServiceCompat"><a href="#MediaBrowserServiceCompat" class="headerlink" title="MediaBrowserServiceCompat"></a>MediaBrowserServiceCompat</h2><blockquote><p>作用</p><p>音乐播放后台服务。</p><p>客户端中获取音乐数据的服务，所有的音乐数据都通过该服务与服务端进行交互获取。</p></blockquote><p>该类是Service类的子类，可以作为一个后台服务来使用，它实现后台服务并不能通过自身直接实现，而是通过MediaSessionCompat媒体会话来实现的。在使用过程中会话会与该服务关联起来，所有的播放操作都要给MediaSessionCompat实现。</p><p>获得数据时，通过 <strong>MediaBrowserServiceCompat</strong> 的两个方法来实现控制</p><pre><code class="kotlin">@Nullable abstract fun onGetRoot(    @NonNull clientPackageName: String,     clientUid: Int,     @Nullable rootHints: Bundle?): MediaBrowserServiceCompat.BrowserRoot?</code></pre><blockquote><p>调用以获取特定客户端浏览的根信息。</p><p>此方法自在服务连接时调用，如果返回一个 rootId为空的BrowserRoot则表示客户端可以连接服务，也可以连接其媒体资源</p><p>如果返回null则表示客户端不能连接媒体资源</p></blockquote><pre><code class="kotlin">abstract fun onLoadChildren(    @NonNull parentId: String,     @NonNull result: MediaBrowserServiceCompat.Result&lt;MutableList&lt;MediaBrowserCompat.MediaItem!&gt;!&gt;): Unit</code></pre><blockquote><p>来获取有关媒体项目的子信息。</p><p>此方法中的 parentId 与上面的方法 onGetRoot 中返回的RootId没有关系，客户端连接后，它可以通过重复调用MediaBrowserCompat.subscribe()方法来发起数据请求。而每次调用subscribe()方法都会返回onLoadChildren()回调到该service中，然后返回MediaBrowser.MediaItem()对象列表</p><p>每个MediaItem都有唯一的Id字符串，它其实是一个隐式的token。当客户想打开子菜单或者播放item时，它就将ID传入。</p></blockquote><h2 id="MediaBrowserServiceCompat-BrowserRoot-抽象类"><a href="#MediaBrowserServiceCompat-BrowserRoot-抽象类" class="headerlink" title="MediaBrowserServiceCompat.BrowserRoot 抽象类"></a>MediaBrowserServiceCompat.BrowserRoot 抽象类</h2><blockquote><p>包含浏览器首次连接客户端的信息。</p></blockquote><table><thead><tr><th align="center">修饰符</th><th align="center">（构造）方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"></td><td align="center">MediaBrowserServiceCompat.BrowserRoot(String rootId,Bundle extras)</td><td align="center">rootId：浏览的根ID。extras：浏览器的附加功能。</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="MediaBrowserServiceCompat-Result-类"><a href="#MediaBrowserServiceCompat-Result-类" class="headerlink" title="MediaBrowserServiceCompat.Result 类"></a>MediaBrowserServiceCompat.Result 类</h2><blockquote><p>异步回调方法的完成处理程序</p></blockquote><table><thead><tr><th align="center">修饰符</th><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">sendResult(T result)</td><td align="center">将结果发送给调用者</td></tr><tr><td align="center">void</td><td align="center">detach()</td><td align="center">分离线程消息，并允许稍后进行sendResult(T)调用。</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="MediaBrowserCompat"><a href="#MediaBrowserCompat" class="headerlink" title="MediaBrowserCompat"></a>MediaBrowserCompat</h2><h3 id="MediaBrowserCompat-MediaItem常量"><a href="#MediaBrowserCompat-MediaItem常量" class="headerlink" title="MediaBrowserCompat.MediaItem常量"></a>MediaBrowserCompat.MediaItem常量</h3><blockquote><p>一个包含单个媒体项目信息的类，用于浏览媒体。</p></blockquote><p><strong>常量</strong></p><h4 id="FLAG-PLAYABLE"><a href="#FLAG-PLAYABLE" class="headerlink" title="FLAG_PLAYABLE"></a>FLAG_PLAYABLE</h4><pre><code class="java">int FLAG_PLAYABLE</code></pre><p>标志：表示该项目可以播放。</p><h4 id="FLAG-BROWSABLE"><a href="#FLAG-BROWSABLE" class="headerlink" title="FLAG_BROWSABLE"></a>FLAG_BROWSABLE</h4><pre><code>int FLAG_BROWSABLE</code></pre><p>标志：表示该项目有其自己的子项。</p><blockquote></blockquote><h2 id="MediaSessonCompat-Token类"><a href="#MediaSessonCompat-Token类" class="headerlink" title="MediaSessonCompat.Token类"></a>MediaSessonCompat.Token类</h2><p>运行中的Token。表示可能会被会话的所有者传递给应用程序，以允许创建一个MediaControllerCompat与会话进行通信。</p><h2 id="MediaMetadataCompat"><a href="#MediaMetadataCompat" class="headerlink" title="MediaMetadataCompat"></a>MediaMetadataCompat</h2><blockquote><p>包含有关项目的元数据，例如标题，艺术家等</p></blockquote><p><strong>各个常量</strong></p><table><thead><tr><th align="center">类型</th><th></th></tr></thead><tbody><tr><td align="center">string</td><td><code>METADATA_KEY_ALBUM</code>媒体专辑标题。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_ALBUM_ART</code>媒体原始资料专辑的作品为 <code>Bitmap</code> 。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_ALBUM_ARTIST</code>媒体原始资料专辑的艺术家。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_ALBUM_ART_URI</code>作为Uri风格字符串的媒体原始源相册的图片。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_ART</code>媒体作品为 <code>Bitmap</code> 。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_ARTIST</code>媒体艺术家。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_ART_URI</code>媒体的作品是Uri风格的字符串。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_AUTHOR</code>媒体的作者。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_COMPILATION</code>媒体的编辑状态。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_COMPOSER</code>媒体的作曲家。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_DATE</code>媒体创建或发布的日期。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_DISC_NUMBER</code>媒体原始来源的光盘号码。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_DISPLAY_DESCRIPTION</code>适合向用户显示的说明。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_DISPLAY_ICON</code>适合向用户显示的图标或缩略图。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_DISPLAY_ICON_URI</code>适合向用户显示的图标或缩略图。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_DISPLAY_SUBTITLE</code>适合向用户显示的字幕。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_DISPLAY_TITLE</code>适合向用户显示的标题。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_DURATION</code>媒体的持续时间以毫秒为单位。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_GENRE</code>媒体的流派。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_MEDIA_ID</code>用于识别内容的字符串键。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_NUM_TRACKS</code>媒体原始来源中的曲目数量。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_RATING</code>媒体整体评分。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_TITLE</code>媒体的标题。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_TRACK_NUMBER</code>媒体的曲目号码。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_USER_RATING</code>用户对媒体的评分。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_WRITER</code>媒体的作者。</td></tr><tr><td align="center">string</td><td><code>METADATA_KEY_YEAR</code>媒体创建或发布的一年。</td></tr></tbody></table><table><thead><tr><th align="center">方法名</th><th align="center">参数</th><th align="center">描述</th><th align="center">返回值</th></tr></thead><tbody><tr><td align="center">getDescription</td><td align="center">无</td><td align="center">为显式，返回次元数据的简单描述</td><td align="center">MediaDescriptionCompat!</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="MediaDescriptionCompat"><a href="#MediaDescriptionCompat" class="headerlink" title="MediaDescriptionCompat"></a>MediaDescriptionCompat</h2><blockquote><p>适合显示的媒体项目的一组简单元数据。 这可以使用Builder创建，也可以使用<code>getDescription()</code>从现有元数据中<code>getDescription()</code> 。</p></blockquote><h2 id="PlaybackStateCompat-类"><a href="#PlaybackStateCompat-类" class="headerlink" title="PlaybackStateCompat 类"></a>PlaybackStateCompat 类</h2><blockquote><p>存放状态的常量类</p></blockquote><table><thead><tr><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_FAST_FORWARD</code>表示此会话支持快进命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_PAUSE</code>表示此会话支持暂停命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_PLAY</code>表示此会话支持播放命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_PLAY_FROM_MEDIA_ID</code>表示此会话支持从媒体id命令播放。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_PLAY_FROM_SEARCH</code>表示此会话支持来自搜索命令的播放。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_PLAY_FROM_URI</code>表示此会话支持来自URI命令的播放。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_PLAY_PAUSE</code>表示此会话支持播放/暂停切换命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_PREPARE</code>表示此会话支持prepare命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_PREPARE_FROM_MEDIA_ID</code>指示此会话支持从媒体id命令准备。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_PREPARE_FROM_SEARCH</code>表示此会话支持从搜索命令准备。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_PREPARE_FROM_URI</code>表示此会话支持从URI准备命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_REWIND</code>表示此会话支持倒带命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_SEEK_TO</code>表示此会话支持寻求命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_SET_RATING</code>表示此会话支持set rating命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_SKIP_TO_NEXT</code>表示此会话支持下一个命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_SKIP_TO_PREVIOUS</code>指示此会话支持上一个命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_SKIP_TO_QUEUE_ITEM</code>表示此会话支持跳转到队列项目命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>ACTION_STOP</code>表示此会话支持停止命令。</td></tr><tr><td align="center"><code>long</code></td><td align="center"><code>PLAYBACK_POSITION_UNKNOWN</code>使用此值表示位置未知。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>STATE_BUFFERING</code>指示此项目的状态当前正在缓冲，并且将在足够的数据已经缓冲时开始播放。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>STATE_CONNECTING</code>指示正在进行回放的班级的状态当前正在连接到路线。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>STATE_ERROR</code>指示此项目的状态当前处于错误状态。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>STATE_FAST_FORWARDING</code>指示此项目的状态当前正在快进。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>STATE_NONE</code>这是默认的播放状态，表示尚未添加媒体，或者表演者已重置且没有要播放的内容。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>STATE_PAUSED</code>指示此项目的状态当前已暂停。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>STATE_PLAYING</code>指示此项目正在播放的状态。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>STATE_REWINDING</code>指示此项目的状态当前正在倒带。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>STATE_SKIPPING_TO_NEXT</code>表示玩家正在跳到下一个项目的状态。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>STATE_SKIPPING_TO_PREVIOUS</code>显示玩家当前正在跳到前一个项目的状态。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>STATE_SKIPPING_TO_QUEUE_ITEM</code>指示玩家当前正在跳到队列中特定项目的状态。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>STATE_STOPPED</code>指示此项目的状态当前已停止。</td></tr></tbody></table><h4 id="getLastPositionUpdateTime-方法"><a href="#getLastPositionUpdateTime-方法" class="headerlink" title="getLastPositionUpdateTime 方法"></a>getLastPositionUpdateTime 方法</h4><blockquote><ul><li><p>Get the elapsed real time at which position was last updated.</p><p>获取最后一次更新位置的实时时间。</p></li><li><p>If the position has never been set this will return 0;</p><p>如果位置没有被设置，这个将返回0;</p></li></ul></blockquote><pre><code class="kotlin">fun getLastPositionUpdateTime(): Long</code></pre><p><strong>返回值</strong></p><blockquote><p>The last time the position was updated.</p><p>最后一次更新位置的时间。</p></blockquote><h4 id="getPosition-方法"><a href="#getPosition-方法" class="headerlink" title="getPosition 方法"></a>getPosition 方法</h4><blockquote><p>Get the playback position in ms at last position update time.</p><p>在最后一次位置更新时，以ms为单位获得播放位置。</p></blockquote><pre><code class="kotlin">fun getPosition(): Long</code></pre><h4 id="getPlaybackSpeed-方法"><a href="#getPlaybackSpeed-方法" class="headerlink" title="getPlaybackSpeed 方法"></a>getPlaybackSpeed 方法</h4><blockquote><ul><li><p>Get the current playback speed as a multiple of normal playback.</p><p>将当前播放速度设置为正常播放速度的倍数。</p></li><li><p>This should be negative when rewinding.</p><p>当倒带时，这应该是负的。</p></li><li><p>A value of 1 means normal playback and 0 means paused.</p><p>1表示正常播放，0表示暂停。</p></li></ul></blockquote><pre><code class="kotlin">fun getPlaybackSpeed(): Float</code></pre><p><strong>返回值</strong></p><blockquote><p>The current speed of playback.</p><p>当前播放速度。</p></blockquote><h2 id="ServiceCompat"><a href="#ServiceCompat" class="headerlink" title="ServiceCompat"></a>ServiceCompat</h2><p>Helper用于访问在向后兼容的API级别4之后引入的 <code>Service</code>功能。</p><h1 id="com-google-android-material"><a href="#com-google-android-material" class="headerlink" title="com.google.android.material"></a>com.google.android.material</h1><h2 id="snackbar-类"><a href="#snackbar-类" class="headerlink" title="snackbar 类"></a>snackbar 类</h2><blockquote><p>Snackbars provide lightweight feedback about an operation.</p><p>snackbar提供关于操作的轻量级反馈。</p><p>They show a brief message at the bottom of the screen on mobile and lower left on larger devices.</p><p>它们会在移动设备的屏幕底部和较大设备的左下方显示一条简短的信息。</p></blockquote><h4 id="make-方法"><a href="#make-方法" class="headerlink" title="make 方法"></a><strong>make 方法</strong></h4><blockquote><p>Make a Snackbar to display a message</p><p>制作一个Snackbar来显示一条信息</p></blockquote><p><strong>返回值</strong></p><blockquote><p><a href="https://developer.android.com/reference/com/google/android/material/snackbar/Snackbar" target="_blank" rel="noopener">Snackbar</a></p></blockquote><pre><code class="java">public static Snackbar make (                View view,                 CharSequence text,                 int duration)</code></pre><p><strong>参数</strong></p><blockquote><p>view：父视图</p><p>text：格式化文本</p><p>duration：显式消息的时间</p><ul><li><code>BaseTransientBottomBar.LENGTH_SHORT</code></li><li><code>BaseTransientBottomBar.LENGTH_LONG</code></li><li><code>BaseTransientBottomBar.LENGTH_INDEFINITE</code></li></ul></blockquote><h1 id="androidx-viewpager2-widget"><a href="#androidx-viewpager2-widget" class="headerlink" title="androidx.viewpager2.widget"></a>androidx.viewpager2.widget</h1><blockquote><p>ViewPager2 replaces androidx.viewpager.widget.</p><p>ViewPager2替换androidx.viewpager.widget。</p><p>ViewPager, addressing most of its predecessor’s pain-points, including right-to-left layout support, vertical orientation, modifiable Fragment collections, etc.</p><p>ViewPager，解决了其前辈的大部分痛点，包括从右向左的布局支持，垂直方向，可修改的片段集合等</p></blockquote><h4 id="registerOnPageChangeCallback-方法"><a href="#registerOnPageChangeCallback-方法" class="headerlink" title="registerOnPageChangeCallback 方法"></a>registerOnPageChangeCallback 方法</h4><pre><code class="java">public void registerOnPageChangeCallback(    @NonNull ViewPager2.OnPageChangeCallback callback)</code></pre><blockquote><p>Add a callback that will be invoked whenever the page changes or is incrementally scrolled.</p><p>添加一个回调，该回调将在页面变动或滚动时调用。</p><p>See OnPageChangeCallback.</p><p>看到OnPageChangeCallback。</p></blockquote><h2 id="ViewPager2-OnPageChangeCallback-抽象类"><a href="#ViewPager2-OnPageChangeCallback-抽象类" class="headerlink" title="ViewPager2.OnPageChangeCallback 抽象类"></a>ViewPager2.OnPageChangeCallback 抽象类</h2><blockquote><p>Callback interface for responding to changing state of the selected page.</p><p>响应所选页面状态变化的回调接口。</p><p>内部有三个抽象方法</p></blockquote><h4 id="onPageSelected-抽象方法"><a href="#onPageSelected-抽象方法" class="headerlink" title="onPageSelected 抽象方法"></a>onPageSelected 抽象方法</h4><blockquote><p>This method will be invoked when a new page becomes selected.</p><p>当选择新页面时，将调用此方法。</p></blockquote><pre><code class="java">public void onPageSelected(int position)</code></pre><p><strong>参数</strong></p><blockquote><p>position：选定页面的位置索引</p></blockquote><h1 id="kotlinx-coroutines"><a href="#kotlinx-coroutines" class="headerlink" title="kotlinx.coroutines"></a>kotlinx.coroutines</h1><h2 id="CoroutineScope-接口"><a href="#CoroutineScope-接口" class="headerlink" title="CoroutineScope 接口"></a>CoroutineScope 接口</h2><blockquote><p>Defines a scope for new coroutines.</p><p>为新的协程定义作用域。</p></blockquote><pre><code class="kotlin">interface CoroutineScope</code></pre><h1 id="androidx-navigation"><a href="#androidx-navigation" class="headerlink" title="androidx.navigation"></a>androidx.navigation</h1><h2 id="NavController-类"><a href="#NavController-类" class="headerlink" title="NavController 类"></a>NavController 类</h2><h4 id="addOnDestinationChangedListener-方法"><a href="#addOnDestinationChangedListener-方法" class="headerlink" title="addOnDestinationChangedListener 方法"></a>addOnDestinationChangedListener 方法</h4><blockquote><p>Adds an OnDestinationChangedListener to this controller to receive a callback whenever the currentDestination or its arguments change.</p><p>向控制器添加一个OnDestinationChangedListener，以便在currentDestination或其参数改变时接收回调。</p></blockquote><pre><code class="java">public void addOnDestinationChangedListener(    @NonNull NavController.OnDestinationChangedListener listener)</code></pre><p><strong>参数</strong></p><p>listener:</p><blockquote><p>the listener to receive events</p><p>接收事件的侦听器</p></blockquote><h4 id="navigate-方法"><a href="#navigate-方法" class="headerlink" title="navigate 方法"></a>navigate 方法</h4><blockquote><ul><li><p>Navigate to a destination from the current navigation graph.</p><p>从当前导航图导航到目标。</p></li><li><p>This supports both navigating via an action and directly navigating to a destination.</p><p>这既支持通过操作导航，也支持直接导航到目的地。</p></li></ul></blockquote><pre><code class="java">@MainThreadpublic void navigate(@IdRes int resId)</code></pre><p><strong>参数</strong></p><p>resId：</p><blockquote><p>an action id or a destination id to navigate to</p><p>要导航到的操作id或目标id</p></blockquote><p><strong>报错</strong></p><blockquote><ul><li><p>kotlin.IllegalStateException</p><p>if there is no current navigation node 如果没有当前导航节点</p></li><li><p>kotlin.IllegalArgumentException</p><p>if the desired destination cannot be found from the current destination</p><p>如果无法从当前目标找到所需的目标</p></li></ul></blockquote><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="">关于媒体浏览器服务(MediaBrowserService)</a></p><p><a href="https://www.apiref.com/android-zh/index.html" target="_blank" rel="noopener">Android开发手册</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ExoPlayer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 图片适配</title>
      <link href="/2020/12/01/Android-%E5%9B%BE%E7%89%87%E9%80%82%E9%85%8D/"/>
      <url>/2020/12/01/Android-%E5%9B%BE%E7%89%87%E9%80%82%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>Android图片适配</p><p>android的drawable文件共有：</p><table><thead><tr><th>中文</th><th>文件夹名称</th></tr></thead><tbody><tr><td>低密度</td><td>drawable-ldpi</td></tr><tr><td>中等密度</td><td>drawable-mdpi</td></tr><tr><td>高密度</td><td>drawable-hdpi</td></tr><tr><td>超高密度</td><td>drawable-xhdpi</td></tr><tr><td>超超高密度</td><td>drawable-xxhdpi</td></tr><tr><td>超超超高密度</td><td>drawable-xxxhdpi</td></tr><tr><td>无缩放</td><td>drawable-nohdpi</td></tr><tr><td>默认</td><td>drawable</td></tr></tbody></table><p>Android 系统会按照设备dpi 范围从合适密度往上适配。</p><p>如果在中等分辨率的手机上，Android 就会现在 drawable-mdpi 文件夹下的图片。如果这里没有那么 drawable-hdpi 上查找以此类推最终会从默认的 drawable 文件夹下查找。</p><p>drawable-nodpi 文件夹，在这里存放的图片系统不会对它进行缩放操作，原图片有多大就会展示多大，匹配原则当匹配更高密度的图片时无法找到的话就会匹配这个文件夹的图片。</p><p>优缺点：放大图片会占用更多内存，缩小时内存减少但是影响打包效果。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android控件</title>
      <link href="/2020/11/29/Android%E6%8E%A7%E4%BB%B6/"/>
      <url>/2020/11/29/Android%E6%8E%A7%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="SeekBar-拖动条"><a href="#SeekBar-拖动条" class="headerlink" title="SeekBar(拖动条)"></a>SeekBar(拖动条)</h1><p>它是 ProgressBar的子类，这样ProgressBar的属性它都可以用！同时它还有自己的属性 android:thumb,允许我们自定义滑块。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Jetpack架构组件 Navigation 导航库</title>
      <link href="/2020/11/20/Navigation-%E5%AF%BC%E8%88%AA%E5%BA%93/"/>
      <url>/2020/11/20/Navigation-%E5%AF%BC%E8%88%AA%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="做什么的？"><a href="#做什么的？" class="headerlink" title="做什么的？"></a>做什么的？</h1><p>用于用户导航、进入或者退出应用中不同内容片段的交互。通过 Jetpack导航组件可帮助你实现导航，无论是简单的按钮点击，还是应用栏或抽屉式导航栏等复杂的模式，这个组件都可以应对。（简化了导航的实现）</p><p>将业务和视图分离。</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li>方便管理Fragment页面。</li><li>可视化页面导航，类似于xcode中的StoryBoard，便于看清页面之间的关系</li><li>通过destination和action来完成页面间的导航</li><li>方便页面切换动画</li><li>页面间内饰内饰的参数传递</li><li>通过NavigationUI类，对菜单，底部导航，抽屉菜单导航进行方便统一的管理</li><li>深层连接</li></ul><blockquote><p>本文中的”<strong>页面</strong>“指的是Fragment和Activity,但主要是Fragment，因为Navigation组件的主要目的就是方便我们在一个Activity中对多个Fragment进行管理。</p></blockquote><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><pre><code>dependencies {    implementation &quot;androidx.navigation:navigation-fragment-ktx:2.3.0&quot;    implementation &quot;androidx.navigation:navigation-ui-ktx:2.3.0&quot;}</code></pre><p><a href="https://developer.android.com/jetpack/androidx/releases/navigation?hl=zh-cn" target="_blank" rel="noopener">更多版本</a></p><h5 id="创建-Navigation-Graph"><a href="#创建-Navigation-Graph" class="headerlink" title="创建 Navigation Graph"></a>创建 Navigation Graph</h5><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123204418.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123204512.png" alt="ok 创建完成"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123204726.png" alt="创建nav_graph文件"></p><h5 id="添加-NavHostFragment"><a href="#添加-NavHostFragment" class="headerlink" title="添加 NavHostFragment"></a>添加 <strong>NavHostFragment</strong></h5><p>添加到Activity布局文件中，作为其他Fragment的容器</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;androidx.appcompat.widget.Toolbar        android:id=&quot;@+id/toolbar&quot;        android:layout_width=&quot;411dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:background=&quot;?attr/colorPrimary&quot;        android:minHeight=&quot;?attr/actionBarSize&quot;        android:theme=&quot;?attr/actionBarTheme&quot;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;        app:layout_constraintStart_toStartOf=&quot;parent&quot;        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;    &lt;fragment        android:id=&quot;@+id/frameLayout&quot;        android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;0dp&quot;        app:defaultNavHost=&quot;true&quot;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;        app:layout_constraintStart_toStartOf=&quot;parent&quot;        app:layout_constraintTop_toBottomOf=&quot;@+id/toolbar&quot;        app:navGraph=&quot;@navigation/nav_graph&quot;&gt;    &lt;/fragment&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><pre><code class="xml">android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;</code></pre><blockquote><p>告诉系统这是一个特殊的Fragment</p></blockquote><pre><code class="xml">app:defaultNavHost=&quot;true&quot;</code></pre><blockquote><p>点击返回按钮是，系统会自动将Fragment退出。</p></blockquote><pre><code class="xml"> app:navGraph=&quot;@navigation/nav_graph&quot;</code></pre><blockquote><p>对应的Fargment导航图</p></blockquote><h5 id="设置导航-Navigation"><a href="#设置导航-Navigation" class="headerlink" title="设置导航(Navigation)"></a>设置导航(Navigation)</h5><p>创建MainFragment和SecondeFragment</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123214054.png" alt=""></p><blockquote><p>destination 表示目的地，既你想要去的地方。Navigation 组件的目的就是方便开发者在一个Activity中管理多个Fragment。所以在这里创建一个MainFragment。</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123214146.png" alt="选择 Fragment"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123214359.png" alt=""></p><blockquote><p>表示首个加载的Fragment</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123214733.png" alt="选择 code"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123214811.png" alt=""></p><blockquote><p>app:startDestination = “@id/mainFragment”</p><p>表示首个加载的Fragment</p></blockquote><p>设置MainFragment界面</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;             xmlns:tools=&quot;http://schemas.android.com/tools&quot;             android:layout_width=&quot;match_parent&quot;             android:layout_height=&quot;match_parent&quot;             tools:context=&quot;.MainFragment&quot;&gt;    &lt;TextView        android:id=&quot;@+id/tvTitle&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_centerInParent=&quot;true&quot;        android:textSize=&quot;18sp&quot;        android:text=&quot;MainFragment&quot;/&gt;    &lt;Button        android:id=&quot;@+id/btnToSecondFragment&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_below=&quot;@+id/tvTitle&quot;        android:textAllCaps=&quot;false&quot;        android:text=&quot;to SecondFragment&quot;/&gt;&lt;/RelativeLayout&gt;</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123215621.png" alt=""></p><h5 id="设置跳转顺序"><a href="#设置跳转顺序" class="headerlink" title="设置跳转顺序"></a>设置跳转顺序</h5><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123215652.png" alt="ps:sscondFragment为secondFragment"></p><blockquote><p>选中mainFragment后点击方块连线到secondFragment</p></blockquote><p>可以看到 <action/>标签中，app:destination 属性表示目的地，这里表示的是secondFragment</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;navigation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/nav_graph&quot;    app:startDestination=&quot;@id/mainFragment&quot;&gt;    &lt;fragment        android:id=&quot;@+id/mainFragment&quot;        android:name=&quot;com.thecara.navigation.MainFragment&quot;        android:label=&quot;fragment_main&quot;        tools:layout=&quot;@layout/fragment_main&quot;&gt;        &lt;action            android:id=&quot;@+id/action_mainFragment_to_sscondFragment&quot;            app:destination=&quot;@id/secondFragment&quot; /&gt;    &lt;/fragment&gt;    &lt;fragment        android:id=&quot;@+id/secondFragment&quot;        android:name=&quot;com.thecara.navigation.SscondFragment&quot;        android:label=&quot;fragment_sscond&quot;        tools:layout=&quot;@layout/fragment_sscond&quot; /&gt;&lt;/navigation&gt;</code></pre><h5 id="设置跳转"><a href="#设置跳转" class="headerlink" title="设置跳转"></a>设置跳转</h5><p>使用这个来跳转</p><pre><code class="kotlin">        view.findViewById&lt;Button&gt;(R.id.btnToSecondFragment).setOnClickListener {            Navigation.findNavController(view).navigate(R.id.action_mainFragment_to_sscondFragment)        }</code></pre><blockquote><p>  Navigation.findNavController(params).navigate(id)</p><p>表示通过指定id跳转的哪里，这里指跳转到 secondeFragment。</p><p>其中还有</p><p>Navigation.findNavController(params).navigateUp()</p><p>负责向上跳转</p></blockquote><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-11-23-0.gif" alt=""></p><h1 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h1><ul><li>Navigation Graph </li></ul><p>这是一种新型的 XML 资源文件，里面包含了应用程序所有的页面及页面之间的关系</p><ul><li>NavHostFragment</li></ul><p>这是一个特殊的布局文件，NavigationGraph中的页面通过该Fragment展示</p><ul><li>NavController</li></ul><p>用于在代码中完成NavigationGraph中的具体页面切换</p><p><strong>所以，当你使用NavController对象，告诉它你想要去NavigationGraph中的那个页面，NavController将会将相关的页面展示在NavHostFragment中。</strong></p><h5 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h5><p><a href="https://developer.android.com/guide/navigation?hl=zh-cn" target="_blank" rel="noopener">导航</a></p><p><a href="https://zhuanlan.zhihu.com/p/69562454" target="_blank" rel="noopener">Navigation(一)基础入门</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Jetpack架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ExoPlayer2 Google依赖库</title>
      <link href="/2020/11/13/ExoPlayer2-Google%E4%BE%9D%E8%B5%96%E5%BA%93/"/>
      <url>/2020/11/13/ExoPlayer2-Google%E4%BE%9D%E8%B5%96%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>ExoPlayer构建在Android低水平媒体API之上的一个应用层媒体播放器。支持内置播放器的所有格式外加自适应格式DASH和SmoothStreaming。所有它可以高度定制和扩展。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><strong>1.添加依赖</strong></p><p>在项目的根目录下 打开 build.gradle 中添加Google和JCenter库。</p><blockquote><p>创建android 项目时 AndroidStudio 会自动添加，在这里提一下。</p></blockquote><pre><code class="groovy">repositories {    google()    jcenter()}</code></pre><ol start="2"><li>在 app module <strong>中添加依赖项</strong>。</li></ol><pre><code class="groovy">implementation &#39;com.google.android.exoplayer:exoplayer:2.X.X&#39;</code></pre><p><strong>2.x.x</strong>替换为首选的最新版本(<a href="https://github.com/google/ExoPlayer/blob/release-v2/RELEASENOTES.md" target="_blank" rel="noopener">ExoPlayer</a>)</p><p>作为完整库的代替方案，可以根据实际需要的库模块。例如，以下内容对Core,DASH和UI库模块的依赖关系，这可能时播放DASH内容的应用程序所需要的。</p><pre><code class="groovy">implementation &#39;com.google.android.exoplayer:exoplayer-core:2.X.X&#39;implementation &#39;com.google.android.exoplayer:exoplayer-dash:2.X.X&#39;implementation &#39;com.google.android.exoplayer:exoplayer-ui:2.X.X&#39;</code></pre><p>可用的库模块在下列出。</p><ul><li><strong>exoplayer-core</strong>：核心功能（必须）。</li><li><strong>exoplayer-dash</strong>：支持DASH内容。</li><li><strong>exoplayer-hls</strong>：支持HLS内容。</li><li><strong>exoplayer-smoothstraming</strong>：支持SmoothStreaming内容。</li><li><strong>exoplayer-ui</strong>：与ExoPlayer一起使用的UI组件和资源。</li></ul><p><a href="https://github.com/google/ExoPlayer/tree/release-v2/extensions/" target="_blank" rel="noopener">更多的扩展模块</a>。</p><p><strong>3.Java8</strong></p><p>在 app 目录下添加 一下内容供所有文件支持Java8</p><pre><code class="groovy">compileOptions {  targetCompatibility JavaVersion.VERSION_1_8}</code></pre><h2 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h2><pre><code class="xml">    &lt;com.google.android.exoplayer2.ui.PlayerView        android:id=&quot;@+id/playerView&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot; /&gt;</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210621172138.png" alt=""></p><h1 id="DOC"><a href="#DOC" class="headerlink" title="DOC"></a>DOC</h1><h1 id="AudioAttributes-Builder-类"><a href="#AudioAttributes-Builder-类" class="headerlink" title="AudioAttributes.Builder() 类"></a><strong>AudioAttributes.Builder() 类</strong></h1><blockquote><p>用于音频回放的属性，用于配置平台下的AudioTrack。</p><p>如果你要设置音频属性，需要创建一个 AudioAttributes实例。</p></blockquote><ul><li><strong>setContentText(int contentType)</strong></li></ul><blockquote><p>设置描述音频信号内容类型的属性。如语言或音乐。</p></blockquote><ul><li><strong>setUsage(int contentType)</strong></li></ul><blockquote><p>设置描述音频信号用途的属性，例如报警或者铃声。</p></blockquote><ul><li><strong>build()方法</strong></li></ul><blockquote><p>构建器创建一个 AudioAttributes 实例。</p></blockquote><h1 id="C-类"><a href="#C-类" class="headerlink" title="C 类"></a>C 类</h1><blockquote><p>定义标准库的常量</p></blockquote><ul><li><strong>C.CONTENT_TYPE_MUSIC</strong></li></ul><blockquote><p>C 类的常量用于</p><p>在你使用内容类型为音乐时使用的内容类型值。</p></blockquote><ul><li><strong>C.USAGE_MEDIA</strong></li></ul><blockquote><p>当使用媒体是使用这个值(如音乐或者电影原声带)</p></blockquote><h1 id="SimpleExoPlayer-类"><a href="#SimpleExoPlayer-类" class="headerlink" title="SimpleExoPlayer 类"></a>SimpleExoPlayer 类</h1><blockquote><p>实现组件的外部播放。</p><p>用SimpleExoPlayer.Build(context:Context)来实现</p></blockquote><ul><li><strong>build()方法</strong></li></ul><blockquote><p>构建器创建一个 SimpleExoPlayer实例。</p></blockquote><ul><li><strong>setAudioAttributes()</strong></li></ul><blockquote><p>设置音轨使用的音频回放属性。如果没有设置，将使用默认的属性。它们一般设置为媒体播放。设置回放音频属性期间可能回在输出中引入一个短间隙，因为音频轨道被重新创建。还生成一个新的音频会话id。如果音轨是由音轨选择器启用的，指定的音频属性将被忽视，但是当它播放时没有音轨那么指定属性将会被使用。</p><p>If the device is running a build before platform API version 21, audio attributes cannot be set directly on the underlying audio track. In this case, the usage will be mapped onto an equivalent stream type using Util.getStreamTypeForAudioUsage(int).</p><p>If audio focus should be handled, the AudioAttributes.usage must be C.USAGE_MEDIA or C.USAGE_GAME. Other usages will throw an IllegalArgumentException.</p><p><strong>Parameters:</strong></p><p><code>audioAttributes</code> - The attributes to use for audio playback. 用于音频回放的属性</p><p><code>handleAudioFocus</code> - True if the player should handle audio focus, false other wise.    用户处理音轨焦点时选择 true。</p></blockquote><ul><li><strong>setHandleAudioBecomingNoisy(boolean handleAudioBecomingNoisy)</strong></li></ul><blockquote><p>设置当前的音频从耳机重新定向到扬声器事，播放器是否应该暂停。</p><p>默认不启用。false</p><p>Sets whether the player should pause automatically when audio is rerouted from a headset to device speakers.</p><p><strong>Parameters:</strong></p><p><code>handleAudioBecomingNoisy</code> - Whether the player should pause automatically when audio is rerouted from a headset to device speakers.</p></blockquote><p><strong>方法</strong></p><table><thead><tr><th align="center">返回值类型</th><th align="center">方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">setPlayWhenReady(boolean playWhenReady)</td><td align="center">playWhenReady:准备好后时候播放。如果播放器已处于就绪状态，则将暂停改为播放。</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="DefaultDataSourceFactory-类"><a href="#DefaultDataSourceFactory-类" class="headerlink" title="DefaultDataSourceFactory  类"></a>DefaultDataSourceFactory  类</h1><blockquote><p>创建工厂，将非文件的数据委托到 DetaultHttpDataSources。</p><p>Factory that produces DefaultDataSource instances that delegate to DefaultHttpDataSources for non-file/asset/content URIs.</p></blockquote><ul><li><strong>DefaultDataSourceFactory(Context context,String userAgent)</strong></li></ul><blockquote><p>创建 DetaultDataSourceFactory 类实例</p><p><strong>Parameters:</strong></p><p><code>context</code> - A context.</p><p><code>userAgent</code> - The User-Agent string that should be used. 使用用户代理</p></blockquote><ul><li><strong>Util.getUserAgent(Context context,String applicationName)</strong></li></ul><blockquote><p>根据给定的应用程序名词和库版本返回用户代理的字符串。</p><p>Returns a user agent string based on the given application name and the library version.</p><ul><li><p><strong>Parameters:</strong></p><p><code>context</code> - A valid context of the calling application. 当前 app 上下文</p><p><code>applicationName</code> - String that will be prefix’ed to the generated user agent.</p></li></ul></blockquote><h1 id="MediaSessionConnector-类"><a href="#MediaSessionConnector-类" class="headerlink" title="MediaSessionConnector 类"></a>MediaSessionConnector 类</h1><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201204220725.png" alt="继承关系"></p><blockquote><p>介绍</p><p>Connects a MediaSessionCompat to a <a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/Player.html" target="_blank" rel="noopener"><code>Player</code></a>.</p><p>负责连接到 MediaSessionCompat 类</p></blockquote><pre><code class="java">public MediaSessionConnector(android.support.v4.media.session.MediaSessionCompat mediaSession)</code></pre><blockquote><p><code>mediaSession</code> - The <a href="https://developer.android.com/reference/android/support.v4.media.session.MediaSessionCompat.html" target="_blank" rel="noopener"><code>MediaSessionCompat</code></a> to connect to.</p><p>用来连接到 MediaSessionCompat</p></blockquote><p><strong>setPlayer</strong></p><pre><code class="java"> public void setPlayer(@Nullable Player player)</code></pre><blockquote><p>Sets the player to be connected to the media session. Must be called on the same thread that is used to access the player.</p><p>将播放器连接到媒体。主要只能在一条线程上。</p></blockquote><table><thead><tr><th align="center">修饰符</th><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">setQueueNavigator(MediaSessionConnector.QueueNavigator queueNavigator)</td><td align="center">设置处理队列导航的操作。queueNavigator：队列编辑器。</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="MediaSessionConnector-PlaybackPreparer-接口"><a href="#MediaSessionConnector-PlaybackPreparer-接口" class="headerlink" title="MediaSessionConnector.PlaybackPreparer 接口"></a>MediaSessionConnector.PlaybackPreparer 接口</h1><blockquote><p>准备播放操作的接口</p></blockquote><p><strong>抽象方法</strong></p><table><thead><tr><th align="center">返回类型</th><th align="center">方法名字</th><th align="center">参数</th><th align="center">描述</th><th align="center">返回</th></tr></thead><tbody><tr><td align="center">long</td><td align="center">getSupportedPrepareActions()</td><td align="center">空</td><td align="center">返回支持的媒体操作常量</td><td align="center">媒体常量</td></tr><tr><td align="center">void</td><td align="center">onPrepare(boolean playWhenReady)</td><td align="center">准备好后是否播放</td><td align="center">准备完成时调用</td><td align="center">空</td></tr><tr><td align="center">void</td><td align="center">onPrepareFromMediaId ( String  mediaId, boolean playWhenReady, @Nullable Bundle  extras)</td><td align="center">mediaId：媒体项的Id，playWhenReady：准备好后是否播放，extras：媒体的控制器可为null</td><td align="center">用以播放特定的媒体</td><td align="center">空</td></tr><tr><td align="center">void</td><td align="center">onPrepareFromSearch(String query, boolean playWhenReady, @Nullable Bundle extras)</td><td align="center">query：搜索，playWhenReady：准备好后是否播放，extras：媒体控制器可为null</td><td align="center">搜索特定音乐</td><td align="center">void</td></tr><tr><td align="center">void</td><td align="center">onPrepareFromUri( Uri  uri, boolean playWhenReady, @Nullable Bundle  extras)</td><td align="center">uri：要播放的媒体项目，playWhenReady：准备完成后是否播放，extras：媒体控制器可为null</td><td align="center">通过Uri处理特定媒体项目</td><td align="center">void</td></tr><tr><td align="center">void</td><td align="center">onCommand(String command,Bundle extras,ResultReceiver cb)</td><td align="center">command：命令名称，extras：命令的可选参数，cb，接收器命令发送到接收器，可为空</td><td align="center">接口继承了 MediaSessionConnector.CommandReceiver 类中的方法。控制器发送自定义命令时调用</td><td align="center">void</td></tr></tbody></table><h1 id="MediaDescriptionCompat-类"><a href="#MediaDescriptionCompat-类" class="headerlink" title="MediaDescriptionCompat 类"></a>MediaDescriptionCompat 类</h1><p>适合显示的媒体项目的一组简单元数据。 这可以使用Builder创建，也可以使用<code>getDescription()</code>从现有元数据中<code>getDescription()</code> 。</p><h1 id="MediaDescriptionCompat-Builder"><a href="#MediaDescriptionCompat-Builder" class="headerlink" title="MediaDescriptionCompat.Builder"></a>MediaDescriptionCompat.Builder</h1><h1 id="ConcatenatingMediaSource-类"><a href="#ConcatenatingMediaSource-类" class="headerlink" title="ConcatenatingMediaSource 类"></a>ConcatenatingMediaSource 类</h1><blockquote><p><code>ConcatenatingMediaSource</code>允许播放期间动态的添加和删除<code>MediaSource</code></p></blockquote><h1 id="PlayerNotificationManager-类"><a href="#PlayerNotificationManager-类" class="headerlink" title="PlayerNotificationManager 类"></a>PlayerNotificationManager 类</h1><blockquote><p>用来启动、更新和取消播放器状态的媒体样式通知的。</p></blockquote><p><strong>内部方法</strong></p><table><thead><tr><th align="center">返回值类型</th><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">setPlaybackPreparer(PlaybackPreparer playbackPreparer)</td><td align="center">准备播放器</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p><strong>嵌套类或方法</strong></p><h4 id="public-static-interface-PlayerNotificationManager-NotificationListener"><a href="#public-static-interface-PlayerNotificationManager-NotificationListener" class="headerlink" title="public static interface PlayerNotificationManager.NotificationListener"></a>public static interface PlayerNotificationManager.NotificationListener</h4><blockquote><p>监听状态的监听器。</p></blockquote><table><thead><tr><th align="center">返回值类型</th><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">onNotificationCancelled(int notificationId,boolean dismissedByUser)</td><td align="center">通知被取消时调用</td></tr><tr><td align="center">void</td><td align="center">onNotificationPosted(int notificationId, Notification notification,boolean ongoing)</td><td align="center">发布通知后调用</td></tr></tbody></table><h4 id="public-static-PlayerNotificationManager-createWithNotificationChannel"><a href="#public-static-PlayerNotificationManager-createWithNotificationChannel" class="headerlink" title="public static PlayerNotificationManager createWithNotificationChannel"></a>public static PlayerNotificationManager createWithNotificationChannel</h4><blockquote><p>创建通知管理器并指定channelId和低优先级的通知通道channelName.</p></blockquote><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">context-Context</td><td align="center">上下文</td></tr><tr><td align="center">channelId</td><td align="center">通知Id</td></tr><tr><td align="center">channelName</td><td align="center">字符串资源标识符，用于用户可见的通知名称。最多40字符过多会被裁断。</td></tr><tr><td align="center">channelDescription</td><td align="center">用户对内容可见部分的描述。没有为0。</td></tr><tr><td align="center">notificationId</td><td align="center">通知的Id</td></tr><tr><td align="center">mediaDescriptionAdapter</td><td align="center">提供当前播放内容的适配器</td></tr><tr><td align="center">notificationListener</td><td align="center">开始和取消通知的监听器</td></tr></tbody></table><h4 id="public-static-interface-PlayerNotificationManager-MediaDescriptionAdapter"><a href="#public-static-interface-PlayerNotificationManager-MediaDescriptionAdapter" class="headerlink" title="public static interface PlayerNotificationManager.MediaDescriptionAdapter"></a>public static interface PlayerNotificationManager.MediaDescriptionAdapter</h4><blockquote><p>提供当前播放内容的适配器</p></blockquote><table><thead><tr><th align="center">方法名</th><th align="center">参数</th><th>返回值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">getCurrentContentTitle()</td><td align="center">com.google.android.exoplayer2.Player player</td><td><strong>CharSequence</strong></td><td align="center">获得当前内容标题</td></tr><tr><td align="center">createCurrentContentIntent()</td><td align="center">com.google.android.exoplayer2.Player player</td><td><strong>PendingIntent</strong></td><td align="center">创建当前选项的意图</td></tr><tr><td align="center">getCurrentContentText()</td><td align="center">com.google.android.exoplayer2.Player player</td><td><strong>CharSequence</strong></td><td align="center">获取当前内容文本</td></tr><tr><td align="center">getCurrentLargeIcon()</td><td align="center">com.google.android.exoplayer2.Player player, PlayerNotificationManager.BitmapCallback callback</td><td><strong>Bitmap</strong></td><td align="center">获取当前大图标。当存在异步加载时可以返回占位符（或null），并且在 PlayerNotificationManager.BitmapCallback 加载后传递给它。由于在使用过程中适配器会多次被调用，因此图片由程序缓存，并尽可能在后续使用中同步返回。</td></tr></tbody></table><h1 id="Player-接口"><a href="#Player-接口" class="headerlink" title="Player 接口"></a>Player 接口</h1><blockquote><p>定义媒体播放器界面的高级功能常量、接口类型等，例如播放、暂停、搜索等属性能力。</p></blockquote><p><strong>常量</strong></p><table><thead><tr><th align="center">修饰类型</th><th align="center">常量</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">static int</td><td align="center">STATE_READY</td><td align="center">移动到指定位置准备播放</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="Player-EventListener-接口"><a href="#Player-EventListener-接口" class="headerlink" title="Player.EventListener 接口"></a>Player.EventListener 接口</h1><blockquote><p>检测播放器的状态。</p></blockquote><p><strong>抽象方法</strong></p><table><thead><tr><th align="center">返回类型</th><th align="center">方法名</th><th align="center">描述</th><th align="center">参数</th></tr></thead><tbody><tr><td align="center">void</td><td align="center">onPlayerError(ExoPlaybackException error)。</td><td align="center">发生错误时调用</td><td align="center">error:错误参数。</td></tr><tr><td align="center">void</td><td align="center">onPlayerStateChanged(boolean playWhenReady,int playbackState)</td><td align="center">检测媒体的状态</td><td align="center">playWhenReady:是否准备好。playbackState：播放的状态。</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h1 id="TimelineQueueNavigator-抽象类"><a href="#TimelineQueueNavigator-抽象类" class="headerlink" title="TimelineQueueNavigator 抽象类"></a>TimelineQueueNavigator 抽象类</h1><blockquote><p>抽象类用来实现 MediaSessionConnector.QueueNavigator 窗口的映射Player，Timeline媒体会话的队列。</p></blockquote><table><thead><tr><th align="center">修饰符</th><th align="center">(构造)方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"></td><td align="center">TimelineQueueNavigator(MediaSessionCompat mediaSession)</td><td align="center">创建一个实例MediaSessionCompat。</td></tr><tr><td align="center">MediaDescriptionCompat</td><td align="center">getMediaDescription(Player player,int windowIndex)</td><td align="center">获得MediaDescriptionCompat给定窗口的索引。通常需要异步加载图标。</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>引用：</p><p><a href="https://juejin.im/post/6854573203994443789" target="_blank" rel="noopener">深入解读ExoPlayer 之 开发者指南全译-02 开始使用</a></p><p><a href="https://exoplayer.dev/doc/reference/overview-summary.html" target="_blank" rel="noopener">DOC</a></p><p><a href="https://www.apiref.com/android-zh/index.html" target="_blank" rel="noopener">Android API</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ExoPlayer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Glide Android图片加载库</title>
      <link href="/2020/11/12/Glide-Android%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93/"/>
      <url>/2020/11/12/Glide-Android%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="下载-添加依赖"><a href="#下载-添加依赖" class="headerlink" title="下载 添加依赖"></a>下载 添加依赖</h1><p><strong>添加依赖</strong></p><blockquote><p>在 app 目录下打开 build.gradle</p></blockquote><pre><code class="kotlin">   // Glide    implementation &#39;com.github.bumptech.glide:glide:4.11.0&#39;    kapt &#39;com.github.bumptech.glide:compiler:4.11.0&#39;</code></pre><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><pre><code class="kotlin">Glide.with(context)    .load(url)    .into(imageView);</code></pre><blockquote><ul><li>with(context:Context) 需要上下文。</li><li>load(url:String) 字符串性质的网络图片Url。</li><li>into(imageView :ImageView) 你需要显示的图片的控件</li></ul></blockquote><p><strong>取消加载</strong></p><pre><code class="kotlin">Glide.with(context).clear(imageView);</code></pre><blockquote><p>Glide.with()中传入Activity或者Fragment时会跟随它们创建和销毁，所有手动取消是非必要的。</p></blockquote><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><blockquote><ul><li>setDefaultRequestOptions(RequestOptions requestOptions)</li></ul><p>用于配置加载图片时的默认选项，编码模式包含在其中，默认配置是RGB_565</p><p>参数：</p><ol><li>requestOptions:设置 RequestOptions 到加载的应用中。</li></ol></blockquote><h1 id="RequestOptions类"><a href="#RequestOptions类" class="headerlink" title="RequestOptions类"></a>RequestOptions类</h1><blockquote><p>提供选项来给 Glide 自定义加载。</p></blockquote><ul><li><strong>placeholder(Drawable drawable)</strong></li></ul><blockquote><p>设置加载时的默认图片。</p><p>参数：</p><ol><li>drawable，显示图片的占位符</li></ol></blockquote><ul><li><strong>onError(Drawable drawable)</strong></li></ul><blockquote><p>设置图片加载错误时的图片。</p><p>参数：</p><ol><li>drawable，显示图片的占位符</li></ol></blockquote><ul><li><strong>diskCacheStrategy(DiskCacheStrategy diskCacheStrategy)</strong></li></ul><blockquote><p>将 DiskCacheStrategy 类型应用到单独请求中。允许你加载过程中使用或者写入磁盘缓存，选择性的仅支持无修改的原声数据，或者变换过的缩略图，或者兼而有之。</p><p>参数：</p><ol><li>diskCacheStrategy：使用DiskCacheStrategy类的常量作为缓存策略。</li></ol></blockquote><h1 id="DiskCacheStrategy-类"><a href="#DiskCacheStrategy-类" class="headerlink" title="DiskCacheStrategy  类"></a>DiskCacheStrategy  类</h1><blockquote><p>缓存策略（Disk 、Cache 、Strategy）</p><p>允许你加载过程中使用或者写入磁盘缓存，选择性的仅支持无修改的原声数据，或者变换过的缩略图，或者兼而有之。</p><p>默认是<strong>AUTOMATIC</strong>，会尝试对本地和远程图片使用最佳策略。当你加载远程数据时，<strong>AUTOMATIC</strong>策略会存储维被你加载过程修改过的原始数据(例如，变换，裁剪)，因为下载远程数据相比调整磁盘上已经存在的数据要昂贵的多。对于本都数据，<strong>AUTOMATIC</strong> 策略会存储变换过的缩略图，因为即使你再次生成另一个尺寸或者类型的图片，取回原始数据也是很容易的。</p></blockquote><p><strong>类型介绍</strong></p><blockquote><p>DiskCacheStrategy.NONE: 表示不缓存任何内容。</p><p>DiskCacheStrategy.DATA: 只缓存原始图片。</p><p>DiskCacheStrategy.RESOURCE：表示只缓存转换过后的图片。</p><p>DiskCacheStrategy.ALL:表示既缓存原始图片，也缓存转换过后的图片。</p><p>DiskCacheStrategy.AUTOMATIC: 表示让Gilde根据图片资源智能的选择一种缓存策略（默认）。</p></blockquote><h2 id="CustomTarget-类"><a href="#CustomTarget-类" class="headerlink" title="CustomTarget 类"></a>CustomTarget<T> 类</h2><blockquote><p>用于加载图片资源。</p></blockquote><table><thead><tr><th align="center">方法名</th><th align="center">参数</th><th align="center">描述</th><th align="center">返回值</th></tr></thead><tbody><tr><td align="center">onResourceReady</td><td align="center">@NonNull  R resource, @Nullable Transition&lt;? super R&gt; transition</td><td align="center">资源加载完成后调用的方法</td><td align="center">void。返回加载的资源</td></tr><tr><td align="center">onLoadCleared</td><td align="center">@NonNull android.graphics.drawable.Drawable placeholder（可以选择的占位符，可为null）</td><td align="center">取消加载并释放资源的生命周期回调。（在重新绘制容器时，你必须确保onResourceReady()方法不接受任何当前的Drawable）</td><td align="center">void</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p><strong>引用</strong></p><p><a href="https://muyangmin.github.io/glide-docs-cn/doc/getting-started.html" target="_blank" rel="noopener">Glide</a></p><p><a href="https://www.jianshu.com/p/4f457a124d67" target="_blank" rel="noopener">Android图片加载框架——Glide（Glide v4）</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Glide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dagger-Hilt Android的依赖注入框架</title>
      <link href="/2020/11/11/Dagger-Hilt-Android%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6/"/>
      <url>/2020/11/11/Dagger-Hilt-Android%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Hilt-是干什么的？"><a href="#Hilt-是干什么的？" class="headerlink" title="Hilt 是干什么的？"></a>Hilt 是干什么的？</h1><p>它是 Google 为Android开发提供的场景化依赖库，皆在减少项目中进行的手动依赖注入。</p><p>Hilt 为项目中的每个 Android 类提供容器并自动管理它们的生命周期，为应用程序提供了 DI的标准方法。它是从 Dagger 库的基础上进行构建的，因为 Dagger提供的编译时正确性、运行时性能、可伸缩性并且从AndroidStudio支持Dagger中获益。</p><blockquote><p><strong>相比Dagger，Hilt有那些优化？</strong></p><p>Hilt的实现要比Dagger简单的多，使用Dagger实现依赖注入，需要去编写modules、components等等。每次去创建一个新的Android组件，比如 Activity、Fragment时，我们都需要将它们手动添加到modules中。</p></blockquote><h1 id="使用-Hilt-前的准备工作"><a href="#使用-Hilt-前的准备工作" class="headerlink" title="使用 Hilt 前的准备工作"></a>使用 Hilt 前的准备工作</h1><ul><li>添加依赖 在项目的根目录下 build.gradle 文件</li></ul><pre><code>buildscript {    ...    dependencies {        ...        classpath &quot;com.google.dagger:hilt-android-gradle-plugin:2.28.3-alpha&quot;    }}</code></pre><ul><li>在项目的应用级目录下 </li></ul><pre><code>...apply plugin: &#39;kotlin-kapt&#39;apply plugin: &#39;dagger.hilt.android.plugin&#39;android {    ...}dependencies {    implementation &quot;com.google.dagger:hilt-android:2.28-alpha&quot;    kapt &quot;com.google.dagger:hilt-android-compiler:2.28-alpha&quot;}</code></pre><p>Hilt 使用Java8的功能，所以我们在项目中启用它，应用模块下 build.gradle 文件添加代码。</p><pre><code class="groovy">android {  ...    compileOptions {        sourceCompatibility JavaVersion.VERSION_1_8        targetCompatibility JavaVersion.VERSION_1_8    }    // For Kotlin projects    kotlinOptions {        jvmTarget = &quot;1.8&quot;    }}</code></pre><blockquote><p><strong>注意</strong></p><p>在 Kotlin 项目中，需要添加 kotlinOptions，否则ViewModel会编译不通过。</p><p>需要注意使用hilt 和data binding，需要AndroidStudio的版本必须&gt;=4.0。</p></blockquote><p>Application 是 App 的入口，所有使用Hilt的App必须包含一个使用@HiltAndroidApp注解的Application</p><pre><code class="kotlin">@HiltAndroidAppclass HiltApplication : Application() {    /**     * 1. 所有使用 Hilt 的 App 必须包含一个使用 @HiltAndroidApp 注解的 Application     * 2. @HiltAndroidApp 将会触发 Hilt 代码的生成，包括用作应用程序依赖项容器的基类     * 3. 生成的 Hilt 组件依附于 Application 的生命周期，它也是 App 的父组件，提供其他组件访问的依赖     * 4. 在 Application 中设置好 @HiltAndroidApp 之后，就可以使用 Hilt 提供的组件了，     *    Hilt 提供的 @AndroidEntryPoint 注解用于提供 Android 类的依赖（Activity、Fragment、View、Service、BroadcastReceiver）等等     *    Application 使用 @HiltAndroidApp 注解     */}</code></pre><ol><li>@HiltAndroidApp会触发Hilt代码的生成，包括用作应用程序依赖容器的基类</li><li>生成的Hilt组件依附于Application的生命周期，它也是App的父组件，提供其他组件访问的依赖。</li></ol><h1 id="使用-Hilt-进行依赖注入"><a href="#使用-Hilt-进行依赖注入" class="headerlink" title="使用 Hilt 进行依赖注入"></a>使用 Hilt 进行依赖注入</h1><p>注入 HiltSimple 并在 Application 中调用它的doSomething方法。</p><pre><code class="kotlin">class HiltSimple @Inject constructor() {    fun doSomething() {        Log.e(TAG, &quot;----doSomething----&quot;)    }}@HiltAndroidAppclass HiltApplication : Application() {    @Inject    lateinit var mHiltSimple: HiltSimple    override fun onCreate() {        super.onCreate()        mHiltSimple.doSomething()    }}</code></pre><p>Hilt 需要知道如何从相对应的组件中提供必要的依赖实例。使用@Inject注解来告诉Hilt如何提供该类的实例，@Inject 常用于构造函数、非私有字段、方法。</p><h1 id="Hilt-常用注解的含义"><a href="#Hilt-常用注解的含义" class="headerlink" title="Hilt 常用注解的含义"></a>Hilt 常用注解的含义</h1><h4 id="HiltAndroidApp"><a href="#HiltAndroidApp" class="headerlink" title="@HiltAndroidApp"></a>@HiltAndroidApp</h4><blockquote><p>1 所有使用HIlt的App必须包含一个使用@HiltAndroidApp注解的Application。</p><p>2 @HiltAndroidApp注解将会触发Hilt代码的生成，作为应用程序依赖项容器的基类。</p><p>3 生成的Hilt组件依附于Application的生命周期，它也是App的父组件，提供其他组件访问的依赖。</p><p>4 在Application中设置号@HiltAndroidApp之后，就可以使用Hilt提供的组件了，组件包含Applicaiton、Activity、Fragment等。</p></blockquote><h4 id="AndroidEntryPoint"><a href="#AndroidEntryPoint" class="headerlink" title="@AndroidEntryPoint"></a>@AndroidEntryPoint</h4><blockquote><p>Hilt 提供的@AndroidEntryPoint注解用于提供Android类的依赖（Activity、Fragment、View、Service、BroadcastReceiver）</p><p>特殊的Application使用 @HiltAndroidApp注解。</p><ul><li><p>Activity：支持ComponentActivity的子类例如FragmentActivity、AppCompatActivity等。</p></li><li><p>Fragment：支持 androidx.Fragment包下的Fragment。</p></li><li><p>View</p></li><li><p>Service</p></li><li><p>BroadcastReceiver</p></li></ul></blockquote><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>在使用@AndroidEntryPoint在非ComponentActivity子类上注解，例如Activity则会抛出异常。</p><pre><code class="groovy">Activities annotated with @AndroidEntryPoint must be a subclass of androidx.activity.ComponentActivity. (e.g. FragmentActivity, AppCompatActivity, etc.)</code></pre><p>使用@AndroidEntryPoint注解时，必须在它的依赖的Android类添加同样的注解，<strong>例如Fragment中添加@AndroidEntryPoint注解，必须在Fragment依赖的Activity上也添加@AndroidEntryPoint注解，否则会抛出一样。</strong></p><pre><code class="kotlin">java.lang.IllegalStateException: Hilt Fragments must be attached to an @AndroidEntryPoint Activity. Found: class com.hi.dhl.hilt.MainActivity</code></pre><h4 id="Module"><a href="#Module" class="headerlink" title="@Module"></a>@Module</h4><p>常用于创建依赖类的对象（例如第三方库 OkHttp、Retrofit等等），使用@Module注解的类，需要使用@InstallIn注解指定范围module。</p><pre><code class="kotlin">@Module@InstallIn(ApplicationComponent::class)// 这里使用了 ApplicationComponent，因此 NetworkModule 绑定到 Application 的生命周期。object NetworkModule {}</code></pre><h4 id="InstallIn"><a href="#InstallIn" class="headerlink" title="@InstallIn"></a>@InstallIn</h4><p>使用@Module注入的类，使用@InstallIn注解指定module的范围，例如使用@InstallIn(ActivityComponent::class)注解的module会绑定到Activity的生命周期上。</p><p>Hilt 提供了以下组件来绑定依赖与对应的Android类的活动范围。</p><table><thead><tr><th align="center">Hilt 提供组件</th><th align="center">对应的Android类活动范围</th><th align="center">作用域</th></tr></thead><tbody><tr><td align="center">ApplicationComponent</td><td align="center">Application</td><td align="center">@Singleton</td></tr><tr><td align="center">ActivityRetainedComponent</td><td align="center">ViewModel</td><td align="center">@ActivityRetainedScope</td></tr><tr><td align="center">ActivityComponent</td><td align="center">Activity</td><td align="center">@ActivityScoped</td></tr><tr><td align="center">FragmentComponent</td><td align="center">Fragment</td><td align="center">@FragmentScoped</td></tr><tr><td align="center">ViewComponent</td><td align="center">View</td><td align="center">@ViewScoped</td></tr><tr><td align="center">ViewWithFragmentComponent</td><td align="center">View annotated with @WithFragmentBindings</td><td align="center">@ViewScoped</td></tr><tr><td align="center">ServiceComponent</td><td align="center">Service</td><td align="center">@ServiceScoped</td></tr></tbody></table><blockquote><p><strong>注意</strong></p><p>Hilt 没有为 broadcast receivers 提供组件，因为Hilt直接从ApplicationComponent注入broadcast receivers。</p></blockquote><p>Hilt 会根据相应的 Android 类生命周期自动创建和销毁生成的组件类的实例。如下。</p><table><thead><tr><th align="center">Hilt 提供的组件</th><th align="center">创建对应的生命周期</th><th>销毁对应的生命周期</th></tr></thead><tbody><tr><td align="center">ApplicationComponent</td><td align="center">Application#onCreate()</td><td>Application#onDestory()</td></tr><tr><td align="center">ActivityRetainedComponent</td><td align="center">Activity#onCreate()</td><td>Activity#onDestroy()</td></tr><tr><td align="center">ActivityComponent</td><td align="center">Activity#onCreate()</td><td>Activity#OnDestroy()</td></tr><tr><td align="center">FragmentComponent</td><td align="center">Fragment#OnAttach()</td><td>Fragment#onDestroy()</td></tr><tr><td align="center">ViewComponent</td><td align="center">View#super()</td><td>View destroyed</td></tr><tr><td align="center">ViewWithFragmentComponent</td><td align="center">View#super()</td><td>View destroyed</td></tr><tr><td align="center">ServiceComponent</td><td align="center">Service#onCreate()</td><td>Service#onDestroy()</td></tr></tbody></table><h4 id="Provides"><a href="#Provides" class="headerlink" title="@Provides"></a>@Provides</h4><p>常用于被 @Module 注解标记类的内部方法，并提供依赖项对象。</p><pre><code class="kotlin">@Module@InstallIn(ApplicationComponent::class)// 这里使用了 ApplicationComponent，因此 NetworkModule 绑定到 Application 的生命周期。object NetworkModule {    /**     * @Provides 常用于被 @Module 注解标记类的内部的方法，并提供依赖项对象。     * @Singleton 提供单例     */    @Provides    @Singleton    fun provideOkHttpClient(): OkHttpClient {        return OkHttpClient.Builder()            .build()    }}</code></pre><h1 id="Hilt-同-第三方组件一起使用"><a href="#Hilt-同-第三方组件一起使用" class="headerlink" title="Hilt 同 第三方组件一起使用"></a>Hilt 同 第三方组件一起使用</h1><p>如果你要在项目中添加第三方依赖，需要使用@Module注解，使用@Module注解的普通类，在其中创建第三方依赖的对象。</p><pre><code class="kotlin">@Module@InstallIn(ApplicationComponent::class)// 这里使用了 ApplicationComponent，因此 NetworkModule 绑定到 Application 的生命周期。object NetworkModule {    /**     * @Provides 常用于被 @Module 注解标记类的内部的方法，并提供依赖项对象。     * @Singleton 提供单例     */    @Provides    @Singleton    fun provideOkHttpClient(): OkHttpClient {        return OkHttpClient.Builder()            .build()    }    @Provides    @Singleton    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {        return Retrofit.Builder()            .client(okHttpClient)            .baseUrl(&quot;https://api.github.com/&quot;)            .addConverterFactory(GsonConverterFactory.create())            .build()    }    @Provides    @Singleton    fun provideGitHubService(retrofit: Retrofit): GitHubService {        return retrofit.create(GitHubService::class.java)    }}</code></pre><ul><li>@Module 常用于创建依赖类对象（如OkHttp、Retrofit等等）。</li><li>使用 @Module注入的类，需要使用@InstallIn注解指定module的范围，会绑定到Android类对应的生命周期上。</li><li>@Provides 常用于标记类的内部方法，并提供依赖项对象。</li></ul><h1 id="当需要上下文是使用的注解（预定义限定符）"><a href="#当需要上下文是使用的注解（预定义限定符）" class="headerlink" title="当需要上下文是使用的注解（预定义限定符）"></a>当需要上下文是使用的注解（预定义限定符）</h1><p>​    HIlt提供了预定义限定符。例如，当你需要使用应用或者Activity的Context类时，Hilt提供了<strong>@ApplicationContext</strong>和<strong>@ActivityContext</strong>限定符。</p><p>假如,当前这个类需要Activity的上下文。</p><pre><code class="kotlin">class Test @Inject constructor(    @ActivityContext private val context: Context,    private val service: AnalyticsService) { ... }</code></pre><h4 id="引用："><a href="#引用：" class="headerlink" title="引用："></a><strong>引用</strong>：</h4><p><a href="https://juejin.im/post/6844904198803292173?utm_source=gold_browser_extension#heading-13" target="_blank" rel="noopener">Jetpack 新成员 Hilt 实践（一）启程过坑记</a></p><p><a href="https://juejin.im/post/6845166890562617352" target="_blank" rel="noopener">Jetpack 新成员 Hilt 与 Dagger 大不同（三）落地篇</a></p><p><a href="https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn" target="_blank" rel="noopener">Hilt 中的预定义限定符</a></p><p><a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/index-all.html" target="_blank" rel="noopener">JavaDoc-Glide</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Dagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何让Firebase使用Kotlin协程</title>
      <link href="/2020/11/08/%E5%A6%82%E4%BD%95%E8%AE%A9Firebase%E4%BD%BF%E7%94%A8Kotlin%E5%8D%8F%E7%A8%8B/"/>
      <url>/2020/11/08/%E5%A6%82%E4%BD%95%E8%AE%A9Firebase%E4%BD%BF%E7%94%A8Kotlin%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>引用：</strong></p><p>​    <a href="https://medium.com/better-programming/how-to-use-kotlin-coroutines-with-firebase-6f8577a3e00f" target="_blank" rel="noopener">How to Use Kotlin Coroutines With Firebase</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Firebase 讲解</title>
      <link href="/2020/10/29/Firebase-%E8%AE%B2%E8%A7%A3/"/>
      <url>/2020/10/29/Firebase-%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="AndroidStudio-添加-Firebase-选项"><a href="#AndroidStudio-添加-Firebase-选项" class="headerlink" title="AndroidStudio 添加 Firebase 选项"></a>AndroidStudio 添加 Firebase 选项</h1><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201029230255.png" alt="使用时可能会没有 firebase 选项"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201029230927.png" alt="settings 添加 plug-in"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201029231529.png" alt="选择添加 Firebase Services"></p><blockquote><p><strong>AndroidStudio4.2 以停止更新，默认存在firebase连接</strong></p></blockquote><h1 id="创建-Firebase-项目-添加到-Android-项目中"><a href="#创建-Firebase-项目-添加到-Android-项目中" class="headerlink" title="创建 Firebase 项目 添加到 Android 项目中"></a>创建 Firebase 项目 添加到 Android 项目中</h1><blockquote><p>准备好 google 账号</p></blockquote><p><strong>打开 Firebase</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-11-2-0.gif" alt=""></p><p><strong>进入控制台</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102004348.png" alt=""></p><p><strong>选择项目名称</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102004431.png" alt="create a firebase"></p><p><strong>继续</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102004513.png" alt=""></p><p><strong>选择默认账户或者创建</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102004549.png" alt=""></p><p><strong>稍等片刻</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102004649.png" alt=""></p><p><strong>完成</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102004812.png" alt=""></p><p><strong>根据提示在Android项目中添加各个SDK</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210702135922.png" alt=""></p><p><strong>使用 Cloud Storage的话需要添加SDK到应用</strong></p><pre><code class="groovy">dependencies {    // Import the BoM for the Firebase platform    implementation platform(&#39;com.google.firebase:firebase-bom:28.1.0&#39;)    // Declare the dependency for the Cloud Storage library    // When using the BoM, you don&#39;t specify versions in Firebase library dependencies    implementation &#39;com.google.firebase:firebase-storage-ktx&#39;}</code></pre><h1 id="删除-Firebase-项目"><a href="#删除-Firebase-项目" class="headerlink" title="删除 Firebase 项目"></a>删除 Firebase 项目</h1><p><strong>点击设置</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102004958.png" alt=""></p><p><strong>选择项目设置</strong></p><p><strong>翻到最底部</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102005205.png" alt=""></p><p><strong>删除项目。</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102005613.png" alt=""></p><h1 id="在-CloudFireStore中添加-元数据"><a href="#在-CloudFireStore中添加-元数据" class="headerlink" title="在 CloudFireStore中添加 元数据"></a>在 CloudFireStore中添加 元数据</h1><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201104131055.png" alt="选择Cloud Firestore"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201104131130.png" alt="点击 “开始收集”"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201104131210.png" alt="添加 集合名字"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201104131719.png" alt="添加 文档称呼"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201104131546.png" alt="点击添加字段 直接添加字段即可"></p><h1 id="将-Storage中的数据链接添加到元数据中"><a href="#将-Storage中的数据链接添加到元数据中" class="headerlink" title="将 Storage中的数据链接添加到元数据中"></a>将 Storage中的数据链接添加到元数据中</h1><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201104131958.png" alt="点击上传文件"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-11-4-2.gif" alt="选择要添加的元数据连接"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201104152013.png" alt="粘贴即可"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EC</title>
      <link href="/2020/10/29/EC/"/>
      <url>/2020/10/29/EC/</url>
      
        <content type="html"><![CDATA[<h3 id="基本的语法概念：词性-，一个单次的分类"><a href="#基本的语法概念：词性-，一个单次的分类" class="headerlink" title="基本的语法概念：词性 ，一个单次的分类"></a>基本的语法概念：词性 ，一个单次的分类</h3><p><strong>英语单词共分两类:</strong>虚词和实词</p><p>虚词：没有具体含义。</p><p>实词：有实际的意义。</p><h4 id="虚词"><a href="#虚词" class="headerlink" title="虚词"></a>虚词</h4><p>虚词共分两类： </p><blockquote><p>介词： in at on （可翻译为 在）</p><p>连词：end but or （和、但是、或者）</p></blockquote><h4 id="实词"><a href="#实词" class="headerlink" title="实词"></a>实词</h4><p>实词共分四大类：</p><blockquote><p>名词：用来表达一件东西的名称的词。（花、草、树木等都表示名词）</p><p>动词：表示运动的词。（跑、蹲下）</p><p>形容词：用来修饰名词的词。（美丽的女孩。美丽形容词）</p><p>副词：辅助作用的词。表行为或者状态。（修饰名词以外所有的词。<strong>大声</strong>的唱歌）</p></blockquote><h4 id="不定时"><a href="#不定时" class="headerlink" title="不定时"></a>不定时</h4><blockquote><p>to do</p></blockquote><h3 id="基本的语法概念：句子成分"><a href="#基本的语法概念：句子成分" class="headerlink" title="基本的语法概念：句子成分"></a>基本的语法概念：句子成分</h3><p><strong>注意：</strong>句子成分和词性是不一样的。</p><h1 id="英语的五大句型"><a href="#英语的五大句型" class="headerlink" title="英语的五大句型"></a>英语的五大句型</h1><h2 id="系动词-主语-系动词-表语"><a href="#系动词-主语-系动词-表语" class="headerlink" title="系动词 主语+系动词+表语"></a>系动词 主语+系动词+表语</h2><h3 id="什么是主系表？"><a href="#什么是主系表？" class="headerlink" title="什么是主系表？"></a>什么是<strong>主系表</strong>？</h3><ul><li>主：句子的主体。</li><li>系：系动词，特殊的动词（特殊的谓语属于动词的一种），<strong>在句子中做谓语的动词没有实际意义就属于系动词。</strong></li></ul><blockquote><p>汉语中表示 “是” “为”，英语中表示 am，is ，are。</p><p>在句子中起联系的作用就叫做系动词。</p><p>linking verb 联系动词</p></blockquote><ul><li>表：</li></ul><blockquote><p>表语。<strong>补充说明主语的性质叫做表语</strong>。</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201030150702.png" alt=""></p><p><strong>如何判断句子是否是主系表结构</strong></p><blockquote><p>用中文的方式判断句子里的谓语，可否使用“是”，或者“为”来翻译。</p></blockquote><p>列如：</p><blockquote><p>I am a good persion</p><p>am 可以理解为 “是”。这是主系表</p><p>I become a good persion</p><p>become 理解为 “成为”  “为”。也是主系表结构</p></blockquote><h3 id="系动词共分类四类"><a href="#系动词共分类四类" class="headerlink" title="系动词共分类四类"></a>系动词共分类四类</h3><h4 id="1-be-动词-（am、-is、-are、过去-was、were-、将来-will、be）"><a href="#1-be-动词-（am、-is、-are、过去-was、were-、将来-will、be）" class="headerlink" title="1.be 动词 （am、 is、 are、过去 was、were 、将来 will、be）"></a>1.be 动词 （am、 is、 are、过去 was、were 、将来 will、be）</h4><p>am、 is、 are</p><p>过去 was、were </p><p>将来 will、be</p><h5 id="Be动词后跟三大类-表语"><a href="#Be动词后跟三大类-表语" class="headerlink" title="Be动词后跟三大类 表语"></a>Be动词后跟三大类 表语</h5><ul><li><strong>名词</strong></li></ul><blockquote><p><strong>名词做表语</strong>，可以同汉语完全对应，<strong>be 动词翻译成汉语的是</strong>。</p></blockquote><p>Tim is an engineer</p><p>蒂姆是个工程师</p><p>The price is a £ 2000</p><p>价格是 2000 英镑</p><ul><li><strong>形容词</strong></li></ul><blockquote><p>和汉语不同，<strong>be 动词不会被翻译出来</strong>，<strong>直接被省略介词短语也相当于形容词。</strong></p></blockquote><p>The play was very interesting.</p><p>戏很有意思</p><blockquote><p>The play：戏剧、戏</p><p>was very interesting：很有意思</p></blockquote><p>The milk is in the refrigerator.</p><p>牛奶在冰箱里</p><blockquote><p>in the refrigerator：在冰箱里，用来形容 The milk （牛奶）。介词短语可以用来做形容词</p><p>这是<strong>主系表</strong>结构</p></blockquote><ul><li><strong>地点副词</strong>    </li></ul><blockquote><p>只能接<strong>地点动词</strong>。</p></blockquote><p>Your sister is here there days。</p><p>你姐姐这段在这儿。</p><h4 id="2-状态保持动词-（keep、remain、stay）"><a href="#2-状态保持动词-（keep、remain、stay）" class="headerlink" title="2.状态保持动词 （keep、remain、stay）"></a>2.状态保持动词 （keep、remain、stay）</h4><blockquote><p>这三个词后只能加<strong>形容词作表语</strong>，可以和 be 无限切换。</p></blockquote><p>you should <strong>keep</strong> quiet！（you should <strong>be</strong> quiet！）</p><p>你应该保持安静！</p><p>No one can <strong>remain</strong> youthful forever （No one can <strong>be</strong> youthful forever）</p><p>没有人能永葆青春</p><p>The weather <strong>stayed</strong> fine for a week （The weather <strong>was</strong> fine for a week 。was：过去式）</p><p>这个星期天气一直很好。</p><h4 id="3-状态转变类动词（become、get、go、come、grow、turn）"><a href="#3-状态转变类动词（become、get、go、come、grow、turn）" class="headerlink" title="3.状态转变类动词（become、get、go、come、grow、turn）"></a>3.状态转变类动词（become、get、go、come、grow、turn）</h4><ul><li><strong>become</strong>是一个万能词，既可以表示“变成”，这时候后面只能接名词。同时也可以表示“<strong>变得</strong>”，后面接形容词。</li></ul><p>He <strong>become</strong> a weather.</p><p>他成为了一名教师。</p><p>He <strong>become</strong> very nervous.</p><p>他变得很紧张。</p><ul><li><strong>get</strong>表示“变得怎样”,后边这能接形容词。</li></ul><p>He got very angry.</p><p>他变得非常生气</p><ul><li>come 这个词的本意是来，什么东西会来，当然是好的东西，所以一般come含有“变好”的意思。</li></ul><p>Thing will <strong>come</strong> right.</p><p>事情会变好。</p><ul><li><strong>go</strong> 表示走，你希望的东西你离而去？当然是坏的东西离你而去，所以表达“变坏”，可以用go</li></ul><p>The meat always <strong>goes</strong> bad in summer.</p><p>肉在夏天常常会变坏</p><ul><li>如果你要表示“慢慢变”，使用 <strong>grow</strong>，本意表示 grow 是生长的意思，慢慢长大。</li></ul><p>The weather <strong>grew</strong> cold in the night.</p><p>晚上天气慢慢变冷。</p><ul><li>要表达<strong>“快速变”</strong>，应该用turn。因为turn本意为转身，一下子转过去</li></ul><p>His face <strong>turned</strong> pale.</p><p>他脸色变得苍白</p><h4 id="4-感官动词（look、sound、smell、taste、feel）"><a href="#4-感官动词（look、sound、smell、taste、feel）" class="headerlink" title="4.感官动词（look、sound、smell、taste、feel）"></a>4.感官动词（look、sound、smell、taste、feel）</h4><blockquote><p>五个动词，一律翻译为 “…起来”，“看起来，听起来，闻起来，尝起来，感觉起来（感到）”，后面只能接形容词（相当于形容词的分词）作表语。</p></blockquote><p>I <strong>felt</strong> very nervous when I went into this office.</p><p>我走到他的办公室，感到非常紧张。</p><p>He <strong>looked</strong> very angry.</p><p>他看上去非常气愤。</p><p>They were all hungry and the food <strong>smelled</strong> good.（were：be动词过去式，可以不做翻译）</p><p>他们全都饿了，饭菜散发出阵阵香气。</p><p>The sun <strong>looks like</strong> an orange globe.</p><p>太阳看上去像橙色的球体。</p><blockquote><p>👆 感官动词后，绝不能直接加名词做表语，如果要加名词，必须用：<strong>感官动词+介词like+名词</strong>，此时翻译为“像…”。</p></blockquote><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201030230419.png" alt="句子"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201030230512.png" alt="答案"></p><h2 id="不及物动词-主语-谓语"><a href="#不及物动词-主语-谓语" class="headerlink" title="不及物动词 主语+谓语"></a>不及物动词 主语+谓语</h2><h3 id="什么是主-谓结构？"><a href="#什么是主-谓结构？" class="headerlink" title="什么是主+谓结构？"></a>什么是主+谓结构？</h3><blockquote><p>通常主谓后应该加宾语。当主谓加在一起也可以作为一个句子。</p><p>例如：我笑了 </p><p>“我”和动词“笑了”组成了句子，“我”是主语，“笑了”是谓语，“笑了”是不及物动词所以就组成了句子。</p><p>汉语：我跳舞她。</p><p>英语：I dance her.</p><p>主谓结构同汉语相同。在汉语中 我跳舞她 是不合理的同样英语这样表达也是不合理的。</p><p>I dance.</p></blockquote><h3 id="谓语"><a href="#谓语" class="headerlink" title="谓语"></a>谓语</h3><p><em>名词</em></p><ol><li>语法学中指对主语加以陈述的成分，表示主语「怎么样」或「是什么」。一般的句子都包括主语、谓语，汉语中谓语一般在主语后面。如「我是学生」中「是学生」是谓语。</li></ol><h3 id="出现主谓结构的原因！"><a href="#出现主谓结构的原因！" class="headerlink" title="出现主谓结构的原因！"></a>出现主谓结构的原因！</h3><blockquote><p>因为有不及物动词。</p><p>其中<strong>不及物动词组成主谓结构</strong>。</p></blockquote><h3 id="什么是不及物动词？"><a href="#什么是不及物动词？" class="headerlink" title="什么是不及物动词？"></a>什么是不及物动词？</h3><blockquote><p>intransitive verb，简称：vi.</p><p>它本身意义就是完全的，没有作用对象，<strong>不需要加宾语就能构成完整句子</strong>，例如：游泳、出生、笑、做梦。</p></blockquote><h3 id="如何判断不及物动词？"><a href="#如何判断不及物动词？" class="headerlink" title="如何判断不及物动词？"></a>如何判断不及物动词？</h3><blockquote><p>如何判断，<strong>把这个动词前加上“被”</strong>，看它的寓意是否合理。</p><p>正常则为及物动词，不正常则为不及物动词。</p><p>例如：被打、被喜欢、被处罚。如果说：被跳舞、被做梦、被笑，则为不及物动词。</p></blockquote><h4 id="状语"><a href="#状语" class="headerlink" title="状语"></a>状语</h4><blockquote><p>说明这个动作发生的时间、地点、目的、以及状态等。</p><p>表示 时间、地点和方式的句子成分就叫做状语。</p></blockquote><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul><li><strong>这个句式多带有状语，来进一步说明这个动作发生的时间，地点，目的。</strong></li></ul><p>Detectives were waiting at the airport all morning .</p><p>They were talking loudly.</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031170041.png" alt=""></p><ul><li><strong>很多动词，本身既可以作不及物动词，也可以做及物动词，除啦上述方法外，还要在语境中判断</strong></li></ul><h3 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031110943.png" alt="题目"></p><p>The birds         sing         happily.</p><p>The rain     will stop     in the afternoon.</p><p>The children     are playing         in the park</p><p>My teacher         passed away     in the hospital         yesterday.</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031162342.png" alt=""></p><h2 id="及物动词-主语-谓语-宾语"><a href="#及物动词-主语-谓语-宾语" class="headerlink" title="及物动词 主语+谓语+宾语"></a>及物动词 主语+谓语+宾语</h2><h3 id="什么是及物动词？"><a href="#什么是及物动词？" class="headerlink" title="什么是及物动词？"></a>什么是及物动词？</h3><blockquote><p><strong>及物动词</strong>（transitive verb 简称：vt）</p><p>意思为：加入宾语之后的完整动词，分为主动和被动语态。</p><p>短语相当于及物动词时为：<strong>及物动词短语</strong>。</p></blockquote><p>Yesterday ，    a pigeon         carried     the first     message     from Pinhurst to Slibury.</p><p>昨天，一只鸽子把第一封信从平赫特带到锡尔伯里.</p><p>The bird     covered     the distance     in three minutes.</p><p>这只鸟只用了三分钟就飞完了全程。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031163058.png" alt=""></p><p>The bride and the groom cur the wedding cake together.</p><p>新郎和新娘一起切下结婚蛋糕</p><p>I <strong>had</strong> an amusing experience last year.</p><p>去年我有一次有趣的经历。</p><p>This wonderful plane can <strong>carry</strong> seven passengers.</p><p>这架奇妙的飞机可以载七名乘客</p><h3 id="练习题-2"><a href="#练习题-2" class="headerlink" title="练习题"></a>练习题</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031171234.png" alt=""></p><p>The teacher put up some pictures on the wall in the classroom.</p><p>You should respect the old in public places.</p><p>He began his diet a week ago.</p><p>He set up a new world record in September 1935</p><p>Only very few people can realize their dreams.</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031173411.png" alt=""></p><h2 id="不完全及物动词-主语-谓语-宾语-宾语补语"><a href="#不完全及物动词-主语-谓语-宾语-宾语补语" class="headerlink" title="不完全及物动词 主语+谓语+宾语+宾语补语"></a>不完全及物动词 主语+谓语+宾语+宾语补语</h2><h3 id="什么是不完全及物动词？"><a href="#什么是不完全及物动词？" class="headerlink" title="什么是不完全及物动词？"></a>什么是不完全及物动词？</h3><blockquote><p>不完全及物动词 incomplete transitive verb，简称i.vt</p><p>这个动词加了宾语之后，<strong>意思仍然不完整，需要加上补语（complement）才能使句子完整。</strong></p><p>补语是 <strong>补充说明宾语的特征，或者补语的动作</strong></p></blockquote><ul><li><p>“她 使 我 爱上生活。” 这个 “使” 就是不完全及物动词 如果只说 “她使我” 意思是不完整的，要加上补语 “爱上生活”，才是完整的句子。</p></li><li><p>“他的表演让我 失望。”这个“让”，如果说“他的表演让我”，当然也不完全要加上补语“失望”</p></li></ul><h3 id="如何分别完全及物动词和不完全及物动词？"><a href="#如何分别完全及物动词和不完全及物动词？" class="headerlink" title="如何分别完全及物动词和不完全及物动词？"></a>如何分别完全及物动词和不完全及物动词？</h3><p>最常用的不完全及物动词： <strong>使役动词</strong></p><blockquote><p>在要使什么，做什么时使用使役动词</p></blockquote><ul><li>使…做…（make，have，let，get）</li></ul><p>make/have/let+宾语+动词原形（补语）</p><p>get+宾语+动词不定式（补语）</p><blockquote><p>has：have 的第三人称时态</p></blockquote><ul><li>I made him wash the car.</li></ul><p>我叫他洗车。</p><ul><li>I got him to wash the car.</li></ul><p>我叫他洗车。</p><p>综上所述，只要宾语发出动作，或宾语的状态，均可构成此类句型。</p><h3 id="练习题-3"><a href="#练习题-3" class="headerlink" title="练习题"></a>练习题</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031194550.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031194437.png" alt=""></p><h2 id="授予动词-主语-谓语-间接宾语-直接宾语"><a href="#授予动词-主语-谓语-间接宾语-直接宾语" class="headerlink" title="授予动词 主语+谓语+间接宾语+直接宾语"></a>授予动词 主语+谓语+间接宾语+直接宾语</h2><h3 id="什么是授予动词？"><a href="#什么是授予动词？" class="headerlink" title="什么是授予动词？"></a>什么是授予动词？</h3><p>dative verb，简称d.v</p><ul><li><strong>是及物动词的一种</strong>，当需要接两个宾语，<strong>第一个间接宾语表示授予对象</strong>，<strong>第二个宾语为直接宾语</strong>，<strong>表示授予的东西</strong></li><li>要注意的是，<strong>直接宾语和间接宾语，都是谓语动作的作用对象</strong>，这是与第四大句型的区别。在第四大句型中，补语说明宾语的性质，或者是宾语发出的动作。</li><li>那么在找间宾和直宾使直接找<strong>授予对象</strong>再找<strong>授予的东西</strong>。</li></ul><h3 id="常见的授予动词"><a href="#常见的授予动词" class="headerlink" title="常见的授予动词"></a>常见的授予动词</h3><blockquote><p><strong>give (授予动词)、send、tall、teach、pay、show、offer</strong></p></blockquote><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031215252.png" alt=""></p><ul><li>Richard Mattes <strong>gave</strong> the testers six different kinds of things.</li></ul><p>Richard Matter 给你这些测试者六种不同类型的东西。</p><blockquote><p>直接宾语 <strong>授予的东西</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031220027.png" alt=""></p><ul><li>I <strong>send</strong>     <u>him</u> a     <u>book</u> in reward for his help.</li></ul><p>我送给他一本书答谢他的帮助。</p><blockquote><p>间接宾语<strong>授予的对象</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031221559.png" alt=""></p><ul><li>The scientist <strong>told</strong> <u>us</u> many <u>stories</u> about birds.</li></ul><p>博物学家给我们讲述了许多有关鸟儿的故事。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031221956.png" alt=""></p><ul><li>A friendly waiter <strong>taught</strong> <u>me</u> a few <u>words</u> of Italian.Then he <strong>lent</strong> <u>me</u> a <u>book</u></li></ul><p>一个好客的服务员教我几句意大利语，之后还借给我一本书。</p><ul><li>Yesterday I <strong>paid</strong> <u>him</u> a <u>visit</u>.</li></ul><p>昨天我去看望了他。</p><ul><li>Then he <strong>showed</strong> <u>me</u> the <u>contents</u> of the parcel .</li></ul><p>接着他给我看了包里的东西。</p><ul><li>He <strong>offered</strong> <u>me</u> a lot of <u>money</u>.</li></ul><p>他给了我很多钱。</p><h2 id="主谓宾补与主谓间宾直宾区分（不完全及物动词和授予动词区分）"><a href="#主谓宾补与主谓间宾直宾区分（不完全及物动词和授予动词区分）" class="headerlink" title="主谓宾补与主谓间宾直宾区分（不完全及物动词和授予动词区分）"></a>主谓宾补与主谓间宾直宾区分（不完全及物动词和授予动词区分）</h2><blockquote><p>只要是 <strong>谓语的动作</strong>，<strong>作用于两个不同的名词，也就是两个宾语</strong>，就是第五大句型</p><p>而在第四大类句型中，补语是宾语的动作或状态。</p></blockquote><p>例子：</p><ol><li><p>他 让 <strong>我 学习</strong>。‘“学习” 是 “我” 发出的动作 （学习是在“我”这个宾语后做补充的）</p></li><li><p>他 给了 <strong>我一本书</strong>。 “书” 和 “我” 都是谓语“给”的作用对象所以，</p><p>第1句是第四大句式（主谓宾补），第2句式第五大句型（主谓间宾直宾）</p></li></ol><h3 id="练习题-4"><a href="#练习题-4" class="headerlink" title="练习题"></a>练习题</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031223426.png" alt=""></p><ol><li>题的主谓双宾结构</li></ol><p>He gave his girlfriend a bunch of flowers on Valentine’s Day.</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031225959.png" alt=""></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="谓语-1"><a href="#谓语-1" class="headerlink" title="谓语"></a>谓语</h2><p>名词</p><ol><li>语法学中指对主语加以陈述的成分，表示主语「怎么样」或「是什么」。一般的句子都包括主语、谓语，汉语中谓语一般在主语后面。如「我是学生」中「是学生」是谓语。</li></ol><h2 id="宾语"><a href="#宾语" class="headerlink" title="宾语"></a>宾语</h2><p>名词</p><ol><li>语法上指受动词支配、关涉或受介词引导的成分。在现代汉语中，宾语一般在动词或介词后面。如「尊敬师长」中的「师长」，「他写信」中的「信」，「对他很好」中的「他」。</li></ol><h2 id="表语"><a href="#表语" class="headerlink" title="表语"></a>表语</h2><p>​        属于主语补足语，语法名词，是指说明主语的身份、性质、品性、特征和状态的词或从句，表语常由名词、形容词、介词短语、动名词、不定式、副词来充当，<strong>它常位于系动词（be）之后。</strong></p><p><a href="https://www.bilibili.com/video/BV1sJ411M7Gb?p=3" target="_blank" rel="noopener">英语简单句的造词法则和基本语法概念</a></p><h2 id="介词"><a href="#介词" class="headerlink" title="介词"></a>介词</h2><p><em>名词</em></p><ol><li>虚词的一类。用在名词、代词或名词性短语前边，引进动作行为的时间、处所、方式、目的、涉及或比较的对象以及动作的施事者等。如「在」「从」「以」「为了」「把」「比」「被」等。</li></ol><h2 id="副词"><a href="#副词" class="headerlink" title="副词"></a>副词</h2><p><em>名词</em></p><ol><li>修饰或限制动词、形容词，表示范围、程度、情态、语气等的词，一般不能修饰或限制名词。如「都」「很」「竟然」「再三」等。</li></ol><h1 id="七大英语句子成分的概述"><a href="#七大英语句子成分的概述" class="headerlink" title="七大英语句子成分的概述"></a>七大英语句子成分的概述</h1><h2 id="定语"><a href="#定语" class="headerlink" title="定语"></a>定语</h2><p>一个句子用来界定，限定名词的部分。</p><blockquote><p>一个 <strong>高个子的</strong>，<strong>留着长头发的</strong>，<strong>穿着红色衣服的，喜欢学习英语的</strong>学生。</p><p>加黑部分为 定语。</p></blockquote><h4 id="什么语法成分能够作为定语呢？"><a href="#什么语法成分能够作为定语呢？" class="headerlink" title="什么语法成分能够作为定语呢？"></a>什么语法成分能够作为定语呢？</h4><p><strong>形容词以及相当于形容词性质的语法成分。</strong></p><blockquote><p>一般来说，一个句子，如果是“…的”，它就是形容词性质的，比如说穿着红色衣服的，喜欢学习英语的，都属于形容词短语或者形容词从句。</p></blockquote><p><strong>英语百分之九十五的定语遵循“前小后大”的规则</strong></p><blockquote><p>一个单词组成的定语（限定词，形容词，名词以及名词所有格），放在所修饰名词的前面。</p></blockquote><blockquote><p>两个以上单词组成的定语（of属格，形容词短语，介词短语，分词短语，不定时短语等），放在所修饰词后面。</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201105155015.png" alt="各种语法成分作定语的例子。黑体部分为定语修饰的名词"></p><blockquote><p>They were expecting a valuable parcel of diamonds from South Africa</p><p>他们正期待从南非来的一个装有钻石的贵重包裹。</p><p>定语共是个分别为：</p><p>限定词 a，作顶词修饰 parcel ，a parcel 的包裹。</p><p>形容词 valuable，作定语，贵重。of diamonds 作定语限定为钻石。from South Africa 作定语限制为来自南非。</p></blockquote><blockquote><p>Mrs.Rumbold was a large,unsmiling lady in a tight black dress.</p><p>兰博尔德夫人是一位身材高大、表情严肃的女人，穿一件紧身的黑衣服。</p><p>a large，定语作形容词，形容高大的。unsmiling，定语作形容词严肃的。in a tight black dress，定语作介词短语（形容词性质），形容穿紧身黑衣服。</p></blockquote><blockquote><p>First of all ,he wrote out a long list of all the foods.</p><p>首先，他开列了一张长长列了所有的食物的目录。</p><p>a，限定词定语，限定 list 为一个。</p><p>long，形容词定语，限定为长的list。</p><p>of all the foods ，of属格，限定为食物</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201105170800.png" alt="练习题"></p><blockquote><p>我喜欢课桌上那本英语书</p><p>主语：我。谓语：喜欢。宾语：英语书</p><p>the：定语形容那本书。English：定语形容词，形容book为英语书。on the table:定语介词短语，指桌子上的书。</p></blockquote><blockquote><p>他们正在研究一个关于贸易标准的复杂问题。</p><p>主语：他们。谓语：研究。宾语：问题、</p><p>a：定语限定为一个。complicated：定语形容词，复杂的。about trading standard：作定语 介词短语 关于贸易标准的。</p></blockquote><blockquote><p>我将告诉你们昨天老师给我讲的那个非常有趣的关于月亮的中国古代故事。</p><p>主谓宾补 句式</p><p>主语：我。谓语：将告诉。宾语：你们。补语：故事。</p><p>不加定语：I will tall you story.</p><p>a：定语限定为一个。very :定语 非常。interesting：定语有趣。old Chinese：定语作形容词，中国古老。</p><p>about the moon：介词短语作定语，关于月亮。my teacher told me yesterday：介词短语作定语，老师昨天告诉我。</p><p>that：定语从句。</p></blockquote><h2 id="状语-1"><a href="#状语-1" class="headerlink" title="状语"></a>状语</h2><h4 id="什么是状语？"><a href="#什么是状语？" class="headerlink" title="什么是状语？"></a>什么是状语？</h4><blockquote><p>状语：用来描述定制的细节特征的成分，汉语里常见的对应成，就是“…地”。</p><p>唱歌：</p><p>可以说：大声地唱歌，欢乐地唱歌，投入地唱歌，等等。表达时间、地点、方式的状语，也可以不带“地”字。</p><p>比如：在教室里唱歌，在三个星期的晚会上唱歌，用古典的方式唱歌。</p></blockquote><p>状语可以修饰除啦名词以外的任何词。</p><h4 id="什么语法成分能做状语？"><a href="#什么语法成分能做状语？" class="headerlink" title="什么语法成分能做状语？"></a>什么语法成分能做状语？</h4><p><strong>副词以及相当于副词的语法成分</strong></p><p>副词在句子中处于副手的位置，就是辅助地位</p><blockquote><p>where,when,how–时间，地点，方式，成都</p><p>表示时间的，now ，just now，</p><p>表示地点的介词短语，比如 in the house</p></blockquote><h5 id="小状语（单独的副词）"><a href="#小状语（单独的副词）" class="headerlink" title="小状语（单独的副词）"></a>小状语（单独的副词）</h5><blockquote><p>​    放在其所修饰的词语之前：修饰动词时，放在动词之前。修饰其他成分时，放在其他成分之气那。</p><p>如果需要小状语可以放在句子中的任何位置。</p></blockquote><p>we are <strong>now</strong> living in a beautiful new house in the country.</p><blockquote><p>now：副词（小状语） 修饰living 表示现在生活在。</p><p>我们<strong>现在</strong>住在先将的一栋漂亮的新住宅里。</p></blockquote><p>Letters will cost a little more, but they will <strong>certainly</strong> travel faster.</p><blockquote><p>certainly：小状语 ，表示当然。</p><p>这样会稍微花点钱，但是肯定是快得多了。</p></blockquote><h5 id="大状语"><a href="#大状语" class="headerlink" title="大状语"></a>大状语</h5><blockquote><p>指 （两个及以上单词构成的状语，如介词短语，不定式短语，状语从句），放在整个句子的两头。放在开头时，一半要加上逗号。</p></blockquote><p>On Wednesday evening, We went to the Town Hall.</p><blockquote><p>星期三的晚上，我们去了市政厅。</p><p>其中 On Wednesday evening, 可以放在开头和结尾。</p><p>to the Town Hall：不定式短语</p></blockquote><p>I was having dinner at a restaurant when Tony Steele came in.</p><blockquote><p>我正在一家餐馆吃饭，托尼.斯蒂尔走了进来。</p><p>at a restaurant ：状语</p></blockquote><h3 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h3><p>①句中同时出现几个时间或者地点状语时，从小打到。</p><blockquote><p>We landed in American at 8 o’ clock on June 15th，2012.</p><p>我们2012年6月15日八点在美国着陆。</p><p>We live at number 35.South Renmin Road，Chengdu.</p><p>我们住在成都市人民南路35号。</p></blockquote><p>②句子后面出现多种状语时，顺序是方式–地点–时间。</p><blockquote><p>He put his milk bottles carefully on the doorstep every morning.</p><p>他每天早上小心地把牛奶拼放在门口的台阶上。</p></blockquote><h2 id="同位语"><a href="#同位语" class="headerlink" title="同位语"></a>同位语</h2><blockquote><p>同位语：句子中指代同一事务的两个词、短语或从句，称同为关系。</p></blockquote><p>My sister，Helen Wilson，will travel with me.</p><blockquote><p>句中 My sister 和 Helen Wilson指的是同一个人，它们是同为成分，后一成分通常叫前一成分的同为语。</p></blockquote><p>英语里的同位语，不属于单独的七大句子成分，而是和英语里边的名词成分（主语，宾语，表语）成冰并列关系，相当于对该名词进一步的解释说明。名词或任何相当名词的成分，均可作同位语。</p><h5 id="练习题-5"><a href="#练习题-5" class="headerlink" title="练习题"></a>练习题</h5><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201105220614.png" alt=""></p><p>My English teacher ，Mr. Brent Peter, is a Canadian.</p><blockquote><p>My English teacher 同 Mr.Brent Peter 为同位语状态</p></blockquote><p>Yesterday I met Tom,a friend of my brother’s</p><blockquote><p>Tom 与 friend of my brother’s 同位语状态</p></blockquote><p>We Chinese people are brave and hardworking.</p><blockquote><p>We 同 Chinese people 是同位语状态。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> EC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVC、MVP、MVVM</title>
      <link href="/2020/10/28/MVC%E3%80%81MVP%E3%80%81MVVM/"/>
      <url>/2020/10/28/MVC%E3%80%81MVP%E3%80%81MVVM/</url>
      
        <content type="html"><![CDATA[<h1 id="MVC-MVP-MVVM-图示"><a href="#MVC-MVP-MVVM-图示" class="headerlink" title="MVC MVP MVVM 图示"></a>MVC MVP MVVM 图示</h1><h2 id="MVC（Model、View、Controller）"><a href="#MVC（Model、View、Controller）" class="headerlink" title="MVC（Model、View、Controller）"></a>MVC（Model、View、Controller）</h2><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201028113524.png" alt=""></p><blockquote><ul><li>视图（View）：用户界面</li><li>控制器（Controller）：业务逻辑</li><li>模型（Model）：数据保存</li></ul></blockquote><h5 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h5><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201028113611.png" alt=""></p><blockquote><ol><li>View 传送指令到 Controller</li><li>Controller 完成业务逻辑后，要求 Model 改变状态</li><li>Model 将新的数据发送到 View，用户得到反馈</li></ol></blockquote><p><strong>通信都是单向的</strong></p><h2 id="互动模式"><a href="#互动模式" class="headerlink" title="互动模式"></a>互动模式</h2><blockquote><p><strong>互动模式</strong>（models of interaction），指使用<a href="https://zh.wikipedia.org/wiki/電腦" target="_blank" rel="noopener">电脑</a>时<a href="https://zh.wikipedia.org/wiki/人機互動" target="_blank" rel="noopener">人机互动</a>的界面。好的界面应该是能够有效地让互动顺利进行。互动系统是要让使用者可以在已存在的应用范围中完成他们的目的。系统使用的语言是核语言（core language），使用者使用的语言是任务语言（task language）。</p><p>摘自<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E5%8B%95%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">维基百科</a></p></blockquote><p>接受用户指令时，MVC可分为两种模式。<strong>一种是通过View接受指令</strong>，<strong>传递给Controller。</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201028114024.png" alt=""></p><p><strong>另一种是直接通过controller接受指令。</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201028114109.png" alt=""></p><h2 id="MVP（Model、View、Presenter）"><a href="#MVP（Model、View、Presenter）" class="headerlink" title="MVP（Model、View、Presenter）"></a>MVP（Model、View、Presenter）</h2><p>MVP 模式将 Controller 改名为 <strong>Presenter</strong>，<strong>同时改变了通信方向</strong>。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015020109.png" alt=""></p><blockquote><ol><li><p>各部分之间的通信，是双向的。</p></li><li><p>View 与 Model 不发生联系，都通过 Presenter 传递。</p></li><li><p>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</p></li></ol></blockquote><h2 id="MVVM（Model、View、ViewModel）"><a href="#MVVM（Model、View、ViewModel）" class="headerlink" title="MVVM（Model、View、ViewModel）"></a>MVVM（Model、View、ViewModel）</h2><p>MVVM 模式将 <strong>Presenter</strong> 改名为 <strong>ViewModel</strong>。</p><p>唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。</p><p><strong>引用：</strong></p><p><a href="https://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">MVC，MVP 和 MVVM 的图示</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin 协程</title>
      <link href="/2020/10/14/Kotlin-%E5%8D%8F%E7%A8%8B/"/>
      <url>/2020/10/14/Kotlin-%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h1><blockquote><p><strong>用同步的方式写异步的代码</strong></p></blockquote><p>【协程 Coroutines】 源于Simula 和 Modula-2语言，术语来自于 1958 年的 <strong>Melvin Edward Conway</strong> 发明并且拥有构建汇编程序，说明 <strong>协程是一种编程思想</strong>， 并不局限于特定的语言。</p><h5 id="线程和协程的关系"><a href="#线程和协程的关系" class="headerlink" title="线程和协程的关系"></a>线程和协程的关系</h5><p>从 Android 开发者的角度去理解它们的关系：</p><ul><li>Android中我们所有的代码都跑在线程中的，<strong>而线程是跑在进程中的</strong>。</li><li><strong>协程没有直接和操作系统关联</strong>，它也是<strong>跑在线程中的</strong>，可以是单线程，也可以是多线程。</li><li>单线程中的协程总的<strong>执行时间</strong>并不会比不用协程少。</li><li>Android中，如果在主线程中进行网络访问，会抛出 <strong>NetworkOnMainThreadException</strong>，对于在主线程上的协程也不例外，所以在这种使用场景中也是要切换线程的。</li></ul><h4 id="协程的应用场景之一-线程控制"><a href="#协程的应用场景之一-线程控制" class="headerlink" title="协程的应用场景之一 线程控制"></a>协程的应用场景之一 线程控制</h4><blockquote><p>协程可以让我们在写<strong>代码时不用更多的关注多线程同时更方便的写出并发操作</strong>。</p></blockquote><p><strong>场景</strong></p><p>在Java中实现并发操作通常需要开启 Thread：</p><pre><code class="java">new Thread(new Runnable() {    @Override    public void run() {        ...    }}).start();</code></pre><p>Kotlin中</p><pre><code class="kotlin">Thread({    ...}).start()</code></pre><p><strong>Kotlin和Java使用线程同样存在的问题：</strong></p><ul><li>线程什么时候执行结束</li><li>线程间如何相互通信</li><li>多线程的管理</li></ul><p>可以用Java控制线程 Executor线程池来进行<strong>线程管理</strong>：</p><pre><code class="kotlin">val executor = Executors.newCachedThreadPool()executor.execute({    ...})</code></pre><p>用Android的<strong>AsyncTask</strong>来<strong>解决线程之间的通讯</strong></p><pre><code class="kotlin">object : AsyncTask&lt;T0, T1, T2&gt; {     override fun doInBackground(vararg args: T0): String { ... }    override fun onProgressUpdate(vararg args: T1) { ... }    override fun onPostExecute(t3: T3) { ... }}</code></pre><p>使用<strong>AsyncTask</strong>进行<strong>线程之间</strong>的<strong>通讯</strong>带来的<strong>缺点</strong>（<strong>AsyncTask</strong>是<strong>Android</strong>对<strong>线程池</strong>Executor的<strong>封装</strong>）：</p><ul><li>需要处理多个回调，容易陷入【回调地狱】。</li><li>将业务强行拆分到前台、中间更新、后台三个函数。</li></ul><p>使用 RxJava和协程都可以很好的解决上述的问题。</p><h5 id="例子-使用协程进行网络访问将请求到的数据显示到对应的控件上："><a href="#例子-使用协程进行网络访问将请求到的数据显示到对应的控件上：" class="headerlink" title="例子 使用协程进行网络访问将请求到的数据显示到对应的控件上："></a>例子 使用协程进行网络访问将请求到的数据显示到对应的控件上：</h5><pre><code class="kotlin">launch({    val user = api.getUser() // 👈 网络请求（IO 线程）    nameTv.text = user.name  // 👈 更新 UI（主线程）})</code></pre><p>无需关心 <strong>launch</strong> 它<strong>不是</strong>一个<strong>顶层函数</strong>，只需要关系它的业务逻辑：</p><p>launch <strong>函数</strong>加上实现在 {} 中的<strong>具体逻辑构成</strong>了<strong>协程</strong>。</p><p>通常我们进行网络请求，会传一个callback，或者在IO线程里进行阻塞式的同步调用，而在这段代码中，上下两个语句分别工作在两个线程里，并且写法上和普通单线程代码是一样的。</p><p>这里的 api.getUser是一个挂起函数，所以能够保证nameTv.text的正确赋值，这就涉及到了协程中最著名的【非阻塞式挂起】了。</p><h1 id="协程好在哪里"><a href="#协程好在哪里" class="headerlink" title="协程好在哪里"></a>协程好在哪里</h1><h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><h4 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h4><p><strong>闭包</strong>并<strong>不</strong>是<strong>kotlin</strong>中提出的新概念，在Java8中就已经支持。</p><p>以Thread为例，看看什么是闭包：</p><pre><code class="kotlin">// 创建一个 Thread 的完整写法Thread(object : Runnable {    override fun run() {        ...    }})// 满足 SAM，先简化为Thread({    ...})// 使用闭包，再简化为Thread {    ...}</code></pre><p>语法糖：当函数的最后一个参数是lambda表达式时，可以将<strong>lambda</strong>写在<strong>括号外</strong>。这就是它的<strong>闭包原则</strong>。</p><h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><p>需要一个类型为 Runnable 的参数，而 Runnable 是一个接口，且只定义了一个函数 run，这种情况满足了 Kotlin 的SAM，可以转换成一个传递的 lambda表达式（第二段），以为闭包原则直接写成 Thread{…}（第三段）。</p><p>通过<strong>闭包简化 launch 函数</strong></p><pre><code class="kotlin">launch {    ...}</code></pre><h2 id="基本使用协程"><a href="#基本使用协程" class="headerlink" title="基本使用协程"></a>基本使用协程</h2><p>说过<strong>launch函数不是顶层函数</strong> 并不能直接使用，我们通过下列方法来创建协程：</p><pre><code class="kotlin">// 方法一，使用 runBlocking 顶层函数runBlocking {    getImage(imageId)}// 方法二，使用 GlobalScope 单例对象//            👇 可以直接调用 launch 开启协程GlobalScope.launch {    getImage(imageId)}// 方法三，自行通过 CoroutineContext 创建一个 CoroutineScope 对象//                                    👇 需要一个类型为 CoroutineContext 的参数val coroutineScope = CoroutineScope(context)coroutineScope.launch {    getImage(imageId)}</code></pre><p>方法①，多用于单元测试，业务开发不会用到它，因为它是线程阻塞的。</p><p>方法②，在Android中不推荐这种用法，因为它的生命周期会和app一直，且不能够取消。和使用runBlocking不同它不会阻塞线程。</p><p>方法三，<strong>推荐用法</strong>，通过context参数去管理和控制协程的生命周期（这里的context和Android里的不是同一种东西，更像是一种概念，会有Android平台的封装配合使用）</p><p>其中 <strong>GlobaScope</strong>与<strong>CoroutineScope</strong> 的更多内容后面的文章再说。</p><p>协程<strong>最常用</strong>的<strong>功能</strong>是<strong>并发</strong>，而并发最常用的场景是多线程。可以使用<strong>Dispatchers</strong>.<strong>IO</strong>参数把<strong>任务切换到IO线程执行</strong>：</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.IO) {    ...}</code></pre><p>使用 <strong>Dispatchers.Main</strong> 参数切换到主线程：</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.Main) {    ...}</code></pre><p>所以【什么是协程】中说到的异步请求的完整例子是这样的：</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.Main) {   // 在主线程开启协程    val user = api.getUser() // IO 线程执行网络请求    nameTv.text = user.name  // 主线程更新 UI}</code></pre><p>在Java中回调式的写法是这样的：</p><pre><code class="kotlin">api.getUser(new Callback&lt;User&gt;() {    @Override    public void success(User user) {        runOnUiThread(new Runnable() {            @Override            public void run() {                nameTv.setText(user.name);            }        })    }    @Override    public void failure(Exception e) {        ...    }});</code></pre><h2 id="更为麻烦的并发场景"><a href="#更为麻烦的并发场景" class="headerlink" title="更为麻烦的并发场景"></a>更为麻烦的并发场景</h2><p>对于回调式的写法，如果并发场景再复杂一点，嵌套的可能够多。如果使用协程，多层网络请求。</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.Main) {       // 开始协程：主线程    val token = api.getToken()                  // 网络请求：IO 线程    val user = api.getUser(token)               // 网络请求：IO 线程    nameTv.text = user.name                     // 更新 UI：主线程}</code></pre><p>如果进行多个<strong>网络请求</strong>等待完成后<strong>再刷新UI</strong>。</p><pre><code class="kotlin">api.getAvatar(user, callback)api.getCompanyLogo(user, callback)</code></pre><p>如果使用回调式写法，我们可能会选择妥协，则使用先后请求代替同时请求。</p><pre><code class="kotlin">api.getAvatar(user) { avatar -&gt;    api.getCompanyLogo(user) { logo -&gt;        show(merge(avatar, logo))    }}</code></pre><p>使用窗帘方式去实现可能会导致等待时长了一倍，也相差了一倍的性能。</p><h5 id="协程并行请求网络"><a href="#协程并行请求网络" class="headerlink" title="协程并行请求网络"></a>协程并行请求网络</h5><p>使用协程可以直接并行请求上下两行，最后把结果合并即可：</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.Main) {    //            👇  async 函数之后再讲    val avatar = async { api.getAvatar(user) }    // 获取用户头像    val logo = async { api.getCompanyLogo(user) } // 获取用户所在公司的 logo    val merged = suspendingMerge(avatar, logo)    // 合并结果    //                  👆    show(merged) // 更新 UI}</code></pre><p>即便是比较复杂的并行网络请求，也可以使用并行写出结构清晰的代码。<strong>suspendingMerge</strong> 并不是协程API提供的方法，而是自定义挂起的结果合并方法。</p><h5 id="协程的优势"><a href="#协程的优势" class="headerlink" title="协程的优势"></a>协程的优势</h5><p>让复杂的并发代码，变得简单且清晰是协程的优势。</p><h1 id="协程如何在项目中使用"><a href="#协程如何在项目中使用" class="headerlink" title="协程如何在项目中使用"></a>协程如何在项目中使用</h1><h2 id="在项目中配置对Kotlin协程的支持"><a href="#在项目中配置对Kotlin协程的支持" class="headerlink" title="在项目中配置对Kotlin协程的支持"></a>在项目中配置对Kotlin协程的支持</h2><p>使用协程前，需要在 build.gradle 文件中增加 Kotlin 协程的依赖：</p><ul><li>项目目录下</li></ul><pre><code class="kotlin">buildscript {    ...    // 👇    ext.kotlin_coroutines = &#39;1.3.1&#39;    ...}</code></pre><ul><li>Module 目录下：</li></ul><pre><code class="kotlin">dependencies {    ...    //                                       👇 依赖协程核心库    implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:$kotlin_coroutines&quot;    //                                       👇 依赖当前平台所对应的平台库    implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:$kotlin_coroutines&quot;    ...}</code></pre><p>Kotlin 协程以官方扩展库的形式进行支持。其中【核心库】和【平台库】的版本应该保持一致。</p><ul><li><strong>核心库</strong>为协程的公共API部分。为拉在各个平台统一接口。</li><li><strong>平台库</strong>主要为协程在具体平台的具体实现方式。原因：多线程在各个平台的实现方式不同。</li></ul><h2 id="开始使用协程"><a href="#开始使用协程" class="headerlink" title="开始使用协程"></a>开始使用协程</h2><p><strong>协程最简单的使用</strong>。通过<strong>launch</strong>函数实现线程切换的功能：</p><pre><code class="kotlin">//               👇coroutineScope.launch(Dispatchers.IO) {    ...}</code></pre><h5 id="代码中协程的表现。"><a href="#代码中协程的表现。" class="headerlink" title="代码中协程的表现。"></a><strong>代码中协程的表现。</strong></h5><p><strong>launch</strong> 函数：我要创建协程，并在指定的线程中运行它。被创建的【协程】是谁？ 就是你传给 launch的代码，这段代码叫【协程】。</p><p>当你要切换线程或指定线程时。<strong>要在后台执行任务？</strong></p><pre><code class="kotlin">launch(Dispatchers.IO) {    val image = getImage(imageId)}</code></pre><p><strong>切换到前台刷新界面？</strong></p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.IO) {    val image = getImage(imageId)    launch(Dispatchers.Main) {        avatarIv.setImageBitmap(image)    }}</code></pre><p>发生了嵌套的代码。</p><h5 id="避免嵌套的样子使用协程"><a href="#避免嵌套的样子使用协程" class="headerlink" title="避免嵌套的样子使用协程"></a>避免嵌套的样子使用协程</h5><p>单单使用协程并不会比线程做更多的事情。使用更实用的函数：<strong>withContext</strong>。指定切换线程，并且在执行完内部逻辑后，自动线程切回执行。上述代码使用 withContext：</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.Main) {      // 👈 在 UI 线程开始    val image = withContext(Dispatchers.IO) {  // 👈 切换到 IO 线程，并在执行完成后切回 UI 线程        getImage(imageId)                      // 👈 将会运行在 IO 线程    }    avatarIv.setImageBitmap(image)             // 👈 回到 UI 线程更新 UI} </code></pre><h5 id="比较两种写法来体现-withContext的优势"><a href="#比较两种写法来体现-withContext的优势" class="headerlink" title="比较两种写法来体现 withContext的优势"></a>比较两种写法来体现 withContext的优势</h5><p>当要频繁切换线程时。通过下属代码对比：</p><pre><code class="kotlin">// 第一种写法coroutineScope.launch(Dispatchers.IO) {    ...    launch(Dispatchers.Main){        ...        launch(Dispatchers.IO) {            ...            launch(Dispatchers.Main) {                ...            }        }    }}// 通过第二种写法来实现相同的逻辑coroutineScope.launch(Dispatchers.Main) {    ...    withContext(Dispatchers.IO) {        ...    }    ...    withContext(Dispatchers.IO) {        ...    }    ...}</code></pre><p><strong>优势：</strong></p><p>由于它可以“来回切回来”消除了并发代码在协作时的嵌套。消除了嵌套关系，还可以将 <strong>withContext</strong> 放在单独的函数里：</p><pre><code class="kotlin">launch(Dispatchers.Main) {              // 👈 在 UI 线程开始    val image = getImage(imageId)    avatarIv.setImageBitmap(image)     // 👈 执行结束后，自动切换回 UI 线程}//                               👇fun getImage(imageId: Int) = withContext(Dispatchers.IO) {    ...}</code></pre><p>实现了【同步的方式写异步的代码】。</p><pre><code class="kotlin">launch(Dispatchers.Main) {              // 👈 在 UI 线程开始    val image = getImage(imageId)    avatarIv.setImageBitmap(image)     // 👈 执行结束后，自动切换回 UI 线程}//                               👇fun getImage(imageId: Int) = withContext(Dispatchers.IO) {    ...}</code></pre><p><strong>withContext 单独放在函数中要注意那些</strong></p><pre><code class="kotlin">fun getImage(imageId: Int) = withContext(Dispatchers.IO) {    // IDE 报错 Suspend function&#39;withContext&#39; should be called only from a coroutine or another suspend funcion}</code></pre><p><strong>需要在 suspend函数中调用</strong>。（<strong>withContext</strong> 是<strong>一个 suspend</strong> 函数，所以需要在<strong>协程</strong>或者<strong>suspend函数</strong>中调用。）</p><h2 id="什么是-suspend-函数"><a href="#什么是-suspend-函数" class="headerlink" title="什么是 suspend 函数"></a>什么是 suspend 函数</h2><p><strong>suspend</strong> 函数是<strong>kotlin协程</strong>最核心的关键字。中文意思为【暂停】、【可挂起】。</p><p>解释：</p><blockquote><p>代码执行到 <strong>suspend 函数</strong>的时候会【<strong>挂起</strong>】，并且这个<strong>【挂起】</strong>是<strong>非阻塞式</strong>的，不会阻塞当前线程。</p></blockquote><p>修改上述代码让它可以执行：</p><pre><code class="kotlin">//👇suspend fun getImage(imageId: Int) = withContext(Dispatchers.IO) {    ...}</code></pre><p>到底什么是 suspend ，什么是 【非阻塞】，如何【挂起】。下篇。</p><h1 id="【挂起的本质】"><a href="#【挂起的本质】" class="headerlink" title="【挂起的本质】"></a>【挂起的本质】</h1><p>协程中挂起的对象是什么？     <strong>挂起的对象是协程。</strong></p><p>协程是什么？</p><blockquote><p>启动一个协程可以使用 <strong>launch 或者 async 函数</strong>，协程就是<strong>这两个函数中闭包的代码块</strong>。<strong>launch，async 或者其他函数创建的协程，</strong>在执行到某个 suspend函数时，这个协程会被 【<strong>suspend</strong>】挂起。</p></blockquote><p>从哪里挂起？</p><blockquote><p>在当前线程挂起。就是说<strong>当前协程</strong>在执行的线程中脱离。注意 它只是脱离了，当前线程不再去管理这个协程要求做什么。</p></blockquote><p><strong>当线程执行到协程的suspend函数的时候，暂时不再执行协程中的代码了。</strong></p><p>分开来看，互相脱离的线程和协程接下来将发生什么事情。</p><h4 id="线程："><a href="#线程：" class="headerlink" title="线程："></a>线程：</h4><p>协程的代码块中，<strong>线程执行到了suspend函数这里的时候，就暂时不再执行剩余的协程代码，跳出协程的代码块。</strong></p><p>那线程接下来会做什么？</p><p>例如它是后台线程：</p><ul><li>无事可做，被系统回收</li><li>继续执行别的后台任务</li></ul><p>同Java线程池用到线程在工作结束后的完全一样：回收或者再利用。</p><p>如果是个Android的主线程，那么它会以一秒六十次的界面刷新任务。</p><p>常见的场景是，获取图片，显示出来：</p><pre><code class="kotlin">// 主线程中GlobalScope.launch(Dispatchers.Main) {  val image = suspendingGetImage(imageId)  // 获取图片  avatarIv.setImageBitmap(image)           // 显示出来}suspend fun suspendingGetImage(id: String) = withContext(Dispatchers.IO) {  ...}</code></pre><p>在主线程的协程，<strong>它实质上会往你的主线程 post 一个 Runnable，这个 Runnable 就是你的协程代码：</strong></p><pre><code class="kotlin">handler.post {  val image = suspendingGetImage(imageId)  avatarIv.setImageBitmap(image)}</code></pre><p>协程被挂起时，<strong>主线程的 post 的Runnable 提前结束，然后继续执行它界面的刷新任务。</strong></p><h4 id="协程："><a href="#协程：" class="headerlink" title="协程："></a>协程：</h4><p>线程的代码在到达 <strong>suspend</strong>函数时会被掐断，<strong>协程会从这个 suspend 函数开始继续往下执行，不过是在指定的线程</strong>。</p><p>谁指定的？</p><blockquote><p>suspend 函数指定的， 比如我们这个例子中， 函数内部的withContext传入的Dispatchers.IO所指定的IO线程。</p></blockquote><p><strong>Dispatchers 调度器，限制协程在特定的线程执行，或者分派的一个线程池，或者让它不受限制的运行。</strong></p><p>常用的 Dispatchers，共有那些：</p><ul><li><strong>Dispatchers.Main</strong>:Android的主线程</li><li><strong>DIspatchers.IO</strong>:针对磁盘和网络IO进行了优化，适合IO密集型的任务，例如：读写文件，操作数据库以及网络请求</li><li><strong>Dispatchers.Detault</strong>:适合GPU密集型任务，例如计算。</li></ul><p>协程从 <strong>suspend</strong> 函数开始脱离启动它的线程，继续执行在 <strong>Dispatchers</strong> 所指定的IO线程。</p><p>在 suspend 函数执行完成之后，协程为我们：<strong>自动将线程切回来</strong></p><p><strong>切回？什么意思？</strong></p><p>协程原本是在 <strong>主线程中运动的</strong>，在代码执到 <strong>suspend</strong> 函数的时候，发生线程切换，根据 <strong>Dispatchers</strong> 切换到了IO线程；</p><p>【<strong>切回</strong>】是协程会棒我再 post 一个 Runnable，让剩下的代码继续回到主线程去执行。</p><h4 id="本质："><a href="#本质：" class="headerlink" title="本质："></a>本质：</h4><p>协程再执行到标记有suspend标记的函数时，会被suspend也就是挂起，而所谓的挂起，就是切线程；不同在于，<strong>挂起函数在执行完成之后，协程会重新切回它的线程。</strong> 再简单来说：<strong>kotlin 中挂起，就是一个稍后会被自动切回的线程调度操作。</strong></p><blockquote><p>【切回】动作，在kotlin里叫做 resume，</p></blockquote><p>函数挂起后是需要恢复的。</p><p>而恢复这个功能是协程的，如果不在协程里调用，恢复这个功能是没法实现的，所以也就回答了这个问题：为什么挂起函数必须在协程或者另一个挂起函数中调用。</p><h1 id="如何挂起的？"><a href="#如何挂起的？" class="headerlink" title="如何挂起的？"></a>如何挂起的？</h1><p>【<strong>挂起</strong>】是如何做到的。</p><p>定义的任意函数：</p><pre><code class="kotlin">suspend fun suspendingPrint() {  println(&quot;Thread: ${Thread.currentThread().name}&quot;)}I/System.out: Thread: main</code></pre><p>输出结果还是为主线程。</p><p>为何没有切换线程了？因为它并不知道往哪里切，需要我们告诉它。</p><p>对比之前例子中的 suspendingGetImage函数代码：</p><pre><code class="kotlin">//                                               👇suspend fun suspendingGetImage(id: String) = withContext(Dispatchers.IO) {  ...}</code></pre><p>不同之处在于 <strong>withContext</strong> 函数</p><p><strong>withContext</strong>源码可知，<strong>它本身就是一个挂起函数，它接受一个Dispatcher 函数，依赖这个Dispatcher 函数的指示，你的协程被挂起，然后切换到别的线程。</strong></p><p>所以suspend，并不能起到挂起函数的作用。</p><p>而真正挂起协程的，kotlin协程框架帮助我们做的。</p><p>加上 suspend 关键词是不行的，还需要直接或者间接的调用到 kotlin 协程框架自带的 <strong>suspend</strong> 函数才行。</p><h1 id="suspend-的意义？"><a href="#suspend-的意义？" class="headerlink" title="suspend 的意义？"></a>suspend 的意义？</h1><p>这个关键词最重要的作用就是<strong>提醒</strong>。</p><p>提醒你这个函数是一个挂起操作，<strong>提醒它是个耗时函数，请在协程你调用它。</strong></p><pre><code class="kotlin">// 👇 redundant suspend modifiersuspend fun suspendingPrint() {  println(&quot;Thread: ${Thread.currentThread().name}&quot;)}</code></pre><p>如果你创建使用 <strong>suspend</strong> 函数但是它内部并没有包含真正的挂起逻辑时，<strong>编译器会给你提示</strong>：<strong>redundant suspend modigier</strong>，这个 <strong>suspend</strong> 关键词是多余的。</p><p>因为这个函数并没有发生真正的挂起，此时 suspend 关键词只有一个效果：<strong>限制这个函数只能在协程里被调用，在非协程的代码中是无法调用的。</strong></p><p>创建suspend函数，要在它内部直接或者间接的调用 kotlin 自带的suspend 函数，这是你的 suspend才有意义。</p><h1 id="如何自定义-suspend-函数？"><a href="#如何自定义-suspend-函数？" class="headerlink" title="如何自定义 suspend 函数？"></a>如何自定义 suspend 函数？</h1><p>先分为两个问题:</p><ul><li>什么时候需要自定义 suspend 函数？</li><li>具体应该怎么写?</li></ul><h4 id="什么时候需要自定义-suspend-函数？"><a href="#什么时候需要自定义-suspend-函数？" class="headerlink" title="什么时候需要自定义 suspend 函数？"></a><strong>什么时候需要自定义 suspend 函数？</strong></h4><p>某个函数需要耗时操作时，那就可以把它写成 suspend 函数。这是原则。</p><p>耗时操作共分为两类：IO操作和CPU计算工作，比如文件的读写、网络交付、图片的模糊处理，都是耗时的。</p><h4 id="具体操作："><a href="#具体操作：" class="headerlink" title="具体操作："></a>具体操作：</h4><p>给函数加上 <strong>suspend</strong> 关键字，然后 <strong>withContext</strong> 把函数的内容包住就可以了。</p><p>使用 <strong>withContext</strong> 是因为它在挂起函数中功能最简单直接：把线程自动切走或者切回。</p><p>当然并不是只有 <strong>withContext</strong> 这个函数来辅助我们自定义<strong>suspend</strong> 函数，比如挂起函数 <strong>delay</strong>，它的作用是等待指定时间再往下执行代码。</p><p><strong>使用delay执行等待耗时操作</strong></p><pre><code class="kotlin">suspend fun suspendUntilDone() {  while (!done) {    delay(5)  }}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>什么是挂起？</p><blockquote><p>挂起，就是一个稍后会被指定切回来的线程调度操作。</p></blockquote><p>疑惑：</p><p>协程中的非阻塞式是什么</p><p>协程和RxJava在切换线程方面功能是一样的，都能写出避免嵌套回调的复杂并发代码，协程相比有什么优势，或者让开发者使用的理由？</p><h1 id="协程-Job"><a href="#协程-Job" class="headerlink" title="协程 Job"></a>协程 Job</h1><p>Job 是标准库中启动协程后返回的对象，代表着协程本次作业。我们可以判断协程是否接受，是否取消，是否完成并且额可以取消当前协程以及嵌套子协程。</p><p>基本上每启动一个协程就会产生对应的Job。</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.IO) {    ...}</code></pre><p>launch 返回的就是一个Job，它可以用来管理协程，一个Job中可以关联多个子Job，同时它也提供了通过外部传入parent的实现。</p><p>Job 管理协程，那么它提供了六种状态表示协程的运行状态。</p><ol><li><strong>New</strong>：创建</li><li><strong>Active</strong>：运行</li><li><strong>Completing</strong>：已经完成等待自身的子协程</li><li><strong>Completed</strong>：完成</li><li><strong>Cancelling</strong>：正在进行取消或者失败</li><li><strong>Cancelled</strong>：取消或失败</li></ol><p>这六种状态 <strong>Job</strong>对外暴露了三种状态，它们可以随时通过Job来获取</p><pre><code class="java">public val isActive: Booleanpublic val isCompleted: Booleanpublic val isCancelled: Boolean</code></pre><p>在你需要手动管理协程时，通过下面的方法来判断当前协程是否在运行。</p><pre><code class="kotlin">while (job.isActive) {// 协程运行中            }</code></pre><p>一般协程创建的时候就处在 <strong>Active</strong>状态，但是也有特殊情况。</p><p><strong>引用：</strong></p><p><a href="https://kaixue.io/kotlin-coroutines-1/" target="_blank" rel="noopener">Kotlin 的协程用力瞥一眼 - 学不会协程？很可能因为你看过的教程都是错的</a></p><p><a href="https://kaixue.io/kotlin-coroutines-2/" target="_blank" rel="noopener">Kotlin 协程的挂起好神奇好难懂？今天我把它的皮给扒了</a></p><p><a href="https://blog.csdn.net/qfanmingyiq/article/details/105547092" target="_blank" rel="noopener">Kotlin协程核心库分析-2 Job简述</a></p><p><a href="https://zhuanlan.zhihu.com/p/297543508" target="_blank" rel="noopener">Kotlin协程实现原理:CoroutineScope&amp;Job</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lifecycle 讲解</title>
      <link href="/2020/10/11/Lifecycle/"/>
      <url>/2020/10/11/Lifecycle/</url>
      
        <content type="html"><![CDATA[<h1 id="Lifecycle使用详解"><a href="#Lifecycle使用详解" class="headerlink" title="Lifecycle使用详解"></a>Lifecycle使用详解</h1><h2 id="Lifecycle可以做什么"><a href="#Lifecycle可以做什么" class="headerlink" title="Lifecycle可以做什么"></a>Lifecycle可以做什么</h2><p><strong>Lifecycle 是具有生命周期感知能力的组件，也就是说，在Activity或者Fragment的生命周期发生变动的是否得到通知</strong>。我们往往会在Activity的各种生命周期方法里执行特定的方法。</p><pre><code class="java">public class TestActivity extends AppCompatActivity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_test);    }    @Override    protected void onStart() {        super.onStart();        EventBus.getDefault().register(this);    }    @Override    protected void onDestroy() {        EventBus.getDefault().unregister(this);        super.onDestroy();    }}</code></pre><p>如果我们把很多这种需要跟生命周期相关的逻辑代码直接放在Activity的生命周期方法中，Activity会变的很难以维护的。通过使用Lifecycle，来避免这种情况。</p><h2 id="Lifecycle使用"><a href="#Lifecycle使用" class="headerlink" title="Lifecycle使用"></a>Lifecycle使用</h2><p>导入Lifecycle依赖</p><p>AndroidX:</p><pre><code class="groovy">implementation &quot;androidx.lifecycle:lifecycle-runtime:2.0.0&quot;</code></pre><h3 id="Lifecycler-实现机制"><a href="#Lifecycler-实现机制" class="headerlink" title="Lifecycler 实现机制"></a>Lifecycler 实现机制</h3><ol><li><strong>需要一个构建Lifecycle对象</strong>（通过一个实现了LifecycleOwner接口的对象 getLifecycle() 方法返回），这个对象就是一个被观察者，具有生命感知能力。</li><li><strong>构建一个LifecycleObserver对象，</strong>对指定的Lifecycle对象进行监听（<strong>观察者</strong>）</li><li>通过将Lifecyc对象的addObserver()方法，将Lifecycle对象和LifecycleObserver对象进行绑定。</li></ol><h3 id="继承AppCompatActivity"><a href="#继承AppCompatActivity" class="headerlink" title="继承AppCompatActivity"></a>继承AppCompatActivity</h3><p>创建 MyObserver.java 让它实现LifeyclerObserver 接口（<strong>LifecycleObserver接口是一个空接口，主要给注解处理器使用</strong>):</p><pre><code class="kotlin">/** *   by:Thecara home *   date:2020/10/11 */class MyObserver : LifecycleObserver {    // 使用注解 @OnLifecycleEvent() 该方法需要监听指定的生命周期事件    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)    fun connectListener() {        Log.d(&quot;MyObserver&quot;, &quot;ON_RESUME&quot;)    }    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)    fun disconnectListener() {        Log.d(&quot;MyObserver&quot;, &quot;ON_PAUSE&quot;)    }}</code></pre><p>可以看到，通过在方法上使用 <strong>@onLifecycleEvent</strong> 注解使得方法具有生命感知能力。<strong>括号里的参数，表明需要监听的是什么生命周期事件。</strong>Lifecycle 主要<strong>通过Event和State者两个枚举类来追踪关联组件的生命周期状态</strong>。具体的Event和State之间的转换关系，可以参考如下：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1692ebbac5daa896" alt=""></p><p>让Activity继承自AppCompatActivity，然后再OnCreate()方法中通过 <strong>getLifecycle().addObserver(new MyObserver())</strong> 完成<strong>Lifecycle</strong>和<strong>LifecycleObser</strong>的绑定:</p><pre><code class="kotlin">class MainActivity : AppCompatActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        // 绑定        lifecycle.addObserver(MyObserver())    }}</code></pre><p>通过切换后台观察状态。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-10-11-0.gif" alt="切换"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-10-11-1.gif" alt="Log"></p><p>library 26.1.0 及之后的库中，<strong>AppCompatActivity的父类SupportActivity已经默认实现了LifecycleOwner接口，直接通过getLifecycle() 方法获得Lifecycle对象。</strong></p><p>之后通过 <strong>addObserver()</strong> 方法将Lifecycle 跟指定 LifecycleObserver 进行绑定。</p><h1 id="Docs"><a href="#Docs" class="headerlink" title="Docs"></a>Docs</h1><h2 id="androidx-lifecycle-ViewModelProvider-类"><a href="#androidx-lifecycle-ViewModelProvider-类" class="headerlink" title="androidx.lifecycle.ViewModelProvider 类"></a>androidx.lifecycle.ViewModelProvider 类</h2><blockquote><p>An utility class that provides ViewModels for a scope.</p><p>Default ViewModelProvider for an Activity or a Fragment can be obtained by passing it to the constructor: ViewModelProvider(myFragment)</p><p>为作用域提供ViewModels的实用程序类。</p></blockquote><h2 id="androidx-lifecycle-LiveData-类"><a href="#androidx-lifecycle-LiveData-类" class="headerlink" title="androidx.lifecycle.LiveData 类"></a>androidx.lifecycle.LiveData 类</h2><blockquote><p>LiveData is a data holder class that can be observed within a given lifecycle.</p><p>LiveData是一个数据持有者类，可以在给定的生命周期中观察它。</p><p>This means that an Observer can be added in a pair with a LifecycleOwner, and this observer will be notified about modifications of the wrapped data only if the paired LifecycleOwner is in active state.</p><p>这意味着观察者可以和LifecycleOwner一起添加，只有当配对的LifecycleOwner处于活动状态时，观察者才会收到包装数据修改的通知。</p><p>LifecycleOwner is considered as active, if its state is STARTED or RESUMED.</p><p>LifecycleOwner被认为是活动的，如果它的状态是STARTED或RESUMED。</p><p>An observer added via observeForever is considered as always active and thus will be always notified about modifications.</p><p>通过observeForever添加的观察者会被认为始终处于活动状态，因此会一直收到修改通知。</p><p>For those observers, you should manually call removeObserver.</p><p>对于这些观察者，您应该手动调用removeObserver。</p></blockquote><h3 id="observe"><a href="#observe" class="headerlink" title="observe"></a>observe</h3><blockquote><p>Adds the given observer to the observers list within the lifespan of the given owner.</p><p>在给定所有者的生命周期内将给定的观察者添加到观察者列表中。</p><p>The events are dispatched on the main thread.</p><p>事件在主线程上分派。</p><p>If LiveData already has data set, it will be delivered to the observer.</p><p>如果LiveData已经拥有数据集，那么它将被交付给观察者。</p></blockquote><pre><code>@MainThreadpublic void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;Object&gt; observer)</code></pre><p><strong>引用：</strong></p><p><a href="https://juejin.im/post/6844903784166998023" target="_blank" rel="noopener">Android生命周期组件Lifecycle使用详解</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Lifecycle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是BuildConfig</title>
      <link href="/2020/09/17/BuildConfig/"/>
      <url>/2020/09/17/BuildConfig/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-BuildConfig"><a href="#什么是-BuildConfig" class="headerlink" title="什么是 BuildConfig"></a>什么是 BuildConfig</h1><p><strong>在打包时自动生成的类。</strong>类似于R.class，生成后不能修改。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200917233605.png" alt="在项目中的位置"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Timber</title>
      <link href="/2020/09/17/Timber/"/>
      <url>/2020/09/17/Timber/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Timber"><a href="#使用-Timber" class="headerlink" title="使用 Timber"></a>使用 Timber</h1><ul><li>配置 timber</li></ul><pre><code class="groovy">implementation &#39;com.jakewharton.timber:timber:4.7.1&#39;</code></pre><ul><li><h5 id="准备Log输出的自定义格式"><a href="#准备Log输出的自定义格式" class="headerlink" title="准备Log输出的自定义格式"></a><strong>准备Log输出的自定义格式</strong></h5></li></ul><blockquote><p>可以直接在Application的onCreate()中调用<code>Timber.plant(new DebugTree())</code>实现Debug功能。但是功能有所欠缺，<strong>可以用来上传crash信息</strong>等。</p><p>ps：</p><p>Timber主要通过添加Tree实例来实现，添加Tree实例可以通过方法Timber.plant完成。</p><p>而使用DebugTree实现自动实例化</p></blockquote><ol><li>不会<strong>打印当前线程</strong></li><li>不会<strong>打印当前行号</strong></li></ol><p>自己创建一个继承类来实现这两个功能。</p><pre><code class="kotlin">class ThreadAwareDebugTree : Timber.DebugTree() {    //添加当前线程    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {        if (tag != null) {            val threadName = Thread.currentThread().name            tag != &quot;&lt;&quot; + threadName + &quot;&gt;&quot;        }        super.log(priority, tag, message, t)    }    // 添加行号    override fun createStackElementTag(element: StackTraceElement): String? {        return super.createStackElementTag(element) + &quot;Line(&quot; + element.lineNumber + &quot;)&quot;    }}</code></pre><p><strong>还有一个类在 release 版本时调用打印log信息</strong></p><blockquote><p>release 版本用来以一种跟踪日志的形式上报给 <strong>Bugly</strong>，它只会显示 w，e，wtf。</p></blockquote><pre><code class="kotlin">class ReleaseTree : ThreadAwareDebugTree() {    override fun isLoggable(tag: String?, priority: Int): Boolean {        return if (priority == Log.VERBOSE || priority == Log.DEBUG || priority == Log.INFO) {            false        } else true    }    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {        if (!isLoggable(tag, priority)) {            return        }        super.log(priority, tag, message, t)    }}</code></pre><ul><li>准备 Application</li></ul><pre><code class="kotlin">class TimberDemoApplication : Application() {    override fun onCreate() {        super.onCreate()        if (DEBUG)            Timber.plant(ThreadAwareDebugTree())    }}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200921111610.png" alt="添加Application"></p><ul><li>调用一个log</li></ul><pre><code class="kotlin">println(Timber.v(&quot;hello&quot;))</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200921112051.png" alt="通过自定义的类型输出了行号的信息"></p><h2 id="重写-Log-方法"><a href="#重写-Log-方法" class="headerlink" title="重写 Log 方法"></a>重写 Log 方法</h2><p><strong>参数</strong></p><blockquote><p>priority:Int 优先级</p><p>tag:String 打印时的标签</p><p>message:String 内容</p><p>t:Throwable 抛出的异常</p></blockquote><p>此方法可以用来根据发送来的 <strong>异常等信息</strong> 自定义接下来的动作。这些信息并不会被从log日志打印出来。</p><p><strong>调用</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201009123005.png" alt="调用log方法"></p><pre><code class="kotlin"> Timber.log(1, &quot;测试打印&quot;)</code></pre><h4 id="打印我们发送来的信息"><a href="#打印我们发送来的信息" class="headerlink" title="打印我们发送来的信息"></a>打印我们发送来的信息</h4><pre><code class="kotlin">class MyTimberFree : Timber.Tree() {    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {        super.log(priority, tag, message, t)        Timber.v(message)    }}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201009123216.png" alt="发送成功，我们可以根据这些信息上传到crash中。"></p><h1 id="为什么使用Timber"><a href="#为什么使用Timber" class="headerlink" title="为什么使用Timber"></a>为什么使用Timber</h1><ol><li><p>项目开发时，为了方便调试，需要输出log，但是发布后，log中包含很多项目信息，如果全部暴露可能会造成安全隐患，当完全删除也不利于后期调试，因此需要一个开关，关闭开关不能输出bug，打开开关则可以输出log。</p></li><li><p>每次需要打印 TAG</p></li><li><p>不会打印当前线程</p></li><li><p>不会打印当前行号</p></li></ol><p><a href="https://xiazdong.github.io/2017/05/17/Timber/" target="_blank" rel="noopener">Timber和Bugly使用入门</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Timber </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用gradle</title>
      <link href="/2020/09/09/%E4%BD%BF%E7%94%A8gradle/"/>
      <url>/2020/09/09/%E4%BD%BF%E7%94%A8gradle/</url>
      
        <content type="html"><![CDATA[<h1 id="创建-Gradle-项目"><a href="#创建-Gradle-项目" class="headerlink" title="创建 Gradle 项目"></a>创建 Gradle 项目</h1><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-9-9-0.gif" alt=""></p><p>👆 联网状态打开 IDEA</p><h1 id="项目结构介绍"><a href="#项目结构介绍" class="headerlink" title="项目结构介绍"></a>项目结构介绍</h1><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910110408.png" alt=""></p><p><strong>src/main/java</strong> 正式代码目录</p><p><strong>src/main/resources</strong> 正式配置文件目录</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910111041.png" alt=""></p><p><strong>src/test/java</strong> 放置单元测试代码目录</p><p><strong>src/test/resources</strong> 放置单元测试配置文件目录</p><p><strong>src/main/webapp</strong> 还有一个可放置的 web 目录（页面信息）</p><h4 id="src-build-gradle-文件"><a href="#src-build-gradle-文件" class="headerlink" title="src/build.gradle 文件"></a>src/build.gradle 文件</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910162235.png" alt=""></p><p><strong>plugins{}</strong></p><blockquote><p>指运行环境</p></blockquote><p><strong>repositories{}</strong></p><blockquote><p>mavenContral() 为中央仓库，在没有指定情况的下会直接从中央仓库下载 jar 包。</p></blockquote><p><strong>dependenciese{}</strong></p><blockquote><p>gradle工程所有的jar包的坐标都在dependencies属性内放置。</p><p>同时每个jar包的坐标都有三个基本元素构成，group，name，version 组成</p></blockquote><p><strong>group</strong>：多分为多段，第一段为 域，第二段公司名称。其中 org 为非盈利组织，con 为商业组织。例如：tomat：为 apache项目 groupid为org.apache。</p><p><strong>name</strong>：项目的全名称。</p><p><strong>version</strong>：版本号。</p><p><strong>testCompile</strong>：测试时所依赖的jar包，在dradle可由 implementation 代替。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910165023.png" alt=""></p><p>创建项目有提到 👆</p><h4 id="项目-build-gradle-文件"><a href="#项目-build-gradle-文件" class="headerlink" title="项目/build.gradle 文件"></a>项目/build.gradle 文件</h4><p><strong>buildscript{} 属性</strong></p><blockquote><p>gradle执行所需要的依赖，分别对应maven库和插件</p></blockquote><h1 id="通过-mevenCentral-引入-jar-包"><a href="#通过-mevenCentral-引入-jar-包" class="headerlink" title="通过 mevenCentral 引入 jar 包"></a>通过 <strong>mevenCentral</strong> 引入 jar 包</h1><p>使用 compile 添加 jar 包</p><blockquote><p>用来解析所需要的依赖在classpath中可用，并且将它们打包。</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-9-10-1.gif" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910180423.png" alt=""></p><p>依赖完成</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910182006.png" alt=""></p><p>在 用户的 user/用户名/.gradle/caches/modules-2/files-2.1 下有我们加载的 jar 包</p><h1 id="demo-引入一个spring包-并测试使用"><a href="#demo-引入一个spring包-并测试使用" class="headerlink" title="demo 引入一个spring包 并测试使用"></a>demo 引入一个spring包 并测试使用</h1><h3 id="在-mavenRepository-中引入jar-包"><a href="#在-mavenRepository-中引入jar-包" class="headerlink" title="在 mavenRepository 中引入jar 包"></a>在 mavenRepository 中引入jar 包</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200911162643.png" alt=""></p><pre><code class="groovy">// https://mvnrepository.com/artifact/org.springframework/spring-contextcompile group: &#39;org.springframework&#39;, name: &#39;spring-context&#39;, version: &#39;5.2.8.RELEASE&#39;</code></pre><h3 id="引入后的依赖包位置查看"><a href="#引入后的依赖包位置查看" class="headerlink" title="引入后的依赖包位置查看"></a>引入后的依赖包位置查看</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200911162549.png" alt=""></p><h3 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h3><p><strong>创建 接口 ”AccountDao“</strong></p><p>位置 ”com.gradlelearn.dao“</p><pre><code class="java">public interface AccountDao {    public List findAll();}</code></pre><p>作为接口，查询方法</p><p><strong>创建 ”AccountDaoImpl“</strong></p><p>位置 ”com.gradlelearn.dao.impl“</p><pre><code class="java">public class AccountDaoImpl implements AccountDao {    @Override    public List findAll() {        System.out.println(&quot;test&quot;);        return null;    }}</code></pre><p>实现查询功能</p><h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><p><strong>创建 ”AccountTest“</strong></p><p>位置 test 文件下 ”com.gradle.test“</p><p><strong>ClassPathXmlApplicationContext</strong> 类型</p><blockquote><p>获得当前 bean 容器</p><p>创建对象 ApplicationContext 类型</p></blockquote><p><strong>applicationContext.getBean</strong> 方法</p><blockquote><p>从容器中获得当前 Dao</p></blockquote><pre><code class="java">public class AccountTest {    @Test    public void acccountTest() {        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);        AccountDao bean = applicationContext.getBean(AccountDao.class);        bean.findAll();    }}</code></pre><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200911164758.png" alt=""></p><h3 id="打包-jar-包"><a href="#打包-jar-包" class="headerlink" title="打包 jar 包"></a>打包 jar 包</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-9-11-0.gif" alt=""></p><p><strong>jar 包的位置</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200911165345.png" alt=""></p><h1 id="创建-web-工程-demo"><a href="#创建-web-工程-demo" class="headerlink" title="创建 web 工程 demo"></a>创建 web 工程 demo</h1><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h5 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h5><p>使用 ext 扩展块可以一次添加多个属性。</p><p>声明多个属性。添加了键值对的属性集合。</p><pre><code class="groovy">ext.versions = [minSdk:21,targetSdk:29]</code></pre><h5 id="apply-plugin"><a href="#apply-plugin" class="headerlink" title="apply plugin"></a>apply plugin</h5><p>此方式用来引入 <strong>Gradle 官方插件库</strong>。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915181918.png" alt=""></p><h5 id="apply-from"><a href="#apply-from" class="headerlink" title="apply from"></a>apply from</h5><p>引用本地资源</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915182720.png" alt=""></p><h2 id="android"><a href="#android" class="headerlink" title="android"></a>android</h2><p>这个闭包主要为了配置项目结构的各种属性。</p><h5 id="compileSdkVersion"><a href="#compileSdkVersion" class="headerlink" title="compileSdkVersion"></a>compileSdkVersion</h5><p>设置编译时用的Android版本</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915183321.png" alt=""></p><h2 id="defaultConfig-闭包"><a href="#defaultConfig-闭包" class="headerlink" title="defaultConfig 闭包"></a>defaultConfig 闭包</h2><p>默认闭包</p><h5 id="applicationId"><a href="#applicationId" class="headerlink" title="applicationId"></a>applicationId</h5><p>项目的包名</p><h5 id="minSdkVersion"><a href="#minSdkVersion" class="headerlink" title="minSdkVersion"></a>minSdkVersion</h5><p>最低兼容版本</p><h5 id="targetSdkVersion"><a href="#targetSdkVersion" class="headerlink" title="targetSdkVersion"></a>targetSdkVersion</h5><p>目标兼容版本</p><h5 id="versionCode"><a href="#versionCode" class="headerlink" title="versionCode"></a>versionCode</h5><p>项目版本号</p><h5 id="versionName"><a href="#versionName" class="headerlink" title="versionName"></a>versionName</h5><p>版本名称</p><h5 id="testInstrumentationRunner"><a href="#testInstrumentationRunner" class="headerlink" title="testInstrumentationRunner"></a>testInstrumentationRunner</h5><p>用来进行 AndroidJUnitRunner 进行单元测试</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915183913.png" alt="detailtConfig闭包"></p><h2 id="buildTypes-闭包"><a href="#buildTypes-闭包" class="headerlink" title="buildTypes 闭包"></a>buildTypes 闭包</h2><p>生成安装文件的主要配置，多数为两个子闭包，    一个debug闭包，<strong>用于指定生成测试版安装文件的配置</strong>，可忽略。一个release闭包，<strong>用于指定生成正式版的配置</strong>。两者配置参数大多一致，区别为<strong>默认属性配置不一样</strong>。</p><h5 id="minifyEnabled"><a href="#minifyEnabled" class="headerlink" title="minifyEnabled"></a>minifyEnabled</h5><p>是否对代码进行混淆</p><h5 id="proguardFiles"><a href="#proguardFiles" class="headerlink" title="proguardFiles"></a>proguardFiles</h5><p>指定混淆的规则文件</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915185118.png" alt=""></p><h2 id="dependencies闭包"><a href="#dependencies闭包" class="headerlink" title="dependencies闭包"></a>dependencies闭包</h2><p>定义了项目的依赖关系，三种依赖方式：<strong>本地依赖，库依赖，和远程依赖</strong>。</p><blockquote><p>自AndroidStudio3.0后 compile 引入库不再使用，而通过api和implementation，api完全等同于先前的 compile</p><p>，通过 api 引入 整个项目是可以使用当前的依赖库的。<strong>implementation 引入的库只有对应的 Module 使用</strong>。</p><p>在使用 compile时导致模块之间的耦合过高，不利于项目的拆解，<strong>通过 implementation做到降低耦合提高安全性</strong>。</p></blockquote><p>Module：指项目中创建的不同Module。</p><h5 id="implementation"><a href="#implementation" class="headerlink" title="implementation"></a>implementation</h5><p>远程依赖</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915190215.png" alt=""></p><h5 id="testImplementation-和-androidTestImplementation"><a href="#testImplementation-和-androidTestImplementation" class="headerlink" title="testImplementation 和 androidTestImplementation"></a>testImplementation 和 androidTestImplementation</h5><p>测试用依赖库</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915190143.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915190127.png" alt=""></p><h1 id="groovy-快速使用"><a href="#groovy-快速使用" class="headerlink" title="groovy 快速使用"></a>groovy 快速使用</h1><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-9-10-0.gif" alt=""></p><p>打开 idea 的 groovy 编辑器</p><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p><strong>groovy hellow word！</strong></p><pre><code class="groovy">println(&quot;hello world!&quot;);</code></pre><p>groovy 更类似于 java 语言。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910113424.png" alt=""></p><p><strong>groovy 可以省略末尾 “;”号</strong></p><pre><code class="groovy">println(&quot;hello world!&quot;)</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910112155.png" alt=""></p><p><strong>groovy 可以 省略括号</strong></p><pre><code class="groovy">println &quot;hello world!&quot;</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910120309.png" alt=""></p><p><strong>定义变量</strong></p><pre><code class="groovy">def x = 15println x</code></pre><p>def 修饰符是 <strong>弱类型</strong> 声明，groovy会自动根据情况来给变量赋予对应的类型。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910150342.png" alt=""></p><p><strong>定义集合</strong></p><pre><code class="groovy">def x = [&#39;x&#39;, &#39;f&#39;, &#39;c&#39;]x &lt;&lt; &#39;y&#39;println x</code></pre><p>定义集合：通过 “[]” 中括号声明</p><p>集合添加数据，”&lt;&lt;” 双小于号即可</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910151126.png" alt=""></p><p><strong>提取元素</strong></p><pre><code class="groovy">x.get(2)</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910151255.png" alt=""></p><p>提取元素下标为 2 的元素</p><h4 id="定义map"><a href="#定义map" class="headerlink" title="定义map"></a><strong>定义map</strong></h4><p><strong>声明map</strong></p><pre><code class="groovy">def m = [&#39;key1&#39;: &#39;value1&#39;]</code></pre><p>在初始化时必须要有初始化的值，用来对弱类型进行修改。</p><p><strong>添加键值对</strong></p><pre><code class="groovy">m.key2 = &quot;value2&quot;</code></pre><p>打印键值对</p><pre><code class="groovy">println m.get(&#39;key2&#39;)println m</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910152935.png" alt=""></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="groovy-中的闭包"><a href="#groovy-中的闭包" class="headerlink" title="groovy 中的闭包"></a>groovy 中的闭包</h3><p><strong>什么是闭包？</strong></p><p>groovy中的一个代码块。用于在<strong>gradle中把闭包当作参数使用</strong>。</p><p><strong>定义闭包和携带参数的闭包</strong></p><pre><code class="groovy">def b = {    println &quot;hello world!&quot;}</code></pre><pre><code class="groovy">def b = {   v-&gt; println &quot;hello world! $v&quot;}</code></pre><p>花括号 “{}” 即为闭包的样式。</p><p>v 表示一个变量，通过 “$v” 引用变量。</p><p><strong>闭包作为方法的参数，为闭包添加参数</strong></p><pre><code class="groovy">def method(Closure closure) {    closure()}</code></pre><pre><code class="groovy">def method(Closure closure) {    closure(&quot;arguments&quot;)}</code></pre><p>Closure：为闭包的类型，位于 “groovy.lang” 包下。</p><p>字符“arguments”作为参数传递给了闭包，<strong>在使用时将对应闭包添加到方法中即可</strong>。</p><p><strong>使用闭包</strong></p><pre><code class="groovy">method (b)</code></pre><p>method 为自己创建的方法。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910155625.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> gradle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> gradle </tag>
            
            <tag> groovy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJava2 Android 中使用</title>
      <link href="/2020/08/21/Android-RxJava/"/>
      <url>/2020/08/21/Android-RxJava/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是RxJava"><a href="#什么是RxJava" class="headerlink" title="什么是RxJava"></a>什么是RxJava</h1><p>实现异步操作的库</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>RxJava 是基于<strong>事件流的、实现异步操作的库</strong></p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>实现异步操作</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><pre><code class="groovy">    implementation &quot;io.reactivex.rxjava2:rxjava:2.2.6&quot;    implementation &quot;io.reactivex.rxjava2:rxandroid:2.1.0&quot;</code></pre><h4 id="使用一次订阅并打印出来"><a href="#使用一次订阅并打印出来" class="headerlink" title="使用一次订阅并打印出来"></a>使用一次订阅并打印出来</h4><ul><li>需要 Observable.fromArray 方法</li></ul><blockquote><p>fromArray用来创建一个Observable（被观察者）对象，可以将一个数组转化为可被观察的序列并且将它的数据逐个发送。</p><p>返回值：Observable</p></blockquote><ul><li>需要 subscribe 方法</li></ul><blockquote><p>subscribe 只用于连接被观察者和观察者”“()”圆括号内为观察者”</p></blockquote><ul><li>需要 Consumber 类作为参数</li></ul><blockquote><p>当你只关心观察者的onNext方法时可以使用Consumer类</p></blockquote><ul><li>需要 Subscriber.onNext() 方法</li></ul><blockquote><p>被观察者执行Subscriber.onNext()方法时会在 观察者 订阅时复写该方法来进行发送数据</p></blockquote><p>启动它即可</p><pre><code class="kotlin">        Observable.fromArray(&quot;Ted&quot;, &quot;Ryan&quot;, &quot;Billy&quot;)            .subscribe { onNext -&gt; println(&quot;name: $onNext&quot;) </code></pre><p>观察者打印了字符</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200824012835.png" alt=""></p><p><a href="https://www.youtube.com/watch?v=v7drKJyxo10&list=PL8g0JDLEKun5cDCSkiLkZ1t4r0kE4j0sV" target="_blank" rel="noopener">Android Kotlin - RxJava Intro</a></p><h4 id="刷新一次界面控件"><a href="#刷新一次界面控件" class="headerlink" title="刷新一次界面控件"></a>刷新一次界面控件</h4><ul><li>需要 Obserbable.subscribeOn()</li></ul><blockquote><p>指定Observable（被观察者）自身在哪个调度器上执行</p></blockquote><ul><li>需要 Schedule() 线程控制器</li></ul><blockquote><p>作用：指定每一段代码在什么样的线程中执行</p></blockquote><ul><li>需要 filer() 过滤操作符号</li></ul><blockquote><p>作用：输出过滤条件后的结果项。</p></blockquote><ul><li>需要 Obserbable.observeOn() 方法</li></ul><blockquote><p>指定 Subscribe 所运行在的线程。或者事件消费的线程。</p><p>指定一个观察者在哪个调度器上观察这个Observable。</p><p><strong>observeOn()可以多次使用，可以随意变换线程</strong>。</p></blockquote><ul><li>使用 AndroidSchedulers.mainThread() 方法</li></ul><blockquote><p>切换至主线程</p></blockquote><pre><code class="kotlin">        Observable.fromArray(&quot;Ted&quot;, &quot;Ryan&quot;, &quot;Billy&quot;)            .subscribeOn(Schedulers.newThread())            .filter { item -&gt; item == &quot;Ted&quot; }            .observeOn(AndroidSchedulers.mainThread())            .subscribe { onNext -&gt; textView.text = onNext }</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200825112654.png" alt=""></p><h4 id="执行一次网络访问"><a href="#执行一次网络访问" class="headerlink" title="执行一次网络访问"></a>执行一次网络访问</h4><ul><li>使用 Observable.create() 方法</li></ul><blockquote><p>作用：创建一个被观察者。</p><p>可以通过泛型<String>指定发送数据的类型</p><p>参数：复写 ObservableOnSubscribe 类型，当被观察者被订阅时会执行 subscribe() 中的事件。</p></blockquote><ul><li>需要 onError() 方法</li></ul><blockquote><p>被观察者执行Subscriber.onError()方法时会在 观察者 订阅时复写该方法来进行发送数据</p><p>参数： 发送的泛型数据类型</p></blockquote><ul><li>需要 onComplate() 方法</li></ul><blockquote><p>被观察者执行Subscriber.onComplate()方法时会在 观察者 订阅时复写该方法来进行发送数据</p><p>参数： 发送的泛型数据类型</p></blockquote><p>创建 方法 getTextFromNetwork () </p><p>创建 Observable （被观察者）处理完成后发送事件，subscribeOn 让 subscribe 到一个新的线程中执行，observeOn 切换观察者的线程到主线程刷新UI，并不断接受被观察者发送来的事件。<strong>这是一个异步的操作。</strong></p><pre><code class="kotlin">    fun getTextFromNetwork() {        val task = Observable.create&lt;String&gt; { subscriber -&gt;            try {                subscriber.onNext(&quot;网络访问&quot;)            } catch (e: Exception) {                subscriber.onError(e)            }            subscriber.onComplete()        }        task.subscribeOn(Schedulers.newThread())        task.observeOn(AndroidSchedulers.mainThread())            .subscribe { onNext -&gt; textView.text = onNext }    }</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200825210344.png" alt=""></p><p>在调用 MainActivity </p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200825211048.png" alt=""></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="Observer-接口"><a href="#Observer-接口" class="headerlink" title="Observer 接口"></a>Observer 接口</h2><pre><code class="kotlin">        val observer = object: Observable&lt;String&gt;() {            //观察者接收事件前，默认最先调用复写 onSubscribe()            override fun subscribeActual(observer: Observer&lt;in String&gt;?) {                TODO(&quot;Not yet implemented&quot;)            }        }</code></pre><h2 id="Subscriber-接口"><a href="#Subscriber-接口" class="headerlink" title="Subscriber 接口"></a>Subscriber 接口</h2><p>Subscriber 接口对 Observer 接口进行了扩展</p><pre><code class="kotlin">        val subscribe= object : Subscriber&lt;String&gt;{            //被观察者调用 onSubscribe 时发送事件，观察者会调用此方法进行响应接受此事件            override fun onSubscribe(s: Subscription?) {                TODO(&quot;Not yet implemented&quot;)            }            //被观察者调用 onNext 时发送事件，观察者会调用此方法进行响应接受此事件            override fun onNext(t: String?) {                TODO(&quot;Not yet implemented&quot;)            }            //被观察者调用 onError 时发送事件，观察者会调用此方法进行响应接受此事件            override fun onError(t: Throwable?) {                TODO(&quot;Not yet implemented&quot;)            }            //被观察者调用 onComplete 时发送事件，观察者会调用此方法进行响应接受此事件            override fun onComplete() {                TODO(&quot;Not yet implemented&quot;)            }        }</code></pre><h2 id="Single与SingleObserver"><a href="#Single与SingleObserver" class="headerlink" title="Single与SingleObserver"></a>Single与SingleObserver</h2><p><strong>什么情况下使用 Single。</strong></p><p>如果你使用一个单一的连续事件流，既然只有一个onNext()事件，接着就触发onComplete或者onError，这样你使用Single。</p><p><strong>Single共包含那些</strong></p><p>一个正常处理成功的onSuccess，另一个处理失败的onError，当然它之发送一次信息，其中Single类似于Observable。</p><p><strong>被观察者</strong></p><pre><code class="kotlin">        val single: Single&lt;String&gt; = Single.create&lt;String&gt;(object : SingleOnSubscribe&lt;String&gt; {            override fun subscribe(emitter: SingleEmitter&lt;String&gt;) {                emitter.onSuccess(&quot;t&quot;)                emitter.onSuccess(&quot;c&quot;)                // 连续发送两次是不能成功的。            }        })</code></pre><p><strong>观察者</strong></p><pre><code class="kotlin">        single.subscribe(object : SingleObserver&lt;String&gt; {            // 在被观察者调用 onSubscribe 后，观察者回调到这里。            override fun onSubscribe(d: Disposable) {            }            // 在被观察者调用 onSuccess 后，观察者回调到这里。            override fun onSuccess(t: String) {                tv.text = t            }            // 在被观察者调用 onError 后，观察者回调到这里。            override fun onError(e: Throwable) {            }        })</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-10-10-0.gif" alt="并没有按照预期变成“c”"></p><p>所有 single只适合单次事件流。</p><h2 id="RxJava中关于-Disposable"><a href="#RxJava中关于-Disposable" class="headerlink" title="RxJava中关于 Disposable"></a>RxJava中关于 Disposable</h2><p>Disposable 类</p><ul><li><h5 id="dispose"><a href="#dispose" class="headerlink" title="dispose()"></a>dispose()</h5></li></ul><blockquote><p>主动解除订阅</p></blockquote><ul><li><h5 id="isDisposed"><a href="#isDisposed" class="headerlink" title="isDisposed()"></a>isDisposed()</h5></li></ul><blockquote><p>查询是否解除订阅 。（true 代表解除）</p></blockquote><h1 id="什么是同步"><a href="#什么是同步" class="headerlink" title="什么是同步"></a>什么是同步</h1><p>在执行功能前必须一件一件做完才能进行下一步。</p><h1 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h1><p>与同步是相对的，在我们执行完某个功能之后，我们并不需要立刻得到结果，我们可以正确的做其他的操作，这个功能可以在完成后通知或者回调告诉我们；</p><p>例如：后台下载的例子中，在执行下载功能后，我们无需关心它的下载过程，在它下载完毕之后通知我们就可以了。</p><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p><a href="https://www.runoob.com/design-pattern/observer-pattern.html" target="_blank" rel="noopener">观察者模式</a></p><p>当对象间存在一对多的关系时，则使用观察者模式（Observer Patterm）。    例如：当前对象被修改时这会通知依赖它的对象。观察者模式属于行为型模式。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图</strong>:定义对象之间的一种对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并且被自动更新。</p><p><strong>主要解决</strong>:一个对象状态改变给其他对象通知的问题，而且要考虑到易用性和低耦合，保证高度的协作。</p><p><strong>何时使用</strong>:一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象)都将得到通知，进行广播通知。</p><p>如何解决当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。</p><p><strong>如何解决</strong>：使用面向对象技术，可以将这种关系弱化。</p><p><strong>关键代码</strong>：在抽象类中有一个ArrayList存放观察者。</p><p><strong>应用实例</strong>：</p><ol><li>拍卖时，拍卖师观察最高标价，然后通知其他竞价者竞价。</li><li>菩萨通过洒水招来老乌龟，老乌龟就是观察者，观察菩萨的洒水动作</li></ol><p><strong>优点</strong>：</p><ol><li>观察者和被观察者是抽象耦合的。</li><li>建立一套触发机制</li></ol><p><strong>缺点</strong>：</p><ol><li>如果一个被观察者对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li><li>如果观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅知道观察目标发送变化。</li></ol><p><strong>使用场景</strong>：</p><p>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装到独立的对象中使它们可以各自独立的改变和复用。</p><p>一个对象的改变将导致一个或多个对象也发生改变，而不知道有多少对象改变，可以降低对象之间的耦合度。</p><p>一个对象必须通知其他对象，而不知道这个对象时谁。</p><p>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……。可以使用观察者模式创建一种链式触发机制。</p><h3 id="谁是观察者谁是被观察者？"><a href="#谁是观察者谁是被观察者？" class="headerlink" title="谁是观察者谁是被观察者？"></a>谁是观察者谁是被观察者？</h3><p>当你做出了某些动作另一个人根据你的动作做出某些行为，这时你就是被观察者，另一个人是观察者。</p><h1 id="订阅-发布模式"><a href="#订阅-发布模式" class="headerlink" title="订阅-发布模式"></a>订阅-发布模式</h1><p>订阅-发布模式是观察者模式的另一个别称。</p><p>但是随着时间的变化，已经独立于观察者模式，成为另一种的设计模式。</p><p>在现在的发布订阅模式中，成为发布者的消息发送者不会将信息直接发送给订阅者，这意味这发布者和订阅者不知道彼此的存在。在发布者和订阅者之间存在第三个组件，称为调度中心或事件通道，它维持着发布者和订阅者之间的联系，过滤所有发布者传入的信息并相应的分发给它的订阅者。</p><p>例子：</p><p>你在微博关注了A，同时其他很多人也关注了A，那么当A发布动态的时候，微博就会为你推送这条动态。A就是发布者，你是订阅者，微博就是调度中心，你和A之间没有直接的消息往来，全是通过微博来协调的。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-8-3-1.gif" alt="如果有些方法没有详细说明你可以自行搜索查看"></p><p><strong>参考</strong></p><p><a href="(https://www.cnblogs.com/onepixel/p/10806891.html)">观察者模式与订阅发布模式的区别</a></p><p><a href="https://maxwell-nc.github.io/android/rxjava2-1.html#Single%E5%92%8CSingleObserver" target="_blank" rel="noopener"><strong>RxJava 2.x 使用详解(一) 快速入门</strong></a></p><p><a href="https://www.jianshu.com/p/2a882604bbe8" target="_blank" rel="noopener">Rxjava关于Disposable你应该知道的事</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> RxJava </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>koin依赖注入框架</title>
      <link href="/2020/08/13/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-koin/"/>
      <url>/2020/08/13/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-koin/</url>
      
        <content type="html"><![CDATA[<h2 id="koin的使用"><a href="#koin的使用" class="headerlink" title="koin的使用"></a>koin的使用</h2><h4 id="添加依赖库"><a href="#添加依赖库" class="headerlink" title="添加依赖库"></a>添加依赖库</h4><pre><code>    implementation &#39;org.koin:koin-androidx-viewmodel:2.0.1&#39;    implementation &#39;org.koin:koin-android:2.0.1&#39;</code></pre><h4 id="需要创建依赖对象"><a href="#需要创建依赖对象" class="headerlink" title="需要创建依赖对象"></a>需要创建依赖对象</h4><p>这里创建三个类，Student，SchoolCourse，Friend。</p><ul><li>Student类</li></ul><blockquote><p>依赖于SchoolCourse，Friend类的方法。</p></blockquote><pre><code class="kotlin">class Student(val course: SchoolCourse,val friend: Friend) {    fun beSmart() {        course.study()        friend.hangout()    }}</code></pre><ul><li>SchoolCourse类</li></ul><blockquote><p>提供方法 study 负责打印 “I am studying”</p></blockquote><pre><code>class SchoolCourse {    fun study() {        println(&quot;I am studying&quot;)    }}</code></pre><ul><li>Friend 类</li></ul><blockquote><p>提供方法 hangout 负责打印 “We’re hanging out”</p></blockquote><pre><code>class Friend {    fun hangout() {        println(&quot;We&#39;re hanging out&quot;)    }}</code></pre><h4 id="定义依赖集合"><a href="#定义依赖集合" class="headerlink" title="定义依赖集合"></a>定义依赖集合</h4><p>创建 Modeles 文件 </p><ul><li>需要使用 module 方法</li></ul><blockquote><p>提供所需要的依赖</p></blockquote><ul><li>需要 signle 方法</li></ul><blockquote><p>使当前依赖为一个单例的对象</p></blockquote><ul><li>需要 factory 方法</li></ul><blockquote><p>定义一个工场每次调用创建一个新的实例</p></blockquote><ul><li>需要 get() 方法</li></ul><blockquote><p>get 用于最终实现注入</p></blockquote><pre><code>val appModule: Module = module {    single { SchoolCourse() }    factory { Friend() }    factory { Student(get(), get()) }}</code></pre><h4 id="启动-Koin"><a href="#启动-Koin" class="headerlink" title="启动 Koin"></a>启动 Koin</h4><ul><li><p>需要系统在创建时第一个启动Application实例</p><blockquote><p>修改 application 中的 name 属性 使得应用第一个启动它</p></blockquote></li></ul><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200813224142.png" alt=""></p><ul><li>需要创建 MyApp</li></ul><blockquote><p>第一个启动的Application实例</p></blockquote><ul><li>需要 startKoin</li></ul><blockquote><p>用来启动Koin</p></blockquote><ul><li>需要 modules</li></ul><blockquote><p>注册声明的Module</p></blockquote><ul><li>需要 androidContext</li></ul><blockquote><p>向Koin中注入context</p></blockquote><pre><code>class MyApp : Application() {    override fun onCreate() {        super.onCreate()        startKoin {            androidContext(this@MyApp)            modules(listOf(appModule))        }    }}</code></pre><h4 id="使用-koin-实现注入"><a href="#使用-koin-实现注入" class="headerlink" title="使用 koin 实现注入"></a>使用 koin 实现注入</h4><p>在需要注入的地方使用</p><ul><li>需要使用 get()</li></ul><blockquote><p>非 懒加载，注入实例</p></blockquote><p>通过 注入依赖完成后的实例调用beSmart()方法</p><pre><code>        val student = get&lt;Student&gt;()        student.beSmart()        val student2 = get&lt;Student&gt;()        student2.beSmart()</code></pre><h4 id="完成注入"><a href="#完成注入" class="headerlink" title="完成注入"></a>完成注入</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/image-20200813233756977.png" alt=""></p><h4 id="什么是-koin？"><a href="#什么是-koin？" class="headerlink" title="什么是 koin？"></a>什么是 koin？</h4><p>一个轻量级的依赖注入组件。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><a href="https://zhuanlan.zhihu.com/p/188485918" target="_blank" rel="noopener">Koin in Android: 更简单的依赖注入</a></p><h4 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h4><p>get()用于实现注入。</p><p>当你所属类型不确定时，可以指定类型。get<Type>()</p><h4 id="声明：绑定一个接口"><a href="#声明：绑定一个接口" class="headerlink" title="声明：绑定一个接口"></a>声明：绑定一个接口</h4><p>一个  single 或者 factory 声明将会使用其给定的 lambda 表达式类型。比如 single{T}，该声明所匹配的类型就是表达式所声明的类型 T 让我们以一个类及其实现的接口为例：</p><pre><code class="java">// Service interfaceinterface Service{    fun doSomething()}// Service Implementationclass ServiceImp() : Service {    fun doSomething() { ... }}</code></pre><p>在koin模块(module)，我们可以使用Kotiln下的 as 操作符。如下所示：</p><pre><code class="java">val myModule = module {    // 只匹配 Service 类型    single { ServiceImp() }    // 只匹配 Service 类型    single { ServiceImp() as Service }}</code></pre><p>你也可以使用推断类型表达式</p><pre><code class="java">val myModule = module {    // 只匹配 Service 类型    single { ServiceImp() }    // 只匹配 Service 类型    single&lt;Service&gt; { ServiceImp() }}</code></pre><p>第二种风格是首选的，在接下来的文档中，也会使用该方法。</p><h4 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h4><ul><li><p><code>bind()</code> - 为给定的对象声明添加要绑定的类型</p><p>Bind 是一个中辍函数，可以用于把一个Service关联到多个类。例如现在有两个接口：Tool，Flammable，Stove实现了这两个接口。显然如果只定义1个Service是不能同时注入Stove和这两个接口的。</p><p>这是就可以发挥Bind的作用了</p><pre><code>val myModule = module{    factory { Stove() } bind Tool::class bind Flammable::class // &lt;- here!    factory { Chef(get()) }}</code></pre><p>这么一来，下面的三个注入都是合法的，并都会得到一个 Stove 实例：</p><pre><code>val chef: Chef = get()val tool:Tool = get()val flammable:Flammable = get()</code></pre></li></ul><h4 id="named"><a href="#named" class="headerlink" title="named"></a>named</h4><p>限定符，用来区别同一个类的不同实例</p><p>使用</p><pre><code class="java"> single(named(&quot;dev&quot;)) { DataRepository() } single(named(&quot;test&quot;)) { DataRepository() }</code></pre><h4 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h4><p>可通过name或者class检索到对应的实例</p><p>使用</p><pre><code class="kotlin">    factory(name = MAIN) {        AndroidSchedulers.mainThread()    }</code></pre><h2 id="依赖注入和控制反转"><a href="#依赖注入和控制反转" class="headerlink" title="依赖注入和控制反转"></a>依赖注入和控制反转</h2><h3 id="依赖注入（Dependency-Injection，简称-DI）"><a href="#依赖注入（Dependency-Injection，简称-DI）" class="headerlink" title="依赖注入（Dependency  Injection，简称 DI）"></a>依赖注入（Dependency  Injection，简称 DI）</h3><p>什么是依赖注入？</p><p>假设 A 是 耳机，B 是播放器。</p><p>当 A 依赖 B 时（也就是耳机想要播放以音乐时），A 要想播放音乐就必须要有B的实例，也就是</p><ol><li>通过A的接口，把B传入；</li><li>通过A的构造，把B传入；</li><li>通过A的属性，把B传入；</li></ol><p>这些过程叫做<strong>依赖注入（DI）</strong></p><h3 id="控制反转（Inversion-of-Control，简称-Ioc）"><a href="#控制反转（Inversion-of-Control，简称-Ioc）" class="headerlink" title="控制反转（Inversion of Control，简称 Ioc）"></a>控制反转（Inversion of Control，简称 Ioc）</h3><p>但是 A 并不能控制 B 何时播放(创建)或者关闭(销毁)，仅使用 B ，那么 B 的控制权交给 A 之外的事务处理，这些叫做 <strong>控制反转（Ioc）</strong></p><h3 id="为什么需要依赖注入"><a href="#为什么需要依赖注入" class="headerlink" title="为什么需要依赖注入"></a>为什么需要依赖注入</h3><p>降低耦合</p><p>什么是耦合</p><p>耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。两个或多个功能模块之间的关联程度。</p><p>什么是解耦</p><p>解除类（模块）之间的直接关系，将直接关系转换成间接关系</p><p><strong>引用：</strong></p><p><a href="https://www.youtube.com/watch?v=eH9UrAwKEcE&t=140s" target="_blank" rel="noopener">Dependency Injection with Koin - Android Kotlin tutorial</a></p><p><a href="https://github.com/AndyJennifer/koin_doc_zh" target="_blank" rel="noopener">koin 中文 DOC</a></p><p><a href="https://juejin.im/post/6844904202586554382" target="_blank" rel="noopener">Koin in Android: 更简单的依赖注入</a></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-8-3-1.gif" alt="如果有些方法没有详细说明你可以自行搜索查看"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> Kotlin </tag>
            
            <tag> koin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BottomSheet、BottomShaeetDialog使用流程</title>
      <link href="/2020/08/06/BottomSheets/"/>
      <url>/2020/08/06/BottomSheets/</url>
      
        <content type="html"><![CDATA[<h1 id="BottomSheet"><a href="#BottomSheet" class="headerlink" title="BottomSheet"></a>BottomSheet</h1><p>Demo 代码 <a href="https://medium.com/@droidbyme/android-bottom-sheet-7e9cfcec6427" target="_blank" rel="noopener">https://medium.com/@droidbyme/android-bottom-sheet-7e9cfcec6427</a><br>使用 BottomSheet、BottomSheetDialog、BottomSheetDialogFragment</p><h4 id="BottomSheet使用流程"><a href="#BottomSheet使用流程" class="headerlink" title="BottomSheet使用流程"></a>BottomSheet使用流程</h4><p>BottomSheet实现按钮在点击之后滑动布局.不联动也是可以的只要不设置它就可以了。</p><p><strong>被联动的布局使用</strong></p><pre><code class="xml">app:layout_behavior=&quot;@string/bottom_sheet_behavior&quot;</code></pre><p><strong>联动按钮使用属性</strong></p><pre><code class="xml">app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-17_21-58-16.png" alt=""></p><p><strong>在初始化时被联动</strong></p><pre><code class="kotlin">          //  设置绑定动作        //  控件和它绑定        var buttomSheetBehavior = BottomSheetBehavior.from(bottom_sheet_layout)</code></pre><p><strong>设置按钮了</strong></p><p>也就是在现在监听按钮的时候才进行这个按钮的联动滑动</p><pre><code class="kotlin">     btnBottomSheet.setOnClickListener {            if (buttomSheetBehavior.getState() != BottomSheetBehavior.STATE_EXPANDED)                buttomSheetBehavior.state = BottomSheetBehavior.STATE_EXPANDED            else                buttomSheetBehavior.state = BottomSheetBehavior.STATE_COLLAPSED        }</code></pre><p>设置在显示时不显示,不显示时显示。</p><p>设置监听器在它被拖动、滑动、切换时产生提示。</p><pre><code class="kotlin">        buttomSheetBehavior.setBottomSheetCallback(object : BottomSheetCallback() {            //这里是拖拽中的回调，根据slideOffset可以做一些动画            override fun onSlide(bottomSheet: View, slideOffset: Float) {            }            //这里是bottomSheet状态的改变            override fun onStateChanged(bottomSheet: View, newState: Int) {                when (newState) {                    BottomSheetBehavior.STATE_EXPANDED -&gt; {                        Toast.makeText(this@MainActivity, &quot;展开&quot;, Toast.LENGTH_LONG).show()                    }                    BottomSheetBehavior.STATE_COLLAPSED -&gt; {                        Toast.makeText(this@MainActivity, &quot;关闭&quot;, Toast.LENGTH_LONG).show()                    }                    BottomSheetBehavior.STATE_DRAGGING -&gt; {                        Toast.makeText(this@MainActivity, &quot;拖拽状态&quot;, Toast.LENGTH_LONG).show()                    }                    BottomSheetBehavior.STATE_HIDDEN -&gt; {                        Toast.makeText(this@MainActivity, &quot;隐藏状态&quot;, Toast.LENGTH_LONG).show()                    }                    BottomSheetBehavior.STATE_SETTLING -&gt; {                        Toast.makeText(                            this@MainActivity,                            &quot; 拖拽松开之后到达终点位置（collapsed or expanded）前的状态&quot;,                            Toast.LENGTH_LONG                        ).show()                    }                }            }        })</code></pre><h4 id="BottomSheetDialog使用流程"><a href="#BottomSheetDialog使用流程" class="headerlink" title="BottomSheetDialog使用流程"></a>BottomSheetDialog使用流程</h4><p>点击按钮之后弹出Dialog提示(布局界面有且准备好的)</p><p><strong>设置按钮的监听器，点击之后直接弹出Dialog窗口。</strong></p><pre><code class="kotlin">  /*        * Java函数式接口        * 弹窗提示        * */        btnBottomSheetDialog.setOnClickListener {            //使用布局加载器layoutInflater            val view = layoutInflater.inflate(R.layout.fragment_bottom_sheet, null)            //实例话BottomSheetDialog():用来实现弹出提示功能            val dialog = BottomSheetDialog(this)            dialog.setContentView(view)            dialog.show()        }</code></pre><h4 id="BottomSheetDialogFragment在当前界面加载Dialog碎片"><a href="#BottomSheetDialogFragment在当前界面加载Dialog碎片" class="headerlink" title="BottomSheetDialogFragment在当前界面加载Dialog碎片"></a>BottomSheetDialogFragment在当前界面加载Dialog碎片</h4><pre><code class="kotlin">        /*        * 在当前界面加载碎片        * */        btnBottomSheetDialogFragment.setOnClickListener {            val bottomSHeetFragment = BottomSheetFragment()            bottomSHeetFragment.show(supportFragmentManager, bottomSHeetFragment.tag)        }</code></pre><p><strong>准备好要加载的碎片,它是要有bottom_sheet_dialog类型的界面</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MediaStore访问图片、视频</title>
      <link href="/2020/08/01/MediaStore%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/08/01/MediaStore%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="使用”MediaStore”访问图片、视频的缩略图"><a href="#使用”MediaStore”访问图片、视频的缩略图" class="headerlink" title="使用”MediaStore”访问图片、视频的缩略图"></a>使用”MediaStore”访问图片、视频的缩略图</h2><h3 id="需要动态申请权限"><a href="#需要动态申请权限" class="headerlink" title="需要动态申请权限"></a>需要动态申请权限</h3><p>需要配置文件中添加要 申请的权限 “AndroidManifest.xml”</p><pre><code class="xml">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</code></pre><h4 id="注册动态权限"><a href="#注册动态权限" class="headerlink" title="注册动态权限"></a>注册动态权限</h4><ul><li><p>需要自定义 “checkReadExternalStoragePermission()”方法</p></li><li><p>需要 “Build.VERSION.SDK_INT”方法获得当前系统的版本号</p></li><li><p>需要 “Build.VERSION_CODES.M”表示安卓6</p></li><li><p>需要 “ContextCompat.checkSelfPermission()”方法, 判断是否获得了权限.</p></li></ul><blockquote><p>参数1:上下文.参数2:要判断的权限. </p><p>返回值:PackageManager.<strong>PERMISSION_GRANTED</strong> <strong>表示授予权限</strong>,PackageManager.<strong>PERMISSION_DENIED</strong>  = -1    <strong>表示权限未开启</strong>；</p></blockquote><ul><li>需要 “shouldShowRequestPermissionRationale()”方法.</li></ul><blockquote><p>判断当前权限是否被拒绝,并且显示窗口,显示”运行”和”拒绝”选项.</p><p>第一次不显示”不再提醒”按钮,第二次窗口添加”不再显示选择框”。</p><p>返回值:拒绝返回 true ,允许返回 false 或者 不再提醒选中后 返回 false</p></blockquote><ul><li>需要 “requestPermission()”方法.</li></ul><blockquote><p>用来申请系统权限. <strong>每次被调用时都会回调”onRequestPermissionsResult()”方法。</strong></p><p>参数1:要申请的权限.</p><p>参数2:要申请权限的 code 以用来在申请方法回调时确定是当前的申请操作.</p></blockquote><p>在需要注册权限的活动上添加</p><pre><code>    private fun checkReadExternalStoragePermission() {        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {            if (ContextCompat.checkSelfPermission(                    this,                    permission.READ_EXTERNAL_STORAGE                ) == PackageManager.PERMISSION_GRANTED            ) {                   } else {                if (shouldShowRequestPermissionRationale(permission.READ_EXTERNAL_STORAGE)) {                    Toast.makeText(this, &quot;App needs to view thumbnails&quot;, Toast.LENGTH_LONG).show()                }                requestPermissions(                    arrayOf(permission.READ_EXTERNAL_STORAGE),                    READ_EXTERNAL_STORAGE_PERMISSION_RESULT                )            }        } else {        }    }</code></pre><pre><code>    private val READ_EXTERNAL_STORAGE_PERMISSION_RESULT: Int = 0</code></pre><ul><li>需要重写 “onRequestPermissionsResult()”方法</li></ul><blockquote><p>申请权限时会调用它(申请权限时的回调)</p><p>参数1:申请权限时的Code,表示申请权限的操作是否相同.</p><p>参数2:这是要申请的权限永远不为空.</p><p>参数3:表示权限授权的结果永远封装在grantResult数组中</p></blockquote><pre><code>override fun onRequestPermissionsResult(        requestCode: Int,        permissions: Array&lt;out String&gt;,        grantResults: IntArray    ) {        super.onRequestPermissionsResult(requestCode, permissions, grantResults)        when (requestCode) {            READ_EXTERNAL_STORAGE_PERMISSION_RESULT -&gt; {                if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {                    Toast.makeText(this, &quot;now have access to view thumbs&quot;, Toast.LENGTH_LONG).show()                }            }        }    }</code></pre><h3 id="需要RecyclerView的适配器"><a href="#需要RecyclerView的适配器" class="headerlink" title="需要RecyclerView的适配器"></a>需要RecyclerView的适配器</h3><p><a href="https://thecara.github.io/2020/07/26/RecyclerView%E5%9C%A8Kotlin%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/#toc-heading-7">使用此案例创建适配器</a></p><p>初始化控件不再复述了,</p><ul><li>需要变量”mMediaStoreCursor”</li></ul><blockquote><p>表示当前的Cursor</p></blockquote><pre><code>class MediaStoreAdapter(private val mActivity: Activity) :    RecyclerView.Adapter&lt;MediaStoreAdapter.ViewHolder&gt;() {    private var mMediaStoreCursor: Cursor? = null        }</code></pre><ul><li><strong>需要自定义”getBitmapFromMediaStore()”方法</strong></li></ul><blockquote><p>获得系统中图片和视频的缩略图.通过Cursor获得照片和Video的缩略图</p><p>参数1:移动到对应Cursor的行.</p></blockquote><ul><li>需要使用”Cursor.getColumnIndex()”方法</li></ul><blockquote><p>获得当前MediaStoreCursor的”参数1”的索引</p><p>参数1:要索引的位置</p><p>返回值: 返回在当前 Cursor 中的位置,没有返回 -1 </p></blockquote><ul><li>需要使用”Cursor.getInt()’方法</li></ul><blockquote><p>获得”Cursor”中索引(列)的数值.</p><p>参数1:你想要获得的列</p><p>返回值:返回指定列的数值</p></blockquote><ul><li>需要 “MediaStore.Images.Thumbnails.getThumbnail”方法</li></ul><blockquote><p>获得缩略图.</p><p>参数1:表示内容提供器. 参数2:当前”Cursor”缩略图的ID. </p><p>参数3:返回时的清晰度.MICRO_KIND,MINI_KIND字面意思为微型和迷你缩略模式,前者分辨率更低.</p><p>返回值:返回一个Bitmap格式</p></blockquote><p>在适配器中添加</p><pre><code>class MediaStoreAdapter(private val mActivity: Activity) :    RecyclerView.Adapter&lt;MediaStoreAdapter.ViewHolder&gt;() {              private fun getBitmapFromMediaStore(position: Int): Bitmap? {        val idIndex: Int = mMediaStoreCursor!!.getColumnIndex(MediaStore.Files.FileColumns._ID)        val mediaTypeIndex: Int =            mMediaStoreCursor!!.getColumnIndex(MediaStore.Files.FileColumns.MEDIA_TYPE)        mMediaStoreCursor!!.moveToPosition(position)        when (mMediaStoreCursor!!.getInt(mediaTypeIndex)) {            // 当前类型为 IMAGE 时            MediaStore.Files.FileColumns.MEDIA_TYPE_IMAGE -&gt; {                return MediaStore.Images.Thumbnails.getThumbnail(                    mActivity.contentResolver,                    mMediaStoreCursor!!.getLong(idIndex),                    MediaStore.Images.Thumbnails.MICRO_KIND, null                )            }            // 当前类型为 VIDEO            MediaStore.Files.FileColumns.MEDIA_TYPE_VIDEO -&gt; {                return MediaStore.Video.Thumbnails.getThumbnail(                    mActivity.contentResolver,                    mMediaStoreCursor!!.getLong(idIndex),                    MediaStore.Video.Thumbnails.MICRO_KIND, null                )            }        }        return null    }}</code></pre><ul><li><strong>需要自定义方法”swapCursor()”</strong></li></ul><blockquote><p>获得上一个Cursor.</p></blockquote><ul><li>需要 “notifyDataSetChanged()” 方法</li></ul><blockquote><p>检测当前UI线程,刷新UI</p></blockquote><pre><code>class MediaStoreAdapter(private val mActivity: Activity) :    RecyclerView.Adapter&lt;MediaStoreAdapter.ViewHolder&gt;() {   private fun swapCursor(cursor: Cursor): Cursor? {        if (mMediaStoreCursor == cursor) {            return null        }        val oldCursor: Cursor? = mMediaStoreCursor        this.mMediaStoreCursor = cursor        if (cursor != null) {            this.notifyDataSetChanged()        }        return oldCursor    }}</code></pre><ul><li><strong>需要 自定义方法”changeCursor()”</strong></li></ul><blockquote><p>检测上一个Cursor,用来关闭上个Cursor.</p></blockquote><pre><code>class MediaStoreAdapter(private val mActivity: Activity) :    RecyclerView.Adapter&lt;MediaStoreAdapter.ViewHolder&gt;() {        fun changeCursor(cursor: Cursor?) {        val oldCursor: Cursor? = swapCursor(cursor!!)        if (oldCursor != null)            oldCursor.close()    }}</code></pre><ul><li>需要重写 “onBindViewHolder()”方法</li></ul><pre><code>    override fun onBindViewHolder(holder: ViewHolder, position: Int) {        val bitmap: Bitmap? = getBitmapFromMediaStore(position)        if (bitmap != null) {            holder.mediastoreImageView.setImageBitmap(bitmap)        }    }</code></pre><ul><li>需要重写”getItemCount()”方法</li></ul><pre><code>    override fun getItemCount(): Int {        return if (mMediaStoreCursor == null) 0 else mMediaStoreCursor!!.count    }</code></pre><ul><li>需要重写”onCreateViewHolder()”方法</li></ul><pre><code>    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {        val view =            LayoutInflater.from(parent.context).inflate(R.layout.media_image_view, parent, false)        return ViewHolder(view)    }</code></pre><h3 id="需要”LoaderManager-LoaderCallbacks”"><a href="#需要”LoaderManager-LoaderCallbacks”" class="headerlink" title="需要”LoaderManager.LoaderCallbacks”"></a>需要”LoaderManager.LoaderCallbacks”</h3><ul><li>需要实现LoaderManager.LoaderCallbacks<cursor>.(在MediaMainActivity)</li></ul><blockquote><p>在需要的Fragment或Activity中实现它。</p></blockquote><pre><code>class MediaMainActivity : AppCompatActivity(), LoaderManager.LoaderCallbacks&lt;Cursor&gt; {}</code></pre><ul><li>需要重写”onCreateLoader”</li></ul><blockquote><p>在调用initLoader()返回时创建一个Loader.</p><p>根据传入的ID,初始化并返回一个新的加载器.</p></blockquote><ul><li>需要返回的列</li></ul><blockquote><p>MediaStore.Files.FileColums.ID 返回Id列</p><p>MediaStore.Files.FIleColums.DATE_ADDED 图片被添加的时间</p><p>MediaStore.Files.FileColums.MEDIA_TYPE 媒体类型</p><p>MediaStore.Files.FileColums.MEDIA_TYPE_IMAGE 图片列(索引)</p><p>MediaStore.Files.FileColums.MEDIA_TYPE_VIDEO 视频列(索引)</p></blockquote><ul><li>需要”CursorLoader()”匿名类</li></ul><blockquote><p>它查询ContentResolver然后返回一个Cursor.</p><p>参数1:上下文. 参数2:要操作的URI.当前表示所有图片的URI.</p><p>参数3:要返回的列. 参数4:一个过滤器,表明哪些行要被返回.当前返回类型为IMAGE 或 VIDEO</p><p>参数5:用作过滤器的参数. </p><p>参数6:设置排序.相当于SQL语句中Order by.这里使用 DATA_ADDED + DESC 表示按照时间进行排序.</p></blockquote><pre><code class="kotlin">    override fun onCreateLoader(p0: Int, p1: Bundle?): androidx.loader.content.Loader&lt;Cursor&gt; {        val projection = arrayOf&lt;String&gt;(            MediaStore.Files.FileColumns._ID,            MediaStore.Files.FileColumns.DATE_ADDED,            MediaStore.Files.FileColumns.MEDIA_TYPE        )        // SQL命令        val selection =            MediaStore.Files.FileColumns.MEDIA_TYPE +                    &quot; = &quot; + MediaStore.Files.FileColumns.MEDIA_TYPE_IMAGE + &quot; or &quot; + MediaStore.Files.FileColumns.MEDIA_TYPE +                    &quot; = &quot; + MediaStore.Files.FileColumns.MEDIA_TYPE_VIDEO        return object : CursorLoader(            this,            MediaStore.Files.getContentUri(&quot;external&quot;),            projection,            selection,            null,            MediaStore.Files.FileColumns.DATE_ADDED + &quot; DESC &quot;        ) {}    }</code></pre><ul><li>需要重写 “onLoadFinished()”方法</li></ul><blockquote><p>更新UI操作.当一个加载器完成了它的装载过程后被调用.</p></blockquote><ul><li>需要调用changeCursor()方法</li></ul><blockquote><p>刷新当前参数1,关闭上一个Cursor</p><p>参数1:当前的Cursor</p></blockquote><pre><code>class MediaMainActivity : AppCompatActivity(), LoaderManager.LoaderCallbacks&lt;Cursor&gt; {    override fun onLoadFinished(loader: androidx.loader.content.Loader&lt;Cursor&gt;, data: Cursor?) {        mMediaStoreAdapter?.changeCursor(data!!)    }}</code></pre><ul><li>需要重写”onLoaderReset()”方法</li></ul><blockquote><p>何时释放内存,当一个加载器完成了它的装载工作之后被调用</p></blockquote><pre><code>class MediaMainActivity : AppCompatActivity(), LoaderManager.LoaderCallbacks&lt;Cursor&gt; {   override fun onLoaderReset(loader: androidx.loader.content.Loader&lt;Cursor&gt;) {        mMediaStoreAdapter?.changeCursor(null)    }}</code></pre><ul><li><p>需要在用于权限和申请权限之后添加</p></li><li><p>需要在”onRequestPermissionsResult()”中调用”getSupportLoaderManager.initLoader()”</p></li></ul><blockquote><p>启动加载器</p><p>参数1:一个唯一的ID来标志加载器.</p><p>参数2:可选参数,用于加载初始化时(本例为null)</p><p>参数3:LoaderManager.LoaderCallbacks的实现.被LoaderManger调用以报告加载事件,在例子中是传递给自己”this”</p></blockquote><pre><code>when (requestCode) {            READ_EXTERNAL_STORAGE_PERMISSION_RESULT -&gt; {                if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {                //添加 supportLoaderManager.initLoader(MEDIASTORE_LODAR_ID, null, this)                }            }        }</code></pre><ul><li>需要在”checkReadExternalStoragePermission()”中调用</li><li>需要在拥有权限后调用,在”checkSelfPermission()”判断拥有权限后调用</li></ul><pre><code>        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {                  if (ContextCompat.checkSelfPermission(                    this,                    permission.READ_EXTERNAL_STORAGE                ) == PackageManager.PERMISSION_GRANTED            ) {              //添加  supportLoaderManager.initLoader(MEDIASTORE_LODAR_ID, null, this)            }         } else {            //添加  supportLoaderManager.initLoader(MEDIASTORE_LODAR_ID, null, this)        }</code></pre><p>ps:显示了在哪里添加其他的代码不用修改.</p><ul><li>需要添加唯一的ID标志加载器.</li></ul><pre><code>class MediaMainActivity : AppCompatActivity(), LoaderManager.LoaderCallbacks&lt;Cursor&gt; {    private val MEDIASTORE_LODAR_ID: Int = 0}</code></pre><ul><li>需要GridLayoutManger,在 “onCreate()” 中添加</li></ul><blockquote><p>设置RecyclerView的布局</p><p>参数1:上下文 . 参数2:多少列</p></blockquote><pre><code>val gridLayoutManager: GridLayoutManager = GridLayoutManager(this, 3)</code></pre><ul><li>需要RecyclerView的setLayoutManager</li></ul><blockquote><p>设置 GridLayoutManager</p></blockquote><pre><code>thumbnailRecyclerView.layoutManager = gridLayoutManager</code></pre><ul><li>需要设置适配器省略..</li></ul><h3 id="使用-“Glide”的方式加载图片"><a href="#使用-“Glide”的方式加载图片" class="headerlink" title="使用 “Glide”的方式加载图片"></a>使用 “Glide”的方式加载图片</h3><ul><li>需要添加依赖</li></ul><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200803180403.png" alt=""></p><ul><li>需要“MediaStore.Files.FileColumns.DATA”（需要在onCreateLoader的projection修改）</li></ul><blockquote><p>表述索引在磁盘中位置</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200803180843.png" alt=""></p><p>需要创建自定义返回“getUriFromMediaStore()”（在MediaStoreAdapter中添加）</p><blockquote><p>获得缩略图在ContentResolver中的uri</p><p>参数1：media的那个行</p></blockquote><p>需要“Uri.parse()” 方法</p><blockquote><p>将字符串解析成uri对象</p></blockquote><pre><code>    private fun getUriFromMediaStore(position: Int): Uri {        val dataIndex: Int = mMediaStoreCursor!!.getColumnIndex(MediaStore.Files.FileColumns.DATA)        mMediaStoreCursor!!.moveToPosition(position)        val mediaUri: Uri =            Uri.parse(&quot;file://&quot; + mMediaStoreCursor!!.getString(dataIndex).toString())        return mediaUri    }</code></pre><p>需要“Glide” - (在onBindViewHolder()中添加)</p><blockquote><p>with(content:Content) - 需要上下文</p><p>load(uri:String) - 图片的uri</p><p>centerCrop() - 将图片按比例缩放到足以填充ImageView的尺寸，但是图片可能会显示不完整。</p><p>override(width,height) 重新改变图片大小。</p><p>into() - 你需要显示图片的目标。</p></blockquote><pre><code>      Glide.with(mActivity).load(getUriFromMediaStore(position)).centerCrop().override(96, 96)            .into(holder.mediastoreImageView)</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200803184305.png" alt=""></p><h2 id="什么是Loader"><a href="#什么是Loader" class="headerlink" title="什么是Loader"></a>什么是Loader</h2><p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/developer/2014/0325/1602.html" target="_blank" rel="noopener">android 加载器loader详解</a></p><p>Loader简化了activity和Fragment中异步加载数据的步骤.</p><p>特点:适用于每个Activity和Fragment,提供异步加载的实现方式,监听数据源,在数据发生改变时自动返回新的结果。当由于配置改变后被重新创建后,它们自动重新链接上一个加载游标,所以不必重新查数据.</p><p>loader API 说明</p><table><thead><tr><th align="center">Class/Interface</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">LoaderManager</td><td align="center">一个与Activity和Fragment相关联的抽象类,它管理一个或者多个Loader实例,帮助一个应用管理哪些与Activity或Fragment的声明周期相关的长时间操作.常见方式是与CursorLoader一起使用,然后应用也可以自己写一个加载其他数据类型或者数据源的loader。<strong>每个Activity或者Fragment只有一个LoaderManager.但是一个LoaderManager可以拥有多个加载器</strong></td></tr><tr><td align="center">LoaderManager.LoaderCallbacks</td><td align="center">用于一个客户端与LoaderManager交互的会调接口.例如,你使用回调方法onCreateLoader()来创建一个新的加载器.</td></tr><tr><td align="center">Loader</td><td align="center">一个执行异步数据加载的抽象类,它是加载器的基础类.你可以使用经典的CursorLoader,但是你也可以实现你的子类.一旦加载器被激活,它们将监听它的数据源并且在数据改变时发送新的结果.</td></tr><tr><td align="center">AsyncTaskLoader</td><td align="center">提供一个AsyncTask来执行异步加载工作的抽象类</td></tr><tr><td align="center">CursorLoader</td><td align="center">AsyncTaskLoader的子类,它查询ContentResolver然后返回一个Cursor.这个类为查询Cursor以标准的方式实现了加载器协议,它的游标查询是通过AsyncTaskLoader在后台线程中执行,从而不会阻断线程</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-8-3-1.gif" alt="如果有些方法没有详细说明你可以自行搜索查看"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLite Database 使用</title>
      <link href="/2020/07/28/SQLite-Database-%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/07/28/SQLite-Database-%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><h5 id="需要-创建数据库-类-“MyHelper”"><a href="#需要-创建数据库-类-“MyHelper”" class="headerlink" title="需要 创建数据库 类 “MyHelper”"></a>需要 创建数据库 类 “MyHelper”</h5><pre><code class="kotlin">class MyHelper(    private val mContext: Context? = null,    private val dbname: String = &quot;mydb&quot;,    private val version: Int = 1) : SQLiteOpenHelper(mContext, dbname, null, version) {    /*    * 需要变量sql确定表的格式    * 需要 execSQL()执行创建表的动作    * */    override fun onCreate(p0: SQLiteDatabase?) {        // 创建数据库表        val sql: String =            &quot;CREATE TABLE PRODUCTS (_id INTEGER PRIMARY KEY AUTOINCREMENT, NAME TEXT, DESCRIPTION TEXT, PRICE READ)&quot;        // 执行创建表的动作        p0?.execSQL(sql)    }    /*    *    * */    override fun onUpgrade(p0: SQLiteDatabase?, p1: Int, p2: Int) {        TODO(&quot;Not yet implemented&quot;)    }}</code></pre><ul><li>创建数据库需要继承SQLiteOpenHelper()类型,需要四个参数进行初始化</li><li>(四个参数:mContext:上下文,dbname: 数据库名称,version:数据库版本,factory:null)</li><li>需要实现两个方法onCreate()和onUpgrade()方法</li></ul><h5 id="在需要创建数据库时调用"><a href="#在需要创建数据库时调用" class="headerlink" title="在需要创建数据库时调用"></a>在需要创建数据库时调用</h5><pre><code class="kotlin"> var myHelper: MyHelper = MyHelper(mContext = this) val sqlLiteDatabase: SQLiteDatabase = myHelper.readableDatabase</code></pre><p>这时数据库就创建完成了</p><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>创建仓库后插入数据</p><p>需要”ContentValues()”类型</p><p>需要”SQLiteDatabase的insert()”方法</p><p>在”自定义数据库中”中添加方法</p><pre><code>    private fun instertData(        name: String,        description: String,        price: Double,        database: SQLiteDatabase    ) {        // ContentValues() 类型负责存放键值的数据.你只需要记住它是往数据库中存放数据的.        val values: ContentValues = ContentValues()        values.put(&quot;NAME&quot;, name)        values.put(&quot;DESCRIPTION&quot;, description)        values.put(&quot;PRICE&quot;, price)        // 向当前数据库(database)插入数据(values)        database.insert(&quot;PRODUCTS&quot;, null, values)    }</code></pre><p>在<strong>外部要插入数据</strong>设置类型为 “public”即可。</p><p>插入数据在外部调用方法</p><pre><code>        // insert        instertData(&quot;Jam&quot;, &quot;Fruit Jam&quot;, 300.1, p0!!)        instertData(&quot;Yli&quot;, &quot;Te Jam&quot;, 305.13, p0!!)        instertData(&quot;Tom Li&quot;, &quot;Zhou Jam&quot;, 210.7, p0!!)</code></pre><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>需要”MyHelper”自定义<strong>数据库类的实例</strong></p><p>需要”MyHelper.readableDatabase”方法读取数据库方法<strong>返回一个可对数据库读写的对象</strong>.</p><p>需要”sqlLiteDatabase.rawQuery()”方法<strong>获得(数据库表)每行的集合</strong>(Cursor类型).</p><pre><code>  // 实例话自定义的数据类        var myHelper: MyHelper = MyHelper(mContext = this)        // 创建数据库        val sqlLiteDatabase: SQLiteDatabase = myHelper.readableDatabase        val cursor: Cursor =            sqlLiteDatabase.rawQuery(&quot;SELECT NAME, PRICE FROM PRODUCTS&quot;, arrayOf&lt;String&gt;())        if (cursor != null)            cursor.moveToFirst()        val builder: StringBuilder = StringBuilder()        do {            val name: String = cursor.getString(0)            val price: Double = cursor.getDouble(1)            builder.append(&quot;NAME - &quot; + name + &quot;PRICE - &quot; + price)        } while (cursor.moveToNext())        // 这是在界面上刷新了读取的数据        text_view.setText(builder.toString())</code></pre><p><img src="1595946627126.png" alt=""></p><h4 id="按照条件查询指定数据"><a href="#按照条件查询指定数据" class="headerlink" title="按照条件查询指定数据"></a>按照条件查询指定数据</h4><pre><code>   val cursor: Cursor =            sqlLiteDatabase.rawQuery(&quot;SELECT NAME, PRICE FROM PRODUCTS WHERE NAME = ?&quot;, arrayOf&lt;String&gt;(&quot;Tom Li&quot;))</code></pre><p>查询 列 “NAME,PRICE” 来自表 “PRODUCTS” 根据条件 “NAME = ?”</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200731132244.png" alt=""></p><p>查询完成</p><h2 id="什么是Cursor类型"><a href="#什么是Cursor类型" class="headerlink" title="什么是Cursor类型"></a>什么是Cursor类型</h2><p><a href="https://blog.csdn.net/android_zyf/article/details/53420267" target="_blank" rel="noopener">引用:Android中的Cursor到底是什么？如何理解Cursor的方法都在做什么事情？</a></p><blockquote><p>Cursor是每行的集合</p></blockquote><p>表中共有多行数据.</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200729122947.png" alt=""></p><p>假如:获得通过”select”语句”gender”获得符合这列的男性那么得到的是 “张三,赵六”这两行数据.也就是<strong>说 “Cursor”类型存放了两行数据。</strong></p><h4 id="如何获得Cursor类型"><a href="#如何获得Cursor类型" class="headerlink" title="如何获得Cursor类型"></a>如何获得Cursor类型</h4><p>通过数据库对象的方法获得。👇</p><pre><code>SQLiteDataBase db;Cursor cursor = db.query(各种参数);</code></pre><p>这些就是每一行的集合</p><h4 id="索引在Cursor中是什么"><a href="#索引在Cursor中是什么" class="headerlink" title="索引在Cursor中是什么"></a>索引在Cursor中是什么</h4><p>在Cursor中索引指的就是<strong>表中的列</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200731174701.png" alt=""></p><p>返回了”PRICE”列在表中的索引(位置)。</p><h4 id="关于为何要使用-“moveToFirst-”-方法"><a href="#关于为何要使用-“moveToFirst-”-方法" class="headerlink" title="关于为何要使用 “moveToFirst()” 方法"></a>关于为何要使用 “moveToFirst()” 方法</h4><p>利用反证法,<strong>不使用”moveToFirst()”方法,</strong>获得游标后,直接输出当前的”position”值</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200729210143.png" alt=""></p><p><strong>“position”的值会直接输出 “-1”</strong>,也就是说当我们不适用”moveToFirst()”方法时它会在坐标”position”(0)的<strong>上边</strong>。</p><p>所以我们应该使用方法”moveToFirst()”使”position”为”0”。</p><h4 id="源码分析-使用”moveToNext-”方法是如何得知遍历完成的"><a href="#源码分析-使用”moveToNext-”方法是如何得知遍历完成的" class="headerlink" title="源码分析 使用”moveToNext()”方法是如何得知遍历完成的?"></a>源码分析 使用”moveToNext()”方法是如何得知遍历完成的?</h4><p>先说明 <strong>调用”moveToNext()”方法最总会调用”moveToPosition()”方法</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200729212802.png" alt=""></p><p>👆界面在被初始化时,指当前页面的对象。这时源<strong>码中的”mPos=-1”会被在一个空参数构造方法里初始化</strong>。</p><p>仅理解的话: <strong>“moveToFirst()”调用的是”moveToPostion(0)”,”moveToNext()” 调用的是”moveToNext(mPos+1)”,所以说当首次调用的他们两个的结果是一样的。</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200729215028.png" alt=""></p><p>ps:个人理解:在使用”cursor.moveToFirst()”先进行判断可以更有效的避免空指针异常j</p><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>需要修改<strong>数据库返回的类型为可写入类型</strong></p><pre><code class="kotlin">        // 创建数据库        val sqlLiteDatabase: SQLiteDatabase = myHelper.writableDatabase</code></pre><p>需要 “ContentValues()” 类型存放更新的值</p><pre><code>        //更新数据        val values: ContentValues = ContentValues()        values.put(&quot;PRICE&quot;, 280)        // 参数1:表示更新的表.参数2:表示更新的数据.参数3:表示条件(表示通过那个条件更新值) 参数4:条件的值        sqlLiteDatabase.update(&quot;PRODUCTS&quot;, values, &quot;_id = ?&quot;, arrayOf&lt;String&gt;(&quot;1&quot;))</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200731130854.png" alt=""></p><p>“280”价格更新了</p><h4 id="多条件更新"><a href="#多条件更新" class="headerlink" title="多条件更新"></a>多条件更新</h4><p>更新表 “<strong>PRODUCTS</strong>“ 的值 “<strong>values</strong>“,根据 “<strong>NAME</strong>“为”<strong>Tom Li</strong>“ 和”<strong>DESCRIPTION</strong>“ 为 “<strong>Zhou Jam</strong>“ 的行中的数据.</p><pre><code>sqlLiteDatabase.update(&quot;PRODUCTS&quot;, values, &quot;NAME = ? AND DESCRIPTION = ?&quot;, arrayOf&lt;String&gt;(&quot;Tom Li&quot;,&quot;Zhou Jam&quot;))</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200731132831.png" alt=""></p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>在获得数据库的<strong>可写入类型后。</strong> 调用 “delete()”方法。</p><pre><code>        // 根据条件删除一行数据        // 参数1:要删除的表名字,参数2:选择删除的条件(根据这个条件删除),参数3:条件的值        sqlLiteDatabase.delete(&quot;PRODUCTS&quot;, &quot;_id=?&quot;, arrayOf&lt;String&gt;(&quot;1&quot;))</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200731131332.png" alt=""></p><p>删除成功了.</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> SQLite </tag>
            
            <tag> Cursor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库索引</title>
      <link href="/2020/07/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
      <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是数据库索引"><a href="#什么是数据库索引" class="headerlink" title="什么是数据库索引"></a>什么是数据库索引</h2><p>MySql官网的介绍,索引是帮助<code>MySQL</code>高效获得数据的结构。类似于书本的目录,从而提高查询速度。</p><p><a href="https://segmentfault.com/a/1190000022341554" target="_blank" rel="noopener">初探MySQL索引</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chocolatey的配置与应用的安装</title>
      <link href="/2020/07/26/choco%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2020/07/26/choco%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-Chocolatey安装7zip"><a href="#使用-Chocolatey安装7zip" class="headerlink" title="使用 Chocolatey安装7zip"></a>使用 Chocolatey安装7zip</h2><p>全程使用科学上网</p><pre><code>choco install 7zip</code></pre><h2 id="如何安装Chocolatey"><a href="#如何安装Chocolatey" class="headerlink" title="如何安装Chocolatey"></a>如何安装Chocolatey</h2><p><a href="https://chocolatey.org/install.ps1" target="_blank" rel="noopener">在桌面下载</a></p><p>使用管理员打开cmd访问到下载的目录中</p><p>输入👇.安装的同时要使用科学上网</p><pre><code>@powershell -NoProfile -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&#39;install.ps1&#39;))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin&quot;</code></pre><p>查看是否安装成功：</p><p>choco</p><p><img src="1595823753408.png" alt=""></p><h2 id="什么是Chocolatey"><a href="#什么是Chocolatey" class="headerlink" title="什么是Chocolatey"></a>什么是Chocolatey</h2><p>Chocolatey是一个Windows下的软件包管理器，你可以像在类Unix系统中使用Yum和APT一样使用它，在Windows中实现自动化轻松管理Windows软件的所有方面。</p><p> <a href="https://zh.wikipedia.org/zh-cn/Chocolatey" target="_blank" rel="noopener">维基百科</a></p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2>]]></content>
      
      
      <categories>
          
          <category> Chocolatey </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chocolatey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin</title>
      <link href="/2020/07/26/kotlin-in-Action-Kotlin%E5%AE%9E%E6%88%98/"/>
      <url>/2020/07/26/kotlin-in-Action-Kotlin%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="2-Kotlin-基础"><a href="#2-Kotlin-基础" class="headerlink" title="2 Kotlin 基础"></a>2 Kotlin 基础</h1><h2 id="2-1-基本要素-函数变量"><a href="#2-1-基本要素-函数变量" class="headerlink" title="2.1 基本要素: 函数变量"></a>2.1 基本要素: 函数变量</h2><h3 id="2-1-3-变量"><a href="#2-1-3-变量" class="headerlink" title="2.1.3 变量"></a>2.1.3 变量</h3><p><strong>可变变量和不可变变量</strong></p><ul><li>val–不可变引用。使用val声明的变量不能在初始化之后再次赋值。它对应的是java中的final变量</li><li>var–可变引用。这种变量的值可以被改变。这种声明对应的是普通(非final)变量</li></ul><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595899792330.png" alt=""></p><p>👆在定义了val变量的代码块期间,<strong>val变量只能进行唯一一次初始化</strong>。但是,如果编译器能确保只有唯一一次初始化语句会被执行,可以根据条件使用不同的值来初始化它。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595899976491.png" alt=""></p><p>自身不可变(只可以执行一次,初始化一次)</p><p>注意,尽管val引用自身是不可变的,但是它指向的对象<strong>`可能</strong>`是可变的。列如</p><pre><code class="kotlin">val languages = arrayListOf(&quot;Java&quot;)lenguages.add(&quot;Kotlin&quot;)</code></pre><h2 id="2-3-表示和处理选择：枚举和“when”"><a href="#2-3-表示和处理选择：枚举和“when”" class="headerlink" title="2.3 表示和处理选择：枚举和“when”"></a>2.3 表示和处理选择：枚举和“when”</h2><h3 id="2-3-1-声明枚举类"><a href="#2-3-1-声明枚举类" class="headerlink" title="2.3.1 声明枚举类"></a>2.3.1 声明枚举类</h3><p><strong>什么是枚举</strong></p><p>为了让编译器能够自动检查某个值在枚举的集合中，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用 <strong>enum</strong> 来定义枚举类。</p><pre><code class="kotlin">enum class Color{    RED,ORANGE,YELLOW,GREEN,BLUE,INDIGO,VIOLET}</code></pre><p>kotlin 中 enum 是一个所谓的软关键词：只有当它出现在class前面时才会有特殊的意义，在其他地方可以把它当作普通的名称使用。</p><h3 id="2-3-5-智能转换：合并类型检查和转换"><a href="#2-3-5-智能转换：合并类型检查和转换" class="headerlink" title="2.3.5 智能转换：合并类型检查和转换"></a>2.3.5 智能转换：合并类型检查和转换</h3><p><strong>kotlin智能转换的案例</strong> </p><p><strong>表达式类型层次</strong></p><pre><code class="kotlin">interface Exprclass Num(val value: Int) : Expr    // 简单的值对象类，只有一个属性value，实现了Expr接口class Sum(val left: Expr, val right: Expr) : Expr   // Sum运算的实参可以是任何Expr:Num 或者 Sum</code></pre><p><strong>对表达式求值</strong></p><pre><code class="kotlin">fun eval(e: Expr): Int {    if (e is Num) {//        val n = e.value as Num //显示的转换为Num类型多余的        return e.value    }    if (e is Sum) {        return eval(e.left) + eval(e.right) // 变量 e 被智能的转换了类型    }    throw IllegalArgumentException(&quot;test&quot;)}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200831171911.png" alt=""></p><p>结果</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200831171248.png" alt=""></p><p><strong>“is” 修饰符</strong></p><p>在 kotlin 中，你要使用 is 检查来判断一个变量是否是某个类型。</p><p><strong>什么时候进行智能转换？</strong></p><p>如果你检查过一个变量是某种类型，后面就不再需要转换它了，可以就把它当作你检查过的类型使用。事实上编译器为你执行了类型转换，我们把这种行为称为 <strong>智能转换。</strong></p><h1 id="3-函数的定义与调用"><a href="#3-函数的定义与调用" class="headerlink" title="3 函数的定义与调用"></a>3 函数的定义与调用</h1><blockquote><ul><li><p>用于处理集合、字符串和正则表达式的函数</p></li><li><p>使用命名参数、默认参数，以及中辍调用语法</p></li><li><p>通过扩展函数和属性来适配Java库</p></li><li><p>使用顶层函数、局部函数和属性架构代码</p></li></ul></blockquote><p>至此，就像使用Java一样，你应该可以自如地使用Kotlin了。可以看到，从Java到Kotlin，它们的很多概念是相似的，而往往Kotlin可以让它们更加简洁并易读。</p><p>在这一章中，你将看到Kotlin改进每个程序的一个重要环节：函数的声明与调用。我们还将研究，如何通过扩展函数将Java库转换为Kotlin风格，以在混合语言的项目中获得Kotlin的全部好处。</p><p>为了让讨论更有用和具体，我们将把Kotlin集合、字符串和正则表达式作为重点问题领域。作为例子，我们来看看如何在Kotlin中创建集合。</p><h2 id="3-1-在Kotlin中创建集合"><a href="#3-1-在Kotlin中创建集合" class="headerlink" title="3.1 在Kotlin中创建集合"></a>3.1 在Kotlin中创建集合</h2><p>在开始学习对集合的各种有趣的操作之前，需要先学习会怎样创建它们。之前使用setOf函数创建了set。当时创建了一组颜色，现在，让我们保持它简单的同时，也支持数字。</p><pre><code class="kotlin">val set = hashSetOf(1,7,53)</code></pre><p>可以用类似的方法创建一个list或者map：</p><p>val list = arrayListOf</p><pre><code class="kotlin">val list = arrayListOf(1,7,53)val map = hashMapOf(1 to &quot;one&quot;,7 to &quot;seven&quot;,53 to &quot;fifty-three&quot;)</code></pre><p>这里的同并不是特殊的结构，而是普通的函数。稍后会探讨它。你能猜到这里创建的对象类型吗？</p><pre><code class="kotlin">println(set.javaClass)  //等价于Java中的getClass()println(list.javaClass)println(map.javaClass)/*     本章代码都按照这种形式运行    */fun main() {    val set = hashSetOf(1, 7, 53)    val list = arrayListOf(1, 7, 53)    val map = hashMapOf(1 to &quot;one&quot;, 7 to &quot;seven&quot;, 53 to &quot;fifty-three&quot;)    println(set.javaClass)  //等价于Java中的getClass()    println(list.javaClass)    println(map.javaClass)}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/img/20220416001329.png" alt=""></p><p>如你所见，Kotlin没有采用它自己的集合类，而是采用的标准的Java集合类，这对Java开发者是一个好消息。你现在所掌握的所有Java集合的知识在这里依然使用。</p><p>为什么Kotlin没有自己专门的集合类呢？那是因为使用标准的Java集合类，Kotlin可以更容易与Java代码交互。当从Kotlin中调用Java函数的时候，不用转换它的集合类来匹配Java的类，反之亦然。</p><p>尽管Kotlin的集合类和Java的集合类完全一致，但kotlin还不止于此。举个例子，可以通过以下方式来获取一个列表中的最后一个元素，或者是得到一个数字列表的最大值：</p><pre><code class="kotlin">    val strings = listOf(&quot;first&quot;, &quot;second&quot;, &quot;fourteenth&quot;)    println(strings.last())    val number = setOf(1, 14, 2)    println(number.max())</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/img/20220416003710.png" alt=""></p><p>本章将会仔细研究它的工作原理，以及Java类上新增的方法从何而来。</p><p>在后续的章节中，我们开始讨论lambda时，你将会见识到更多的对于集合的操作，但是目前，就继续保持采用Java标准的集合类。6.3章节中会学习到集合类在Kotlin类型系统中的表示。</p><h2 id="3-2-让函数更好调用"><a href="#3-2-让函数更好调用" class="headerlink" title="3.2 让函数更好调用"></a>3.2 让函数更好调用</h2><p>现在你已经知道了如何创建一个集合，让我们再来做点别的：打印它的内容。</p><p>Java的集合都有一个默认的toString实现，但是它格式化的输出是固定的，而且往往不是你需要的样子：</p><pre><code class="kotlin">fun main() {    val list = listOf(1, 2, 3)//    出发toString    println(list) }</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220416200251.png" alt=""></p><p>假设你需要用分号来分割每一个元素，然后用括号括起来，而不是采用默认实现用的方括号：(1;2;3)。要解决这个问题，Java项目会使用第三方的库，比如Guava和Apach Commons，或者在这个项目中重写打印函数。在Kotlin中，它的标准库中有一个专门的函数来处理这种情况。</p><p>本节你将自己实现这个函数。不借助Kotlin的工具来简化函数声明，从直接重写实现函数开始，然后再过度到Kotlin更惯用的方法来重写。</p><p>下面的joinToString函数就展示了通过在元素中间添加分隔符号，在最前面添加前戳，在最末尾添加后戳的方式把集合的元素逐个添加到一个StringBuilder的过程。</p><pre><code class="kotlin">/*joinToString()的基本实现*/fun &lt;T&gt; joinToString(    collection: Collection&lt;T&gt;,    separator: String,    prefix: String,    postfix: String): String {    val result = StringBuilder(prefix)    for ((index, element) in collection.withIndex()) {//        不用在第一个元素前添加分隔符        if (index &gt; 0) result.append(separator)        result.append(element)    }    result.append(postfix)    return result.toString()}</code></pre><p>这个函数是泛型：它可以支持元素为任何类型的集合。这里泛型的语法和Java类似。</p><p>我们来验证一下，这个函数运行起来是不是像我们设想的那样：</p><pre><code class="kotlin">fun main() {    val list = listOf(1, 2, 3)    println(joinToString(list, &quot;;&quot;, &quot;(&quot;, &quot;)&quot;))}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220416201919.png" alt=""></p><p>看来这个函数是可行的。</p><h3 id="3-2-1-命名参数"><a href="#3-2-1-命名参数" class="headerlink" title="3.2.1 命名参数"></a>3.2.1 命名参数</h3><p>我们要关注的第一个问题就是函数的可读性。例子，看看joinToString的调用：</p><pre><code class="kotlin">joinToString(collection,&quot;&quot;,&quot;&quot;,&quot;.&quot;)</code></pre><p>你能看出这些String都对应的什么参数吗？这个集合的元素用空格还是点号来分割的？如果不去查看函数的声明，我们很难回答这个问题。或许你记住了这个声明，又或许你可以借助你的IDE，但从调用代码来看，这依然很隐晦</p><p><code>表明名称</code> <strong>对于Boolean类型的标志，这个问题尤其明显。为了解决这个问题，一些Java编程风格，推荐尝试enum类型而不是采用Boolean；而另外一些风格，会通过让你添加注释，在注释中指明参数的名称，例如</strong>：</p><pre><code class="java">joinToString(collection, /*     separator    */ &quot;&quot;,/* prefix    */&quot;&quot;,/*    postfix    */&quot;.&quot;);</code></pre><p>在Kotlin中，可以做到更优雅：</p><pre><code class="kotlin">joinToString(collection,separator = &quot;&quot;,prefix = &quot; &quot;,postfix = &quot;.&quot;)</code></pre><p><strong>但调用Kotlin定义的函数时，可以显式的标明一些参数的名称。如果在调用一个函数时，指明了一个参数的名称，为了避免混淆，那它之后的所有参数都需要表明名称</strong>。</p><blockquote><p>当你在重命名函数的参数时，IntelliJ IDEA 可以帮助你调用该函数的地方，一同更新命名参数。不过需要注意的是，要确保在重命名的时候，是采用的IDEA自带的Rename（重命名）或者ChangeSignature（改变函数签名）来处理，而不是手动地修改参数名称。</p></blockquote><blockquote><p>警告：</p><p>不幸的是，当你调用Java函数时，不能采用命名函数，不管是JDK中的函数，或者是Android框架的函数，都不行。把参数名称存到.class文件Java8及其更高版本的一个可选功能，而Kotlin需要保持和Java6的兼容性。所以，编译器不能识别出调用函数的参数名称，然后把这些参数名对应到函数的定义的地方。</p></blockquote><h3 id="3-2-2-默认参数值"><a href="#3-2-2-默认参数值" class="headerlink" title="3.2.2 默认参数值"></a>3.2.2 默认参数值</h3><p>Java的另一个普遍存在的问题是，一些类的重载函数实在太多了。只要看一眼java.lang.Thread以及它对应的八个构造方法（ <a href="http://mng.bg/4KZC" target="_blank" rel="noopener">http://mng.bg/4KZC</a> )，能让人够受了！这些重载，原本是为了向后兼容，方便一些API的使用者，又或者出于别的原因，但导致的最终结果都是一致的：重复。这些参数名和类型被重复了一遍又一遍，如果你是一个良好的公民，还必须在每次重载的时候重复大部分的文档。与此同时当你调用了一个省略了部分参数的重载函数时，你可能会搞不清它们到底用的哪个。</p><p><code>使用默认参数值减少重载</code><strong>在Kotlin中，可以在声明函数的时候，指定参数的默认值，这样就可以避免创建重载的函数。让我们尝试改进一下前面的joinToString函数。在大多数情况下，字符串可以不加前戳或者后戳并用逗号分割。所以我们把这些设置为默认值</strong>。</p><pre><code class="kotlin">fun main() {    val list = listOf(1, 2, 3)    println(joinToString(list, &quot;,&quot;, &quot;&quot;, &quot;&quot;))    println(joinToString(list))    println(joinToString(list, &quot;;&quot;))}/*joinToString()的基本实现*/fun &lt;T&gt; joinToString(    collection: Collection&lt;T&gt;,    separator: String = &quot;,&quot;,/*有默认值的参数*/    prefix: String = &quot;&quot;,    postfix: String = &quot;&quot;): String {    val result = StringBuilder(prefix)    for ((index, element) in collection.withIndex()) {        if (index &gt; 0) result.append(separator)        result.append(element)    }    result.append(postfix)    return result.toString()}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220418203941.png" alt=""></p><p>当使用常规的调用语法时，必须按照函数声明中定义的参数顺序来给定参数，可以省略的只有排在末尾的参数。如果使用命名参数，可以省略中间的一些参数，也可以以你想要的任意顺序给定你需要的参数：</p><pre><code class="kotlin"> println(joinToString(list, postfix = &quot;;&quot;,prefix = &quot;# &quot;))</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220418204532.png" alt=""></p><p><strong>注意，参数的默认值是被编码到被调用的函数中，而不是调用的地方。如果你修改了参数的默认值并重新编译这个函数，没有给参数重新赋值的调用者，将会开始使用行的默认值</strong>。</p><blockquote><p>默认值和Java</p><p>考虑到Java没有参数默认值的概念，当你从Java中调用Kotlin函数的时候，必须显式地指定所有参数值。如果需要从Java代码中做频繁的调用，而且希望他能对Java的调用者更加便捷，可以使用@JvmOverloads注解它。这个指示编译器生成Java重载函数，从最后一个开始省略每个参数。</p><p>举个例子，如果用@JvmOverloads注解joinToString，编译器就会生成如下的重载函数：</p><pre><code class="java">String joinToString(Coollection&lt;T&gt; collection,String separator,String prefix,String postfix);String joinToString(Coollection&lt;T&gt; collection,String separator,String prefix);String joinToString(Coollection&lt;T&gt; collection,String separator);String joinToString(Coollection&lt;T&gt; collection);</code></pre><p>每个重载函数的默认参数值都会被省略。</p></blockquote><h3 id="3-2-3-消除静态工具类：顶层函数和属性"><a href="#3-2-3-消除静态工具类：顶层函数和属性" class="headerlink" title="3.2.3 消除静态工具类：顶层函数和属性"></a>3.2.3 消除静态工具类：顶层函数和属性</h3><p>Java作为一门面向对象的语言，需要所有的代码都写作类的函数。大多数情况下，这种方式还能行得通。但事实上，几乎所有的大型项目，最终都有很多的代码并不能归属到任何一个类中。有时一个操作对应两个不同的类的对象，而且重要性相差无几。有时存在一个基本的对象，但你不想通过实例函数来添加操作，让它的API持续膨胀。</p><p>结果就是，最终这个类将不包含任何的状态或者实例函数，而且仅仅作为一堆静态函数的容器。在JDK中，最合适的例子应该是Collection了，看看你自己的代码，是不是也有一些类本身的Util作为后戳命名。</p><p><code>无需创建工具类</code> <strong>在Kotlin中，根本不需要去创建这些意义的类。相反，可以把这些函数直接放到代码文件的顶层，不用从属于任何类。这些放在文件顶层的函数依然是包类的成员，如果你需要从包外访问它，这需要import，但不需要跟外包一层</strong>。</p><p>让我们来把joinToString直接放到strings的包中试一下。创建join.kt的文件：</p><pre><code>/*声明 joinToString作为顶层函数*/package stringsfun joinToString(...):String{...}</code></pre><p><code>创建顶层函数</code> 这些如何运行？当你编译这个文件的时候，会生成一些内，因为JVM只会执行类中的代码。当你使用Kotlin的时候，知道这些就够了。但是，如果需要从Java中来调用这些函数，你就必须理解它将会怎样被编译。为了方便理解，查看一段Java代码，这里会编译成相同的类：</p><pre><code class="java">/*    Java    */package strings;public class JoinKt{    public static String joinToString(...){...}}</code></pre><p>可以看到Kotlin编译生成的类的名称，对应包含函数的文件的名称。这个文件中的所有顶层函数编译为这个类的静态函数。因此，但从Java调用这个函数的时候，和调用任何其他静态函数一样非常简单：</p><pre><code class="java">/*    java    */import strings.JoinKt;...JoinKt.joinToString(list,&quot;&quot;,&quot;&quot;,&quot;&quot;);</code></pre><blockquote><p>修改文件类名</p><p>要修改包含Kotlin顶层函数的生成类的名称，需要为这个文件添加@JvmName的注解，将其放在这个文件的开头，位于包名的前面：</p><pre><code class="kotlin">@file:JvmName(&quot;StringFunction&quot;)    //注解指定包名package strings    //包的声明跟在文件注解之后fun joinToString(...):String{...}</code></pre><p>现在可以这样调用这个函数：</p><pre><code class="java">/*    Java    */import strings.StringFunctionsStringFunctions.joinToString(list,&quot;&quot;,&quot;&quot;,&quot;&quot;);</code></pre></blockquote><p><strong>顶层属性</strong></p><p>和函数一样，属性也可以放在文件的顶层。在一个类的外面保存单独的数据片段虽然不常用，但还是有它的价值。</p><p>例子，使用var属性来计算一些函数被执行的次数：</p><pre><code class="kotlin">var opCount = 0 //声明一个顶层属性fun performOperation(){//    改变该属性的值    opCount ++    //...}fun reportOperationCount(){    println(&quot;Operation performed $opCount times&quot;)   //读取属性值}</code></pre><p>像这个值将会被存储到一个静态的字段中。</p><p>也可以在代码中用顶层属性来定义常量：</p><pre><code class="kotlin">val UNIX_LINE_SEPARATOR = &quot;\n&quot;</code></pre><p>默认情况下，顶层属性和其他任意的属性一样，是通过访问器暴露给Java使用（如果是val就只有一个getter，如果是var就对应一对getter和setter）。<code>暴露给Java调用时这样</code> <strong>为了方便使用，如果你想要把一个常量public static final的属性暴露给Java，可以用const修饰它（这个适用于所有的基本数据类型的属性，以及String类型）</strong>。</p><pre><code class="kotlin">const val UNIX_LINE_SEPARATOR = &quot;\n&quot;</code></pre><p>等同于Java代码</p><pre><code class="java">/*    Java    */public static final String UNIX_LINE_SEPARATOR = &quot;\n&quot;</code></pre><h2 id="3-3-给别人的类添加方法：扩展函数和属性"><a href="#3-3-给别人的类添加方法：扩展函数和属性" class="headerlink" title="3.3 给别人的类添加方法：扩展函数和属性"></a>3.3 给别人的类添加方法：扩展函数和属性</h2><p><code>使用扩展函数场景</code> <strong>Kotlin的一大特色，就是可以平滑地与现有代码集成。甚至，纯Kotlin的项目都可以基于Java库构建，如JDK、Android框架，以及其他的第三方框架。当你在一个现有的Java项目中集成Kotlin的时候，依然需要面临现有代码目前不能转成Kotlin，甚至将来也不能转成Kotlin的局面。当使用这些API的时候，如果不用重写，就能使用到Kotlin为它带来方便，岂不是更好</strong>？这里，可以用扩展函数来实现。</p><p><code>定义一个扩展函数</code> 理论上，<strong>扩展函数</strong>非常简单，它就是一个类的成员函数，不过定义在类的外面。为了方便阐释，让我们添加一个方法，来计算一个字符串的最后一个字符：</p><pre><code class="kotlin">fun String.lastChar(): Char = this.get(this.length - 1)</code></pre><p>你所要做的，就是把你要扩展的类或者接口的名称，放到即将添加的函数前面。这个类的名称被称为<strong>接收者类型</strong>；用来调用这个扩展函数的对象，叫做<strong>接收者对象</strong>，如下</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220418232008.png" alt="接收者类型是由扩展函数定义 ，接收者对象是该类型的一个实例"></p><p>可以像调用类的普通成员函数一样去调用这个函数：</p><pre><code class="kotlin">fun main() {    println(&quot;Koltin&quot;.lastChar())}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220418232214.png" alt=""></p><p>在这个例子中，String就是接收者类型，而“Kotlin”就是接收者对象。</p><p>从某种意义上来说，你已经为String类添加了自己的方法。即使字符串不是代码的一部分，在没有类的源代码，你仍然可以在自己的项目中根据需要去扩展方法。不管String类是Java、Kotlin，或者像Groovy的其他JVM语言编写的，只要是它的编译为Java类，你就可以为这个类添加自己的扩展。</p><p>在这个扩展函数中，可以像其他成员函数一样用this。而且也可以像普通的成员函数一样，省略他。</p><pre><code class="kotlin">package stringsfun String.lastChar(): Char = this.get(this.length - 1) //接收者对象成员可以不用this来访问</code></pre><p><strong>在扩展函数中，可以直接访问被扩展的类的其他方法和属性，就好像是在这个类自己的方法中访问它们一样。注意，扩展函数并不允许你打破它的封装性。和在类内部定义的方法不同的是，扩展函数不能访问私有或者受保护的成员</strong>。</p><h3 id="3-3-1-导入扩展函数"><a href="#3-3-1-导入扩展函数" class="headerlink" title="3.3.1 导入扩展函数"></a>3.3.1 导入扩展函数</h3><p>对于你定义的一个扩展函数，它不会自动的在整个项目范围类生效。相反，如果你要使用它，需要进行导入，就像其他任何的类或者函数一样。为了避免偶然性的命名冲突。Kotlin允许你和导入类一样的语法来导入单个函数：</p><pre><code class="kotlin">import string.lastCharval c = &quot;Kotlin&quot;.lastChar()</code></pre><p>当然，用*来导入也是可以的：</p><pre><code class="kotlin">import string *val c = &quot;Kotlin&quot;.lastChar()</code></pre><p>可以使用关键字as来修改导入的类或者函数名称：</p><pre><code class="kotlin">import string.lastChar as lastval c = &quot;Kotlin&quot;.last()</code></pre><p>当你在不同的包中，有一些重名的函数，在导入时给它的重新命名就显得很有必要了，这样可以在同一个文件中去使用它们。在这种情况下，对于一般的类和函数，还有另一个选择：可以选择用全命名来指出这个类或者函数。对于扩展函数，Kotlin的语法要求你用简短的名称，修改，在导入声明的时候，关键字as就是你解决命名冲突问题的唯一方式。</p><h3 id="3-3-2-从Java中调用扩展函数"><a href="#3-3-2-从Java中调用扩展函数" class="headerlink" title="3.3.2 从Java中调用扩展函数"></a>3.3.2 从Java中调用扩展函数</h3><p>实质上，扩展函数是静态函数，它把调用对象作为它的第一参数。调用扩展函数，不会扩展适配的或者任何运行时的额外消耗。</p><p>这使得从Java中调用Kotlin的扩展函数变的非常简单：调用这个静态函数，然后把接收者对象作为第一个参数传进去集合。和其他顶层函数一样，包括这个函数的Java类的名称，是由这个函数声明的文件名称决定的。假设它声明在一个叫StringUtil.kt文件中：</p><pre><code class="kotlin">/*    Java    */char c = StringUtil.lastChar(&quot;Java&quot;)</code></pre><p>这个扩展函数被声明为顶层函数，所以，它将会被编译为一个静态函数。在Java中静态导入lastChar函数，就可以直接使用它，如lastChar(“Java”)。</p><h3 id="3-3-3-作为扩展函数的工具函数"><a href="#3-3-3-作为扩展函数的工具函数" class="headerlink" title="3.3.3 作为扩展函数的工具函数"></a>3.3.3 作为扩展函数的工具函数</h3><p>现在，可以写一个joinToString函数的终极版本了，它和你在Kotlin标准库中看到的一摸一样。</p><pre><code class="kotlin">/*扩展函数joinTOString()*/fun &lt;T&gt; Collection&lt;T&gt;.joinToString( //为Collection&lt;T&gt;声明一个扩展函数    separator: String = &quot;,&quot;,    //默认参数    prefix: String = &quot;&quot;,    postfix: String = &quot;&quot;): String {    val result = StringBuilder(prefix)    for ((index, element) in this.withIndex()) {    //this指向接收者对象：T的集合        if (index &gt; 0) result.append(separator)        result.append(element)    }    result.append(postfix)    return result.toString()}&gt;&gt;&gt; val list = listOf(1,2,3)&gt;&gt;&gt; println(list.joinToString(separator = &quot;;&quot;,        prefix = &quot;(&quot;,postfix = &quot;)&quot;))</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220425215826.png" alt=""></p><p>可以给元素的集合类添加一个扩展函数，然后给所有的参数添加一个默认值。这样，你就可以像使用一个类的成员函数一样，去调用joinToString了：</p><pre><code class="kotlin">&gt;&gt;&gt; val list = arrayListOf(1,2,3)&gt;&gt;&gt; println(list.joinToString(&quot;&quot;))</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220425220259.png" alt=""></p><p>因为扩展函数无非就是静态函数的一个高效的语法糖，可以使用更具体的类型来作为接收者类型，而不是一个类。假设你需要一个join函数，只能由字符串集合来触发。</p><pre><code class="kotlin">fun Collection&lt;String&gt;.join(    separator: String=&quot;,&quot;,    prefix: String=&quot;&quot;,    postfix: String=&quot;&quot;)=joinToString(separator,prefix,postfix)&gt;&gt;&gt; println(listOf(&quot;one&quot;,&quot;two&quot;,&quot;eight&quot;).join(&quot; &quot;))</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220425220656.png" alt=""></p><p>如果使用其他类型的对象列表来调用，将会报错：</p><pre><code class="kotlin">&gt;&gt;&gt; listOf(1,2,8).join()Error:Type mismatch:inferred type is List&lt;Int&gt; but Collection&lt;String&gt; was expected</code></pre><p>扩展函数的静态属性也决定了扩展函数不能被之类重写。</p><h3 id="3-3-4-不可重写的扩展函数"><a href="#3-3-4-不可重写的扩展函数" class="headerlink" title="3.3.4 不可重写的扩展函数"></a>3.3.4 不可重写的扩展函数</h3><p><strong>在Kotlin中，重写成员函数是很平常的一件事。但是，不能重写扩展函数</strong>。<code>假设</code>这里有两个类，View和它的子类Button，然后Button重写了父类的clike函数。</p><pre><code class="kotlin">/*重新成员函数*/open class View{    open fun click()=println(&quot;View clicked&quot;)}class Button:View(){    override fun click() {        println(&quot;Button clicked&quot;)   //Button 继承View    }}</code></pre><p><strong>当你声明了类型View的变量，那么它被赋值为Button类型的对象，因为Button是View的子类。当你在调用这个变量的一般函数，比如clicke的时候，如果这个函数被Button重写了</strong>，<code>调用子类被重写的函数</code>  那么这里</p><p>将会调用到Button中重写的函数：</p><pre><code class="kotlin">fun main() {    val view:View= Button()    view.click()    //具体调用那个方法，由实际的view的值来决定}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220429005715.png" alt=""></p><p>但是对于扩展函数来说，并不是这样的。如下：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220429005809.png" alt="扩展函数声明在类的外部"></p><p>扩展函数并不是类的一部分，它是声明在类之外的。尽管可以给基类和子类都分别定义一个同名的扩展函数，当这个函数被调用时，它会用到哪一个呢？这里，它是由该变量的静态类型所决定的，而不是这个变量的运行时类型。</p><p>下面的例子就展示了两个分别声明在View和Button的showOff扩展函数。</p><pre><code class="kotlin">fun main() {  val view= Button()    view.showOf()//扩展函数被静态的解析}/*不能重写扩展函数*/fun View.showOf()= println(&quot;I&#39;m a view&quot;)fun Button.showOf()= println(&quot;I&#39;m a button!&quot;)</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220505184003.png" alt=""></p><p>当你在调用一个类型为View的变量的showOff函数时，对应的扩展函数会被调用，尽管实际上这个变量现在是一个Button的对象。</p><p>回想一下，扩展函数将会在Java中被编译为静态函数，同时接收值将会作为第一个参数，对于此你应该清楚，因为Java会执行相同的函数：</p><pre><code class="kotlin">/* Java */&gt;&gt;&gt; View view = new Button();&gt;&gt;&gt; ExtensionKt.showOf(view);//showOff函数声明在extension.kt中I&#39;m a view</code></pre><p>如你所见，扩展函数并不存在重写，因为Kotlin会把它们当作静态函数对待。</p><blockquote><p>注意：</p><p><code>如果一个类的成员函数和扩展函数有相同的签明，成员函数往往会被优先使用</code>。你应该牢记，当在扩展API的时候；如果添加一个和扩展函数同名的成员函数，那么对应类定义的消费者将会重新编译代码，这将会改变它的意义并开始指向新的成员函数。</p></blockquote><h3 id="3-3-5-扩展函数"><a href="#3-3-5-扩展函数" class="headerlink" title="3.3.5 扩展函数"></a>3.3.5 扩展函数</h3><p>扩展函数提供了一种方法，<code>用来扩展API</code>，可以用来访问属性，用的是属性的语法而不是函数的语法。尽管它们被称为<strong>属性</strong>，但它们可以没有任何状态，因为没有合适的地方来存储它，不可能给现有的Java对象的实例添加额外的字段。但有时短语法仍然是便于使用的。</p><p>上节，我们又定义了一个lastChar的函数，现在让我们把它转换成一个属性试试。<code>声明扩展属性</code></p><pre><code class="kotlin">/*    声明一个扩展函数    */val String.lastChar: Char    get() = get(length - 1)</code></pre><p>可以看到，和扩展函数一样，扩展属性也像接收者的一个普通的成员属性一样。这里，必须定义getter函数，因为没有支持字段，因此没有默认getter的实现。同理，初始化也不可以：因为没有地方存储初始化值。</p><p><strong>如果在StringBuilder上定义一个相同的属性</strong>，可以置为var，因为StringBuilder的内容是可变的。<code>声明扩展属性</code>  </p><pre><code class="kotlin">/*   声明一个可变的扩展函数   */var StringBuilder.lastChar: Char    get() = get(length - 1)    set(value: Char) {        this.setCharAt(length - 1, value)    }</code></pre><p>可以像访问使用成员属性一个访问它：</p><pre><code>fun main() {    println(&quot;Kotlin&quot;.lastChar())    val sb = StringBuilder(&quot;Kotlin?&quot;)    sb.lastChar = &#39;!&#39;    println(sb)}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220514230636.png" alt=""></p><p>注意，当你需要从Java中访问属性的时候，应该显式地调用它的getter属性：StringUtilKt.getLastChar(“Java”)。</p><h2 id="3-4-处理集合：可变参数、中辍调用和库的支持"><a href="#3-4-处理集合：可变参数、中辍调用和库的支持" class="headerlink" title="3.4 处理集合：可变参数、中辍调用和库的支持"></a>3.4 处理集合：可变参数、中辍调用和库的支持</h2><p>这一节将会展示Kotlin标准库中用来处理集合的一些方法。另外，也会设计几个相关的语言特性：</p><ul><li><strong>可变参数的关键vararg</strong>，可以用来声明一个函数将可能有任意数量的参数</li><li><strong>一个中辍表示法</strong>，当你在调用一些只有一个参数的函数时，使用它会让代码更简练</li><li>解构声明，用来把一个单独的组合值展开到多个变量中</li></ul><h3 id="3-4-1扩展Java集合的API"><a href="#3-4-1扩展Java集合的API" class="headerlink" title="3.4.1扩展Java集合的API"></a>3.4.1扩展Java集合的API</h3><p>我们开始本章的前提，是基于Kotlin中的集合与Java的类的相同，但对API做了扩展。我们看一个示例，用来获取列表中最后一个元素并找到数字集合中的最大值：</p><pre><code class="kotlin">fun main() {    val strings: List&lt;String&gt; = listOf(&quot;first&quot;, &quot;second&quot;, &quot;fourteenth&quot;)    println(strings.last())    val numbers: Collection&lt;Int&gt; = setOf(1, 14, 2)    println(numbers.max())}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220515212621.png" alt=""></p><p>我们感兴趣的是<strong>它是怎么工作的</strong>：尽管它们是Java库类的实例，为什么在Kotlin中能对集合有这么多丰富的操作？现在答案很明显了：<strong>因为函数last和max都被声明成了扩展函数</strong>。</p><p><strong>last函数不会比String的lastChar更复杂</strong>，在上节讨论过：它（last）是List类的一个扩展函数。对于max，我们做一个简单的声明（真正的库函数不仅用于Int数字，而且适用于任何可比较的元素）：</p><pre><code class="kotlin">fun &lt;T&gt; List&lt;T&gt;.list(): T {/* 返回最后一个元素  */}fun Collection&lt;Int&gt;.max(): Int {/*  找到集合的最大值   */}</code></pre><p><em>许多扩展函数在Kotlin标准库中都有声明，在这里，我们不会列出所有这些方法。你可能会想知道，在Kotlin标准库中学习所有内容的最佳方法。这个并没有比较，在你需要操作集合或任何其他对象的时候，IDE中的代码补全功能，将为你列出所有可能用于该类型对象的方法，不管是普通函数或者扩展函数，都会有显式，你可以选择所需的方法。除此之外，标准库的引用会列出库中每个类的所有可用的函数，包括成员函数及扩展函数。</em></p><h1 id="4-类、对象和接口"><a href="#4-类、对象和接口" class="headerlink" title="4 类、对象和接口"></a>4 类、对象和接口</h1><h2 id="4-1-定义类继承结构"><a href="#4-1-定义类继承结构" class="headerlink" title="4.1 定义类继承结构"></a>4.1 定义类继承结构</h2><h3 id="4-1-1-Kotlin-中的接口"><a href="#4-1-1-Kotlin-中的接口" class="headerlink" title="4.1.1 Kotlin 中的接口"></a>4.1.1 Kotlin 中的接口</h3><p><strong>声明接口</strong></p><pre><code class="kotlin">interface Clickable{    fun click()}</code></pre><p><strong>实现接口</strong></p><pre><code>class Button : Clickble {    override fun click() {        println(&quot;I was clicked&quot;)    }}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200826205307.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200826205356.png" alt=""></p><p><strong>Kotlin实现接口与 Java 有那些不同</strong></p><p>Kotlin 在类后面使用冒号来代替 <strong>Java</strong> 中的 extends 和 implements 关键词。 和 Java 一样，<strong>一个类可以实现任意多个接口</strong>，但<strong>只能继承一个类型</strong>。</p><p><strong>override 修饰符的作用</strong></p><ul><li>相同</li></ul><p>与 Java 中的 @Override 注解类似，<strong>override 修饰符用来标注被重写的父类或者接口的方法和属性</strong>。</p><ul><li>不同</li></ul><p>在 Kotlin 中使用 override 修饰符是强制要求的。<strong>这会避免先写出实现方法再添加抽象方法造成的意外重写：</strong>你的代码将不能编译，除非你显式地将这个方法标注为 Override 或者重命名它。</p><p><strong>如何给接口添加一个默认实现的方法</strong></p><p>接口的方法可以有一个默认实现的方法。</p><pre><code class="kotlin">interface Clickable{    fun click() // 普通的方法声明    fun showOff() = println(&quot;I&#39;m clickable!&quot;) // 带默认实现的方法}</code></pre><p><strong>实现一个带有默认实现的方法的接口要注意什么</strong></p><p>如果你实现了这个接口，你需要为 click 提供一个实现。可以重新定义 showOff() 方法的行为，或者如果你对默认行为感到满意也可以直接省略它。（默认实现的方法也可以被重写）</p><p><strong>定义实现了同样方法的接口</strong></p><pre><code class="kotlin">interface Focusable {    fun setFocus(b: Boolean) = println(&quot;I ${if (b) &quot;got&quot; else &quot;lost&quot;} focus.&quot;)    fun showOff() = println(&quot;I&#39;m focusable!&quot;)}</code></pre><p><strong>在类中实现两个有相同默认实现方法的接口会发生什么</strong></p><p>在这两个接口中都带有默认实现的 showOff() 方法：在没有显示的实现 showOff() ,会得到编译错误信息。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827000446.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827000526.png" alt=""></p><p><strong>解决办法</strong></p><p>必须显式的实现相同方法。</p><p><strong>调用继承(接口)的默认实现方法</strong></p><pre><code class="kotlin">class Button : Clickable, Focusable {    override fun click() {        TODO(&quot;Not yet implemented&quot;)    }    //如果同样的继承成员不止一个实现，必须提供一个显示的实现。    override fun showOff() {        // 使用尖括号加上父类名字的“super”表明了你想要调用哪一个父类的方法        super&lt;Clickable&gt;.showOff()        super&lt;Focusable&gt;.showOff()    }}</code></pre><p>通过调用继承的两个父类型中的实现来实现 showOff() 。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827005257.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827005432.png" alt=""></p><h3 id="4-1-2-open、final-和-abstract-修饰符：默认为-final"><a href="#4-1-2-open、final-和-abstract-修饰符：默认为-final" class="headerlink" title="4.1.2 open、final 和 abstract 修饰符：默认为 final"></a>4.1.2 open、final 和 abstract 修饰符：默认为 final</h3><p><strong>kotlin 中如何继承一个类</strong></p><p>如果你想要创建一个类的子类，需要使用 open 修饰符来标示这个类。此外<strong>需要给每个可以被重写的属性或者方法添加 open 属性</strong>。</p><p><strong>声明一个带open 方法的 open 类</strong></p><pre><code class="kotlin">open class RichButton : Clickable {    fun disable() {}    // 这个函数是 final 的： 不能在子类中重写它。    open fun animate() {} // 这个函数是 open 的： 可以在子类中重写它    // 这个函数重写了 open 函数并且它本身同样是 open 的    override fun click() {        TODO(&quot;Not yet implemented&quot;)    }}</code></pre><p><strong>默认 final 的好处</strong></p><p>类默认 final 带来了一个重要的好处就是这使得在大量的场景中的只能转换成为可能。</p><p><strong>智能转换的前提</strong></p><p><strong>智能转换只能在进行类型检查后没有改变过的变量上起的作用。</strong>对于一个类来说，这意味着<strong>智能转换在val类型并且没有自定义访问器的类属性上使用</strong>。 这个前提意味着属性必须是 final 的，否则如果一个子类可以重写属性并且定义一个自定义的访问器将会打破智能转换的关键前提。</p><p><strong>抽象类的默认修饰符</strong></p><p>抽象成员始终是open的，所以不需要显式地使用open修饰符。</p><p><strong>声明一个抽象类</strong></p><pre><code class="kotlin">abstract class Animated {    abstract fun animate()  // 这个函数是抽象的：它没有实现必须被子类重写    // 抽象类中的非抽象函数 并不是默认 open 的，但是可以标注为 open的    open fun stopAnimating() {    }    fun animateTwice() {}}</code></pre><h3 id="4-1-4-内部类和嵌套类：默认嵌套类"><a href="#4-1-4-内部类和嵌套类：默认嵌套类" class="headerlink" title="4.1.4 内部类和嵌套类：默认嵌套类"></a>4.1.4 内部类和嵌套类：默认嵌套类</h3><p>内部类：非静态嵌套类，也被成为内部类。</p><p>嵌套类：静态嵌套类，嵌套类多称为：静态嵌套类。</p><p><strong>Kotlin中嵌套类和Java中的不同</strong></p><p>在Kotlin中的嵌套类不能访问外部类的实例，除非你特别的做出要求。 </p><p><strong>在序列化时使用内部类</strong></p><p>在你定义一个 View 元素，它的状态时可序列化的。<strong>想要序列化一个视图可能并不容易，但是可以把所有需要的数据复制到另一个辅助类中去。</strong></p><pre><code class="kotlin">interface State : Serializableinterface View {    fun getCurrentState(): State    fun restoreState(state: State) {}}</code></pre><p>声明State接口去实现Serializable。View接口声明了可以用来保存视图状态的getCurrentState和restoreState方法。</p><p><strong>用内部类的java代码来实现View</strong></p><pre><code class="java">public class Button implements View{    @Override    public State getCurrentState(){        return new ButtonState();    }    @Override    public voiew restoreState(State state){        /**/    }    public class ButtonState implements State{        /**/    }}</code></pre><p>问题：在运行时你会得到 java.io.NotSerializable.Exception:Button 异常，在你序列化声明的按钮状态时。这个可能看起来会很奇怪：你序列化的变量是ButtonState类型，为什么会有Button异常呢？</p><p><strong>无法序列化的原因</strong></p><p>在java中，当你在另一个类中声明一个类时，它会默认变成内部类。案例中：ButtonState类隐示的存储了它的外部Button类的应用。从而解释了为什么ButtonState不能被序列化。</p><p><strong>修复无法序列化</strong></p><p><strong>需要声明ButtonState类是static的</strong>。将嵌套类声明为static会冲这个类中删除包围它的类的隐式引用。</p><p><strong>在kotlin中使用嵌套类来实现 View</strong></p><pre><code class="kotlin">class Button : View {    override fun getCurrentState(): State {        TODO(&quot;Not yet implemented&quot;)    }    override fun restoreState(state: State) {        TODO(&quot;Not yet implemented&quot;)    }    // 这个类与Java中的静态潜逃类类似    class ButtonState : State {    }}</code></pre><p><strong>kotlin中默认行为是嵌套类。</strong></p><p><strong>如何让默认嵌套类的类型变为内部类！</strong></p><p>要把它（嵌套类）变成为一个内部类来持有一个外部类的引用的话需要使用 <strong>inner</strong> 修饰符。</p><p><strong>kotlin中内部类访问外部类</strong></p><p>在kotlin中引用外部类实例的语法与java不同。需要使用this@Outer从Inner类去访问Outer类。</p><blockquote><p>创建内部类</p><pre><code class="kotlin">fun main() {    var innerClass = InnerClass()    innerClass.testClass().innerFun()}class InnerClass {    //  创建一个变量用来让内部类的方法调用    val tag = &quot;外部变量&quot;    //    使用inner修饰符修饰类如果不修饰内部类无法调用到外部变量    inner class testClass {        fun innerFun() {            println(&quot;内部类调用外部变量:$tag&quot;)        }    }}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220426195526.png" alt=""></p><p>内部类调用到外部变量需要声明到inner修饰符，当然外部类调用内部类不需要。</p></blockquote><h3 id="4-1-5-密封类：定义受限的类继承结构"><a href="#4-1-5-密封类：定义受限的类继承结构" class="headerlink" title="4.1.5 密封类：定义受限的类继承结构"></a>4.1.5 密封类：定义受限的类继承结构</h3><p><strong>什么是密封类”sealed“</strong></p><p>sealed 类。为父类添加了一个新的 sealed 修饰符，可对创建的子类做出严格的限制。<strong>所有的子类必须嵌套在父类中。</strong></p><p><strong>为什么要使用密封类（定义受限的类继承结构）</strong></p><p><strong>作为接口实现的表达式 👇</strong></p><pre><code class="kotlin">interface Exprclass Num(val value: Int) : Exprclass Sum(val left: Expr, val right: Expr):Exprfun eval(e: Expr): Int =    when (e) {        is Num -&gt; e.value        is Sum -&gt; eval(e.left) + eval(e.right)        else -&gt; // 必须检查 else 分支            throw  IllegalArgumentException(&quot;Unknown expression!&quot;)    }</code></pre><p><strong>当使用 when 结构来执行表达式的时候，Kotlin 编译器会强制检查默认选项</strong>。在这个例子中，<strong>不能返回一个有意义的值，所以直接返回异常状态。</strong></p><p>更重要的是，如果你添加了一个新的子类，编译器并不能发现你修改了。<strong>如果你忘记添加一个新的分支，就会选择默认选项，这又可能导致潜在的 bug。</strong></p><p><strong>如何使用密封类 “sealed”</strong></p><pre><code class="kotlin">sealed class Expr { //将基类标记为封闭的    class Num(val value: Int) : Expr()    class Sum(val left: Expr, val right: Expr) : Expr() // 将所有可能的类作为嵌套类列出}fun eval(expr: Expr): Int =    // “when”表达式覆盖了所有的可能情况，所以不再需要 else 分支    when (expr) {        is Expr.Num -&gt; expr.value        is Expr.Sum -&gt; eval(expr.left) + eval(expr.right)    }</code></pre><p><strong>如果你在 when 表达式中处理了所有的 sealed 类的子类，你就不再需要提供默认分支。</strong>注意，sealed 修饰符隐含的这个类是一个 open 类，你不再需要显式地添加 open 修饰符。</p><h2 id="4-2-声明一个带默认构造方法或属性的类"><a href="#4-2-声明一个带默认构造方法或属性的类" class="headerlink" title="4.2 声明一个带默认构造方法或属性的类"></a>4.2 声明一个带默认构造方法或属性的类</h2><p><strong>kotlin中构造方法和java中有那些不同</strong></p><p>与java中一个类可以声明一个或多个构造方法。kotlin也是类似的，只是做出了一些修改：区分了主构造方法（通常是主要而简洁的初始化类的方法，并且在类体外部声明）和从构造方法。</p><h3 id="4-2-1-初始化类：主构造方法和初始化代码块"><a href="#4-2-1-初始化类：主构造方法和初始化代码块" class="headerlink" title="4.2.1 初始化类：主构造方法和初始化代码块"></a>4.2.1 初始化类：主构造方法和初始化代码块</h3><p><strong>什么是主构造方法。</strong></p><pre><code class="kotlin">class User(val nickname:String)</code></pre><p>这段被括号围起来的代码块就叫<strong>做主构造方法</strong>。它有两个目的：表明构造方法的<strong>参数</strong>，以及定义使用这个<strong>参数</strong>的属性。</p><p><strong>明确的主构造方法声明</strong></p><pre><code class="kotlin">class User constructor(_nickname: String) {   // 带一个参数的主构造方法    val nickname: String    init {  // 初始化代码块        nickname = _nickname    }}</code></pre><p>现在来看看完成同样功能的代码具体是什么样子。</p><blockquote><p>两个关键词 <strong>construtor</strong> 和 <strong>init</strong>。 constructor 关键词用来开始一个<strong>构造方法</strong>或者<strong>从构造方法</strong>的声明。init 关键词用来引入初始化代码块。这种代码块包含了类在创建时执行的代码，并且会和主构造方法一起使用。<strong>因为主构造方法有语法限制，不能包含初始化代码，这就是需要初始化代码块（init）的原因。</strong>同时可以创建多个初始化代码块。</p></blockquote><p><strong>用参数来初始化属性</strong></p><pre><code class="kotlin">class User(_nickname: String) { // 带一个参数的构造方法    val nickname: String = _nickname    // 用参数来初始化属性}</code></pre><blockquote><p>在例子中，不需要把初始化代码放在初始化代码块中，因为它可以与nickname属性声明结合。如果主构造方法没有注解或可见性修饰符，同样可以去除 constructor 关键词。</p></blockquote><p><strong>用最简洁的方法再次初始化类</strong></p><pre><code class="kotlin">class User(val nickname:String)    // “val” 意味相对应的属性会用构造方法的参数来初始化。</code></pre><p>前几个案例用 val 关键词声明了属性。如果属性用相对应的构造方法参数来初始化，<strong>代码可以通过把 val 关键词加载参数前的方法来简化它</strong>。可以用来代替类中的属性定义了。</p><p><strong>为构造方法提供默认值</strong></p><pre><code class="kotlin">class User(val nickname: String, val isSubscribed: Boolean = true) // 为构造方法提供一个默认值    </code></pre><p>可以像函数参数一样为构造方法声明默认值。</p><p><strong>如何让一个类不被其他代码实例化</strong></p><p>如果想要你的类不被其他代码实例化，必须把构造方法标记为 private。</p><pre><code class="kotlin">class Secretive private constructor()   // 这个类有 private 构造方法</code></pre><h3 id="4-2-2-构造方法：用不同的方法来初始化方法"><a href="#4-2-2-构造方法：用不同的方法来初始化方法" class="headerlink" title="4.2.2 构造方法：用不同的方法来初始化方法"></a>4.2.2 构造方法：用不同的方法来初始化方法</h3><p><strong>为什么要使用多种方法初始化父类</strong></p><p>最常见的一种就是当你需要扩展一个框架类来提供多个构造方法，以便于通过不同的方法来初始化类的时候。</p><p><strong>父类使用从构造方法</strong></p><pre><code class="kotlin">open class View {    constructor(ctx: Context) { // 从构造方法        //some code    }    constructor(ctx: Context, attr: AttributeSet) { // 从构造方法        //some code    }}</code></pre><p><strong>扩展父类</strong></p><pre><code class="kotlin">class MyButton : View {    constructor(ctx: Context) : super(ctx) {        // 调用父类构造方法    }    constructor(ctx: Context, attr: AttributeSet) : super(ctx, attr) {    }}</code></pre><p><strong>调用父类的另一个构造方法</strong></p><pre><code class="kotlin">class MyButton : View {    constructor(ctx: Context) : this(ctx, My_SYTLE) {        // 委托给这个类的另一个构造方法    }    constructor(ctx: Context, attr: AttributeSet) : super(ctx, attr) {    }}</code></pre><p>从<strong>构造方法</strong>中调用你自己类的另一个<strong>构造方法</strong>。</p><p>可以修改 MyButton类 <strong>使得一个构造方法委托给同一个类的另一个构造方法</strong>，为参数传入默认值，图下👇。第二个方法继续调用super()。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200906113216.png" alt=""></p><blockquote><p>注意 如果主构造函数中存在参数那么次构造函数中使用需要继承它。</p><pre><code class="kotlin">class User(name:String){    constructor(name:String,age:Int):this(name)    //name需要继承}</code></pre></blockquote><h3 id="4-2-3-实现在接口中声明的属性"><a href="#4-2-3-实现在接口中声明的属性" class="headerlink" title="4.2.3 实现在接口中声明的属性"></a>4.2.3 实现在接口中声明的属性</h3><p><strong>在接口中声明一个属性</strong></p><pre><code class="kotlin">interface User {    val nickname: String}</code></pre><p>接口可以包含抽象属性声明。</p><p>这意味这<strong>实现User接口的类需要</strong>提供一个取得nickname值的方式。</p><p><strong>实现接口中的属性 三种</strong></p><p>第一种</p><pre><code class="kotlin">// 主构造方法属性class PrivateUser(override val nickname: String) : User {}</code></pre><p>对于 PrivateUser 来说，<strong>你是用了间接的语法直接在主构造方法中声明了一个属性</strong>。这个属性实现了来自于User的抽象属性，所以你将其标记为 override。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908100413.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908095819.png" alt=""></p><p>运行结果</p><p>第二种</p><pre><code class="kotlin">class SubscribingUser(val email: String) : User {    override val nickname: String get() = email.substringBefore(&#39;@&#39;)  // 自定义getter}</code></pre><p>对于 SubscribeingUser 来说，nikename属性通过一个自定义 getter 实现。<strong>这个属性没有一个支持字段来存储它的值，它只有一个 getter 在每次调用时从 email 中得到昵称。</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908100342.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908100257.png" alt=""></p><p>运行结果</p><p>第三种</p><pre><code class="kotlin">class FacebookUser(val accoundId: Int) : User {    override val nickname = getFacebookName(accoundId)  // 属性初始化    fun getFacebookName(text: String): String {        return text    }}</code></pre><p>nickname在SubscribingUser和FackbookUser中的不同实现。即使它们看起来很相似，第一个属性有一个自定义getter在每次访问时计算 subscringBefore，然后 FackbookUser中的属性有一个<strong>支持字段来存储在类初始化时计算得到数据</strong>。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908104646.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908111027.png" alt=""></p><p>运行结果</p><h3 id="4-2-4-通过-getter或setter访问支持字段"><a href="#4-2-4-通过-getter或setter访问支持字段" class="headerlink" title="4.2.4 通过 getter或setter访问支持字段"></a>4.2.4 通过 getter或setter访问支持字段</h3><p>关于两种属性的例子：存储值的属性和具有自定义访问器在每次访问时的属性。<strong>现在让我们来看看怎么结合这两种来实现一个既可以存储值又可以被值访问和修改时提供额外逻辑的属性。</strong>要支持这种情况，需要能够从属性的访问器中访问它的支持字段。</p><p>假设在任何适合对存储的属性中的数据进行修改时输出日志，你声明了一个可变属性并且在每次 setter 访问时执行额外的代码。</p><pre><code class="kotlin">/*    在 setter 中访问支持字段    */class User(val name:String) {    var address: String = &quot;unspecified&quot;        set(value: String){            println(&quot;&quot;&quot;                Address was changed for $name:&quot;$field&quot; -&gt; &quot;$value&quot;.&quot;&quot;&quot;.trimIndent())    //读取支持字段的值                field = value    // 更新支持字段的值        }}</code></pre><pre><code class="kotlin">&gt;&gt;&gt; val user = User(&quot;Alice&quot;)&gt;&gt;&gt; user.address = &quot;Elasenheimerstrasse 47, 80687 Muenchen&quot;Address was changed for Alice:&quot;unspecified&quot; -&gt; &quot;Elsenheimerstrasse 47, 80687 Muenchen&quot;</code></pre><blockquote><p>可以像平常一样通过使用 user.address = “new value” 来修改一个属性的值，这其实在底层调用了setter。在这个例子中，setter 被重新定义了，所以额外的输出日志的代码被执行了（简单起见，这里直接将其打印出来）。</p><p>在 setter 的函数体中，使用了特殊的标识符 field来访问支持字段的值。在 getter 中，只能读取值：而在 setter 中，既能读取它也能修改它。</p></blockquote><h2 id="4-3-编译器生成的方法-数据类和委托"><a href="#4-3-编译器生成的方法-数据类和委托" class="headerlink" title="4.3 编译器生成的方法:数据类和委托"></a>4.3 编译器生成的方法:数据类和委托</h2><h3 id="4-3-2-数据类-自动生成通用方法的实现"><a href="#4-3-2-数据类-自动生成通用方法的实现" class="headerlink" title="4.3.2 数据类:自动生成通用方法的实现."></a>4.3.2 数据类:自动生成通用方法的实现.</h3><p>实现一个数据类需要重写方法:toString、equals和hashcode。</p><p><strong>数据类</strong></p><pre><code class="kotlin">data class Client(val name:String,val postalCode:Int)</code></pre><p>这是一个数据类,重写了所有标准的Java方法:</p><ul><li>equals 用来比较实例</li><li>hashCode用来作为例如HashMap这种基于哈希容器的键</li><li>toString用来为类生成按声明顺序排列的所有字段的字符串表达形式</li><li>copy函数，可以用这个函数复制并修改部分属性。</li></ul><blockquote><p><strong>创建数据类</strong></p><p>并且使用copy函数复制修改</p><pre><code class="kotlin">fun main() {    val li=Student(&quot;小李&quot;,15)    val li18=li.copy(age = 18)    println(li)    println(li18)}data class Student(val name:String,val age:Int)</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220426202102.png" alt=""></p></blockquote><h2 id="4-4-“object”-关键字：-将声明一个类与创建一个实例结合起来"><a href="#4-4-“object”-关键字：-将声明一个类与创建一个实例结合起来" class="headerlink" title="4.4 “object” 关键字： 将声明一个类与创建一个实例结合起来"></a>4.4 “object” 关键字： 将声明一个类与创建一个实例结合起来</h2><p>这个关键词定义一个类并同时创建一个实例（换句话说就是一个对象）。</p><ul><li><strong>对象声明</strong>是定义一个单例的一种方式。</li><li><strong>伴生对象</strong>可以持有<strong>工场方法</strong>和其他与这个类的相关，但是在调用时并不依赖类实例方法。<strong>它们的成员可以通过类名来访问</strong>。</li><li><strong>对象表达式用来代替Java的匿名内部类</strong></li></ul><blockquote><p><strong>对象表达式</strong></p><p>假如一个方法需要一个类,那么Kotlin将对象表达式传递给它就可以了</p><pre><code class="kotlin">方法接收一个类(object:匿名对象的类型{    override fun 匿名类的方法(){        println(&quot;通过对象表达式调用了匿名类&quot;)    }})</code></pre><p>这个方法参数需要匿名类通过对象表达式重写了类的方法。</p></blockquote><h3 id="4-4-1-对象声明：创建单例易如反掌"><a href="#4-4-1-对象声明：创建单例易如反掌" class="headerlink" title="4.4.1 对象声明：创建单例易如反掌"></a>4.4.1 对象声明：创建单例易如反掌</h3><p><strong>为什么使用对象声明？</strong></p><p>在面向对象系统中一个相当常见的情形就是只需要一个实例的类。例如，可以使用一个对象声明来表示一个组织的工资单。</p><p><strong>在Java中是如何实现单例模式？</strong></p><p>定义一个使用private构造方法并且用静态字段来持有这个类仅有的实例。</p><p><strong>什么是对象声明</strong></p><p>Kotlin通过使用对象声明功能为这一切提供了最高级的语言支持。<strong>对象声明将类声明与该类的单一实例声明结合到了一起。</strong></p><p><strong>对象声明使用</strong></p><pre><code>object Payroll {    val allEmployees = arrayListOf&lt;Person&gt;()    fun calculateSalary() {        for (person in allEmployees){        }    }}</code></pre><p>对象声明通过 object 关键词引入。与类一样，一个对象声明也可以包含属性、方法、初始化语句块等的声明，唯一不允许的是构造方法。对象声明在定义时就创建了构造对象，不需要在代码的其他地方调用构造方法。对象声明同样可以继承类和接口。</p><h1 id="5-Lambda-编程"><a href="#5-Lambda-编程" class="headerlink" title="5 Lambda 编程"></a>5 Lambda 编程</h1><h2 id="5-1-Lambda表达式和成员引用"><a href="#5-1-Lambda表达式和成员引用" class="headerlink" title="5.1 Lambda表达式和成员引用"></a>5.1 Lambda表达式和成员引用</h2><h3 id="5-1-1-Lambda-简介：作为函数参数的代码块"><a href="#5-1-1-Lambda-简介：作为函数参数的代码块" class="headerlink" title="5.1.1 Lambda 简介：作为函数参数的代码块"></a>5.1.1 Lambda 简介：作为函数参数的代码块</h3><p>在代码中存储和传递一小段行为是常有的任务。例如，“当一个事件发生的时候运行这个事件处理器”又或是“把这个操作应用到这个数据结构的所有元素上”。在老版本的Java中可以使用匿名函数。</p><blockquote><p>使用函数式编程 提供了另外一种解决问题的方法：</p><p>把函数当作值来对待。可以直接传递函数，而不需要先声明一个类再传递一个类的实例。使用 lambda 表达式后代码会变的更加简洁。</p></blockquote><p>例子。假设你要定义一个点击按钮的行为，添加一个处理点击的监听器。监听器实现了想对应的接口 OnClickListener 和它的一个方法 onClick。</p><pre><code class="java">/*    用匿名内部类实现监听器    */button.setOnClickListener(new OnClickListener(){    @Override    public void onClick(View view){        /*点击之后执行的动作*/    }})</code></pre><p>使用匿名内部类的写法，更加冗余。接下来使用 lambda 写法</p><pre><code class="kotlin">/*    用 lambda 实现监听器    */button.setOnClickListener{    /*    点击后执行操作    */    }</code></pre><h3 id="5-1-2-Lamda-和-集合"><a href="#5-1-2-Lamda-和-集合" class="headerlink" title="5.1.2 Lamda 和 集合"></a>5.1.2 Lamda 和 集合</h3><p>良好的编程风格原则之一是避免代码的重复。我们对集合执行大部分任务都遵循这几个通用的模式，所以要实现这几个模式的代码应该放在一个库里。在没有 lambda 的帮助，很难为集合提供一个好用方便的库。</p><p>看个例子。</p><p>创建一个 Person 类，它包含了这个了的名字和年龄信息。</p><pre><code class="kotlin">data class Person(val name:String, val age :Int)</code></pre><p>假设你现在要在列表中找到年龄最大的那个人。</p><pre><code class="kotlin">/*    手动在集合中搜索    */fun findTheOldest(people:List&lt;Person&gt;){    var maxAge = 0    //存储最大年龄    var theOldest:Person ?= null //存储年龄最大的人    for (person in people){        if(person.age &gt; maxAge){    //如果下一个比现在年龄最大的人还要大，改变最大值            maxAge = person.age            theOldest = person        }    }    println(theOldest)}&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31))&gt;&gt;&gt; findTheOldest(people)Person(name = Bob,age = 31)</code></pre><pre><code class="kotlin">/*    用 lambda 在集合中搜索    */&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31))&gt;&gt;&gt; println(people.maxBy{it.age})    // 比较年龄最大的元素Person(name = Bob, age = 31)</code></pre><p>maxBy函数可以在任何集合上调用，且只需要一个参数：函数指定比较哪个值来找到最大元素。</p><p>花括号中的代码 <strong>{it.age}</strong>就是实现了这个逻辑的lmabda。 它接收一个集合中的元素作为实参(作用 it 引用它)并且返回用来比较的值。在这个例子中，集合元素是Person对象，用来比较的是存储在其age属性中的年龄。</p><pre><code class="kotlin">/*    用成员引用    */people.maxBy(Person:age)</code></pre><h3 id="5-1-3-Lambda-表达式的语法"><a href="#5-1-3-Lambda-表达式的语法" class="headerlink" title="5.1.3 Lambda 表达式的语法"></a>5.1.3 Lambda 表达式的语法</h3><p>概述 lambda</p><blockquote><p>一个 lambda 把一小段行为进行编码，你能把它当作值到处传递。它可以被独立地声明并储存一个变量。</p></blockquote><pre><code class="kotlin">/*    lambda 表达式的语法    */{x:Int,y:Int -&gt; x+y}/*    参数 -&gt; 函数体    */</code></pre><blockquote><p>Kotlin 的lambda 表达式始终用花括号包围。实参并没有用括号括起来。箭头把实参列表和lambda 函数体隔开了。</p></blockquote><p>可以把 lambda表达式存储在一个变量中，把这个变量当作普通函数对待（即通过相应实参调用它）</p><pre><code class="kotlin">&gt;&gt;&gt; val sum = {x:Int,y:int -&gt; x+y}&gt;&gt;&gt; println(sum(1,2))    // 调用保存在变量中的lambda3</code></pre><blockquote><p>Kotlin 中的语法约定，如果 lambda 表达式是函数调用的最后一个实参，它可以放到括号外边。在这个例子中lambda是唯一的实参，所以可以放到括号外边</p><pre><code class="kotlin">people.maxBy(){p:Person -&gt; p.age}</code></pre><p>当 lamdba 是函数的唯一实参时，还可以去除调用代码中的空括号。</p><pre><code class="kotlin">people.maxBy{p:Person -&gt; p.age}</code></pre><p>三种语法形式的含义都是一样的，但最后都是易读的。如果lambda是唯一的实参，你当然愿意在写代码的时候省掉这个括号。而当你有多个实参时，既可以把lambda留在括号内来强调它是一个实参，也可以把它放在括号外面，两种选择都是可行的。如果你想传递两个或多个lamdba，不能把超过一个的lamdba放在外面。这时使用常规语法来传递它们通常是更好的选择。</p></blockquote><p>回顾 joinToString 函数 （对元素添加分隔符）。 Kotlin 标准库中也有定义它，标准库中的这个版本的不同之处在于它可以接收一个附加的函数参数。这个函数可以使用 toString函数以外的方法把一个元素转换成字符串。</p><p><strong>打印出人的名字</strong></p><pre><code class="kotlin">/*    把 lambda 作为命名实参传递    */&gt;&gt;&gt;val people = listOf(Person(&quot;Alice&quot;,31),Person(&quot;Bob&quot;,29))&gt;&gt;&gt;val names = people.joinToString(separator = &quot;&quot;,transform = {p:Person -&gt; p.name})&gt;&gt;&gt;println(names)Alices Bob</code></pre><p><strong>用更简单的方法</strong></p><pre><code class="kotlin">/*    把 lambda 放在括号外传递    */people.joinToString(&quot; &quot;){p:Person -&gt; p.name}</code></pre><p><strong>简化语法，移除参数类型</strong></p><pre><code class="kotlin">/*    省略 lambda 参数类型    */people.maxBy{p:Person -&gt; p.age}    // 显式地写出参数类型people.maxBY{p-&gt;p.age}    // 推导出参数类型</code></pre><p>和局部变量一样，如果 lambda 参数的类型可以被推导出来，你就不需要显式地指定它。以这里的 maxBy 为例子，其参数类型始终和集合的元素类型相同。编译器知道你是对一个Person对象的集合调用maxBy函数，所以它能推断出 lambda参数也会是Person类型。<strong>也存在不能推断出的情况，先遵循：先不声明类型，等编译器报错后再指定它。</strong></p><p><strong>最后的简化是使用默认参数名称 it 代替命名参数</strong></p><pre><code class="kotlin">/*    使用默认参数名称    */people.maxBy(it.age)    //&quot;it&quot;是自动生成的参数名称</code></pre><p>仅在参数名称没有显式地指定时这个默认的名称才会生成。</p><p><strong>可以用变量存储 lambda 表达式</strong></p><pre><code class="kotlin">&gt;&gt;&gt; val getAge = {p:Person -&gt; p.age}&gt;&gt;&gt; people.maxBy(getAge)</code></pre><blockquote><p>lambda 并没有被限制在这样小的规模，它可以包含更多的语句。</p></blockquote><pre><code class="kotlin">&gt;&gt;&gt; val sum = {x:Int,y:Int -&gt;    println(&quot;Computing the sum of $x and $y...&quot;)    x + y}&gt;&gt;&gt; println(sum(1,2))Computing the sum of 1 and 2...3</code></pre><h3 id="5-1-4-在作用域中访问变量"><a href="#5-1-4-在作用域中访问变量" class="headerlink" title="5.1.4 在作用域中访问变量"></a>5.1.4 在作用域中访问变量</h3><blockquote><p>在声明一个匿名内部类的时候，能够在这个匿名类内部引用这个函数的参数和局部变量。</p><p>而在使用 lambda 声明的时候，也可以做同样的事情。如果在函数内部使用 lambda 也可以访问这个函数的参数，还有在 lambda 之前定义的局部变量。</p></blockquote><p><strong>forEach 函数</strong></p><p> 用 forEach 函数展示 上述行为。<code>便利字符串操作。</code></p><p>它是最基本集合操作函数之一；它所作的全部事情就是在集合中的每个元素上都调用给定的 lambda。forEach 函数比普通for 函数循环更简洁，除此之外没有其它优势，所以并不急于把所有的循环更改为  lambda。</p><pre><code class="kotlin">/*    在 lambda 中使用函数参数    */fun printMessageWithPrefix(message : Collection&lt;String&gt;,prefix:String){    messages.forEach{    // 接受 lambda 作为实参指定对每个元素操作        println(&quot;$prefix $it&quot;)    // 在 lambda 中访问 “prefix”    }}&gt;&gt;&gt; val errors = listOf(&quot;433 Forbidden&quot;,&quot;404 Not Found&quot;)&gt;&gt;&gt; printMessagesWithPrefix(errors,&quot;Error:&quot;)Error:403 ForbiddenError:404 Not Found</code></pre><blockquote><p>Kotlin 和 Java的一个显著区别就是，在 Kotlin 中不会仅限于访问 final 变量，在 lambda 内部也可以修改变量。</p></blockquote><pre><code class="kotlin">/*    在lambda中改变局部变量    */fun printProblemCounts(responeses:Collection&lt;String&gt;){    var clientErrors = 0    var serverErrors = 0    responeses.forEach{        if(it.startsWith(&quot;4&quot;)){            clientErrors ++        }else if(it.startsWith(&quot;5&quot;)){            serverErrors++        }    }    println(&quot;$clientErrors client error,$serverErrors server errors&quot;)}&gt;&gt;&gt; val responses = listOf(&quot;200 OK&quot;,&quot;418 I&#39;m a teapot&quot;,&quot;500 Internal Server Error&quot;)...&gt;&gt;&gt; printProblemCounts(responses)1 client errors,1 server errors</code></pre><blockquote><p>于 Java 不同，Kotlin 允许在 lambda 内部访问非 final 变量甚至修改它们。从 lambda 内访问外部变量，我们称这个变量被 <strong>lambda捕捉</strong>，如同上述的案例中的 prefix，clientErrors，serverErrors一样。</p></blockquote><p><strong>默认情况下，局部变量的声明期被限制在声明这个变量的函数中。但是如果它被lambda捕捉了，使用这个变量的代码可以被存储并稍后执行。</strong></p><p><strong>如果 lambda 被用作 <em>事件处理器</em> 或者用在其他 <em>异步执行</em> 的情况下，对局部变量的修改只会在 lambda 执行的时候发生。</strong></p><blockquote><p>反面案例</p><pre><code class="kotlin">fun tryToCountButtonClicks(button:Button):Int{    var clicks = 0    button.onClick{clicks++}    return clicks}</code></pre><p>这个函数始终返回0。尽管 onClick 处理器可以修改clicks的值，你并不能观察到值发生了变化，因为onClick处理器是在函数返回之后调用的。<strong>这个函数正确的实现方法需要把点击次数存储在函数外依然可以访问到的地方–例如类的属性，而不是存储在函数的局部变量中。</strong></p></blockquote><h3 id="5-1-5-成员引用"><a href="#5-1-5-成员引用" class="headerlink" title="5.1.5 成员引用"></a>5.1.5 成员引用</h3><p>​    如果把函数转换成一个值，你就可以传递它。</p><pre><code class="kotlin">val getAge = Person::age    //引用 age</code></pre><blockquote><p>这种表达式称为 <strong>成员引用</strong>，它提供了简明语法，来创建一个调用单个方法或者访问单个属性的函数值。 <strong>双冒号把类名称与你要引用的成员（一个方法或者一个属性）名称隔开</strong></p><pre><code class="kotlin">Person::age //类::成员</code></pre></blockquote><p>等价于 </p><pre><code class="kotlin">val getAge = {person:Person -&gt;person.age}</code></pre><blockquote><p>注意，不管你引用的是函数还是属性，都不要在成员引用的名称后面添加括号。</p></blockquote><blockquote><p>成员引用和调用该函数的lambda具有一样的类型，所以可以互换使用：</p><pre><code class="kotlin">people.maxBy(Person::age)</code></pre><p>还可以引用顶层函数</p><pre><code class="kotlin">fun salute() = println(&quot;Salute!&quot;)&gt;&gt;&gt; run(::salute)    // 引用顶层函数Salute!</code></pre><p>这种情况下，你省略了类名称，直接以::开头。成员引用::salute被当作实参传递给库函数run，它会调用想对应的函数。</p><p>如果 lambda 要委托给一个接收多个参数的函数，提供成员引用代替它将会非常方便</p><pre><code class="kotlin">val action = {person:Person,message:String -&gt;    sendEmail(person,massage)    //这个lambda委托sendEmail函数    }val nextAction = :: sendEmail    //用成员引用代替</code></pre><pre><code class="kotlin">/*    用构造方法引用存储或者延期执行创建类实例的动作。 构造方法引用的形式在双冒号后指定类的名称：    */data class Person(val name:String,val age:Int)&gt;&gt;&gt; val createPerson = :：Person    //创建Person实例的动作被保存成了值&gt;&gt;&gt; val p = createPerson(&quot;Alice&quot;,29)&gt;&gt;&gt; println(p)Person(name = Alice,age = 29)</code></pre><p><strong>可以用同样的方法引用扩展函数</strong></p><pre><code class="kotlin">fun Person.isAdult() = age &gt;= 21val predicate = Person::isAdult</code></pre><p>尽管 isAdult 不同类的成员，还是可以通过引用访问它，这个访问的成员没有两样：person.isAdult()。</p></blockquote><p><strong>绑定引用</strong></p><blockquote><p>在 kotlin 1.0 中 ，当接受一个类的方法或者属性引用时，你始终需要提供一个该类的实例来调用这个引用。Kotlin1.1计划支持绑定成员引用，它允许你使用成员引用语法捕捉特定实例对象的方法引用。</p><pre><code class="kotlin">&gt;&gt;&gt; val p = Person(&quot;Dmitry&quot;,34)&gt;&gt;&gt; val personAgeFunction = Person::age&gt;&gt;&gt; println(personsAgeFunction(p))34 &gt;&gt;&gt; val dmitrysAgeFunction = p::age&gt;&gt;&gt; println(dmitryAgeFunction())34</code></pre><p>注意，personsAgeFunction是一个当参数函数（返回给定了的年龄），而dmitryAgeFunction是一个零参数的函数（返回已经指定好的人的年龄）。</p><p>在 Kotlin1.1之前，你需要显式地写出 lambda{p.age},而不是使用绑定成员引用p::age。</p></blockquote><h2 id="5-2-集合的函数式API"><a href="#5-2-集合的函数式API" class="headerlink" title="5.2 集合的函数式API"></a>5.2 集合的函数式API</h2><p>我们先从filter和map这类函数及它们背后的概念开始。</p><h3 id="5-2-1-基础：filter和map"><a href="#5-2-1-基础：filter和map" class="headerlink" title="5.2.1 基础：filter和map"></a>5.2.1 基础：filter和map</h3><p>filter和map函数形成了集合操作的基础，很多集合操作都是借助它们来表达的。</p><p>通过两种样子的例子帮助你来理解，一个纯数字形式一个使用<strong>自定义</strong>的Person类来实现。</p><pre><code class="kotlin">data class Person(val name:String,val age:Int)</code></pre><p><strong>filter函数</strong></p><blockquote><p>遍历集合并选出引用给定 lambda 条件 后会返回true的那些元素</p><pre><code class="kotlin">&gt;&gt;&gt; val list = listOf(1,2,3,4)&gt;&gt;&gt; println(list.filter{it%2==0})[2,4]</code></pre></blockquote><p><strong>map函数</strong></p><blockquote><p>对集合中每个元素应用给定的函数并把结果收集到一个新的集合中。</p><p>根据lambda参数作为判断生成新的集合。</p><pre><code class="kotlin">&gt;&gt;&gt; val list = listOf(1,2,3,4)&gt;&gt;&gt; println(list.map{it*it})[1,4,9,16]</code></pre></blockquote><blockquote><p>如果直想打印名字列表，而不是完整信息，可以用map变换列表：</p><pre><code class="kotlin">&gt;&gt;&gt; val people=listOf(Person(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31))&gt;&gt;&gt; println(people.map{it.name})[Alice,Bob]</code></pre><p>使用 <strong>成员引用</strong> 同样可以</p><pre><code class="kotlin">people.map(Person::name)</code></pre></blockquote><blockquote><p>当需要获得分组中最大人的名字时。</p><pre><code class="kotlin"> val maxAge = people.maxBy(Person::age).age people.filter{it.age == maxAge}</code></pre><p><strong>map 应用过滤和变换函数</strong></p><pre><code class="kotlin">&gt;&gt;&gt; val numbers = mapOf(0 to &quot;zero&quot;,1 to &quot;one&quot;)&gt;&gt;&gt; println(numbers.mapValues{it.value.toUppterCase()})    // 对map集合的值进行操作[0=ZERO,1=ONE]</code></pre><p>键和值分别由各自的函数来处理。<strong>filterKeys和mapKeys过滤和变换map的键，而另外的filterValues和mapValues过滤和变换对应的值。</strong></p></blockquote><h3 id="5-2-2-“all”“any”“count”和“find”：对集合引用判断式"><a href="#5-2-2-“all”“any”“count”和“find”：对集合引用判断式" class="headerlink" title="5.2.2 “all”“any”“count”和“find”：对集合引用判断式"></a>5.2.2 “all”“any”“count”和“find”：对集合引用判断式</h3><blockquote><p>这些方法作用</p><p>Kotlin中，它们是通过 all 和 any 函数表达式的（检查集合中的所有元素是否都符合某个条件）。count 函数检查由多少元素满足判断式，而find函数返回第一个符合条件的元素。</p><p>案例：</p><p>检查一个人是否还没有到28岁。</p><pre><code class="kotlin">val canBeInClub27 = {p:Person -&gt; p.age &lt;=27}</code></pre><p>如果是<strong>所有元素都满足判断式条件</strong>的应该使用 all 函数。（）</p><pre><code class="kotlin">&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,27),Person(&quot;Bob&quot;,31))&gt;&gt;&gt; println(people.all(canBeInClub27))false</code></pre><p>如果你<strong>检查集合中至少存在一个匹配的元素</strong>，则使用 any 函数</p><pre><code class="kotlin">&gt;&gt;&gt; println(people.any(canBeInClub27))</code></pre><p>true</p><p>如果<strong>你想知道有多少元素满足判断式</strong>，使用count：</p><pre><code class="kotlin">&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,27),Person(&quot;Bob&quot;,31))&gt;&gt;&gt; println(people.count(canBeInClub27))1</code></pre></blockquote><p><strong>使用正确的函数完成工作：”count” VS. “size”</strong></p><p>count 方法容易被遗忘，然后通过过滤集合之后再取大小来实现它：</p><pre><code class="kotlin">&gt;&gt;&gt; println(people.filter(canBeInClub27).size)1</code></pre><p>再这种情况下，一个集合中间会被创建并用来存储所有满足判断式的元素。</p><p>而另一方面，count 方法只是最终匹配元素的数量，不关心元素本身，所以更高效。</p><blockquote><p><strong>要找到一个满足判断式的元素，使用 find 函数</strong></p><pre><code class="kotlin">&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,27),Person(&quot;Bob&quot;,31))&gt;&gt;&gt; println(people.find(canBeInClub27))Person[name = Alice,age = 27]</code></pre><p>存在多个能够匹配的元素就返回其中第一个元素：或者返回 null，如果没有一个元素能满足判断式。find还有一个同义方法 firstOrNull，可以使用这个方法更加清楚的表达你的意图。</p></blockquote><h3 id="5-2-3-groupBy：把列表转换成分组的map"><a href="#5-2-3-groupBy：把列表转换成分组的map" class="headerlink" title="5.2.3 groupBy：把列表转换成分组的map"></a>5.2.3 groupBy：把列表转换成分组的map</h3><blockquote><p><strong>当你想把人按照年龄分组，相同年龄的人放在一组。</strong></p><p>groupBy: 按照表达式将几个进行分组并返回一个 map 集合</p><pre><code class="kotlin">&gt;&gt;&gt; val people = listOf(Perosn(&quot;Alice&quot;,31),Perosn(&quot;Bob&quot;,29),Person(&quot;Carol&quot;,31))&gt;&gt;&gt; println(people.groupBy{it.age})</code></pre><p>返回结果 map，是元素分组依据的键（这个例子中是age）和元素分组（persons）之间映射</p><pre><code class="kotlin">{29 = [Person(name = Bob,age = 29)],31 = [Person(name = Alice,age = 31),        Person(name = Carol,age = 31)]        }</code></pre><p>每个分组都是存储在一个列表中，<strong>结果的类型就是Map&lt;Int,List<Person>&gt;</strong>。</p><p>可以使用像 mapKeys 和 mapValues 这也的函数对这个map做进一步的修改。</p></blockquote><blockquote><p><strong>使用成员引用把字符串按照首字母分组：</strong></p><pre><code class="kotlin">&gt;&gt;&gt; val list = listOf(&quot;a&quot;,&quot;ab&quot;,b)&gt;&gt;&gt; println(list.groupBy(String::first)){a = [a,ab], b = [b]}</code></pre><p>first并不是String类的成员，而是一个扩展。然而，可以把它当作成员引用访问。</p></blockquote><h3 id="5-2-4-flatMap-和-flatten：处理嵌套集合和元素"><a href="#5-2-4-flatMap-和-flatten：处理嵌套集合和元素" class="headerlink" title="5.2.4 flatMap 和 flatten：处理嵌套集合和元素"></a>5.2.4 flatMap 和 flatten：处理嵌套集合和元素</h3><p><strong>例子</strong></p><blockquote><p>假设你有一堆藏书，使用Book表示：</p><pre><code class="kotlin">class Book(val title:String,val authors:List&lt;String&gt;)</code></pre><p>authors ：保存书的所有作者。</p><p>统计出图书馆中所有作者的set；</p><pre><code class="kotlin">books.flatMap{it.authros}.toSet()    //包含撰写 “books” 集合中书籍的所有作者 set</code></pre><p>flatMap:作用，1.首先根据作为实参给定的函数对集合中的每个元素做转换（或者说映射），然后把多个列表合并（或者说平铺）成一个列表。</p></blockquote><blockquote><p>说明：</p><pre><code class="kotlin">&gt;&gt;&gt; val strings = listOf(&quot;abc&quot;,&quot;def&quot;)&gt;&gt;&gt; pritnln(strings.flatMap{it.toList()})[a,b,c,d,e,f]</code></pre><p>字符串上的toList函数把它转换成字符列表。</p><p>使用 map 函数，你会得到一个字符列表的列表。</p><p>flatMap 函数：执行后面操作，并返回一个包含所有元素（字符）的列表</p><p>回到例子中：</p><pre><code class="kotlin">&gt;&gt;&gt; val books = listOf(Book(&quot;Thursday Next&quot;,listOf(&quot;Jasper Fforde&quot;)),                        Book(&quot;Mort&quot;,listOf(&quot;Terry Pratchett&quot;)),                        Book(&quot;Good Omens&quot;,listOf(&quot;Terry Pratchett&quot;,                                                &quot;Neil Gaiman&quot;)))&gt;&gt;&gt; println(books.flatMap{it.authors}.toSet)                                                [Jasper Fforde,Terry Pratchett,Neil Gaiman]</code></pre><p>book.authors 是存储了多个作者的集合。flatMap 函数把所有书籍的作者合并成变频的列表。</p><p><strong>toSet调用移除了结果集合中的所有重复元素。</strong></p><p>所以 Terry Pratchett 在输出中只出现了一次。</p><p><strong>如果你只需要平铺一个集合，可以使用 flatten 函数：listOfLists.flatten</strong></p></blockquote><h2 id="5-3-惰性集合操作：序列"><a href="#5-3-惰性集合操作：序列" class="headerlink" title="5.3 惰性集合操作：序列"></a>5.3 惰性集合操作：序列</h2><blockquote><p>你看到了关于许多链式调用的例子，例如 map 和 filter。这些函数会及早的创建中间集合，也就是说每一步的中间结果都被存储在一个临时列表。</p><pre><code class="kotlin">people.map(Person::name).filter{it.startsWith(&quot;A&quot;)}</code></pre><p>Kotlin 标准库参考文档说明，filter 和 map 都会返回一个列表。这意味这上面的例子中的链式调用会创建两个列表：一个保存filter函数的结果，另一个保存 map函数的结果。如果源列表只有两个元素，这不是什么问题，但是如果有一百万个元素，（链式）调用就会变得十分低效。</p><p>为了提高效率可以将操作变换成序列，而不是使用集合：</p><pre><code class="kotlin">people.asSequence()    //把初始集合转换成序列      .map(Person::name)          .filter{it.startsWith(&quot;A&quot;)}    //系列支持和集合一样的API      .toList()    // 把结果序列转换会列表</code></pre><p>这个例子没有创建任何一个存储元素的，所以元素数量巨大的情况下性能显著提升。</p><p>Kotlin 惰性集合操作的入口就是 Sequence 接口。这个接口表示可以诸葛列举的元素序列。Sequence 只提供了一个方法，iterator，用来从序列中获取值</p></blockquote><p>优势</p><blockquote><p>Sequence接口的强大之处在于其操作的实现方式。序列中的元素求值是惰性的，因此可以使用序列更高效地对集合元素执行链式操作，而不需要创建额外的集合来保存过程中产生的总结结果。</p></blockquote><p>为什么需要把序列转换回集合？把序列代替集合不是更方便吗？特别是它的这些优点。</p><blockquote><p>大多数是这样的。如果你需要迭代序列中的元素，可以直接使用。而要使用其他API方法，例如下标访问元素，那么你需要将序列转换成列表。</p></blockquote><blockquote><p>通常，对一个大型集合执行链式操作时要使用序列。在后面的章节中继续讨论Kotlin常规集合的及早操作高效的原因，尽管它会创建中间集合。当集合拥有数量巨大的元素，元素为中间结果进行重新分配开销巨大，所以惰性求值是更好的选择。</p></blockquote><h3 id="5-3-1-执行序列操作：中间和末端操作"><a href="#5-3-1-执行序列操作：中间和末端操作" class="headerlink" title="5.3.1 执行序列操作：中间和末端操作"></a>5.3.1 执行序列操作：中间和末端操作</h3><p><strong>序列操作共分两种</strong>：</p><blockquote><p>中间和末端。</p><p>一次中间操作返回的是另一个序列，这个序列知道如何变换原始序列中的元素。</p><p>而末端操作返回的是一个结果，这个结果可能是集合、元素、数字，或者其他的初始集合的变换序列中获得的任意对象。</p><pre><code class="kotlin">sequence.map{...}.filter{...}//中间操作        .toList()//末端操作</code></pre></blockquote><p><strong>没有末端操作的例子：</strong></p><pre><code class="kotlin">&gt;&gt;&gt; listOf(1,2,3,4).asSequence()    //序列化...        .map{print(&quot;map($it)&quot;);it*it}    // 转换成map集合并操作它...        .filter{ print(&quot;filter($it)&quot;);it%2==0}    //调用对象，然后根据条件过滤</code></pre><blockquote><p>执行这段代码并不会在控制台上输出任何内容。这意味着map和filter变换被延期了，它们只有在获取结果的是否才会被应用(即末端操作被调用的时候)：</p><pre><code class="kotlin">&gt;&gt;&gt;listOf(1,2,3,4).asSequence()...                .map{print(&quot;map($it);it*it&quot;)}...                .filter{print(filter(&quot;$it&quot;);it%2 == 0)}...                .toList()map(1) filter(1) map(2) filter(4) map(3) filter(9) map(4) filter(16)</code></pre><p>末端操作触发执行了所有的延期计算。</p></blockquote><p><strong>计算执行的顺序。</strong></p><blockquote><p>一个笨办法实在每个元素上调用map函数，然后再结果序列的每个元素上再调用filter函数。</p><p>map和filter对集合就是这样做的，而序列不一样。对序列来说，所有操作是按序列应用再每个元素上：处理完第一个元素（先映射再过滤），然后完成第二个元素的处理，以此类推。</p><p><strong>这种方法意味着部分元素根本不会发生任何转换</strong></p><p>如果在轮到它们之前就已经取得了结果。我们来看一个map和find的例子。首先一个数字映射成它的平方，然后找到第一个比数字3大的条目：</p><pre><code class="kotlin">&gt;&gt;&gt; println(listOf(1,2,3,4).asSequence()                           .map{it*it}                           .find{it &gt; 3}                           )4</code></pre><p>如果同样的操作被应用在集合而不是序列上时，那么 map 的结果首先被求出来。即变换初始集合中的所有元素。第二步，中间集合中满足判断式的一个元素会被找出来。而对于序列来说，惰性方法意味这你可以跳过处理部分元素。图 5.8 阐明了 这段代码两种求值方法之间的区别，一种是及早求值（使用集合），一种是惰性求值（使用序列）。</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210402111938.png" alt="及早求值在整个集合上执行每个操作；惰性求值则逐个处理元素"></p><p><strong>在集合上执行操作的顺序也会影响性能。</strong></p><p>假设你有一个人的集合，想要打印集合中那些长度小于某个限制的人名。</p><p>这时你需要做两件事：把每个人映射成他们的名字，然后过滤掉其中那些不够短的名字。</p><p><strong>这种情况可以用任何顺序应用map和filter操作。两种顺序得到的结果是一样的如下</strong></p><pre><code class="kotlin">&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31),Person(&quot;Charles&quot;,31),Person(&quot;Dan&quot;,21))&gt;&gt;&gt; println(people.asSequence().map(Person::name).filter{it.length &lt; 4}.toList()) // 先 “map” 后 “filter”[Bob,Dan]&gt;&gt;&gt; println(people.asSequence().filter{it.name.length &lt; 4}...            .map(Person::name).tolist())    // 先“filter”后 map[Bob,Dan]</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210402103856.png" alt="先应用filter有助于减少变换的总次数"></p><blockquote><p>如果 filter 在强，不适合的元素会被尽早地过滤掉且不会发生变换。</p></blockquote><h3 id="5-3-2-创建序列"><a href="#5-3-2-创建序列" class="headerlink" title="5.3.2 创建序列"></a>5.3.2 创建序列</h3><blockquote><p>asSequence()：函数用来在集合中创建序列</p><p>generateSequence()函数：给定序列中的前一个元素，这个函数会计算出下一个元素。</p><p><strong>案例 使用 generateSequence 计算 100 以内所有的自然数之和。</strong></p><pre><code>&gt;&gt;&gt; val naturalNumbers = generateSequence(0) {it +1}&gt;&gt;&gt; val numbersTo100 = naturalNumbers.takeWhile{it &lt;= 100}&gt;&gt;&gt; println(numbersTo100.sum())    //当获得结果 “sum” 时，所有被推迟的操作都被执行5050</code></pre><p>例子中 naturalNumbers 和 numbersTo100都有延期操作序列。这些序列中的实际数字知道你调用末端操作的时候才会求值。（sum）</p></blockquote><p><strong>创建父目录的序列</strong></p><blockquote><p>如果元素的父元素和它的类型相同（比如人类或者java文件），你可能会对它的所有祖先组成的序列的特质感兴趣。下列这个例子可以查询是否放在隐藏目录中，通过创建一个其父目录的序列并检查每个目录的属性来实现。</p><pre><code class="kotlin">/*    创建并使用父目录的序列    */fun File.isInsideHiddenDirectory() =         generateSequence(this){it.parentFile}.any{it.isHidden}    // 查询文件是否放在隐藏目录中。&gt;&gt;&gt; val file = File(&quot;/Users/svtk/.HiddenDir/a.txt&quot;)        &gt;&gt;&gt; println(file.IsInsideHiddenDirectory())true</code></pre><p>你生成了一个序列，通过提供第一个元素和获取每个后续元素的方式来实现。如果把any换成find，你还可以得到你想要的那个目录（对象）。注意，使用序列允许你找到需要的目录之后立即停止遍历父目录。</p></blockquote><h2 id="5-4-使用-Java-函数式接口"><a href="#5-4-使用-Java-函数式接口" class="headerlink" title="5.4  使用 Java 函数式接口"></a>5.4  使用 Java 函数式接口</h2><p>Kotlin 的 lambda 可以和 Java API 互操作。</p><p>在本章节开头处，有看过一个把 lambda 传递给 Java 方法的例子：</p><pre><code class="kotlin">button.setOnClickListener{/*    点击之后的动作     */}    //复习 作为方法的最后一个参数可以省略()。把lambda作为实参传递。</code></pre><p>Botton 通过接收类型为OnClickListener的实参的setOnClickListener方法给按钮设置一个新的监听器：</p><pre><code class="java">/*    Java    */public class Button{    public void setOnClickListener(OnClickListener l){...}}</code></pre><p>OnClickListener 接口声明了一个方法，onClick：</p><blockquote><p><em>接口可以被实现，但不能被实例化。</em></p></blockquote><pre><code class="java">public interface OnClickListener{    void onClick(View v)}</code></pre><p>在Java 8 之前你不得不创建一个匿名类的实例来作为实参传递给 setOnClickListener方法：</p><pre><code class="java">button.setOnClickListener(new OnClickListener(){    @Override    public void onClick(View v){        ...    }})</code></pre><p>在 kotlin 中 可以传递一个 lambda，代替这个实例：</p><pre><code class="kotlin">button.setOnClickListener{view -&gt; ...}</code></pre><p>lambda 用来实现 OnClickListener，它有一个类型为View的参数，和onClick一样。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210402121803.png" alt="Lmabda的参数和方法参数对应"></p><blockquote><p>这个方法可以工作的原因是OnClickListener接口只有一个方法。<strong>这种方法被称为函数式接口，或者 SAM 接口，SAM 代表单抽象方法。Java API随处可见像Runnable和Callable这样的函数式接口，以及支持它的方法。</strong>Kotlin允许你在调用接口函数式接口作为参数的方法时使用lambda，来保证你的Kotlin代码即整洁又符合习惯。</p></blockquote><p>​             </p><h3 id="5-4-1-把lambda-当作参数传递给Java方法"><a href="#5-4-1-把lambda-当作参数传递给Java方法" class="headerlink" title="5.4.1 把lambda 当作参数传递给Java方法"></a>5.4.1 把lambda 当作参数传递给Java方法</h3><p>可以把lambda传递给任何期望函数式接口的方法。</p><blockquote><p>例如，如下的方法 Runable类型的参数：</p><pre><code class="Java">/*    Java    */void postponeComputation(int delay,Runnable computation);</code></pre><p>在 Kotlin 中，可以调用它并把一个lambda作为实参传给它。编译器会<strong>自动</strong>把它转换成一个Runnable的实例：</p><p>postponeComputation(1000){ println(42) }</p><p>当我们说“一个Runnnable的实例”时，指的是“一个实现了Runnable接口的匿名类的实例”。编译器会帮你创建它，并使用lambda作为单抽象方法–这个例子中式run方法–的方法体。</p><p>如下：显式的创建一个Runnable的匿名对象也能达到同样的效果：</p><pre><code class="kotlin">postponeComputation(1000,object:Runnable{    //把对象表达式作为函数式接口的实现传递。    override fun run(){        println(42)    }})</code></pre><p>但是这里有点不一样。当你显式地声明对象时，每次调用都会创建一个新的实例。使用lambda的情况不同：如果lambda没有访问任何来自定义它的函数变量，相应的匿名类实例可以在多次调用之间重（chóng）用：</p><pre><code class="kotlin">postponeComputation(1000){println(42)}    //整个程序只会创建一个Runnable的实例</code></pre><p>想要完全等价的实现应该是下面这段代码中的显式object声明，它把Runnable实例存储在一个变量中，并且每次调用的时候都使用这个变量：</p><pre><code class="kotlin">val runnable = Runnable{println(42)}    //编译成全局变量：程序中仅此一个实例fun handleComputation(){    postponeComputation(1000,runnable)    //每次postponeComputation调用时用的是一个对象}</code></pre><p>如果lambda在包围它的作用域中捕捉到了变量，那么每次调用就不再可能重用同一个实例了。</p><p>这时，每次调用编译器都要创建一个新对象，其中存储着被捕捉的变量的值。</p><p>如下：每次调用都会使用一个新的Runnable实例，把id值存储在它的字段中：</p><pre><code class="kotlin">fun handleComputation(id:String){    //lambda会捕捉“id”这个变量    postponeComputation(1000){println(id)}    //每次handleComputation调用都创建一个Runnable的新实例。}</code></pre></blockquote><p>Lmabda的实现细节</p><blockquote><p>从 Kotlin1.0起，每次lambda表达式都会被编译成一个匿名类，除非它是内联lambda。（内联函数不会创建匿名类）。在后续版本支持生成java8字节码后，编译器就可以避免为每一个lambda表达式都生成一个独立的.class文件。如果lambda捕捉了变量，每个被捕捉的变量会在匿名类中有对应的字段，而且每次（对lambda）的调用都会创建一个这个匿名类的新实例。</p><p><em>否则，一个单例就会被创建。类的名称由lambda声明所在的函数名字称加上后缀衍生出来：这个例子中就是 HandleComputation$1。如果你反编译之前lambda表达式的代码，就会看到：</em> </p><pre><code class="kotlin">class HandleComputation$1(val id:String):Runnable{    override fun run(){        println(id)    }}fun handleComputation(id:String){    postponeComputation(1000,HandleComputation$1(id))    //底层创建一个特殊的实例，而不是lambda}</code></pre><p>编译器给每个被捕捉的变量生成了一个字段和一个构造方法参数。</p></blockquote><p><strong>把lambda传给标记成 inline 的Kotlin函数，是不会创建任何匿名类的。</strong></p><h3 id="5-4-2-SAM构造方法：显式地把lambda转换成函数式接口"><a href="#5-4-2-SAM构造方法：显式地把lambda转换成函数式接口" class="headerlink" title="5.4.2 SAM构造方法：显式地把lambda转换成函数式接口"></a>5.4.2 SAM构造方法：显式地把lambda转换成函数式接口</h3><blockquote><p>SAM<strong>构造方法</strong>是<strong>编译器生成的函数</strong>。用来让你执行从lambda到函数式接口实例的显式转换。</p><p>可以用在编译器不会自动应用转换的上下文中使用它。</p><p><strong>例如：如果有一个方法返回一个函数式接口（只有一个抽象方法的实例）的实例，不能直接返回一个lambda，要用SAM构造方法把它包装起来。</strong></p><p><strong>如下例子：</strong></p><pre><code class="kotlin">/*    使用SAM构造方法来返回值    */fun createAllDoneRunnable():Runnable{    return Runnable {println(&quot;All done!&quot;)}}&gt;&gt;&gt; createAllDoneRunnable().run()All done!</code></pre><p><strong>SAM（函数式接口）构造返回的名称和底层函数式接口的名称一样。</strong>SAM构造方法只接收一个参数— 一个被用作函数式接口单抽象方法的lambda – 并返回实现了这个接口类的一个实例。</p></blockquote><blockquote><p>除开返回值外，SAM构造方法还可以用在需要<strong>把从lambda生成的函数式接口实例存储在一个变量中的情况。**</strong>假设你要在多个按钮上重用同一个监听器**，就像下面的代码清单一样（在Android应用中，这段代码可以作为Activity.onCreate方法的一部分）</p><pre><code class="kotlin">/*    使用SAM构造方法来重用listener实例    */val listener =OnClickListener{    view -&gt;    val text = when (view.id){        R.id.button1 -&gt; &quot;First button&quot;        R.id.button2 -&gt; &quot;Second button&quot;        else -&gt; &quot;Unknown button&quot;    }    toast(text)}button1.setOnClickListener(listener)button2.setOnClickListener(listener)</code></pre><p>listener 会检查那个按钮是点击的事件源并作出对应的行为。可以使用实现了OnClickListener的对象声明来定义监听器，但是SAM构造方法提供了更简洁的方法。</p></blockquote><blockquote><p><strong>Lambda 和 添加/移除监听器</strong></p><p>lambda 内部类有匿名对象那样的this：没有办法应用lambda转换成的匿名类实例。<strong>从编译器的角度来看，lambda是一个代码块，而不是一个对象，而且也不能当作一个对象来引用</strong>。<strong>Lambda中的this引用指向的是包围它的类。</strong></p><ul><li><input disabled="" type="checkbox"> 如果你的事件监听器在处理事件时需要取消它自己，不能使用lambda这样做。<strong>这种情况使用实现了接口的匿名对象</strong>。<strong>在匿名对象内，this关键词指向该对象实例，可以把它传递给移除监听器的API</strong></li></ul></blockquote><p>尽管方法调用中的SAM转换一般都会自动发生，<strong>但是当把lambda作为参数传给一个重载方法</strong>，<strong>也有编译器不能选择正确的重载情况</strong>。这时显式的SAM构造方法时解决错误的好方法。</p><h2 id="5-5-带接收器的lambda：”with“-与-”apply“"><a href="#5-5-带接收器的lambda：”with“-与-”apply“" class="headerlink" title="5.5 带接收器的lambda：”with“ 与 ”apply“"></a>5.5 带接收器的lambda：”with“ 与 ”apply“</h2><p><strong>带接收者的lambda：</strong></p><p>此节将办理逐步熟悉Kotlin的lambda的独特功能：<strong>在lambda函数体类可以调用一个不同对象的方法，而却无需借助任何限定符</strong>；此方法在java中是不存在的。这样的lambda叫做带接收者的lambda</p><p><strong>什么是带接收者的 lambda？</strong></p><blockquote><p>Kotlin 中独特的 lambda 功能：在lambda函数体内可以调用一个不同的对象方法，而且无需借助任何额外的限定符。</p></blockquote><p><strong>接收者：</strong>调用者</p><h3 id="5-5-1-“with”-函数"><a href="#5-5-1-“with”-函数" class="headerlink" title="5.5.1 “with” 函数"></a>5.5.1 “with” 函数</h3><p>从 with 函数开始它用到了带接收者lambda。</p><p>with的库函数：</p><blockquote><p>它对同一个对象执行多次操作，而不需要反复把对象的名称写出来。</p></blockquote><p><strong>构建字母表</strong></p><pre><code class="kotlin">fun alphabet(): String {    val result = StringBuilder()    for (letter in &#39;A&#39;..&#39;Z&#39;) {        result.append(letter)    }    result.append(&quot;\n Now I know the alphbet!&quot;)    return result.toString()}</code></pre><pre><code class="kotlin">fun main() {    println(alphabet())}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201022214803.png" alt=""></p><p><strong>使用场景（为什么要用”with“）</strong></p><p>案例中多次调用到 “<strong>result</strong>“实例。使用”<strong>with</strong>“减少对实例的调用。</p><p><strong>如何使用 ”with“？</strong></p><pre><code class="kotlin">fun alphabet(): String {    val result = StringBuilder()    return with(result) {// 指定接收者的值        for (letter in &#39;A&#39;..&#39;Z&#39;) {            this.append(letter) // 显式的使用‘this’来调用接收者值的方法（result.appned()方法）        }        append(&quot;\n Now I know the alphabet!&quot;)   // 隐藏 ‘this’ 同样可以使用        this.toString()    }}</code></pre><pre><code class="kotlin">fun main() {    println(alphabet())}</code></pre><p><strong>”with“的结构</strong></p><blockquote><p>with 结构看上去像是一种特殊的语法结构，但它实际上是一个接收两个参数的函数：这个例子中两个参数分别是 stringBuilder 和 lambda 。</p></blockquote><p>with 函数把第一个参数转换为第二个参数传递给 lambda 的接收者。</p><p><strong>在普通函数中与扩展函数中带接收者的 lambda 有那些不同</strong></p><blockquote><p>在扩展函数体内部，this 指向了这个函数扩展的那个类型实例，而且也可以被省略掉，让你直接访问接收者的成员。</p></blockquote><blockquote><p>上面的代码中，this 指定了stringBuilder，这时传给with的第一个参数。可以通过显式的this引用来访问stringBuilder的方法，就像this，append(latter)这样：也可以像append（”\nNow…”)</p></blockquote><p><strong>重构初始的alphabet函数，去除stringBuilder变量。</strong></p><blockquote><pre><code class="kotlin">/*    使用with和一个表达式函数体来构造字母表    */fun alphabet() = with(StringBuilder){    for(letter in &#39;A&#39;...&#39;Z&#39;){        append(letter)    }    append(&quot;\n Now I know the alphabet!&quot;)    toString()}</code></pre><p>现在此函数只返回一个表达式，所有表达式函数体语法重写了它。</p><p>可以创建一个新的StringBuilder实例直接当作实例传递给这个函数，然后 lambda中不需要显式的this就可以引用到这个实例。</p></blockquote><h3 id="5-5-2-“apply”-函数"><a href="#5-5-2-“apply”-函数" class="headerlink" title="5.5.2 “apply” 函数"></a>5.5.2 “apply” 函数</h3><p><strong>apply 和 with 的不同</strong></p><blockquote><p>apply 函数同with 函数功能相同，区别在于 apply 始终会返回作为实参传递给它的对象。（返回本身作为实例）</p></blockquote><pre><code class="kotlin">fun alphabet() = StringBuilder().apply {    for (letter in &#39;A&#39;..&#39;Z&#39;) {        append(letter)    }    append(&quot;\n Now I know the alphbet!&quot;)}.toString()</code></pre><p>apply 被声明成一个扩展函数。它的<strong>接收者</strong>变成了作为实参的 lambda 的接收者。执行 apply 的结果是StringBuilder,所以接下来里可以调用 toString 把它转换成 String。</p><p><strong>使用apply初始化一个TextView</strong></p><pre><code class="kotlin">fun createViewWithCustomAttributes(context : Context) = {    TextView(context).apply{        text = &quot;Sample Text&quot;        textSize = 20.0        setPadding(10,0,0,0)    }}</code></pre><p><strong>apply函数允许里使用紧凑的表达式函数体风格</strong>。新的<strong>TextView</strong>实例<strong>创建</strong>之后立即被传给了<strong>apply</strong>。</p><p><strong>那个是接收者?</strong></p><p>TextView实例变成了 (lambda 的) 接收者，你可以调用它的属性和方法。</p><p>with 函数和 apply 函数是最基本和最通用的使用带接收者的 lambda 的例子。更多的函数也可以使用这种模式。例如，使用<strong>标准库函数buildString进一步简化alphbet函数</strong>，它会负责<strong>创建StringBuilder</strong>并<strong>调用toString</strong>。<strong>building实际是带接收者的lambda</strong>，<strong>接收者</strong>就是<strong>StringBuilder</strong>。</p><p><strong>使用buildString创建字母表</strong></p><pre><code class="kotlin">/*    使用bulderString创建字母表    */fun alphabet()=builderString{    for (letter in &#39;A&#39;...&#39;Z&#39;){        append(latter)    }    append(&quot;\n Now I know tha alphabet!&quot;)}</code></pre><p>buildString 函数完成了借助StringBuilder创建String的任务。</p><h2 id="5-6-小结"><a href="#5-6-小结" class="headerlink" title="5.6 小结"></a>5.6 小结</h2><ul><li><strong>Lambda 允许你将代码块当作参数传递给函数。</strong></li><li><strong>Kotlin可以把lambda放在括号括号外穿的给函数，而且可以使用it引用单个lambda参数</strong></li><li><strong>lambda中的代码可以访问和修改包括这个lambda调用的函数的变量（访问修改调用者的变量）</strong></li><li><strong>通过在函数名称前加上前戳::，可以创建方法、可以创建方法及属性的引用，并用这些引用代替lambda传递给函数。</strong></li><li><strong>使用像filter、map、all、any、等函数，大多数公共的集合操作不需要手动迭代元素就可以完成。</strong></li><li><strong>序列允许你合并一个集合上的多个操作，而不需要创建新的集合来保存中间结果。</strong></li><li><strong>可以把lambda作为实参传递给接收Java函数式接口（带单抽象方法的接口，也叫SAM接口）作为形参的方法。</strong></li><li><strong>with标准库函数允许你调用同一个对象的多个方法，而不需要反复写出这个对象的引用。apply函数让你使用构造者风格的API创建和初始化任何对象。</strong></li></ul><h1 id="6-Kotlin的类型系统"><a href="#6-Kotlin的类型系统" class="headerlink" title="6  Kotlin的类型系统"></a>6  Kotlin的类型系统</h1><h2 id="6-1-可空性"><a href="#6-1-可空性" class="headerlink" title="6.1 可空性"></a>6.1 可空性</h2><p><strong>可空性是Kotlin类型系统中帮助你避免NullPointerException错误的特性。</strong></p><p>现代编程语言包括Kotlin解决这类问题的方法是把运行时的错误转变成编译期的错误。通过支持作为类型系统的一部分的可空性，编译器就能在编译器发现很多潜在的错误，从而减少运行时抛出异常的可能性。</p><p>我们会讨论Kotlin中的可空类型：Kotlin怎样表示允许null的值，以及Kotlin提供的处理这些值的工具。除此之外，我们还要讨论混合使用Kotlin和Java代码时关于可空类型的细节。</p><h3 id="6-1-1-可空类型"><a href="#6-1-1-可空类型" class="headerlink" title="6.1.1 可空类型"></a>6.1.1 可空类型</h3><p>Kotlin  和 Java 的类型系统之间第一条也可能是最重要的一条区别是，Kotlin对可空类型的显式的支持。</p><blockquote><p>这意味着，这是一种指出你程序中那些变量和属性允许为null的方式。如果一个变量可以为null，对变量的方法的调用就是不安全的，因为这样会导致NullPointerException。Kotlin不允许这样的调用因而可以阻止许多可能的异常。</p></blockquote><p><strong>在实践时它是如果工作的</strong></p><pre><code class="kotlin">int strLen(String s){    return s.length();}</code></pre><blockquote><p>这个函数被调用的时候，传给它的是一个null实参，它会抛出NullPointerException。是否需要在方法中增加对null的检查，这取决于使用该函数的意图。</p></blockquote><p><strong>用Kotlin重写这个函数</strong></p><blockquote><p>不希望在调用时传递一个 null 进来</p><pre><code class="kotlin">fun strLen(s:String) = s.length</code></pre><p>使用可能为null的参数调用strLen是不允许的，在编译期就会被标记成错误：</p><pre><code class="kotlin">&gt;&gt;&gt; strLen(null)ERROR:Null can not be a value of a non-null type String</code></pre><p>这个函数中的参数被声明成String类型，在Kotlin中这个表示它必须包含一个String实例。这一边由编译器强制实施，所以你不能传递一个包含null的参数。</p><blockquote><p>如果你允许调用这个方法的时候传递给它可能所有的实参，包含那些可以为null的实参，需要显式地在类型名称后面加上问号来标记它：</p><pre><code class="kotlin">fun strLenSafe(s:String?) = ... //允许为空</code></pre><p>问号可以加载任何类型的后面来表示这个类型的变量可以存储null引用：String?、Int?、MyCustomType?等等</p></blockquote></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210404144208.png" alt="可空类型的变量可以存储null引用"></p><p><strong>所有类型在没有问号的类型声明的情况下是不能存储null引用的，也就是说常见类型默认都是非空的。</strong></p><blockquote><p><strong>在拥有一个可空类型的值，能对它进行操作也是有限制的。</strong></p><p>例如，不能再调用它的方法：</p><pre><code class="kotlin">&gt;&gt;&gt; fun strLenSafe(s:String?) = s.length()ERROR:only safe(?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type kotlin.String?</code></pre><p>也不能再把它赋值给非空类型的变量：</p><pre><code class="kotlin">&gt;&gt;&gt; val x:String ?= null&gt;&gt;&gt; var y:String =xERROR:Type mismatch:inferred type is String? but String was expected</code></pre><p>也不能把可空类型的值传递给拥有非空类型参数的函数：</p><pre><code class="kotlin">&gt;&gt;&gt; strLen(x)ERROR:Type mismatch:inferred type is String? but String was expected</code></pre><p><strong>可以进行的操作</strong></p><p>最重要的操作就是和null进行比较。而且一旦你进行了比较操作，编译器就会记住，并且在这次比较发生的作用域内把这个值当作非空来对待。</p><p>例如，下列代码是合法的：</p><pre><code class="kotlin">/*    使用 if 检查处理null    */fun strLenSafe(s:String?):Int =     if (s != null) s.length else 0    // 增加了null 检查后，这段代码就可以编译了&gt;&gt;&gt; val x:String?= null&gt;&gt;&gt; println(strLenSafe(x))0&gt;&gt;&gt; println(strLenSafe(&quot;abc&quot;))3</code></pre><p>if 检查并不是唯一处理可空性的工具，稍后会有其他工具来帮助我们处理可空值。</p></blockquote><h3 id="6-1-2-类型的含义"><a href="#6-1-2-类型的含义" class="headerlink" title="6.1.2 类型的含义"></a>6.1.2 类型的含义</h3><p><strong>什么是类型，为什么变量拥有类型？</strong></p><blockquote><p>类型就是数据的分类，决定了该类型可能的值，以及该类型的值上可能完成的操作（维基百科）。</p></blockquote><p>试试在Java的一些类型上套用如上的定义，从double类型开始。double类型是64位的双精度浮点数。可以对double类型的值进行标准的算术运算，所有的功能都可以一视同仁的运用到所有double类型的值上。因此如果你有一个类型为double的变量，那么你就能确定编译器允许在该值上进行任意操作，都可以被成功的执行。</p><p>现在我们把它和String类型的变量对比一下。在Java中，这样的变量可以持有两种值，分别是String实例和null。这两种完全不一样：就连Java自己的instanceof运算符都会告诉你null不是String。这两种值的操作也完全不一样：真实的String实例允许你调用它的任何方法，而null值只允许非常有限的操作。</p><p>上述表明在Java中类型系统不能很好的工作。<strong>即使变量拥有声明类型String你依然无法知道能对该变量的值做些什么，除非做额外的检查。你往往跳过这些检查，因为你觉得你了解程序中大概的数据流动，并确定在某个点上的值不可能为null。有时候你想错了，而你的程序就会因为NullPointerException而崩溃。</strong></p><p>Kotlin的可空类型为这类问题提供了全面的解决方案。区分开可空类型和非空类型使事情变得明朗：那些对值的操作使允许的，哪些操作有会导致运行时异常并因此被禁止。</p><blockquote><p><strong>注意</strong>：</p><p>可空的和非空的对象在运行时没有什么区别；可空类型并不是非空类型的包装。所有的检查都发生在编译期。这意味Kotlin的可空类型并不会在运行时带来额外的开销。</p></blockquote><h3 id="6-1-3-安全调用运算符：“-”"><a href="#6-1-3-安全调用运算符：“-”" class="headerlink" title="6.1.3 安全调用运算符：“?.”"></a>6.1.3 安全调用运算符：“?.”</h3><p><strong>安全调用运算符</strong>：“?.”，它允许你把null检查和一次方法复用合并成一次操作。</p><p>例如：表达式 s?.toUpperCase() 等用于下面这种繁琐的写法： if (s!=null) s.toUpperCase() else null。</p><blockquote><p>也就是说在你调用一个非空值的方法，这次方法调用会被正常的调用。如果是null值的话，这次调用不会发生，而整个表达式的值为null。</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210409163831.png" alt="安全调用运算符只会调用非空值的方法"></p><p>注意，这次调用的结果类型也是可空的。尽管String.toUppferCase()会返回String类型的值，但s是可空的时候，表达式s?.toUpperCase()的结果类型是String?:</p><pre><code class="kotlin">fun printAllCaps(s:String?){    val allCaps:String? = s?.toUppperCase()    // allCaps可能是null    println(allCaps)}&gt;&gt;&gt; printAllCaps(&quot;abc&quot;)ABC&gt;&gt;&gt; printAllCaps(null)null</code></pre><p><strong>安全调用不光可以调用方法，可能用来访问属性。</strong></p><pre><code class="kotlin">/*    使用安全调用处理可控属性    */class Employee(val name:String,val manager:Employee?)fun managerName(employee:Employee):String?= employee.maneger?.name&gt;&gt;&gt; val ceo = Employee(&quot;Da Boss&quot;,null)&gt;&gt;&gt; val developer = Employee(&quot;Bob Smith&quot;,ceo)&gt;&gt;&gt; println(managerName(developer))Da Boss&gt;&gt;&gt; println(managerName(ceo))</code></pre><p>如果你的对象途中又多个可空类型的属性，通常可以在同一表达式中方便地使用多个安全调用。加入你要使用不同的类型来保存关于个人的信息、他们的公司，以及公司的地址，而公司和地址都可以省略。使用?.运算符，不需要任何额外的检查，就可以在以放代码中访问到Person的country属性。</p><pre><code class="kotlin">/*    链接多个安全调用    */class Address(val streetAddress:String,val zipCode:Int,val city:String,val country:String)class Company(val name:String, val address:Address?)class Person(val name:String,val company:Company?)fun Person.countryName():String{    val country = this.company?.address?.country    // 多个安全调用链接在一起    return if (country!=null) contry else &quot;Unknown&quot;}&gt;&gt;&gt; val person = Person(&quot;Dmitry&quot;,null)&gt;&gt;&gt; println(person.countryName())Unknown</code></pre><h3 id="6-1-4-Elvis-运算符：“-”"><a href="#6-1-4-Elvis-运算符：“-”" class="headerlink" title="6.1.4 Elvis 运算符：“?:”"></a>6.1.4 Elvis 运算符：“?:”</h3><p>Kotlin有方便的运算符来提供代替null的默认值。它被称为Elvis运算符。（或者null合并运算符，或空合并运算符）</p><blockquote><p>及不为null时运算左侧，null时运算右侧。</p></blockquote><pre><code class="kotlin">fun foo(s:String?){    val t:String = s?:&quot;&quot;    //如果“s”为null，结果为空字符串}</code></pre><blockquote><p>Elvis运算符接收两个运算数，如果第一个运算数不为null，或者结果就是第一个运算数；如果第一个运算数为null，运算结果就是第二个运算数。</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210411235620.png" alt="Elvis运算符用其他值代替null"></p><blockquote><p>Elvis 运算符经常和安全调用运算符一起使用，<strong>用一个值代替null对象调用返回时返回null。</strong></p><pre><code class="kotlin">fun strLenSafe(s:String?):Int = s?.length?:0&gt;&gt;&gt; println(strLenSafe(&quot;abc&quot;))3&gt;&gt;&gt; pritnln(strLenSafe(null))0</code></pre></blockquote><blockquote><p>在 6.1.3 “链接多个安全调用” 的函数 countryName现在也可以使用一行代码来完成。</p><pre><code class="kotlin">fun Person.countryName()=conpany?.address?.country?:=&quot;Unknown&quot;**</code></pre></blockquote><p><strong>在Kotlin中有种场景下Elvis运算符会特别顺手，想return和throw这样的操作其实是表达式，因此可以把它们写在Elvis运算符的右边。这种情况下，如果Elvis运算符左边的值为null，函数就会立即返回一个值或者抛出一个异常，如果函数中需要检查先决条件，这个方式会很有用。</strong></p><p><strong>实现一个打印包含个人公司地址的出货标签函数。</strong></p><pre><code class="kotlin">/*    同时使用throw和Elvis运算符    */class Address(val streetAddress:String,val zipCOde:Int,val city:String,val country:String)class Company(val name:String,val address:Address?)class Person(val name:String,val company:Company?)fun pritnlnShippingLabel(person:Person){    val address = person.company?.address                ?: throw IllegalArgumentException(&quot;No address&quot;)    //如果缺少addres就抛出异常    with(address){    //address 不为空        println(streetAddress        println(&quot;$zipCode $city,$country&quot;)    }}&gt;&gt;&gt; val address = Address(&quot;Elsestr. 47&quot;,80687,&quot;Munich&quot;,&quot;Germany&quot;)               &gt;&gt;&gt; val jetbrains = Company(&quot;JetBrains&quot;,address)                &gt;&gt;&gt; val person = Person(&quot;Dmitry&quot;,jetbrains)                &gt;&gt;&gt; printShippingLabel(person)Elsestr.4780687 Munich.Germany&gt;&gt;&gt; printShippingLable(Person(&quot;Alexey&quot;,null))java.lang.IllegalArgumentException:No address</code></pre><p><strong>如果一切正常，函数printShippingLable会打印出标签。如果地址不存在，它不会只是抛出一个带行号的NullPointerException，相反，它会报告一个有意义的错误。</strong>如果地址存在，标签会包含街道地址、邮编、城市和国家。留意之前说过的with函数是如何被用来避免在一行中重复四次address的。</p><h3 id="6-1-5-安全转换-“as-”"><a href="#6-1-5-安全转换-“as-”" class="headerlink" title="6.1.5 安全转换 “as?”"></a>6.1.5 安全转换 “as?”</h3><p>“as”用来转换类型的常规Kotlin运算符，<strong>和常规的Java类型转换一样，如果被转换的值不是你试图转换的类型，就会抛出ClassCastException异常。</strong></p><p><strong>“as?”运算符尝试把值转换成指定的类型，如果值不是合适的类型就返回null</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210414230332.png" alt="安全转换运算符尝试把值转换成给定的类型。如果类型不合适就返回null"></p><p><strong>一种常见的模式是把安全转换和Elvis运算符结合使用。</strong></p><pre><code class="kotlin">/*    使用安全转换实现equals    */class Person(val firstName:String,val lastName:String){    override fun equals(o:Any?):Boolean{        val otherPerson = o as? Person ?: return false    // 检查类型，如果不匹配就返回false        return otherPerson.firstName == firstName &amp;&amp; otherPerson.lastName == lastName    //在安全转换之后，变量otherPerson被智能地转换为 Person 类型    }    override fun hashCode():Int = firstName.hashCode() * 37 + lastName.hashCode()}&gt;&gt;&gt; val p1 = Person(&quot;Dmitry&quot;,&quot;Jemerov&quot;)&gt;&gt;&gt; val p2 = Person(&quot;Dmitry&quot;,&quot;Jemerov&quot;)&gt;&gt;&gt; println(p1 == p2)true&gt;&gt;&gt; println(p1.equals(42))false</code></pre><p><strong>使用这种模式，可以非常容易地检查实参是否是适当的类型，转换它，并在它的类型不能确定是返回false，而且这些操作全部在同一个表达式中。</strong>当然，这种场景下智能转换也会生效：当你检查过类型并拒绝了null值，编译器就确定了变量otherPerson值的类型是Person并当你能够相应的使用它。</p><h3 id="6-1-6-非空断言：“-”"><a href="#6-1-6-非空断言：“-”" class="headerlink" title="6.1.6 非空断言：“!!”"></a>6.1.6 非空断言：“!!”</h3><p>非空断言：</p><p><strong>它使用双感叹号表示，可以把任何值转换成非空类型。如果对null值做非空断言，则会抛出异常。</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210414234748.png" alt="通过使用非空断言，如果值为null，可以显式地抛出异常"></p><p><strong>使用非空断言来吧可空的实参转换成非空。</strong></p><pre><code class="kotlin">/*    使用非空断言    */fun ignoreNulls(s:String?){    val sNotNull:String = s!!    // 异常指向这一行    println(sNotNull.length)}&gt;&gt;&gt; igoreNulls(null)Exceptin in thread &quot;main&quot; kotlin.KotlinNullPointerException    at &lt;...&gt;.ignoreNulls(07_NotnullAssertions.kt:2)</code></pre><blockquote><p>如果上面函数中s为null会发生什么？Kotlin没有其他选择，它会在运行时抛出一个异常（一种特殊的NullPointerException）。但是注意异常抛出的位置是非空断言所在的哪一行，而不是接下来试图使用那个值的一行。本质上，你在告诉编译器：“我知道这个字不为null，如果我错了我准备好啦接收这个异常。”</p><blockquote><p>注意：Kotlin的设计者试图说服你思考更好的解决方案，这些方案不会使用断言这种编译器无法验证的方法。</p></blockquote><p>但是确实存在这种情况，某些问题适合使用非空断言来解决。当你在一个函数中检测一个值是否为null，而在另一个函数中使用这个值时，这种情况下编译器无法识别这种用法是否安全。（也就是使用前检查他是否为null）</p></blockquote><p>使用情况</p><blockquote><p>在确定你的变量非空时推荐使用它。因为在null状态下它会报出空指针异常。</p></blockquote><h3 id="6-1-7-“let”-函数"><a href="#6-1-7-“let”-函数" class="headerlink" title="6.1.7 “let” 函数"></a>6.1.7 “let” 函数</h3><p><strong>用来处理可空表达式。和安全调用运算符一起使用，允许你对表达式求值，检查求值结果是否null，并把结果保存为一个变量。</strong></p><p><code>其中在let的匿名函数中it表示email字符串本身。</code></p><pre><code class="kotlin">/*    使用let调用一个接收非空参数的函数    */fun sendEmailTo(email : String){    println(&quot;Sending emaill to $emaill&quot;)}&gt;&gt;&gt; var email:String ? = &quot;yole@example.com&quot;&gt;&gt;&gt; email?.let{sendEmailTo(it)}Sending email to yole@example.com&gt;&gt;&gt; emaill = null&gt;&gt;&gt; emaill?.let{    sendEmailTo(it)        }</code></pre><blockquote><p>所以说只有这段表达式不为空时才会执行代码块里的代码</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220411183210.png" alt="安全调用“let”只在表达式不为null时执行"></p><h3 id="6-1-8-延迟初始化的属性"><a href="#6-1-8-延迟初始化的属性" class="headerlink" title="6.1.8 延迟初始化的属性"></a>6.1.8 延迟初始化的属性</h3><p><strong>使用延迟初始化属性的原因</strong></p><blockquote><p>Kotlin 通常要求你在构造方法中初始化所有属性，如果某个属性是可空类型，你就必须提供一个非空的初始化值。否则，你就必须使用可空类型。如果你这样做，该属性的每一次访问都需要null检查或者”!!”运算符</p></blockquote><p><strong>使用非空断言访问可控属性</strong></p><pre><code class="kotlin">/*    使用非空断言访问可空属性    */class MyService{    fun performAction():String = &quot;foo&quot;}class MyText{    private var myService : MyService ?= null    // 声明了一个可空类型初始化为 null    @Before fun setUp(){    // 在 setUp方法中提供真正的初始化器        myService = MyService()    }    @Test fun testAction(){        Assert.assertEquals(&quot;foo&quot;,myService!!.performAction())    // 必须注意可空性：要么用&quot;!!&quot;，要么用&quot;?.&quot;    }}</code></pre><pre><code class="kotlin">/*    使用延迟初始化属性    */class MyService{    fun performAction():String = &quot;foo&quot;}class MyText{    private lateinit var myService : MyService    // 声明了一个不需要初始化器的非空类型属性    @Before fun setUp(){    // 在 setUp 方法中初始化 myService        myService = MyService()    }    @Test fun testAction(){        Assert.assertEquals(&quot;foo&quot;,myService.performAction())    // 不需要 null 检查直接访问属性    }}</code></pre><p>注意</p><blockquote><p>初始化的属性必须为var，因为需要在构造方法外修改它的值，使用val属性被编译时必须在构造方法中初始化final片段。</p><p>尽管 myService 属性是非空的，你不需要在构造方法中初始化它。在属性没有被初始化之前调用会得到异常 “lateinit property myService has not been initialized”。</p><blockquote><p>lateinit 属性常见的一种用法是在依赖注入。在某种情况下，lateinit 属性的值是被依赖注入框架从外部设置的。为了保证和各种依赖注入框架的兼容性</p><p>，Kotlin 会自动生成一个和 lateinit 属性具有相同可见性的字段。如果属性的可见性是public，生成字段也是可见性public</p></blockquote></blockquote><h3 id="6-1-9可空类型的扩展"><a href="#6-1-9可空类型的扩展" class="headerlink" title="6.1.9可空类型的扩展"></a>6.1.9可空类型的扩展</h3><blockquote><p>为可空类型定义扩展函数。可以允许接收者（调用者）为空null 的（扩展函数）调用，并在该函数中处理null，而不是在确保变量不为null之后再调用它的方法。</p><p><strong>只有扩展函数才能做到这一点，普通成员方法的调用是通过对象实例来分发的，因此实例为null时（成员方法）永远不能被执行。</strong></p></blockquote><p>Kotlin标准库中定义的String的两个扩展函数isEmpty和isBlanck就是这样的例子。第一个函数判断字符串是否是一个空的字符串“”。第二个函数则判断它是否是空的或者它只包含空白字符。通常用这些函数来检查字符串中是否有价值的，以确保对它的操作是由意义的。</p><p><strong>像这种无意义的空字符串和空白字符串这样处理null也很有用。事实上，你的确可以这样做：函数isEmptyOrNull和isNullOrBlank就可以由String?类型的接收者调用（用于可空类型接收者调用）。</strong></p><pre><code class="kotlin">/*    用可空接收者调用扩展函数    */fun verifyUserInput(input:String?){    if (input.isNullOrBlank()){    //不需要安全调用        println(&quot;Please fill in the requied fileds&quot;)    }}&gt;&gt;&gt; verifyUserInput(&quot; &quot;)    //可空类型的扩展函数在接收者为空时也可以调用Please fill in the required fields&gt;&gt;&gt; verifyUserInput(null)Please fill in the required fields</code></pre><p>不需要安全访问，就可以直接为可控接收者声明扩展函数</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210417170332.png" alt="不需要安全调用就可以访问可空类型的扩展"></p><p><strong>函数isNullOrBlank显式地检查了null，这种情况下返回true，然后调用isBlank，它只能在非空String上调用：</strong></p><pre><code class="kotlin">fun String?.isNullOrBlank():Boolean =    //可空字符串的扩展        this == null || this.isBlank    //第二个“this”使用了智能转换</code></pre><blockquote><p>当你为一个可空类型（以?结尾）定义扩展函数时，这意味着你可以对可空的值调用这个函数；并且函数体中的this可能为null，所以你必须显式地价差。在Java中，this永远是非空的，因为它引用的时当前你所在这个类的实例。而在Kotlin中，这并不永远成立：在可空类型的扩展函数中，this可以是null的。</p><p>let函数也能被可空的接收者调用，但它并不检查值是否为null。如果你在一个可空类型上调用let函数，而没有使用安全调用运算符，lambda的实参将会是可空的：</p><p>（let检查是否为null，并把结果保存为一个变量）</p><pre><code class="kotlin">&gt;&gt;&gt; val person:Person?=...    // 可空类型的非空属性&gt;&gt;&gt; person.let{ sendEmailTo(it) }    // 没有安全调用，所以“it”是可空类型ERROR:Type mismatch:inferred type is Person? but Person was expected</code></pre><p><strong>使用let来检查非空的实参，必须使用安全调用运算符“?.”，就像代码：person?.let{ sendEmailTo(it) }。</strong></p><blockquote><p>当你定义自己的扩展函数时，需要考虑该扩展是否需要为可空类型定义。默认情况下，应该把它定义成会空类型的扩展函数。在发现大部分情况下需要在可空类型上使用这个函数，再安全的修改它。</p></blockquote></blockquote><h3 id="6-1-10-类型参数的可空性"><a href="#6-1-10-类型参数的可空性" class="headerlink" title="6.1.10 类型参数的可空性"></a>6.1.10 类型参数的可空性</h3><p>Kotlin 中<strong>所有泛型类和泛型函数的类型参数默认</strong>都是可空的。</p><p>任何类型，包括可空类型在内，都可以替换类型参数。这种情况下，使用类型参数作为类型的声明都允许为null，尽管类型参数T并没有用问号结尾。</p><p>例子：</p><pre><code class="kotlin">/*    处理可空的类型参数    */fun &lt;T&gt; printHashCode(t:T){    println(t?.hashCode())    //因为”T“ 可能为null，所以必须使用安全调用}&gt;&gt;&gt; printHashCode(null)    //”T“被推导为”Any?“null</code></pre><p>在printHashCode调用中，类型参数T推导出的类型是可空类型Any?。    因此，尽管没有用问号结尾，实参t依然允许持有null。</p><p><strong>要使类型参数非空（不为空）必须要为它指定一个非空的上界，那样泛型就会拒绝可空值作为实参。</strong></p><pre><code class="kotlin">/*    为类型参数声明非空三界    */fun &lt;T:Any&gt; printHashCode(t:T){    //现在”T“就不是可空的    println(t.hashCode())}&gt;&gt;&gt; printHashCode(null)    //这段代码是无法编译的：你不能传递null，因为期望值是非空值。Error:Type paramater bound for &#39;T&#39; is not asthisfied&gt;&gt;&gt; printHashCode(42)42</code></pre><p>注意必须使用问号结尾来标记类型为可空的，没有问号就是非空的。类型参数是这个规则唯一的例外。（在使用三界后，想使用可空类型就要加问号来标记可空。）</p><h3 id="6-1-11-可空性和Java"><a href="#6-1-11-可空性和Java" class="headerlink" title="6.1.11 可空性和Java"></a>6.1.11 可空性和Java</h3><p>Kotlin 引以为傲的是和Java的互操作性，而你知道Java类型系统是不支持可空性的。在你混合使用Kotlin和Java时会发生什么？会不会失去所有的安全性？或者每个值都必须检查是否为null？</p><blockquote><p>有些时候Java代码包含了可空性的信息，这些信息用注解来表达。</p><p><strong>当代码中出现了这些信息时，Kotlin就会使用。因此Java中@Nullable string 被Kotlin当作String?(可空类型)，而@NotNull String就是String(不为空类型)</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210419170543.png" alt="根据Java类型识别的注解，Java类型回在Kotlin中表示为可空类型和非空类型"></p><p>Kotlin 可以识别多种不同风格的可空性注解，包括JSR-305标准的注解（在javax.annotation包之中）、Android的注解（android.support.annotation包之中）和JetBrains工具支持的注解（org.jetbrains.annotation）。</p><p><strong>如果这些注解不存在会发生什么？</strong></p><p><strong>Java 类型会变成Kotlin中的平台类型</strong></p><p><strong>平台类型</strong></p><blockquote><p><strong>平台类型本质上就是Kotlin不知道可空性信息的类型</strong>。<strong>即可以把它当作可空类型处理，也可以当作会空类型处理</strong>。</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210420145256.png" alt="Java类型在Kotlin中表示为平台类型，既可以把它当作可空类型也可以当作会空类型来处理"></p><blockquote><p>这意味着，你要像在Java中意义，对你在这个类型上做的操作负全部责任。编译器将会允许所有的操作，它不会把对这些字的空安全操作高亮多余的，但它平时确实这样对待会空类型值上的空安全操作。<strong>如果你认为这个字为null，在使用它之前可以用它和null进行比较。如果你认位它不为null，就直接使用它。就像在Java中一样，如果你错误地理解了这个值，使用的时候就会遇到NullPointerException。</strong></p></blockquote><p><strong>例子</strong></p><pre><code class="java">/*    没有可空性注解的Java类    */public class Person{    private final String name;    public Person(String name){        this.name = name    }    public String getName(){        return name    }}</code></pre><blockquote><p>getName能不能返回null?这种情况下Kotlin编译器完全不知道String类型的可空性，所以你必须处理它。<strong>如果你确定name不为null，就可以像Java中一样按照通常的方式对它解引用，不需要额外的检查。但是这种情况下请准备好接受异常。</strong></p></blockquote><pre><code class="kotlin">/*    不使用null检查访问Java类    */fun yellAt(person:Person){    println(person.name.toUpperCase()+ &quot;!!!&quot; )    //toUpperCase()调用的函数接收者person.name为null，所以这里会抛出异常}&gt;&gt;&gt; yellAt(Person(null))java.lang.IllegalArgumentException:Paramater specified as non-null is null: method toUpperCase, parameter $receiver</code></pre><blockquote><p>注意，这里你看到的不是一个NullPointerException，而是一条更详细的错误信息，告诉你方法toUpperCase不能在null的接收者上调用。</p><p><strong>对于公有的Kotlin函数，编译器生成对每个非空类型的参数（和接收者）的检查和，所以使用不正确的参数的调用尝试都立即被报告为异常。（在使用参数前会检查非空的参数。）</strong></p><p>这种值检查在函数调用的时候就执行，而不是等到这些参数被使用的时候。这确保了不正确的调用会被尽早的发现，那些由于null值被传给代码不同层次的多个函数之后，并被这些函数访问时而产生的难以理解的异常就能被避免。</p></blockquote><p>把getName()的返回类型解释为可空的并安全的访问它。</p><pre><code>/*    使用null检查来访问的Java类    */fun yellAtSafe(person:Person){    println((person.name?:&quot;Anyone&quot;).toUpperCase()+&quot;!!!&quot;)}&gt;&gt;&gt; yellAtSafe(null)ANYONE!!!</code></pre><blockquote><p>Java API 中大部分库没有（可空性）注解，所以可以把所有类型都解释为非空，但是会导致错误。为了避免错误，你应该阅读Java方法的文档（必要时还要查看它的实现），并知道它上面时候返回null，并给那些返回加上检查。</p><blockquote><p>为什么需要平台类型？</p><p>对 Kotlin 来说，把来自Java的所有值都当成可空的是不是更安全？这种设计也许可行，但是这需要对永远不为空的值做大量冗余的null检查，因为Kotlin编译器无法了解到这样的信息。</p><p>涉及泛型的话这种新款就更加糟糕了。例如，在Kotlin中，每次来自Java的ArrayList<String>都被当作ArrayList&lt;String?&gt;?，每次访问或者转换类型都需要检查这些值是否为null，这样抵消掉安全性带来的好处。编写这样的检查非常令人厌烦，所以Kotlin的设计者做出了更实用的选择，让开发者负责正确处理来自Java的值</p></blockquote></blockquote><p>在<strong>Kotiln中不能声明一个平台类型（不知道可空信息的）的变量</strong>，这些信息只能来自Java代码，但你可能会在IDE的错误信息中见到它们。</p><pre><code class="kotlin">&gt;&gt;&gt; val i:Ine = person.nameERROR:Type mismatch: inferred type is String! but Int was expected</code></pre><blockquote><p>String! 表示法被Kotlin编译器用来表示来自<strong>Java代码的平台类型</strong>。你不能在自己的代码中使用这种语法。而且感叹号通常与问题的来源无关，所以通常可以忽略它。<strong>这只是在强调类型的可空性是未知的。</strong></p></blockquote><p><strong>你可以用你喜欢的方式来解释平台类型，既可以是可控的也可以是非空的。</strong></p><pre><code class="kotlin">&gt;&gt;&gt; val s:String?=person.name    //可空&gt;&gt;&gt; val s1:String = person.name    //非空</code></pre><p><strong>如果你用来自Java的null值给一个非空的Kotlin变量赋值，在赋值的瞬间你就会得到异常。</strong>你需要正确的理解可空性。</p><p><strong>继承</strong></p><p>Kotlin 重写Java的方法时，<strong>可以选择把参数和返回类型定义成可空的，也可以选择把它们定义成非空的。</strong></p><p><strong>例子</strong></p><pre><code class="java">/*    Java中的StringProcessor接口    */interfece StringProcessor{    void process(String value);}</code></pre><p>Kotlin 中下面的两种实现编译器都可以接收。</p><pre><code class="kotlin">/*    实现Java接口时使用不同的参数可空性    */class StringPrinter:StringProcessor{    override fun process(value:String){        pritlin(value)    }}class NullableStringPrinter:StringProcessor{    override fun process(value:String?){    // 参数可空        if(value != null){            println(value)        }    }}</code></pre><blockquote><p>在实现Java类或者接口的方法时一定要搞清楚它的可空性。<strong>因为方法实现可在非Kotlin的代码中被调用，Kotlin编译器会为你声明的每个非空的参数生成非空断言。</strong>如果Java代码传给这个方法一个null值，断言就会触发，你就会得到一个异常，即便你从来没有在你的实现中访问过这个参数的值。</p></blockquote><h2 id="6-2-基本数据类型和其他基本类型"><a href="#6-2-基本数据类型和其他基本类型" class="headerlink" title="6.2 基本数据类型和其他基本类型"></a>6.2 基本数据类型和其他基本类型</h2><p>描述程序中的基本数据类型，例如Int、Boolean和Any。</p><p>与Java不同，Kotlin并不区分基本数据类型和它们的包装类。</p><h3 id="6-2-1-基本数据类型：Int、Boolean及其他"><a href="#6-2-1-基本数据类型：Int、Boolean及其他" class="headerlink" title="6.2.1 基本数据类型：Int、Boolean及其他"></a>6.2.1 基本数据类型：Int、Boolean及其他</h3><blockquote><p><strong>Java把基本数据类型和引用类型做了区分。</strong></p><p>一个基本数据类型（如int）的变量直接存储了它的值，而一个引用类型（如String）的变量存储的时指向包含该对象的内存地址的引用。</p></blockquote><blockquote><p>基本数据类型的只能够更高效地存储和传递，但你不能对这些值调用方法，或是它们存放在集合中。</p><p><strong>Java提供了特殊的包装类型（比如java.lang.Integer),在你需要对象的是否对基本数据类型进行封装。因此，你不能用Collection<int>来定义一个整数的集合，而必须用Collection<integer>来定义。</strong></p></blockquote><blockquote><p><strong>Kotlin 并不区分基本数据类型和包装类型，</strong>永远是同一个类型（比如int）</p><pre><code class="kotlin">val i:Int = 1val list:List&lt;Int&gt; = listOf(1,2,3)</code></pre><p>同时还能对数字类型的值调用方法。</p><pre><code class="kotlin">/*    使用标准库的函数coerceIn来把值限制在特定范围内    */fun showProgress(progress:Int){    val percent = progress.coerceIn(0,100)    println(&quot;We&#39;re ${percent}% done!&quot;)}&gt;&gt;&gt; showProgress(146)We&#39;re 100% done!</code></pre><p>虽然没有区分基本数据类型和包装类型，但是这不意味着Kotlin使用对象来表示所有数组！</p><p><strong>在运行时，数字类型会尽可能地使用最高效的方式来表示。大多数形况下——对于变量、属性、参数和返回类型——Kotlin的Int类型会被编译成Java基本类型int。唯一不可行的例外是泛型类，例如集合。用作泛型参数的基本数据类型会被编译成对应的包装类。例如，Int类被用作集合类型的类型参数时，集合类将会保存对应包换类型java.lang.Integer的实例。</strong></p></blockquote><p><strong>Java基本数据类型完整列表</strong></p><ul><li>整数类型——Byte、Short、Int、Long</li><li>浮点整数类型——Float、Double</li><li>字符类型——Char</li><li>布尔类型——Boolean</li></ul><p><strong>就像Int 这样的Kotlin类型在底层可以轻易的编译成对应的Java基本类型，因为两种类型都不能存储null引用。当你在Kotlin中使用Java声明时，Java基本数据类型就会变成非空类型（而不是平台类型），因为它们不能持有null值。</strong></p><h3 id="6-2-2-可空基本数据类型：Int-、Boolean？及其他"><a href="#6-2-2-可空基本数据类型：Int-、Boolean？及其他" class="headerlink" title="6.2.2 可空基本数据类型：Int?、Boolean？及其他"></a>6.2.2 可空基本数据类型：Int?、Boolean？及其他</h3><blockquote><p>Kotlin中的可空类型不能用Java的基本数据类型表示，因为null只能被存储在Java的引用类型的变量中。这意味着任何时候使用了基本数据类型的可空版本，它就会被编译成对应的包装类。</p></blockquote><pre><code class="kotlin">/*    名字永远已知的Person类，但是年龄可能未知或者未指定。添加函数检查一个人是否比另一个人年长    */class Person(val name:String,val age:Int ?= null){        fun isOlderThan(other:Person):Boolean?{            if(age == null ||other.age == null)                return null            return age &gt; other.age        }}&gt;&gt;&gt; println(Person(&quot;Sam&quot;,35).isOlderThan(Person(&quot;Amy&quot;,42)))false&gt;&gt;&gt; println(Person(&quot;Sam&quot;,34).isOlderThan(Person(&quot;Jane&quot;)))null</code></pre><p><strong>注意，普通的可空性规则如何在这里引用。</strong>你不能就这样比较两个值，因为它们当中任何一个都可能为null。你必须检查两个值都不为null。</p><p>Person类声明的age属性的值被当作java.lang.Integer存储（包装类）。但是只有在你使用来自Java的类时这些细节才有意义。为了在Kotlin中选出正确的类型，你只需要考虑对变量或者属性来说，null是否是它们可能的值。</p><p><strong>泛型类（ArrayList<Integer>)是包装类型应用的另一种情况。如果你用基本数据类型作为泛型类的参数类型，那么Kotlin会使用该类型的包装形式（Int ==&gt; Integer）</strong></p><p>创建一个Integer包装类的列表，<strong>尽管没有指定过可空类型或者用过null值</strong></p><pre><code class="kotlin">val listOfInts = listOf(1,2,3)</code></pre><p>这是由Java虚拟机实现泛型的方式决定的。JVM不支持用基本数据类型作为类型参数，所以泛型类（Java和Kotlin一样）必须始终使用类型的包装表示。<strong>因此，你要高效的存储基本数据类型元素的大型集合，要么使用支持这种集合的第三方库（如Trove4J）要么使用数组来存储。</strong></p><h3 id="6-2-3-数字转换"><a href="#6-2-3-数字转换" class="headerlink" title="6.2.3 数字转换"></a>6.2.3 数字转换</h3><p>Kotlin和Java<strong>之间一条重要的区别就是处理数字转换的方式。</strong>Kotlin不会自动的把数字从一种类型转换成另一种，即便是转换范围更大的类型。</p><pre><code class="kotlin">val i = 1val i : Long = i    //错误：类型不匹配</code></pre><p>正确的转换</p><pre><code class="kotlin">val i = 1val l:Long = i.toLang()</code></pre><blockquote><p>基本数据类型类型（Boolean除外）都定义有转换函数：toByte()、toShort()、toChar()等。这些函数支持双向转换：既可以把 小范围的类型扩展到大范围，比如Int.toLong(),也可以把大范围的类型截取到小范围，比如Long.toInt()。</p><p>Kotlin 要求转换必须是显式的，尤其是在比较<strong>装箱值</strong>的时候。比较两个装箱值的equals方法不仅会检查它们存储的值，还会比较装箱类型。所以，在Java中new Integer(42).equals(new Long(42)) 会返回false。</p><blockquote><p>Java中的装箱和拆箱</p><p><strong>装箱和拆箱是从Java1.5开始引入的，它的目的是将原始类型值自动地转换成对应的对象。</strong>自动装箱机制可以让我们在Java的变量赋值或者其他方法调用等情况下使用原始类型或者对象类型更加简单直接。</p></blockquote></blockquote><p>假如 Kotlin 支持隐式转换，</p><pre><code class="kotlin">val x = 1    // Int变量val list = listOf(1L,2L,3L)    //Long值列表x in list //假如支持隐式转换它仍然是 false</code></pre><blockquote><p>因此，上列中 x in list 根本不会编译。Kotlin要求你显式的转换类型，这样只有类型相同的值才比较：</p><pre><code class="kotlin">&gt;&gt;&gt; val x = 1&gt;&gt;&gt; println(x.toLong() in listOf(1L,2L,3L))true</code></pre><p>在代码中用到不同的数据类型，你必须显式的转换这些变量，来避免意想不到的结果。</p></blockquote><blockquote><p><strong>基本数据类型字面值</strong></p><ul><li>使用后戳L表示Long类型(长整型)字面值:123L.</li><li>使用标准浮点数表示Double(双浮点精度)字面值:0.12、2.0、1.2e10、1.2e-10。</li><li>使用F表示Float类型（浮点数）字面值：123.4f、.345F、1e3f。</li><li>使用前戳0x或者0X表示十六进制字面值：0xCAFEBABE或者0xbcdL。</li><li>使用前戳0b或者0B表示二进制字面值：0b000000101.</li></ul><p>在Kotlin1.1才开始支持数字字面值中的下划线。对字符字面值来说，可以使用和Java几乎一样的语法。把字符卸载单引号中，必要时还可以使用转义序列。有效的Kotlin字符字面值：‘1’、‘/t’（制表符）、‘\u0009’（使用Unicode转义序列表示的制表符）。</p></blockquote><blockquote><p>当你在书写数字字面值的时候，一般不需要使用转换函数。这种（字面值）特殊的语法来显示地标记常量类型，例如42L或者42.0f。即使你没有使用这种语法，数字字面值去初始化一个类型已知的变量是（Ine 类型已知，初始化为Long），又或是把字面值当作实参传递给函数时，必要的转换会自动发生。  算数运算符也会被重载，它们可以接收所有适当的数字类型。</p><pre><code class="kotlin">/*    如下的代码并没有任何显式的转换却可以正常工作过    */fun foo(l:Long) = println(l)&gt;&gt;&gt; val b:Byte = 1    //常量有正确的类型&gt;&gt;&gt; val l = b+1L    //+可以进行直接类型和长整型参数的计算&gt;&gt;&gt; foo(42)    // 编译器认为42是一个长整型42</code></pre><blockquote><p>Koylin算术运算符关于数值范围溢出的行为和Java完全一直；Kotlin并没有引入由溢出检查带来的额外开销。</p></blockquote></blockquote><p><strong>字符串转换</strong></p><blockquote><p>Kotlin 标准库提供了一套相似的扩展方法，用来把字符串转换成基本数据类型（toInt、toByte、toBoolean、等）。</p><pre><code class="kotlin">&gt;&gt;&gt; println(&quot;42&quot;.toInt())42</code></pre><p>函数会尝试把字符串的内容解析成对应的函数，如果解析失败抛出NumberFormatException。</p></blockquote><h3 id="6-2-4-“Any”和“Ant？”：根类型"><a href="#6-2-4-“Any”和“Ant？”：根类型" class="headerlink" title="6.2.4 “Any”和“Ant？”：根类型"></a>6.2.4 “Any”和“Ant？”：根类型</h3><blockquote><p><strong>和Ojbect作为Java类层级结构的根差不多，Any类型是Kotlin所有非空类型的超类型（非空类型的根）。</strong>而在Java中，Object只是所有应用类型的超类型（引用类型的的根），而基本数据类型并不是类层级结构的一部分。这意味着当你需要Object的时候，不得不使用java.long.Integer这样的包装类型来表示基本数据类型的值。<strong>而在Kotlin中，Any是所有类型的超类型（所有类型的根），包括像Int这样的基本数据类型。</strong></p></blockquote><p>基本数据类型的值赋给Any类型的变量时会自动装箱：</p><pre><code class="kotlin">val answer:Any = 42    \\Any是引用类型，所以值42会被装箱</code></pre><p><strong>Any是非空类型，所以Any类型的变量不可以持有null值。Kotlin中想要持有任何可能的变量，包括null在内，必须使用Any?类型。</strong></p><blockquote><p>在底层，Any类型对应java.lang.Object。Kotlin把Java方法参数和返回类型中用到的Object类型看作Any（更确切的说是当作平台类型，因为其可空性是位置的）。当Kotlin函数使用Any时，它会被编译成Java字节码中的Object。</p></blockquote><blockquote><p>这是匿名函数在使用两种不同的类型作为返回时自动使用Any类型。</p><pre><code class="kotlin">    val printNumberReturn = { numberInt: Int -&gt;        when (numberInt) {            1 -&gt; &quot;输入1返回字符1&quot;            2 -&gt; &quot;输入2返回字符2&quot;            3 -&gt; &quot;输入3返回字符3&quot;            4 -&gt; &quot;输入4返回字符4&quot;            5 -&gt; &quot;输入5返回字符5&quot;            6 -&gt; &quot;输入6返回字符6&quot;            7 -&gt; &quot;输入7返回字符7&quot;            else -&gt; -1        }    }    println(printNumberReturn(7))    println(printNumberReturn(10))------------------------------输入7返回字符7-1</code></pre></blockquote><h3 id="6-2-5-Unit-类型：Kotlin的“void”"><a href="#6-2-5-Unit-类型：Kotlin的“void”" class="headerlink" title="6.2.5 Unit 类型：Kotlin的“void”"></a>6.2.5 Unit 类型：Kotlin的“void”</h3><p><strong>Kotlin中的Unit类型和Java中void是一样的功能</strong>。在函数没有什么需要返回的时候，Unit可以用作函数的返回类型：</p><pre><code class="kotlin">fun f(): Unit{...}fun f(){...}    //省略Unit声明</code></pre><p>两个代码块的结果是相同的。</p><p>大多数情况下你不会留意到void和Unit之间的区别。<strong>如果你的Kotlin函数使用Unit作为返回类型并且没有重写泛型函数，在底层它会被编译成旧的void函数。如果你要在Java中重写这个函数，新的Java函数需要返回void。</strong></p><p><strong>Kotlin中的Unit和Java中的void到底有那些不同？</strong></p><blockquote><p>Unit是一个完整的类型，可以作为类型参数，而void却不行。只存在值是Unit类型，这个值也叫Unit，并且会被隐式地返回。当你在重写返回泛型参数的函数</p><p>时会非常有用只需要让方法返回Unit类型的值：</p><pre><code class="kotlin">interface Processor&lt;T&gt;{    fun process():T}class NoResultProcessor:Processor&lt;Unit&gt;{    override fun process(){    // 返回 Unit ，这里可以省略类型说明        // do stuff    }    // 这里不需要显式的return}</code></pre><p>接口签名要求process函数返回一个值；而且，因为Unit类型确实有值，所以从方法中返回它并没有问题。然而你不需要在NoResultProcessor.process函数中写上显式的return语句，因为编译器会隐式地加上return Unit.</p></blockquote><p>在与Java对比中，Java中为了解决使用“没有值”作为类型参数的任何一个可能解法，都没有Kotlin好用。一种是分开接口定义来表示需要和不需要返回值的接口（如Callable和Runnable）。另一种使用特殊的java.lang.Void类型作为类型参数。即便你使用了后面这种方法，你还是需要加入return null；语句来返回唯一能匹配这个类型的值，因为只要返回类型不是void，你就必须始终有显式的return语句。</p><p>在函数式编程语言中，Unit这个名字习惯上被用来表示“只有一个实例”，这正是Kotlin和Java的void的区别。</p><h3 id="6-2-6-Nothing类型：“这个函数永不返回”"><a href="#6-2-6-Nothing类型：“这个函数永不返回”" class="headerlink" title="6.2.6 Nothing类型：“这个函数永不返回”"></a>6.2.6 Nothing类型：“这个函数永不返回”</h3><p><strong>解释了为什么要创建Nothing类型</strong></p><blockquote><p>对于某些Kotlin函数来说，“返回类型的概念没有任何意义，因为它从来不会成功地结束。例如，许多测试库都有一个叫fail的函数，它通过抛出带有特定信息的异常来让当前测试失败。一个包含无限循环的函数也永远不会成功地结束。</p></blockquote><p>分析调用函数代码时，知道函数永远不会正常结束是很有帮助的。Kotlin 使用Nothing这种特殊的返回类型来表示:</p><pre><code class="kotlin">fun fail(message:String):Nothing{    throw IllegalStateException(message)}&gt;&gt;&gt; fail(&quot;Error occurred&quot;)java.lang.IllegalStateException:Error occurred</code></pre><p>Nothing 类型没有任何值，只有被当作函数返回值使用，或者被当作泛型函数返回值的类型参数使用才会有意义。在其他情况下，声明一个不能存储任何值的变量是没有意义的。</p><p>Nothing函数可以放在Elvis运算符的右边来做先决条件检查：</p><pre><code class="kotlin">val address = company.address?:fail(&quot;No address&quot;)println(address.city)</code></pre><p><strong>编译器知道这种返回类型的函数从不终止，然后在分析调用这些函数的代码时利用这个信息。</strong>上例，编译器会把address的类型推断成非空，因为它为null时的分支处理会始终抛出异常。</p><h2 id="6-3-集合与数组"><a href="#6-3-集合与数组" class="headerlink" title="6.3 集合与数组"></a>6.3 集合与数组</h2><p>Kotlin以Java集合库为基础构建，并通过扩展函数增加的特性来增强它。</p><h3 id="6-3-1-可空性和集合"><a href="#6-3-1-可空性和集合" class="headerlink" title="6.3.1 可空性和集合"></a>6.3.1 可空性和集合</h3><p>我们讨论了可空类型的概念，但仅仅简略的谈到类型参数的可空性。对前后一致的类型系统来说十分关键<strong>：知道集合是否可以持有null元素，和知道变量值是否可以为null同等重要。Kotlin完全支持类型参数的可空性。就像变量的类型可以加上？字符来表示变量可以持有null一样，类型在被当作类型参数时也可以用同样的方式标记。</strong></p><p>这个函数从一个文件中读取文本行的列表，并尝试把每一行文本解析成数字。</p><pre><code class="kotlin">/*    创建一个可以包含可空值的集合    */fun readNumbers(reader: BufferedReader): List&lt;Int?&gt;{    var result = ArratList&lt;Int?&gt;()    //创建包含可空Int值的列表    for (line in reader.lineSequence()){        try{            val number = line.toInt()            result.add(number)    // 向列表中添加整数（非空）        }        catch(e: NumberFormatException){            result.add(null)    //向列表添加 null，因为当前行不能被解析成整数。        }    }    return result}</code></pre><blockquote><p><strong>如果这一行文本被解析，那么就向result列表中添加一个整数，否则添加null。List&lt;Int?&gt;是能持有Int?类型值的列表：换句话说，可以持有Int或者null。（集合中可以存放null值）。从Kotlin1.1中，可以使用函数String.toIntOrNull来简化例子，字符串不能被解析的时候会返回null。</strong></p></blockquote><p><strong>变量自己的可空性</strong>和用<strong>作类型参数的类型的可空性是有区别的。</strong>包含<strong>可空Int</strong>的列表和<strong>包含Int的可空列表</strong>之间是有区别的。如下：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210426224838.png" alt="要小心决定什么是可空的：集合的元素还是集合本身？"></p><p>第一种情况，列表本身始终不为null，列表中的每个值都可以为null。第二种类型的变量可能包含空引用而不是列表实例，<strong>但列表中的元素始终保持非空的。</strong></p><p>在另一种上下文中，<strong>你可能需要声明一个持有可空的列表，并且包含可空的数字。</strong>Kotlin中的写法是List&lt;Int?&gt;?，有两个问号。在使用变量自己值的时候，<strong>以及使用列表中每个元素的时候，需要使用null检查。（因为内容可能为空，所以在使用时需要做null检查）</strong></p><p><strong>如何使用可空值的列表，</strong>如下函数计算列表中有效数字之和，并单独的对无效数字计数。</p><pre><code class="kotlin">/*    使用可空值集合    */fun addValidNumbers(numbers:List&lt;Int?&gt;){    var sumOfValidNumbers = 0    var invalidNumbers = 0    for (number in numbers){    //从列表中读取可空值        if (number != null){    //检查值是否为null            sumOfValidNumbers +=number        }else {            invalidNumbers++        }    }    println(&quot;Sum of valid numbers: $sumOfValidNumbers&quot;)    println(&quot;Invalid numbers: $invalidNumbers&quot;)} &gt;&gt;&gt; val reader = BufferedReader(StringReader(&quot;1\nabc\n42&quot;)) &gt;&gt;&gt; val numbers = readNumber(reader) &gt;&gt;&gt; addValidNumbers(numbers) Sum of valid numbers: 43 Invalid numbers:1</code></pre><p>当你访问一个列表中的元素时，你得到的是一个类型为Int?的值，并且要在用它进行算数运算之前检查它是否为null。</p><p><strong>Kotlin 提供了标准库函数filterNotNull函数，用来遍历一个包含可空值的集合并过滤掉null的操作。</strong></p><pre><code class="kotlin">fun addValidNumbers(numbers:List&lt;Int?&gt;){    val validNumbers = numbers.filterNotNull()    println(&quot;Sum of valid numbers:${validNumbers.sum()}&quot;)    println(&quot;Invalid numbers:${numbers.size - validNUmbers.size}&quot;)}</code></pre><p>过滤影响了集合的类型。validNumbers的类型是List<Int>，因此过滤保证了集合不会再包含任何为null的元素。</p><h3 id="6-3-2-只读集合与可变集合"><a href="#6-3-2-只读集合与可变集合" class="headerlink" title="6.3.2 只读集合与可变集合"></a>6.3.2 只读集合与可变集合</h3><p><strong>集合分为两种：只读集合和可变集合</strong></p><p>Kotlin 的集合设计和Java不同的另一个重要特质是，<strong>它把访问集合数据的接口和修改集合数据的接口分开了。</strong>这种区别存在于最基础的使用集合之中：kotlin.collection.Collection。使用这个接口，可以遍历集合中的元素、获得集合的大小、判断集合中是否包含某个元素，以及执行其他从集合中读取数据的操作。<strong>但这个接口没有任何添加或移除元素的返回</strong>。</p><p><strong>使用kotlin.collection.MutableCollection接口可以修改接口中的数据。</strong>它继承了普通的kotlin.collections.Collection接口，并提供了方法来添加和移除、清空集合等。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210510115136.png" alt="MutableCollection继承了Collection并增加了修改集合内容的方法。"></p><p>通常规则是在代码的任何地方都应该使用只读接口，只在代码需要修改集合的地方使用可变接口的变体。</p><p>就像 val 和 var 之间的分离一样，只读集合接口和可变集合接口的分离能让程序中的数据发生的事情更容易理解。如果函数接收Collection而不是MutableCollection作为形参，你就知道它不会修改集合，而只是读取集合中的数据。如果函数要求你传递给它MutableCollection，可以认为它将会修改数据。如果你使用了集合作为组件部状态的一部分，可能需要把集合先拷贝一份传递给这个函数（这种模式通常称为 <strong>防御式拷贝</strong>）。</p><pre><code class="kotlin">/*    使用只读集合接口与可变集合接口    */fun &lt;T&gt; copyElemets(source: Collection&lt;T&gt;,                    target: MutableCollection&lt;T&gt;){    for (item in source){    // 在source集合中的所有元素中循环        target.add(item)    // 向可变的target集合中添加元素    }}&gt;&gt;&gt; val source:Collection&lt;Int&gt; = arrayListOf(3,5,7)&gt;&gt;&gt; val target:MutableCollection&lt;Int&gt; = arratListOf(1)&gt;&gt;&gt; copyElements(source,target)&gt;&gt;&gt; println(target)[1,3,5,7]</code></pre><p><strong>只读集合类型不能作为可变集合的参数。</strong>不能把只读集合类型的变量作为target参数传给函数，即便它的值是一个可变集合：</p><pre><code class="kotlin">&gt;&gt;&gt; val source:Collection&lt;Int&gt; = arrayListOf(3,5,7)&gt;&gt;&gt; val target:Collection&lt;Int&gt; = arratListOf(1)&gt;&gt;&gt; copyElements(source,target)Error: Type mismatch:inferred type is Collection&lt;Int&gt;    but MutableCollection&lt;Int&gt; was expected</code></pre><p>使用集合接口时需要牢记的关键点是 <strong>只读集合是不一定可变的。</strong>如果你使用的变量只有一个只读接口类型，它可能只是同一个集合的众多引用中的一个。任何其他的引用都可能拥有一个可变接口类型。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210516151639.png" alt="两种不同的引用，一个只读，另一个可变，指向同一个集合对象"></p><p>如果你调用了这样的代码，它<strong>持有其他指向你集合的引用</strong>，或者并行的运行了这样的代码。你依然会遇到这种状况，你正在使用集合的时候它被其他代码修改了，则会导致concurrentModificationException错误和其他一些问题。因此，<strong>必须了解只读集合并不总是线程安全的。如果你在多线程环境下处理数据，你需要保证代码正确的同步的对数据的访问，或者使用支持并发访问的数据结构。</strong></p><h3 id="6-3-3-Kotlin集合和Java"><a href="#6-3-3-Kotlin集合和Java" class="headerlink" title="6.3.3 Kotlin集合和Java"></a>6.3.3 Kotlin集合和Java</h3><p><strong>Kotlin接口是Java接口的实例</strong>。每一个Kotlin接口都是其对应Java集合接口的一个实例。在Kotlin和Java之间转移并不需要转换；不需要包装器也不需要拷贝数据。但每个Kotlin中都有两种表示：一种是只读一种是可变的。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210516154303.png" alt="Kotlin集合接口的层级结构，Java类ArrayList和HashSet都继承了Kotlin可变接口"></p><p>Kotlin中只读接口和可变接口的基本构造与 Java.util中的Java集合接口的构造是平行的。可变接口直接对应java.util中的接口，而它们的只读版本缺少了所有产生改变的方法。</p><p>Kotlin中Map类（并没有继承Collection或是Interable）也被表示成了两种不同的版本：Map和MutableMap。表中展示了不同集合的函数。</p><table><thead><tr><th>集合类型</th><th>只读</th><th>可变</th></tr></thead><tbody><tr><td><strong>List</strong></td><td>listOf</td><td>mutableListOf、arrayListOf</td></tr><tr><td><strong>Set</strong></td><td>setOf</td><td>mutableSet、hashSetOf、linkedSetOf、sortedSetOf</td></tr><tr><td><strong>Map</strong></td><td>mapOf</td><td>mutableMapOf、hashMapOf、linkedMapOf、sortedMapOf</td></tr></tbody></table><p><strong>注意，setOf()和mapOf()返回的是Java标准库中类的实例（至少在Kotlin1.0版本中是这样），在底层它们都是可变的。但你不能完全信赖这一点：Kotlin的未来版本可能会使用真正不可变的实现类作为setOf和mapOf的返回值。</strong></p><blockquote><p><strong>Set集合</strong></p><p>在set集合中只包含不相同元素，也就是说相同类型会被移除。</p><p>elementAt函数</p><pre><code class="kotlin">fun main() {    val set = setOf&lt;String&gt;(&quot;one&quot;, &quot;two&quot;, &quot;3&quot;, &quot;3&quot;)    println(set.elementAt(1))    println()    println(set.elementAt(4))}</code></pre><p>描述</p><p>返回给定index处的元素，如果超出边界抛出 ：[IndexOutOfBoundsException] 异常。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220413162419.png" alt=""></p></blockquote><blockquote><p><strong>集合之间的快速转换</strong></p><p>toSet()函数转换到Set集合类型</p><pre><code class="kotlin">fun main() {    var list = listOf&lt;String&gt;(&quot;one&quot;, &quot;two&quot;, &quot;3&quot;, &quot;3&quot;)    println(list)//    转换到toSet去除重复元素    val set = list.toSet()    println(set)//    转换到List类型    list = set.toList()    println(list)//    使用distinct去除重复元素    list += &quot;3&quot;    println(list.distinct())}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/img/20220414002233.png" alt=""></p></blockquote><blockquote><p><strong>Map集合</strong></p><p><strong>获取Map集合的值，getOrDefault函数</strong></p><p>按照键值对获取值，在值为null时返回参数 defaultValue中的值</p><pre><code class="kotlin">fun main() {//    创建集合键值对喂String与Int类型 val map = mapOf&lt;String, Int&gt;(Pair(&quot;one&quot;, 1), Pair(&quot;two&quot;, 2))//    获取键为 “one” 的值 println(map[&quot;one&quot;])//    使用 getOrDefault获取值    ,没有找到键值会返回 defaultValue = 0 val defaultValue = map.getOrDefault(&quot;two&quot;, 0) println(defaultValue)}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/img/20220414224017.png" alt=""></p><p><strong>遍历Map集合</strong></p><pre><code class="kotlin">fun main() { val map = mapOf&lt;String, Int&gt;(Pair(&quot;one&quot;, 1), Pair(&quot;two&quot;, 2), &quot;three&quot; to 3)//  通过forEach获取遍历键和值，使用匿名函数获取 map.forEach { print(&quot;${it.key} ${it.value} \n&quot;) } println(&quot;--------------&quot;)//    通过for获取每个元素 ，key表示元素 for (key in map) {     print(&quot;${key.key} ${key.value} \n&quot;) }}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/img/20220414230641.png" alt=""></p><p><strong>可变Map添加元素</strong></p><pre><code>fun main() {    val map = mutableMapOf&lt;String, Int&gt;(Pair(&quot;Li&quot;, 10), Pair(&quot;Liu&quot;, 20), &quot;Wang&quot; to 23)    map += &quot;Song&quot; to 12    map += Pair(&quot;Zhou&quot;, 15)    map[&quot;Tian&quot;] = 16//    put函数在添加完成后如果key存在返回替换前的值，不存在返回null    println(map.put(&quot;Zhou&quot;, 18))    println(map)}</code></pre><p>put函数</p><p>按照key与参数value进行关联，在添加时如果存在就返回之前的值并添加新值。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/img/20220415174643.png" alt=""></p></blockquote><p><strong>当你需要调用Java方法并把集合作为参数时。例如：使用java.util.Collection做为形参，你可以使用Collection或MutableCollection（只读集合或可变集合）的值作为实参传递给形参。</strong></p><p><strong>这时的操作对可变性有重要影响。因为Java并不会区分只读集合与可变集合，即使Kotlin中把集合声明成只读的，Java代码也可以修改这个集合。Kotlin编译器不能完全的分析Java代码到底对集合做了什么，因此Kotlin无法拒绝向可以修改集合的Java代码传递只读Colleciton。</strong>例如，如下代码组成了一个多语言兼容的Kotlin/Java程序：</p><pre><code class="java">/*    Java    *///    ColletionUtils.Javapublic class ColletionUtils{    public static List&lt;String&gt; uppercaseAll(List&lt;String&gt; items){        for(int i = 0 ;i &lt; items.size(); i++){            items.set(i,items.get(i).toUpperCase());        }        return items    }}</code></pre><pre><code class="kotlin">/*    Kotlin    */// collections.ktfun printInUppercase(list:List&lt;String&gt;){    // 声明只读的参数    println(CollectionUtils.uppercaseAll(list))    //调用可以修改集合的Java函数    println(list.first())    //打印被修改过的集合}&gt;&gt;&gt; val list = listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)&gt;&gt;&gt; printInUpppercase(list)[A,B,C]A</code></pre><p><strong>如果你写了Kotlin函数，使用集合并传递给了Java，这时你要确认使用了正确的参数类型，同时取决于你调用的Java代码是否会修改集合。</strong></p><p>注意，<strong>这些也适用于包含非空类型元素的集合类。</strong>如果你向Java方法传递了这样的集合，该方法就可能在其中写入null值；Kotlin没有办法再不影响性能的情况下，禁止它的发生，或者察觉到已经发生的改变。因此，当你向可以修改集合的Java代码传递集合的时，你需要采取特别的预防措施，来确保Kotlin类型正确的反映出集合上所有可能的修改。</p><h3 id="6-3-4-作为平台类型的集合"><a href="#6-3-4-作为平台类型的集合" class="headerlink" title="6.3.4 作为平台类型的集合"></a>6.3.4 作为平台类型的集合</h3><p><strong>Kotlin集合作为平台类型的集合</strong></p><p><strong>平台类型不会理会可空或者非空，所以在Kotlin重写或实现平台类型时需要选择集合是否可空。</strong></p><p><strong>Kotlin 把定义在java代码中的类型看成平台类型。</strong>Kotlin没有任何关于平台类型的可空性信息，所以编译器允许Kotlin代码将其视为可空或者非空的。同样，Java中声明的集合类型的变量也被视为平台类型。<strong>一个平台类型集合本质上就是可变性未知的集合——Kotlin代码将其视为只读的或者可变的。</strong>实际上你想要执行的所有操作都不受影响。</p><p><strong>当你重写或者实现签名中有集合类型的Java方法时这种差异才变的重要。</strong>这里像平台类型的可空性一样，你需要决定使用那种 <strong>Kotlin类型 *<em>来表示这个Java类型， *</em>它来自你要重写或实现的方法。</strong></p><p>在重写或者实现时，你要做出多种选择，<strong>它们都会反映在产生的Kotlin代码类型中:</strong></p><ul><li>集合是否可空？</li><li>集合的元素是否可空？</li><li>你的方法会不会修改集合？</li></ul><p>代码中直观的表示。一个Java接口表示一个能处理文件中的文本对象。</p><pre><code class="java">/*    使用集合参数的Java接口    */interface FileContentProcessor{    void processContents(File path,        byte[] binaryContents,        List&lt;String&gt; textContents);}</code></pre><p>这个接口的Kotlin实现需要做出如下选择：</p><ul><li>列表将是可空的，因为有些文件是二进制格式，它们的内容不能被表示成文本。</li><li>列表中的元素将会是非空的，因为文件中每一行都永远不为null。</li><li>列表将是可读的，因为它表示的文本内容，而且这些内容不会被修改。</li></ul><p>实现的样子</p><pre><code class="kotlin">/*    FileContentProcessor 的Kotlin实现    */class FileIndexer:FileContentProcessor{    override fun processContents(path:File,        binaryContents:ByteArray?,        textContents:List&lt;String&gt;?){            ....        }}</code></pre><p>与另一个接口对比。这里接口的实现从文本表单中解析出的数据并放大一个对象列表中，再把这些对象附加到输出列表中。当发现解析失败时，就把错误信息添加到另一个单独的列表中，作为错误日志。</p><pre><code class="java">/*    另一个集合参数的Java接口    Java*/interface DataParser&lt;T&gt;{    void parseData(String input,        List&lt;T&gt; output,        List&lt;String&gt; errors);}</code></pre><p>这种情况下的选择：</p><ul><li>List<String> 将是非空的，因为调用者总是需要接收错误的信息。</li><li>列表的元素将是可空的，因为不是每个输出列表中的条目都有关联的错误信息。</li><li>List<String> 将是可变的，因为代码实现需要向其中添加元素。</li></ul><p>实现这个接口</p><pre><code class="kotlin">/*    DataParser的Kotlin实现    */class PersonParser: DataParser&lt;Person&gt;{    override fun parseData(input:String,        output:MutableList&lt;Person&gt;,        error:MutableList&lt;String?&gt;){            //...        }}</code></pre><p>注意，同样为Java类型——List<String>——如何表示成了两种不同的Kotlin类型：一种是List<String>?（包含字符串的可空列表），另一个是MutableList&lt;String?&gt;（包含可空字符串的可变列表）。你必须知道Java接口或类必须遵守的确切契约。基于你的实现要做的事情通常很容易理解。</p><h3 id="6-3-5-对象和基本数据类型的数组"><a href="#6-3-5-对象和基本数据类型的数组" class="headerlink" title="6.3.5 对象和基本数据类型的数组"></a>6.3.5 对象和基本数据类型的数组</h3><p>默认情况下，你应该优先使用集合而不是数组。但是因为有大量JavaAPI仍然在使用数组，所以来介绍它们在Kotlin中如何使用。</p><p>Kotlin 数组的语法出现在了每个例子中， <strong>因为数组是 Java main 函数标准签名的一部分。</strong></p><blockquote><p>方法签名：</p><p>方法签名由方法名+形参列表组成，目的是让此方法确定为唯一的。</p></blockquote><pre><code class="kotlin">/*    使用数组    */fun main(args:Array[String]){    for (i in args.indices){    // 使扩展属性array.indeces在下标的访问内迭代        pritnl(&quot;Argument $i is :${args[i]}&quot;)    //通过下标使用 array[index] 访问元素    }}</code></pre><p> Kotlin中的数组是一个带有类型参数的类，其元素类型被指定为相应的类型参数。</p><p><strong>要在Kotlin中创建数组，如下方法供你选择</strong></p><blockquote><ul><li>arrayOf函数创建数组，它包含元素是指定为该函数的实参。</li><li>arrayOfNulls创建一个给定大小的数组，包含为null元素。当然，它只能用来创建包含元素类型的可空数组。</li><li>Array构造方法接收数组大小和一个lambda表达式，使用lambda表达式来创建每一个数组元素。这就是使用元素类型来初始化数组，当不用显式地传递每个元素的方式。</li></ul></blockquote><p>展示如何使用Array函数来创建“a”到”z”的字符串数组。</p><pre><code class="kotlin">/*    创建字符数组    */&gt;&gt;&gt; val letters = Array&lt;String&gt;(26){i-&gt;(&#39;a&#39;+i).toString()}&gt;&gt;&gt; pritnln(letters.joinToString(&quot;&quot;))abcdefghijklmnoprstuvwxyz</code></pre><p>为了清楚起见，这里显示了数组元素的类型，但在真实的代码中可以省略。因为编译器会推导出它的类型。</p><blockquote><p>Kotlin <strong>代码中最常见的创建数组的情况之一是需要调用参数为数组的Java方法</strong>，或是在调用带有vararg参数的Kotlin函数时。这种情况下，通常已经将数据存储在集合中，只需要将其转换为数组即可。可以使用toTypedArray方法来执行此操作。</p><pre><code class="kotlin">/*    向vararg方法传递集合    */&gt;&gt;&gt; val string = listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)&gt;&gt;&gt; pritnln(&quot;%s/%s/%s&quot;.format(*strings.toTypedArray()))    // 期望vararg参数时使用展开运算符(*)传递数组a/b/c</code></pre></blockquote><blockquote><p>数组类型的类型参数始终会变成对象类型。<strong>因此，如果你声明了一个Array<Int>,它将会是一个包含装箱整型的数组（它的Java类型将是java.lang.Integer[])。如果你需要创建没有装箱的基本数据类型的数组，必须使用一个基本数据类型数组的特殊类。</strong></p></blockquote><p>为表示基本数据类型的数组，Kotlin提供了若干独立的类，每一个基本数据类型都对应一个。例如，Int类型值的数组叫做IntArray。</p><p>要创建一个基本数据类型的数组，你有如下选择：</p><ul><li><strong>该类型的构造方法接收size参数并返回一个使用对应基本数据类型默认值（通常是0）初始化好滴数组。</strong></li><li><strong>工厂函数（IntArray的intArrayOf，以及其他数组类型的函数）接收边长参数的值并创建存储这些的数组。</strong></li><li><strong>另一个构造方法，接受一个大小和一个用来初始化元素的lambda</strong></li></ul><p>例子</p><pre><code class="kotlin">/*    下面创建存储了5个0的整形数组的两种选择    */&gt;&gt;&gt; val fiveZeros = IntArray(5)    //默认值 0&gt;&gt;&gt; val fiveZerosToo = intArrayOf(0,0,0,0,0)</code></pre><pre><code class="kotlin">/*    下面接收lambda的构造方法的例子    */&gt;&gt;&gt; val squares = IntArray(5){i-&gt;(i+1)*(i+1)}&gt;&gt;&gt; println(squares.joinToString())1,4,9,16,25</code></pre><blockquote><p><strong>假如你有一个持有基本数据类型装箱后的值的数组或者集合，</strong>可以使用对应的转换函数把它们转换成基本数据类型的数组，例如toIntArray。</p></blockquote><blockquote><p><strong>我们来看看你可是对数组做的事情。</strong>处理基本操作外（获得数组长度，获取或者设置元素），Kotlin标准库支持一套和集合相同的用于数组的扩展函数。其中（filter，map等）也适用于数组，包括基本数据类型的数组（注意这些返回值返回的是列表不是数组）。</p><pre><code class="kotlin">/*    使用forEachIndexed函数加上lambda来重写”使用数组“例子    */fun main(args:Array&lt;String&gt;){    atgs.forEachIndexed{index,elemnt -&gt;        println(&quot;Argument $index is: $element&quot;)}}</code></pre></blockquote><h3 id="6-4-小结"><a href="#6-4-小结" class="headerlink" title="6.4 小结"></a>6.4 小结</h3><ul><li>Kotlin对空类型的支持，可以帮助我们在编译期，检测出潜在的NullPointerException错误。</li><li>Kotlin提供了安全调用（?.）、Elvis运算符（?:）、非空断言（!!）及let函数这些工具来简洁的处理可空类型。</li><li>as?运算符提供了一个简单的方式来把值转换成一个类型，以及处理当它拥有不同类型时的情况。</li><li>Java中的类型在Kotlin中被解释成平台类型，允许开发者把它们当作可空或非空来对待。</li><li>表示基本数据类型（如Int）看起来用起来都像普通的类，但通常会被编译成Java基本数据类型。</li><li>可空的基本数据类型（如Int?）对应着Java中的装箱基本数据类型（如java.lang.Integer）。</li><li>Any类型是所有其他类型的超类型，类似于Java的Object。而Unit类比于void。</li><li>不会正常终止的函数使用Nothing类型作为返回类型。</li><li>Kotlin使用标准Java集合类，并通过区分只读和可变集合来增强它们。</li><li>当你在Kotlin中继承Java类或者实现Java接口时，你需要自己考虑参数的可空性和可变性。</li><li>Kotlin的Array类就像普通的泛型，但它会被编译成Java数组。</li><li>基本数据类型的数组使用像IntArray这样的特殊类来表示。</li></ul><h1 id="7-运算符重载及其他约定"><a href="#7-运算符重载及其他约定" class="headerlink" title="7 运算符重载及其他约定"></a>7 运算符重载及其他约定</h1><blockquote><ul><li>运算符重载</li><li>约定：支持各种运算的特殊命名函数</li><li>委托属性</li></ul></blockquote><h1 id="8-高阶函数：Lambda作为形参和返回值"><a href="#8-高阶函数：Lambda作为形参和返回值" class="headerlink" title="8 高阶函数：Lambda作为形参和返回值"></a>8 高阶函数：Lambda作为形参和返回值</h1><p><strong>内联函数作用</strong></p><p>能够消除lambda带来的性能开销，还能够使lambda内的控制流更加灵活。</p><h2 id="8-1-声明高阶函数"><a href="#8-1-声明高阶函数" class="headerlink" title="8.1 声明高阶函数"></a>8.1 声明高阶函数</h2><p>定义</p><blockquote><p>高阶函数就是以另一个函数作为参数或者返回值的函数。在kotlin中，函数可以用lambda或者函数引用来表示。因此，<strong>任何以lambda或者函数引用作为参数的函数，或者返回值为lambda或函数引用的函数</strong>，或者两者都有满足的函数都是高阶函数。</p></blockquote><p>标准库中的filter函数将一个判断式函数作为参数，因此它是一个高阶函数：</p><pre><code class="kotlin">list.filter{x&gt;0}</code></pre><h3 id="8-1-1-函数类型"><a href="#8-1-1-函数类型" class="headerlink" title="8.1.1 函数类型"></a>8.1.1 函数类型</h3><p>在变量中我们有<strong>Int类型</strong>，<strong>String类型</strong>等那么也有属于函数的<strong>函数类型</strong>。</p><p>声明一个lambda作为实参的函数，你需要知道如何声明对应形参的类型。在那之前，看接下来的例子，把 lambda 表达式保存在局部变量中。在不声明类型的情况下，这些就依赖于Kotlin的类型推导。</p><pre><code class="kotlin">val sum = {x:Int,y:Int -&gt; x+y}val action = {println(42)}</code></pre><p>编译器推导出sum和action两个变量具有<strong>函数类型</strong>。</p><p>显式声明<strong>函数类型的变量</strong></p><pre><code class="kotlin">val sum:(Int ,Int) -&gt; Int = {x,y-&gt;x+y}    // 有两个Int类型参数和Int类型返回值val action:() - &gt; Unit = { println(42) }    //没有参数和返回值</code></pre><p>声明函数类型，需要将函数参数类型放在括号中，紧接着是一个箭头和函数的返回值类型。</p><pre><code class="kotlin">(Int,String) -&gt; Unit// ↑参数类型    ↑返回类型</code></pre><p>在声明函数类型时Unit是不能省略的，其他情况下可以。</p><p>函数类型的返回值标记为可空类型：</p><pre><code class="kotlin">val canReturnNull: (Int,Int) -&gt; Int?={null}</code></pre><p>定义函数类型的可空变量。</p><blockquote><p>为了明确表示是变量本身可空，而不是函数类型的返回类型可空，你需要将整个函数类型的定义包含在括号内并在括号后添加问号。</p><pre><code class="kotlin">val funOrNull:((Int,Int) -&gt; Int) ?= null</code></pre></blockquote><h3 id="8-1-2-调用作为参数的函数"><a href="#8-1-2-调用作为参数的函数" class="headerlink" title="8.1.2 调用作为参数的函数"></a>8.1.2 调用作为参数的函数</h3><p>实现一个高阶函数。</p><p>实现2，3两个数字的任意操作。</p><blockquote><p>函数类型作为参数，形参和实参更像是接口，形参是接口实参则用来具体的实现。</p></blockquote><p>定义一个简单的高阶函数</p><pre><code class="kotlin">//    定义一个函数类型的参数fun twoAndThree(operation: (Int,Int) -&gt; Int){    val result = opration(2,3)    // 调用参数（函数类型）    println(&quot;The result is $result&quot;)}&gt;&gt;&gt; twoAndThree{a,b -&gt; a+b}The result is 5&gt;&gt;&gt; twoAndThree(a,b -&gt; a*b)The result is 6</code></pre><p>实现最常用的标准库函数：filter函数。为了更让事情更简单一些，将实现基于String类型的filter函数，但和作用于泛型的版本原理是显示的。</p><pre><code class="kotlin">/* &quot;String&quot;:接收者类型。    “predicate”：参数类型    “(Char) -&gt; Boolean”：函数类型参数    “Char”:函数类型参数的参数类型    “Boolean”：函数类型的参数返回类型    */fun String.filter(predicate:(Char) -&gt; Boolean):String</code></pre><blockquote><p>filter 函数的声明，以一个判断式作为参数</p></blockquote><p>判断式的类型是一个函数，以字符作为参数并返回boolean类型的值。如果要让传递给判断式的字符出现在最终返回的字符串中，判断式需要返回ture，反之false。</p><pre><code class="kotlin">//    实现一个简单版本的filer函数fun String.filter(predicate: (Char) -&gt; Boolean):String{    val sb = StringBuilder()    for (index in 0 until length){        val element = get(index)        if (predicate(element)) sb.append(element)    // 调用引用的String类型参数给predicate函数进行判断    }    return sb.toString()}&gt;&gt;&gt; println(&quot;ab1c&quot;.filter{it in &#39;a&#39;..&#39;z&#39;})    //传递 lambda 作为 &#39;predicate&#39;参数abc</code></pre><blockquote><p>filter 函数的实现非常简单明了。它检查每个字符时候满足判断式，如果满足就将字符添加到包含结果的StringBuilder中。</p></blockquote><blockquote><p><strong>访问时作为参数的函数</strong></p><p>reposeResult作为参数在编写时调用，在其它地方实现。</p><pre><code class="kotlin">fun main() {    loginAPI(&quot;TestFun&quot;, &quot;12354&quot;) { msg, code -&gt;        println(&quot;登录 msg :$msg, code:$code&quot;)    }    loginAPI(&quot;TestFun213&quot;, &quot;12354&quot;) { msg, code -&gt;        println(&quot;登录 msg :$msg, code:$code&quot;)    }    }const val USER_NAME_SAVE_DB = &quot;TestFun&quot;const val USER_PWD_SAVE_DB = &quot;12354&quot;fun loginAPI(username: String, userpwd: String, responseResult: (String, Int) -&gt; Unit) {    if (username == null || userpwd == null) {        TODO(&quot;出现问题停止运行&quot;)    }    if (username.length &gt; 3 &amp;&amp; userpwd.length &gt; 3) {        if (webServiceLoginAPI(username, userpwd)) {//            登陆成功            responseResult(&quot;login sourcess&quot;, 200)        } else {//            登陆失败            responseResult(&quot;login error&quot;, 400)        }    } else {        TODO(&quot;“不合格 出现问题 &quot;)    }}private fun webServiceLoginAPI(name: String, pwd: String): Boolean {    return name == USER_NAME_SAVE_DB &amp;&amp; pwd == USER_PWD_SAVE_DB}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220330000438.png" alt="一次为存在的账号，一次为不存在的账号"></p></blockquote><h3 id="8-1-3-在Java中使用函数类"><a href="#8-1-3-在Java中使用函数类" class="headerlink" title="8.1.3 在Java中使用函数类"></a>8.1.3 在Java中使用函数类</h3><p><strong>原理</strong></p><blockquote><p>函数类型被声明为普通的接口：一个函数类型的变量是<strong>FunctionN接口的实现</strong>。</p><p>Kotlin 标准库定义了一系列的接口，这些接口对应于不同的参数数量的函数：<strong>Function0<R>(没有参数的函数)、Function&lt;P1,R&gt;(一个参数的函数)</strong>。</p><p>每个接口定义了一个 invoke 方法，调用这个方法就会执行函数。</p><p>一个函数类型的变量就是实现了对应的Function接口的实现类的实力，实现类的invoke方法包含了lambda函数体。</p></blockquote><p><strong>在 Java 中调用使用了函数类型的 Kotlin 函数。</strong></p><pre><code class="kotlin">/*    kotlin声明    */fun processTheAnswer(f:(Int) -&gt;){    println(f(42))}</code></pre><pre><code class="kotlin">/*    Java    */&gt;&gt;&gt; processTheAnswe(number -&gt; number+1);43</code></pre><p>在旧版 Java 中，可以传递一个实现了函数接口中 invoke 方法的匿名类的实例：</p><pre><code class="java">/*    Java    */&gt;&gt;&gt; processTheAnswer(...        new Function1&lt;Integer,Integer&gt;(){    // 在Java 8 以前使用函数类型...            @Override...            public Integer invoke(Integer number){...                System.out.println(number);...                return number+1;...                }...        });43</code></pre><p>在 Java 中使用函数类型必须显示地传递一个接收者对象作为第一个参数。</p><p>在Java中可以很容易地使用 Kotlin 标准库中以lambda作为参数的扩展函数。</p><pre><code class="java">/*    Java    */&gt;&gt;&gt; List&lt;String&gt; strings = new ArrayList()；&gt;&gt;&gt; strings.add(&quot;42&quot;)&gt;&gt;&gt; CollectionKt.forEach(strings, s -&gt;{    //可以在Java中使用Kotlin标准库中的函数...        System.out.println(a);...        return unit.INSTANCE;    // 必须显示的返回一个Unit类型的值。...})</code></pre><blockquote><p>在 Java 中 ，函数或许lambda可以返回Unit。因为在 Kotlin 中 Unit 类型是有值的，所以需要显示的返回它。</p><p>一个返回 void 的lambda 不能作为返回 Unit 的函数类型的实参，就像之前的例子中的(String) -&gt;Unit.</p></blockquote><h3 id="8-1-4-函数类型的参数默认值和null值"><a href="#8-1-4-函数类型的参数默认值和null值" class="headerlink" title="8.1.4 函数类型的参数默认值和null值"></a>8.1.4 函数类型的参数默认值和null值</h3><p>声明函数类型的参数时可以指定参数的默认值。</p><p><strong>用来理解参数默认值的关键作用</strong></p><pre><code class="kotlin">/*    使用了硬编码toString转换的joinToString函数    */fun &lt;T&gt; Collection&lt;T&gt;.joinToString(        separator: String = &quot;,&quot;,        prefix: String = &quot;&quot;,        postfix: String = &quot;&quot;): String{        val result = StringBuilder(prefix)        for ((index,element) in this.withIndex()){            if(index &gt;0) result.append(separator)            result.append(element)    // 使用默认toString方法将对象转换成字符串        }        result.append(postfix)        return result.toString()}</code></pre><blockquote><p>这里的实现很灵活但是并没有让你控制转换的关键点： 集合中的原始是如何转换成字符串的。</p></blockquote><blockquote><p>这里使用 StringBuilder.append(o:Any?) (result.append(element)),他总是使用toString方法将对象转换成字符串。在大多数情况下这样是可以的，但是不总是这样。</p></blockquote><blockquote><p>现在可以传递一个lambda去指定如何将对象转换成字符串。</p></blockquote><blockquote><p>但是要求所有调用者都传递lambda是比较烦人的，因为大部分调用者使用默认的行为就可以了。为了解决这个问题，可以定义一个函数类型的参数并用一个lambda作为它的默认值。</p></blockquote><pre><code class="kotlin">/*    给函数类型的参数指定默认值    */fun &lt;T&gt; Collection&lt;T&gt;.joinToString(        separator: String = &quot;,&quot;,        prefix: String = &quot;&quot;,        postfix: String = &quot;&quot;,        transform: (T) -&gt; String = {it.toString()}    //声明一个lambda为默认值的函数类型的参数): String {        val result = StringBuilder(prefix)        for ((index,element) in this.withIndex()){            if(index &gt; 0 ) result.append(separator)            result.append(transform(element))    // 调用作为实参的element传递给 “transform”形参的函数        }        result.append(postfix)        return result.toString()}&gt;&gt;&gt; val letters = listOf(&quot;Alpha&quot;,&quot;Beta&quot;)&gt;&gt;&gt;  println(letters.joinToString())    // 使用默认的转换函数Alpha, Beta&gt;&gt;&gt; println(letters.joinToString{it.toLowerCase()})    // 传递一个 lambda 作为参数alpha,beta&gt;&gt;&gt; println(letters.joinToString(separator = &quot;!&quot;,postifx = &quot;!&quot;, transform = {it.ToUpperCase()}))    // 使用命名参数参数语法几个参数，包括lambda。ALPHA,BETA</code></pre><blockquote><p>这个带默认值的函数类型是一个泛型参数T表示集合中的元素类型。 Lambda transform 将接收这个类型的参数。</p></blockquote><blockquote><p>声明函数类型的默认值并不需要特殊的语法，只需要把 lambda 作为值放在 = 号后。上述例子展示了多种方式调用函数类型。</p></blockquote><p><strong>声明函数类型其参数是可空的</strong></p><pre><code class="kotlin">/*    案例1    一般情况*/fun foo(callback: (() -&gt;Unit)?){    if(callback != null){        callback()    }}</code></pre><blockquote><p>这里不能直接调用作为参数传递进行的函数：Kotlin 会因为检查到潜在的空指针异常而导致编译失败。<strong>这里可选的办法是显式地检查null</strong>。</p></blockquote><pre><code class="kotlin">/*    使用函数类型的可空参数    */fun &lt;T&gt; Collection&lt;T&gt;.joinToString(        separator: String = &quot;,&quot;,        prefix: String = &quot;&quot;,        postfix: String = &quot;&quot;,        transform:    ((T) -&gt; String ) ?=null    // 声明一个函数类型的可空参数): String{    val result = StringBuilder(prefix)    for ((index,element) in this.withIndex()){        if (index &gt; 0) result.append(separator)        val str = transform?.invoke(element)    // 使用安全调用语法，调用函数            ?: element.toString()    //使用 Elvis 运算符处理回调没有被指定的情况        result.append(str)    }    result.append(postfix)    return result.toString()}</code></pre><blockquote><p>这是一个更简单的版本，它利用了一个事实 ，函数类型是包含 invoke 方法的接口具体实现。作为一个普通方法，invoke可以通过安全调用语法被调用：callback?.invoke()方法</p></blockquote><h3 id="8-1-5-返回函数的函数"><a href="#8-1-5-返回函数的函数" class="headerlink" title="8.1.5 返回函数的函数"></a>8.1.5 返回函数的函数</h3><pre><code class="kotlin">/*    定义一个返回函数的函数    */enum class Delivery {STANDARD, EXPEDITED}class Order(val itemCount:Int)fun getShippingCostCalculator(delivery:Delivery):(Order)-&gt;Double{    // 声明返回函数的函数    if (delivery == Delivery.EXPEDITEM){    // 返回 lambda        return {order -&gt; 6+2.1 * order.itemCount}    }    return {order -&gt;1.2*order.itemCount}}&gt;&gt;&gt; val calculator = getShippingCostCalculator(Delivery.EXPEDITEM)    // 将返回的函数保存在变量中&gt;&gt;&gt; println(&quot;Shapping costs ${calculator(Order(3))}&quot;)    // 调用返回的函数Shipping costs 12.3</code></pre><blockquote><p><strong>使用场景</strong></p><p>例如，运输费用的计算依赖于选择恰当的逻辑变体并将它作为另一个函数返回。<strong>声明一个 返回另一个函数的函数，需要指定一个函数类型作为返回类型。</strong></p><p>函数 getShippingCostCalculator返回一个函数，这个函数以Order最为参数并返回一个Double类型的值。</p><p><strong>要返回一个函数，需要写一个return表达式，跟上一个lambda、一个成员引用，或者其他的函数类型的表达式，比如一个函数的局部变量。</strong></p></blockquote><blockquote><p>返回函数的函数通过。打印字符穿的长度。</p><p>returnFun返回一个获得字符长度的函数并在applyFun中调用它获得长度并打印它的长度。</p><pre><code class="kotlin">fun main() {    applyFun(&quot;testReturnFunLength&quot;)}fun applyFun(testName: String) {    val testReturnFun = returnFun()    println(&quot;$testName, 字符串的函数${testReturnFun(testName)}&quot;)}fun returnFun(): (testName: String) -&gt; Int {    return { testName -&gt; testName.length }}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220330133107.png" alt="使用了返回函数的函数方法"></p></blockquote><p><strong>另一个返回函数的例子</strong></p><blockquote><p>例如，你可以在 UI 上输入一个字符串，然后只显示那些名字以这个字符串开头的联系人；还可以隐藏没有电话号码的联系人。用ContactListFilters这个类来保存这个选项的状态。</p></blockquote><pre><code class="kotlin">class ContactListFilters{    var prefix: String = &quot;&quot;    var onlyWithPhoneNumber: Boolean = false}</code></pre><blockquote><p>当用户输入 D 来查看姓或者名以 D 开头的联系人时，prefix的值会被更新。</p></blockquote><pre><code class="kotlin">/*    在UI代码中定义一个返回函数的函数    */data class Persion(    val firstName:String,    val lastName:String,    val phoneNumber:String?)class ContactListFilters{    val prefix:String = &quot;&quot;    val onlyWithPhoneNumber: Boolean = false    fun getPredicate():(Person) -&gt; Boolean{    //声明一个返回函数的函数        val    startWithPrefix  = {p:Persion -&gt; p.firstName.startsWith(prefix) || p.lastName.startsWith(prefix)        }        if (!onlyWithPhoneNumber){            return startWithPrefix    // 返回一个函数类型的变量        }        return { startsWithPrefix(it)&amp;&amp;it.phoneNumber != null }    //从函数返回一个lambda    }}&gt;&gt;&gt; val contacts = listOf(Persion(&quot;Dmitry&quot;,&quot;Jemeroy&quot;,&quot;123-4567&quot;),...                          Persion(&quot;Svetlane&quot;,&quot;Isakova&quot;,null))&gt;&gt;&gt; val contactListFilters = ContactListFilters()&gt;&gt;&gt; with (contactListFilters){&gt;&gt;&gt;        prefix = &quot;Dm&quot;&gt;&gt;&gt;     onlyWithPhoneNumber = true&gt;&gt;&gt; }&gt;&gt;&gt; println(contacts.filter(...        contactListFilters.getPredicate()))        // 将 getPredicate 返回的函数作为参数传递给 “filter” 函数[Persion (firstName = Dmitry,lastName = Jemetov,phoneNumber = 123-4567)]</code></pre><blockquote><p>为了让展示联系人列表的逻辑代码和输入的过滤条件的UI条件解耦，可以定义一个函数来创建一个判断式，用来过滤联系人列表。判断式检查前戳，如果有需要也检查电话号码时候存在。</p></blockquote><blockquote><p>getPredicate 函数返回一个函数（类型）的值，这个值被传递给filter作为参数。</p></blockquote><h3 id="8-1-6-通过lambda-去除重复代码"><a href="#8-1-6-通过lambda-去除重复代码" class="headerlink" title="8.1.6 通过lambda 去除重复代码"></a>8.1.6 通过lambda 去除重复代码</h3><p>例子</p><blockquote><p>这是一个分析网站访问的例子。SiteVisit类用来保存每次访问的路径、持续时间和用户的操作系统。不同的操作系统使用枚举来表示。</p></blockquote><pre><code class="kotlin">/*    定义站点访问数据    */data calss SiteVisit(    val path: String,    val dutation: Double,    val os: OS    )enum class OS{ WINDOWS,LINUX,MAC,IOS,ANDROID}val log = listOf(    SiteVisit(&quot;/&quot;,34.0,OS.WINDOWS),    SiteVisit(&quot;/&quot;,22.0,OS.MAC),    SiteVisit(&quot;/login&quot;,12.0,OS.WINDOWS),    SiteVisit(&quot;/signup&quot;,8.0,OS.IOS),    SiteVisit(&quot;/&quot;,16.3.OS.ANDROID))</code></pre><blockquote><p>需要显示来自 Windows 的平均访问时间，可以使用 average 函数来完成这个任务。</p></blockquote><pre><code class="kotlin">/*    使用硬编码的过滤器分析站点访问数据    */val averageWindowsDutation = log    .filter {it.os == OS.WINDOWS}    .map(SiteVisit::dutation)    .avaerage()&gt;&gt;&gt;println(averageWindowsDutaion)23.0</code></pre><blockquote><p>显示来自于Windows机器的平均访问时间，用 average 函数来完成任务。</p></blockquote><pre><code class="kotlin">/*    使用普通的方法去除重复代码    */fun List&lt;SiteVisit&gt;.averageDurationFor(os:OS) = filter{it.os == os}.map(SiteVisit::dutation).average()    // 将重复代码抽取到函数中&gt;&gt;&gt; println(log.averageDurationFor(OS.WINDOWS))23.0&gt;&gt;&gt; println(log.averageDurationFor(OS.MAC))22.0</code></pre><blockquote><p>现在你要计算一个来自MAC用户的相同数据，为了避免重复，可以将平台类型抽象成一个参数.</p><p>注意这个函数作为扩展函数增强了可读性。如果它值在局部的上下文中有用，你甚至可以将这个函数声明为局部的扩展函数。</p></blockquote><pre><code class="kotlin">/*    用一个重复的硬编码函数分析站点访问数据    */val averageMobileDutation = log    .filter{it.os == setOf(OS.IOS,OS.ANDROID)}    .map(SiteVisit::duration)    .average()&gt;&gt;&gt; println(averageMobileDuration)12.15</code></pre><blockquote><p>如果你对移动平台的访问的平均时间感兴趣。</p><p>这时已经不能再再用简单的参数表示不同的平台了。可能还需要使用更加复杂的条件查询日志，比如，“来自IOS平台对注册页面的访问平均时间是多少？”</p><p><strong>可以使用函数类型将需要的条件抽象到一个参数中</strong></p></blockquote><pre><code class="kotlin">/*    用高阶函数去除重复代码    */fun List&lt;SiteVisit&gt;.averageDutationFor(predicate:(SiteVisit) -&gt; Boolean) = filter(predicate).map(SiteVisit::duration).average()&gt;&gt;&gt; println(log.averageDurationFor{...        it.os in setOf(OS.ANDROID,OS.IOS)})12.15&gt;&gt;&gt; println(log.averageDurationFor{...        it.os == OS.IOS &amp;&amp; it.path == &quot;/signup&quot;    // 满足系统为IOS，访问地址为 注册界面的条件})8.0</code></pre><blockquote><p>函数类型可以帮助去除重复代码。使用lambda，不仅可以去除重复的数据，也可以去除重复的行为。</p></blockquote><h2 id="8-2-内联函数：消除lambda带来的运行时开销"><a href="#8-2-内联函数：消除lambda带来的运行时开销" class="headerlink" title="8.2 内联函数：消除lambda带来的运行时开销"></a>8.2 内联函数：消除lambda带来的运行时开销</h2><blockquote><p>Kotlin 中传递 lambda 作为函数参数的简明语法与普通的表达式语法很相似。</p><p><strong>lambda 表达式会被正常地编译成匿名类。这表示每调用一次 lambda 表达式，就会额外的创建一个类。并且如果 lambda 捕捉了某个变量，那么每次调用的时候都会创建一个新的对象。这会带来运行时的额外开销，导致使用 lambda 比使用一个直接执行相同代码的函数效率更低。</strong></p><p>有没有可能让编译器生成跟 Java 语句相同高效的代码，但还是能把重复的逻辑抽取到库函数中呢？（作用）</p><p>如果使用 <strong>inline</strong> 修饰符标记一个函数，在函数被使用的时候编译器并不会生成函数调用的代码，而是使用函数实现的真实代码替换每一次的函数调用。</p></blockquote><p><strong>内联函数简介</strong></p><blockquote><p>在<a href="https://baike.baidu.com/item/计算机科学" target="_blank" rel="noopener">计算机科学</a>中，<strong>内联函数</strong>（有时称作<strong>在线函数</strong>或<strong>编译时期展开函数</strong>）是一种<a href="https://baike.baidu.com/item/编程语言" target="_blank" rel="noopener">编程语言</a>结构，用来建议<a href="https://baike.baidu.com/item/编译器" target="_blank" rel="noopener">编译器</a>对一些特殊<a href="https://baike.baidu.com/item/函数" target="_blank" rel="noopener">函数</a>进行内联扩展（有时称作<strong>在线扩展</strong>）；也就是说建议编译器将指定的函数体插入并取代每一处调用该函数的地方（<a href="https://baike.baidu.com/item/上下文" target="_blank" rel="noopener">上下文</a>），从而节省了每次调用函数带来的额外时间开支。但在选择使用内联函数时，必须在程序占用空间和程序执行效率之间进行权衡，因为过多的比较复杂的函数进行内联扩展将带来很大的存储资源开支。另外还需要特别注意的是对<a href="https://baike.baidu.com/item/递归函数" target="_blank" rel="noopener">递归函数</a>的内联扩展可能引起部分编译器的无穷编译。</p></blockquote><h3 id="8-2-1-内联函数如何运作"><a href="#8-2-1-内联函数如何运作" class="headerlink" title="8.2.1 内联函数如何运作"></a>8.2.1 内联函数如何运作</h3><blockquote><p><strong>内联函数！</strong></p><p>当一个函数被声明为 inline 时，它的函数体是内联的–换句话说，函数体会被直接替换到函数被调用的地方，而不是被正常调用。</p></blockquote><pre><code class="kotlin">/*    定义一个内联函数    */inline fun &lt;T&gt; sysnchronized(lock:Lock,action : () -&gt; T):T{    lock.lock()    try{        return action()    }    finally    {        lock.unlock()    }}val l = Lock()synchronized(1){    //...}</code></pre><blockquote><p>函数用于确保一个共享资源不会并发地被多个线程访问。函数锁住一个Lock对象，执行代码块。</p></blockquote><blockquote><p>调用这个函数的语法跟Java中使用 synchronized 语法完全一直。<strong>区别</strong>，Java 的 synchronized 语法可以用于<strong>任何对象</strong>，这个函数则要求传入一个Lock实例。</p><p>同时，Kotlin 标准库中定义了一个可以接受<strong>任何对象</strong>作为参数的 synchronized 函数版本。</p><p>这里使用同步操作时显式的对象锁能够提升代码的可读性和维护性。</p></blockquote><blockquote><p><strong>使用 inline 的效果！</strong></p><p>因为已经将 synchronized 函数声明为 inline，所以每次调用它所生成的代码跟 Java 的synchronized 语句都是一样的。</p></blockquote><p><strong>使用 synchronized 的例子。</strong></p><pre><code class="kotlin">fun foo(l:Lock){    println(&quot;Before sync&quot;)    synchronized(1){        println(&quot;Action&quot;)    //内联函数    }    println(&quot;After sync&quot;)}</code></pre><pre><code class="kotlin">/*    编译后的 foo 函数    */fun _foo_(l:Lock){    println(&quot;Before sync&quot;)    //这是调用者 foo 的代码    l.lock()    // 这是被内联的 synchronized 函数代码    try(        println(&quot;Action&quot;)    //被内联的lmabda题代码    )finally{        l.unlock()        //这是调用者 foo 的代码    }    println(&quot;After sync&quot;)    //这是调用者 foo 的代码}</code></pre><blockquote><p>展示的是作用相同的代码，将会被编译成同样的字节码。</p></blockquote><blockquote><p>这里 lambda 表达式 和 synchronized 函数实现了内联。</p><p>由于lambda 生成的字节码成为了函数调用这定义的部分，而不是被包含在一个实现了函数接口的匿名类中</p></blockquote><pre><code class="kotlin">/*    调用内联函数的时候可以传递函数类型的变量作为参数    */class LockOwner(val lock:Lock){    fun runUnderLock(body:() -&gt; Unit){        synchronized(lock,body)    //作为函数类型的变量作为参数，而不是lambda    }}</code></pre><blockquote><p>使用函数类型的变量作为参数，不会被内联。</p></blockquote><blockquote><p>只有synchronized 函数体被内联了，lambda 才会被正确调用。</p></blockquote><pre><code>/*    runUnderLock 的函数字节码    */class LockOwner(val lock:Lock){    fun runUnderLock(body:() -&gt; Unit){    //函数类似于真正的runUnberLock被编译成的字节码        lock.lock()        try{            body() // body 没有被内联，因为在调用到地方换没有 lambda        }finally{            lock.unlock()        }    }}</code></pre><h3 id="8-2-2-内联函数的限制"><a href="#8-2-2-内联函数的限制" class="headerlink" title="8.2.2 内联函数的限制"></a>8.2.2 内联函数的限制</h3><blockquote><p>鉴于内联的运作方式，不是所有使用lambda的函数都可以被内联的。</p></blockquote><blockquote><p>当函数被内联的时候，作为参数的lambda表达式函数体会被直接替换成最终生成的代码中。这会限制函数体中对应的（lambda）参数使用。如果（lambda）参数被调用，这样的代码能被容易的内联。<strong>但是如果（lambda）参数在某个地方被保存起来，一遍后边可以继续使用，lambda表达式的代码将不能被内联，因为必须要有一个包含这些代码的对象存在。</strong></p></blockquote><blockquote><p>一般来说，参数如果被直接调用或者作为参数传递给另外一个inline函数，它是可以被内联的。否则，编译器会禁止参数被内联并给出错误信息“Illeal usage of inline-parameter”</p></blockquote><blockquote><p>例如，许多作用域序列的函数会返回一些类的实例，这些类代表对应的序列操作并接受lambda作为构造参数。 这是 Sequence.map函数的定义：</p></blockquote><pre><code class="kotlin">fun &lt;T,R&gt; Sequence&lt;T&gt;.map(transform:(T) -&gt; R):Sequence&lt;R&gt;{    return TransformingSequence(this,transform)}</code></pre><blockquote><p>map 函数没有直接调用作为 transform参数传递进来的函数。而是将这个函数传递给类的构造方法，构造方法将它保存在一个属性中。</p><p>这时为了支持这一点，作为transform参数传递的lambda需要被编译成标准的非内联的表达式，即实现了一个函数接口的匿名类。</p></blockquote><blockquote><p> 当函数期望两个或多个 lambda 参数，可以选择只内联其中一些参数。这是有道理的，因为一个lambda可能会包含很多代码或者不允许内联的方式使用。接受这样的非内联lambda的参数，可以用 noinline 修饰符来标记它：</p><pre><code class="kotlin">inline fun foo(inlined:() -&gt; Unit,noinlune notInlined:() -&gt; Unit){    //...}</code></pre></blockquote><h3 id="8-2-3-内联集合操作"><a href="#8-2-3-内联集合操作" class="headerlink" title="8.2.3 内联集合操作"></a>8.2.3 内联集合操作</h3><p>Kotlin 标准库中操作集合函数的性能。大部分标准库中的集合函数都带有lambda参数。<strong>不管使用标准库函数，还是直接实现这些操作效率都是一样的。</strong></p><p>我们来比较一下。</p><pre><code class="kotlin">/*    使用lambda过滤一个集合    */data class Person(val name:String,val age:Int)val people = listOf(Persion(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31))&gt;&gt;&gt; println(people.filter(it.age&lt;30))[Person(name = Alice,age = 29)]</code></pre><pre><code class="kotlin">/*    手动过滤一个集合 不用lambda表达式来实现*/&gt;&gt;&gt; val result = mutableListOf&lt;Person&gt;()&gt;&gt;&gt; for (person in people){&gt;&gt;&gt;         if(person.age &lt; 30) result.add(person)&gt;&gt;&gt;}&gt;&gt;&gt; println(result)[Person(name = &quot;Alice&quot;, age = 29)]</code></pre><blockquote><p>Kotlin 对内联函数的支持让你不必担心性能问题。</p></blockquote><blockquote><p>在Kotlin中，filter 函数被声明为内联函数。这意味着 filter 函数，以及传递给它的lambda的字节码会被一起内联到filter被调用的地方。最终，第一种实现所产生的字节码和第二种实现所产生的字节码大致是一样的。你可以很安全地使用符合语言习惯的集合操作。</p></blockquote><blockquote><p>现象你在连续使用 filter 和 map 两个操作。</p><pre><code class="kotlin">&gt;&gt;&gt; println(people.filter{it.age &gt; 30}...                .map (Persion::name))[Bob]</code></pre><p><strong>这个例子使用了 lambda 表达式和一个成员引用。</strong></p><p>这里 filter 和 map 都被声明为了 inline 函数，所以他们的函数体会被内联，因此不会产生额外的类和对象。上述的代码却创建了一个中间集合来把偶出来列表过滤的结果，由 filter 函数生成的代码会向这个集合种添加元素，而由 map 函数生成的代码会读取这个几个。</p><p><strong>如果有大量的元素需要处理，中间集合的运行开销将成为不可忽视的问题，这时可以在调用链后加上一个asSequence调用，用序列代替集合。</strong></p><p>同时如同上一节看到的一样，用于处理序列的 lambda 不能够被内联，每个中间序列被表示成lambda保存在其字段中的对象，<strong>而末端操作会导致由每个中间序列调用组成的链被执行</strong>。因此，即便序列上的操作是惰性的，你不应该总是试图在集合操作的链后<strong>asSequence</strong>。只有在处理大量数据时有用，小的集合可以用普通集合处理。</p></blockquote><h3 id="8-2-4-决定何时将函数声明成内联"><a href="#8-2-4-决定何时将函数声明成内联" class="headerlink" title="8.2.4 决定何时将函数声明成内联"></a>8.2.4 决定何时将函数声明成内联</h3><p>使用 inline 关键词只能提高 lambda 参数的函数性能，其他情况需要额外的度量和研究。</p><p><strong>将带有 lambda 参数的函数内联能够带来什么好处。</strong></p><blockquote><p>首先， 通过内联避免运行时开销更加明显了。毕竟节约了函数运行时的开销，而且节约了 lambda 创建匿名类，以及创建 lambda 实例对象的开销。其次，JVM 还没有聪明到总是能将函数调用内联。内联可以使用一些不可能被普通 lambda 使用的特征，比如非局部返回。</p></blockquote><p><strong>注意</strong></p><blockquote><p><strong>在使用 inline 关键字的时候，你还是应该注意代码的长度。如果你要内联的函数不大，将它的字节码拷贝到每一个调用点将会极大地增加字节码的长度。在这种情况下，你应该将那些与 lambda 参数无关的代码抽取到一个独立的非内联函数中。在 Kotlin 中内联函数总是很小的。</strong></p></blockquote><h3 id="8-2-5-使用-内联-lambda-管理资源"><a href="#8-2-5-使用-内联-lambda-管理资源" class="headerlink" title="8.2.5  使用 内联 lambda 管理资源"></a>8.2.5  使用 内联 lambda 管理资源</h3><p><strong>Lambda 可以去除重复代码的一个常见模式是资源模式</strong></p><blockquote><p>先获取资源，完成一个操作，释放资源。</p><p>这里资源表示多种不同的东西：一个文件、一个锁、一个数据库事务等。</p><p>实现这个模式的标准做法是使用 try/finally 语句。资源在 try 代码块之前被获取，在 finally 代码块中释放。</p></blockquote><p><strong>synchronization</strong></p><blockquote><p>前部分讲到将 try/finally的逻辑封装在一个函数中，然后将使用资源的代码作为 lambda 传递给这个方法。</p><p>synchronization将一个锁对象作为参数。</p></blockquote><p>代替 <strong>synchronization</strong></p><blockquote><p>Kotlin 标准库定义了一个叫 withLock的函数，它提供了实现同样功能的更符合语言习惯的API：它是 Lock 接口的扩展函数。</p><p>如何使用。</p><pre><code class="kotlin">val l:Lock = ...l.withLock{    // access the resource protected by this lock 在加锁的情况下执行指定的操作。}/*    在Kotlin标准库中的定义    */fun &lt;T&gt; Lock.withLock(action : () -&gt; T):T{    //需要加锁的代码被抽取到一个独立的方法中    lock()    try{        return action()    } finally{        unlock()    }}</code></pre></blockquote><p><strong>文件是另一种可以使用这种模式的常见资源类型。（文件使用 资源模式）</strong></p><blockquote><p>Java 7 为这种模式引入了特殊的语法：try-with-resource 语句。</p><pre><code class="kotlin">/*    下述代码来读取文件的第一行Java方法    *//*    在Java中使用try-with-resource语句    */static String readFirstLineFromFile(String path) throws IOException{    try(BufferedReader br = new BufferedReader(new FileReader(path))){        return br.readLine();    }}</code></pre><p>Kotlin 中并没有等价的语法，因为通过使用一个带有函数类型参数的函数可以无缝地完成相同的事情。这个函数叫use()</p><p><strong>使用 use 函数 重写上述代码</strong></p><pre><code class="kotlin">/*    使用use函数作为资源管理    */fun readFirstLineFromFile (path:String):String{    BufferedReader(FileReader(path)).use{    // 构成 BufferedReader，调用 “use” 函数，传递一个lambda执行文件操作        br -&gt; return br.readLine()    // 从函数中返回文件的一行    }}</code></pre><p>use 函数是一个扩展函数，被用来操作可关闭的资源，它接受一个lambda作为参数。这个返回调用lambda并且确保资源被关闭，无论lambda正常执行饭是抛出了异常。当然使用use函数是内联函数，所以使用它并不会引发任何性能开销。</p></blockquote><h2 id="8-3-高阶函数中的控制流"><a href="#8-3-高阶函数中的控制流" class="headerlink" title="8.3 高阶函数中的控制流"></a>8.3 高阶函数中的控制流</h2><p>把 return 语句放在循环的中间是很简单的事情，但是如果将循环转换成一个类似于 <strong>filter （filter 是内联函数）</strong> 的函数呢？这种情况下 return 会如何工作。</p><h3 id="8-3-1-lambda-中的返回语句：从一个封闭的函数返回"><a href="#8-3-1-lambda-中的返回语句：从一个封闭的函数返回" class="headerlink" title="8.3.1 lambda 中的返回语句：从一个封闭的函数返回"></a>8.3.1 lambda 中的返回语句：从一个封闭的函数返回</h3><p>比较两种不同的 遍历集合的返回： 在下面的代码清单中，如果一个人的名字是 “Alice” ，就应该从函数lookForAlice 返回。</p><pre><code class="kotlin">/*    在一个普通循环中使用return    */data class Person(val neme:String, val age:Int)val people = listOf(Person (&quot;Alice&quot;,29),Person(&quot;Bob&quot;,11))fun lookForAlice(people:List&lt;Person&gt;){    for (person in people){        if (person.name == &quot;Alice&quot;){            println(&quot;Found!&quot;)            return        }    }    println(&quot;Alice is not found&quot;)     //如果“people”中没用Alice，这一行就会被打印出来}&gt;&gt;&gt; lookForAlice(people)Found!</code></pre><blockquote><p>使用 forEach迭代重写这段代码安全吗？</p><pre><code class="kotlin">/*    在传递给 forEach 的lambda 中使用 return    */fun lookForAlice(people:List&lt;Person&gt;){    people.forEach{        if (it.name == &quot;Alice&quot;){            println(&quot;Found!&quot;)            return        }    }    println(&quot;Alice is not found&quot;)    //和上一个代码清单中的效果是一样的}</code></pre><p>这是安全的</p></blockquote><blockquote><p>当你在 lambda 中使用 return 关键字，它会从调用 lambda 的函数中返回，并不是从 lambda 中返回。这个叫做<strong>非局部返回</strong>。<strong>因为它从一个比包含 return 的代码块更大的代码块中返回了。</strong></p></blockquote><blockquote><p>为了理解这条规则背后的逻辑，从Java函数中在for循环或者synchronized 代码块中使用 return 关键字。显然这会从函数中返回，而不是从循环或者代码块中返回。使用以 lambda 作为参数的函数的时候 kotlin 保留了同样的行为。</p></blockquote><blockquote><p>需要注意的是，<strong><em>只有在以 lambda 作为参数的函数是内联函数的时候才能从跟外层的函数返回。</em></strong>在上述代码中，forEach 的函数体和lambda的函数体一起被内联了，所以在编译的时候能很容易做到从包含它的函数中返回。在 非内联函数的lambda 中使用 return 表达式是不允许的。一个非内联函数可以把传给它的lambda保存在变量中，以便在函数返回以后可以继续使用，这个时候lambda先去影响函数的返回已经太晚了。</p></blockquote><h3 id="8-3-2-从-lambda-返回：使用标签返回"><a href="#8-3-2-从-lambda-返回：使用标签返回" class="headerlink" title="8.3.2 从 lambda 返回：使用标签返回"></a>8.3.2 从 lambda 返回：使用标签返回</h3><p><strong>标签返回</strong></p><blockquote><p>可以在lambda表达式总使用<strong>局部返回</strong>。</p><p>lambda 中的局部返回跟 for 循环中的 break 表达式显示。它会终止 lambda 的执行，并接着从调用 lambda 的代码处执行。</p></blockquote><p><strong>区分 局部返回和非局部返回</strong></p><blockquote><p>要区分局部返回和非局部返回，要用到<strong>标签</strong>。</p><p><strong>如何区分。</strong></p><p>想从 lambda 表达式处返回你可以标记它，然后在 return 关键字后面引用这个标签。</p></blockquote><pre><code class="kotlin">/*    用一个标签实现局部返回    */fun lookForAlice(people:List&lt;Person&gt;){    people.forEach lable@{    // ←给lambda表达式加上标签        if (it.name == &quot;Alice&quot;) return@label    //← return@label 引用了这个标签    }    println(&quot;Alice might be somewhere&quot;)    //这里总被打印}&gt;&gt;&gt; lookForAlice(people)Alice might be somewhere!</code></pre><blockquote><p><strong>如何使用标签</strong></p><p>要标记一个lambda表达式，在 lambda 的花括号之前放一个标签名，接着放一个 @ 符号。（标签名可以是任意的）、</p><p>要从一个lambda返回，在return关键词后放一个@符号，接着放标签名。</p><pre><code class="kotlin">// “label@” lambda标签people.forEach label@{    if (it.name == &quot;Alice&quot;) return@label //返回表达式标签}/*    用 “@” 符号标记一个标签从一个lambda返回    */</code></pre></blockquote><blockquote><p><strong>另一种方式，使用 lambda 作为参数的函数的函数名可以作为标签</strong></p><pre><code class="kotlin">/*    用函数名 return 标签    */fun lookForAlice(people:List&lt;Person&gt;) {    people.forEach{        if(it.name == &quot;Alice&quot;)    return@forEach    // ←return@forEach从 lambda 表达式返回    }    println(&quot;Alice might be somewhere&quot;)}</code></pre><p>当里显式的<strong>指定了 lambda 表达式的标签</strong>，再使用函数名作为标签没有任何效果。</p><p>一个 lambda 表达式的标签数量不能多于一个。</p></blockquote><blockquote><p><strong>带标签的 “this” 表达式</strong></p><p>同样的规则也适用于this表达式。在带接收者的lambda中–包含一个隐式上下文对象的lamdba也有通过一个this去访问。</p><p>如果你给带接收者 lambda 指定标签，就可以通过对应的带有标签的this表达式访问它的隐式接收者。</p><pre><code class="kotlin">&gt;&gt;&gt; println(StringBuilder().apply sb@{    // 这个 lambda 隐式接收者可以通过 this@sb 访问...        listOf(1,2,3).apply{    // ”this”指定作用域内最近的隐式接收者...            this@sb.append(this.toString())    // 所以隐式接收者都可以被访问，外层的接收者通过显式的标签访问...        }...    })     [1,2,3]</code></pre><p>局部返回的语法相当冗长，如果一个 lambda 包含多个返回语句会变得更加笨重。所以这里可以使用 <strong>匿名函数。</strong></p></blockquote><h1 id="9-泛型"><a href="#9-泛型" class="headerlink" title="9 泛型"></a>9 泛型</h1><p><strong>Kotlin中引入了新的概念，例如实化类型参数和声明点变型。</strong></p><p><strong>实化类型参数允许你在运行时的内联函数调用中引用作为类型实参的具体类型（对普通的类和函数来说，这样行不通，因为类型实参在运行时会被消除）</strong></p><p><strong>声明点变型可以说明一个带类型参数的泛型类型，是否是另一个泛型类型的之类或者超类型，它们的基础类型相同但类型参数不同。</strong>例如它可以调节是否可以把List<Int>类型的参数传给期望List<Any>的函数。<strong>使用点变型在具体使用一个泛型时做同样的事，达到和Java通配符一样的效果。</strong></p><blockquote><p>类型参数：</p><p>在计算机编程语言中，TypeParameter是用于泛型编程的通用标签，用于引用未知的数据类型，数据结构或类。TypeParameter最常用于C ++模板和Java泛型。TypeParameter与元语法变量相似，但有所不同。</p><p>引用：维基百科</p></blockquote><h2 id="9-1-泛型类型参数"><a href="#9-1-泛型类型参数" class="headerlink" title="9.1 泛型类型参数"></a>9.1 泛型类型参数</h2><blockquote><p>泛型允许你定义带类型形参的类型。当这种类型的实例被创建出来的时候，类型形参被替换成称为类型实参的具体类型。</p><p>类型形参：声明定义时的参数，作用域仅本身。</p></blockquote><p><strong>Kotlin编译器能推导出类型实参：</strong></p><pre><code class="kotlin">val authors = listOf(&quot;Dmitry&quot;,&quot;Svetlane&quot;)</code></pre><p>因为传给listOf函数的两个值都是字符串，编译器推导出你正在创建一个List<String>。另一方面，如果你想创建一个空的列表，这样就没有任何可以推导处类型实参的线索，你就得显式指定它（类型形参）。就创建列表来说，即可以选择在变量声明中说明泛型的类型，也可以选择在创建列表的函数中说明类型实参。例子：</p><pre><code class="kotlin">val readers :MutableList&lt;String&gt; = mutableListOf()val reader = mutableListOf&lt;String&gt;()</code></pre><h3 id="9-1-1-泛型函数和属性"><a href="#9-1-1-泛型函数和属性" class="headerlink" title="9.1.1 泛型函数和属性"></a>9.1.1 泛型函数和属性</h3><p>如果你在编写一个使用列表的函数，希望它可以在任何列表上使用，而不是某个具体类型的元素列表，那么编写一个 <strong>泛型函数</strong>。</p><blockquote><p>泛型函数有它自己的类型形参。类型形参在每次函数调用时都必须替换成具体的类型实参。</p></blockquote><p>大部分使用集合的库函数都是泛型的。下面这个函数就返回一个只包含在指定下标区间内的元素。</p><pre><code class="kotlin">fun &lt;T&gt; List&lt;T&gt;.slice(indeces: IntRange):List&lt;T&gt;    //接收者和返回类型使用了类型形参// &lt;T&gt;:类型形参声明</code></pre><p>接收者和返回类型用到了函数的类型形参T，它们的类型都是List<T>。当你在一个具体的列表上调用这个函数时，可以显式地指定类型实参。</p><blockquote><p>多数情况下，编译器会推导出类型。</p></blockquote><pre><code class="kotlin">//调用泛型函数&gt;&gt;&gt; val letter = (&#39;a&#39;..&#39;z&#39;).toList()&gt;&gt;&gt; println(letter.slice&lt;Char&gt;(0..2))    //显式地指定类型实参[a, b, c]&gt;&gt;&gt; println(letter.slice&lt;Char&gt;(10..13))    [k, l, m, n]</code></pre><p>调用的结果都是List<Char>。编译器把函数返回类型List<T>总的T替换成推导出来的类型Char</p><h3 id="9-1-2-声明泛型类"><a href="#9-1-2-声明泛型类" class="headerlink" title="9.1.2 声明泛型类"></a>9.1.2 声明泛型类</h3><blockquote><p><strong>和Java一样，Kotlin通过在内名称后加上一对尖括号，并把类型参数放在尖括号内来声明泛型类及接口。</strong></p><p>一旦声明以后，就可以在类的主体内像其他类型一样使用类型参数。</p></blockquote><pre><code class="kotlin">interface List&lt;T&gt;{    //List 接口顶类类型参数T    operator fun get(index:Int):T    //在接口或类的内部，T可以当作普通类型使用。}</code></pre><blockquote><p><strong>如果你的类继承了泛型类（或者实现了泛型接口），你就得为<em>基础类型</em>的泛型形参提供一个类型实参。它可以是具体类型或一个类型形参：</strong></p><pre><code class="kotlin">class StringList(override val size: Int) : List&lt;String&gt; {   //这个类实现了List，提供了具体类型实参：String override fun get(index: Int): String {  //注意T被String替代     TODO(&quot;Not yet implemented&quot;) }}class ArratList&lt;T&gt; : List&lt;T&gt; {  // 现在ArrayList泛型类型形参T就是List的类型实参。 override fun get(index: Int): T {     TODO(&quot;Not yet implemented&quot;) }}</code></pre><p>StringList类被声明成只能 <strong>只能包含String元素，所以它使用String作为基础类型的类型实参。</strong>之类中的任何函数都要用这个正确的类型换掉T，所以在StringList中你会得到函数签名get(Int):String ，而不是fun get(Int):T。</p><p><strong>而类ArrayList定义了它自己的类型参数T并把它指定为父类的类型实参。</strong>注意ArrayList<T>中的T和LIst<T>中的T不一样，它是全新的类型形参，不必保留一样的名称。</p><p><strong>一个类甚至可以把它自己作为类型实参应用。</strong>实现Comparable接口的类就是这种模式的经典例子。任何可以比较的元素都必须定义它如何与同样类型的对象进行比较：</p><pre><code class="kotlin">interface Comparable&lt;T&gt; { fun comparableTo(other: T): Int}class String : Comparable&lt;String&gt; { override fun comparableTo(other: String): Int {     TODO(&quot;Not yet implemented&quot;) }}</code></pre><p>String 实现了Comparable接口的泛型接口，提供类型String给类型实参T。</p></blockquote><h3 id="9-1-3-类型参数约束"><a href="#9-1-3-类型参数约束" class="headerlink" title="9.1.3 类型参数约束"></a>9.1.3 类型参数约束</h3><blockquote><p><strong>类型参数约束可以限制作为类和函数的类型实参的类型。</strong> 以计算列表元素之和的函数为例。它们可以在List<Int>和List<Double>上，当不可以用在LIst<String>这样的列表上。可以定义一个类型参数的约束，说明sum的类型形参必须是数字，来表达这个限制。</p></blockquote><blockquote><p><strong>如果你把一个类型指定为泛型类型形参的上街约束</strong>，在泛型类型具体的初始化中，其对应的类型实参就必须这个具体类型或它的子类型（暂时子类型和子类的一样相同）。</p></blockquote><blockquote><p><strong>你是这样定义约束的，把冒号放到类型参数名称之后，作为类型形参上界的类型紧跟其后，在Java中，用的关键词extends来表达一样的概念：<T extends Number> T sum(List<T> list)。</strong></p><pre><code class="kotlin">// &lt;T: 类型参数// Number&gt; ：上界fun &lt;T:Number&gt; List&lt;T&gt;.sum():T</code></pre></blockquote><blockquote><p><strong>一旦指定了类型形参T的上界，你就可以把类型T的值作为它的上界（类型）的值使用。</strong></p><pre><code class="kotlin">fun &lt;T : Number&gt; oneHalf(value: T): Double {    //指定Number为类型形参上界 return value.toDouble() / 2.0}&gt;&gt;&gt; println(oneHalf(3))1.5</code></pre></blockquote><blockquote><pre><code class="kotlin">// 声明带类型参数约束的函数fun &lt;T : Comparable&lt;T&gt;&gt; max(first: T, second: T): T {   //这个函数的实参必须是可比较元素 return if (first &gt; second) first else second}&gt;&gt;&gt; println(max(&quot;kotlin&quot;, &quot;java&quot;)) // 字符串按照字母表顺序比较</code></pre><p><strong>T的上界是泛型类型Comparable<T> 。前面已经看到了，String累继承了Comparable<String> 这样使得String变成了max函数的有效类型实参。</strong></p><p>记住，first&gt;second的简写形式会根据Kotlin的运算符约定被编译成first.compareTo(second) &gt; 0。这种比较之所以可行，是因为first的类型T继承自Comparable<T>,这样你就可以比较first和另外一个类型T的元素。</p><p><strong>极少数情况下，需要在类型参数上指定多个约束</strong>。例如下面这个代码清单用泛型的饭是保证给定的CharSequence以句号结尾。</p><pre><code class="kotlin">//为一个类型参数指定多个约束fun &lt;T&gt; ensureTrailingPeriod(seq: T) where T : CharSequence, T : Appendable {    //类型参数约束的列表 if (!seq.endsWith(&quot;.&quot;)) {    //调用为CharSequence接口定义的扩展函数     seq.append(&quot;.&quot;)    //调用Appendable接口的方法 }}&gt;&gt;&gt; val helloWorld = StringBuilder(&quot;Hello World&quot;)&gt;&gt;&gt; ensureTrailingPeriod(helloWorld)&gt;&gt;&gt; println(helloWorld)</code></pre><p>这种情况下，可以说明作为类型实参的类型必须实现CharSequence和Appendable接口。这意味着该类型的值可以使用访问数据(endsWith)和修改数据(append) 两种操作。</p></blockquote><h3 id="9-1-4-让类型形参非空"><a href="#9-1-4-让类型形参非空" class="headerlink" title="9.1.4 让类型形参非空"></a>9.1.4 让类型形参非空</h3><blockquote><pre><code class="kotlin">class Processor&lt;T&gt;{    fun process(value:T){        value?.hashCode()    //“value“是可空的，所以要安全调用    }}</code></pre><p>如果你声明的是泛型类或者泛型函数，任何类型实参，包括哪些可空的类型实参，都可以替换它的类型形参。<strong>没有指定上界的类型形参将会使用Any?这个默认上界。</strong></p><p>process函数中，参数value是可空的，尽管T并没有使用问好标记。下面这种情况是因为Processor类具体初始化T能使用可空类型。</p></blockquote><blockquote><pre><code class="kotlin">val nullableStringProcessor = Processor&lt;String?&gt;()    //可空类型替换为String?被用来替换TnullableStringProcessor.process(null)    //使用“null”作为“value”实参的代码可以编译</code></pre><p>如果你想保证替换类型形参的始终是非空类型，可以通过指定一个约定来实现。如果你除啦可空性之外没有任何限制，可以使用Any代替默认的Any?作为上界：</p><pre><code class="kotlin">class Processor&lt;T:Any&gt;{    //指定非空上界。    fun process(value:T){        value.hashCode()    //类型T的值现在是非“空”的。    }}</code></pre><p><strong>约束&lt;T:Any&gt;确保了类型T永远都是非空类型。编译器不会接收代码Processor&lt;String?&gt;,因为类型实参String?不是Any的子类型。（它是 Any? 的子类型）</strong></p><p>可以通过指定任意非空类型作为上界，来让类型参数非空，不光是类型Any。</p></blockquote><h2 id="9-2-运行时的泛型：擦除和实例化参数"><a href="#9-2-运行时的泛型：擦除和实例化参数" class="headerlink" title="9.2 运行时的泛型：擦除和实例化参数"></a>9.2 运行时的泛型：擦除和实例化参数</h2><p>JVM上的泛型一般是通过<strong>类型擦除</strong>实现，就是说泛型类实例的类型实参在运行时是不保留的。可以声明一个inline函数，使其类型实参不被擦除（或者，Kotlin术语称为实化）。</p><h3 id="9-2-1-运行时的泛型：类型检查和转换"><a href="#9-2-1-运行时的泛型：类型检查和转换" class="headerlink" title="9.2.1 运行时的泛型：类型检查和转换"></a>9.2.1 运行时的泛型：类型检查和转换</h3><p>和Java一样，Kotlin的泛型在运行时也被 <strong>擦除</strong> 了。这意味着泛型类实例不会携带用于创建它的类型实参的信息。例如，如果你创建了一个List<String>并将一堆字符串放到其中，在运行时你只能看到它是一个List，不能识别出列表本打算包含的是那种类型元素（当然，你可以获取一个元素然后检查它的类型，但即便检查通过了也不会有任何保证，因为其他元素可能拥有不同类型）。</p><pre><code class="kotlin">val list1:List&lt;String&gt; = listOf(&quot;a&quot;,&quot;b&quot;)val list2:List&lt;Int&gt; = listOf(1,2,3)</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210905153004.png" alt="在运行时，你不会知道list1和list2时候声明成字符串或者整数列表。它们每个都只是List    "></p><p>即使编译器看到的是两种完全不同类型的列表，在执行的时候它们看起来却完全一样。即便如此，你通常可以确信List<String>在包含字符串，而List<Int>只包含整数。因为编译器知道类型实参，并确保每个列表只存储正确的元素。</p><p><strong>因为类型实参没有被保留下来，你不能检查它们。</strong>例如，你不能判断一个列表是只包含字符串的列表还是包含其它对象的列表。一般而言，在is检查中不可能使用类型实参中的类型。</p><pre><code class="kotlin">&gt;&gt;&gt; if (value is List&lt;String&gt;){...}ERROR:Cannot check for instance of erased type</code></pre><p><strong>为什么擦除了泛型类型信息？</strong></p><p>尽管在运行时可以完全断定这个值是一个List，但你依然无法判断它是一个含有字符串的列表，还是含有人，或者含有其他什么：这些信息被擦除了。<strong>注意擦除泛型类型信息是有好处的：应用程序使用的内存总量较小，因为要保存在内存中的类型信息更少。</strong></p><p><strong>检查类型是否是个列表？</strong></p><p>路上所述，Kotlin不允许使用没有指定类型实参的泛型类型。那么你可能想知道如何检查一个值是否是列表，而不是set或者其他对象。可以使用特殊的<strong>星号投影</strong>语法来做这种检查：</p><pre><code class="kotlin">if (value is List&lt;*&gt;){... ...}</code></pre><p>这里检查了value是否是一个List，而且并没有得到关于它的任何信息。</p><blockquote><p>注意，在as 和 as? 转换中仍然可以使用一般的泛型类型。但如果该类有正确的<strong>基础类型</strong>但<strong>类型实参</strong>是错误的，转换也不会失败，因为在运行时转换发生的时候类型实参是未知的。因此这样的转换会导致编译器发出“unchecked cast”（未受检转换）的警告。这仅仅是个警告，你仍然可以继续使用这个值，但它拥有必要的类型。</p><pre><code class="kotlin"> // 对泛型类型做类型转换fun printSum(c: Collection&lt;*&gt;) { val initList = c as? List&lt;Int&gt;     ?: throw IllegalArgumentException(&quot;List is expected&quot;)    //这里警告。Unchecked cast:List&lt;*&gt;to List&lt;Int&gt; println(initList.sum())}&gt;&gt;&gt; printSum(listOf(1, 2, 3))6</code></pre><p>编译一切正常：编译器只是发出了一个警告，这意味着代码是合法的。如果一个整型的列表或者set上调用printSum函数，一切都会如预期发生：一种情况会打印出元素之和，而第二种情况则会IllegalArgumentException。但如果你传递了一个错误类型的值，运行时会得到一个ClassCastException：</p><pre><code class="kotlin">&gt;&gt;&gt; printSum(setOf(1,2,3))    //Set不是列表所以抛出了异常IllegalArgumentException:List is expected&gt;&gt;&gt; printSum(listOf(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;))    //类型转换成功，但后面抛出了另外的异常ClassCastException:String cannot be cast to Number    </code></pre><p>我们来讨论一下字符串列表上调用printSum函数时抛出的异常。你得到的并不是IllegalArgumentException，因为你没有办法判断实参是不是一个List<Int>。因此类型转换成功，无论如何函数sum都会在这个列表上调用。在这个函数执行期间，异常抛出了。这是因为sum函数试着从列表中读取Number值然后把它们加在一起。把String但Number用的尝试会导致运行时ClassCastException。</p></blockquote><blockquote><pre><code class="kotlin">/*    对已知类型实参做类型转换    */fun printSum(c: Collection&lt;Int&gt;) { if (c is List&lt;Int&gt;) {     println(c.sum())    //这次检查是合法的 }}&gt;&gt;&gt; printSum(listOf(1, 2, 3))6</code></pre><p>c 时候拥有类型List<Int>的检查是否可行，因为在编译期就确定了集合（不管它是列表还是其他类型的集合）包含的都是整型数字。</p><p>Kotlin有特殊的语法结构可以允许你在函数体中使用具体的类型实参，但是又inline函数可以。</p></blockquote><h3 id="9-2-2-声明带实化类型参数的函数"><a href="#9-2-2-声明带实化类型参数的函数" class="headerlink" title="9.2.2 声明带实化类型参数的函数"></a>9.2.2 声明带实化类型参数的函数</h3><blockquote><p>Kotlin泛型在运行时会被擦除，这意味着如果你有一个泛型类的实例，你无法弄清楚在这个实例创建时你究竟用的是那个类型的实参。泛型类型的类型实参也是这样。在调用泛型函数的时候，在函数体中你不能决定函数调用它用的类型实参：</p><pre><code class="kotlin">&gt;&gt;&gt; fun &lt;T&gt; isA(value:Any)=value is T    //表达式Error:Cannot check for instance of erased type:T</code></pre><p>这种情况下只有<strong>内联函数</strong>能够使用，内联函数的类型形参能够被实化，意味着你可以在运行时应用实际的类型实参。</p><p><strong>如果使用inline函数标记函数，编译器会把每次函数调用都换成函数实际的代码实现。使用内联函数还可以提升性能，如果该函数使用了lambda实参：lambda的代码会被内敛，所以不会创建任何匿名类。</strong>  <strong>inline函数使用时的另一种场景：它们的类型参数可以被实化。</strong></p><p>把前面列子中的isA函数声明成inlie并且用reified标记类型参数，你能够用该函数检查value是不是T的实例。</p><pre><code class="kotlin">/*  声明带实化类型参数的函数   */inline fun &lt;reified T&gt; isA(value: Any) = value is T&gt;&gt;&gt; println(isA&lt;String&gt;(&quot;abc&quot;))true&gt;&gt;&gt; println(isA&lt;String&gt;(123))false</code></pre></blockquote><blockquote><p>一个实化类型参数能够发挥作用最简单的例子就是标准库函数filterIsInstance。<strong>这个函数接收一个集合，选择其中哪些指定类的实例，然后返回这些被选中的实例。</strong></p><pre><code class="kotlin">/*  使用标准库函数filterIsInstance */&gt;&gt;&gt; val items = listOf(&quot;one&quot;, 2, &quot;three&quot;)&gt;&gt;&gt; println(items.filterIsInstance&lt;String&gt;())[one,three]</code></pre><p>通过指定<String>作为函数的类型参数，你表明感兴趣的只是字符串。<strong>因此函数的返回类型时List<String>。这种情况下，<em>类型实参在运行时是已知的</em>函数filterIsInstance使用它来检查列表中的值是不是指定为该类型实参的类的实例。</strong></p><pre><code class="kotlin">/*  filterIsTance声明的简化版本    */inline fun &lt;reified T&gt; Iterable&lt;*&gt;.filterIsTance(): List&lt;T&gt; {    //“reified”声明了类型参数不会在运行时被擦除 val destination = mutableListOf&lt;T&gt;() for (element in this) {     if (element is T) {        //可以检查元素是不是指定为类型实参的类的实例         destination.add(element)     } } return destination}</code></pre></blockquote><p><strong>为什么实化只对内联函数有效？</strong></p><p>为什么在inline函数中允许这样写 element is T ，而普通的类或者函数却不行？</p><p>编译器把实现内联函数的字节码插入每一次调用发生的地方。每次你调用带实化类型参数的函数时，编译器都知道这次特定调用中用作实参的确切类型。因此，编译器可以生成应用作为类型实参的具体类的字节码。上述 filterIsInstance<String>调用来说，生成的代码和下面这段代码是等价的：</p><pre><code class="kotlin">for (element in this){    if(element is String){    //引用具体类        destination.add(element)    }}</code></pre><p>因为生成的字节码引用了具体类型，而不是类型参数，它不会被运行时发生的类型参数擦除影响。</p><p><strong>注意reified类型参数的inline函数不能在java中调用。</strong>普通的内联函数可以像常规函数那样在Java中调用–它们可以被调用而不能被内联。带实化类型参数的函数需要额外的处理，来吧类型实参的值替换到字节码中，所以它们必须永远是内联的。所以不能在java中调用。</p><p><strong>内联函数在什么情况下性能有势最有效？</strong></p><p><strong>一个内联函数可以有多个实化类型参数，也可以同时拥有飞实化类型参数和实化类型参数。注意，filterIsInstance函数虽然被标记成了inline，而他并不期望lamdba作为实参。（决定何时将函数声明为内联函数）中，我们提到函数把函数标记成内联只有在一种情况下有性能优势，即函数拥有函数类型的形参并且其对应的实参–lambda–和函数一起被内联的实化。</strong></p><p>为了保证良好的性能，你仍然需要追踪了解标记为inline的函数的大小。如果函数变的庞大，最好把不依赖实化类型参数的代码抽取到非内联函数中。</p><h3 id="9-2-3-使用实化类型参数代替类引用"><a href="#9-2-3-使用实化类型参数代替类引用" class="headerlink" title="9.2.3 使用实化类型参数代替类引用"></a>9.2.3 使用实化类型参数代替类引用</h3><p>实化类型参数的常见使用场景是为接收java.lang.Class 类型参数的API构造适配器。这个API的例子是JDK中ServiceLoader，它接收一个代表接口或抽象类的java.long.Class，并返回实现了该接口（或继承了该抽象类）java.lang.Class，并返回实现了该接口（或继承了该抽象类）的类的实例。如何利用实化类型参数更容易地调用这些API。</p><pre><code class="kotlin">/*    通过类引用 加载ServiceLoader    */val serviceImpl = ServiceLoader.load(Service::class.java)</code></pre><p>::class.java 的语法展示了如何获取java.lang.Class对应的Kotlin类。</p><p>这和Java中的Service.class是完全等同的。</p><p><strong>使用实化类型参数的函数重写这个例子：</strong></p><pre><code class="kotlin">val serviceImpl = loadService&lt;Service&gt;()</code></pre><p>代码短了许多。</p><p><strong>那么如何定义实化函数？</strong></p><p>要加载的服务类现在被指定成了loadService函数的类型实参。把一个类要指定成类型实参要容易理解的多，因为它的代码比使用::class.java语法更短。</p><p>看看loadService函数是如何定义的：</p><pre><code class="kotlin">inline fun &lt;reified T&gt; loadService(){    //类型参数标记成了“reified”    return ServiceLoader.load(T::Class.java)    //把T::Class当成类型形参的类访问。}</code></pre><p>这种用在类型上的::Class.java语法也可以用在实化类型参数上。使用这种语法会产生对应到指定为类型参数的类的java.lang.Class,你可以正常使用它。</p><p><strong>简化 Android上的startActivity 函数</strong></p><p>如果你是Android开发者，可以使用实化类型参数简化startActivity函数。实化类型参数用来代替传递作为java.lang.Class的Activity类。</p><pre><code class="kotlin">inline fun &lt;reified T: Activity&gt; Context.startActivity(){    //类型参数标记为“reified”    val intent = Intent(this,T::Class.java)    //把T::Class当成类型参数的类访问    startActivity(intent)}startActivity(intent)    //调用方法显式Activity</code></pre><h3 id="9-2-4-实化类型参数的限制"><a href="#9-2-4-实化类型参数的限制" class="headerlink" title="9.2.4 实化类型参数的限制"></a>9.2.4 实化类型参数的限制</h3><p>实化类型参数是有一些限制的。有一些实化是与生俱来的，另一些是现有的实现决定的，而且可能在未来的Kotlin版本中放开这些限制。</p><p><strong>可以按下面的方式使用实化类型参数：</strong></p><ul><li>用在类型检查和类型转换中(is、!is、as、as?)</li><li>使用Kotlin反射API（::Class)</li><li>获取相应的java.lang.Class（::Class.java)</li><li>作为调用其他函数的类型实参</li></ul><p><strong>不能做的事情：</strong></p><ul><li>创建指定为类型参数的类的实例</li><li>调用类型参数类的伴生对象的方法</li><li>调用带实化类型参数函数的时候使用 <strong>非实化类型形参作为实参</strong></li><li><em>把类、属性或者非内联函数的类型参数标记</em>成reified</li></ul><p><strong>最后一条限制的后果：因为实化类型参数只能用于在内联函数上，使用实化类型参数意味着函数和所有给它的lambda都会被内联。如果内联函数使用lambda的方式导致lambda不能被内联，或者你不想lambda因为性能的关系被内联，<em>可以使用noinline修饰符把它们标记成非内联的。</em></strong></p><h2 id="9-3-变型：泛型和子类型化"><a href="#9-3-变型：泛型和子类型化" class="headerlink" title="9.3 变型：泛型和子类型化"></a>9.3 变型：泛型和子类型化</h2><p><strong>变型的概念描述了拥有相同基础类型和不同<em>类型实参</em>的（泛型）类型之间是如何关联的。</strong>例如：List<String>和List<Any>之间如何关联。当编写自己的泛型类或者泛型函数时，理解变型的概念十分重要：它有助于你创建出，既不会以不方便的方式限制用户，也不会破坏用户所期望的类型安全。</p><h3 id="9-3-1-为什么存在变型：给函数传递实参"><a href="#9-3-1-为什么存在变型：给函数传递实参" class="headerlink" title="9.3.1 为什么存在变型：给函数传递实参"></a>9.3.1 为什么存在变型：给函数传递实参</h3><p><strong>假如你有一个接收List<Any>作为实参的函数。</strong>把List<String>类型的变量传给这个函数是否安全？把一个字符串传给一个期望Any的函数是安全的，因为String类型继承自Any。<em>但是当String和Any变成List接口的类型实参后，情况就没有这么简单了。</em></p><p><strong>考虑一个打印出列表内容的函数。</strong></p><pre><code class="kotlin">fun printContents(list: List&lt;Any&gt;) {    println(list.joinToString())}&gt;&gt;&gt; printContents(listOf(&quot;aaa&quot;, &quot;bbb&quot;))aaa,bbb</code></pre><p>看起来这些字符串列表可以正常工作。函数把每个元素都当成Any对待，而且因为每个字符串都是Any，这完全是安全的。</p><p><strong>来看另一个函数它会修改列表（因此它接收一个MutableList作为参数）：</strong></p><pre><code class="kotlin">fun addAnswer(list: MutableList&lt;Any&gt;) {    list.add(42)}&gt;&gt;&gt; val strings = mutableListOf(&quot;abc&quot;, &quot;bac&quot;)&gt;&gt;&gt; addAnswer(strings)  //如果这一行编译通过了&gt;&gt;&gt; println(strings.maxBy { it.length })    //运行时就会产生异常ClassCaseException:Integer connot be cast to String</code></pre><p>你声明了一个类型为MutableList<String>的变量Strings，然后尝试把它传递给这个函数。假如编译器接收了，你就能在字符串中添加一个整数，这会导致你在运行时尝试访问列表中的字符串的时候出现异常。正因如此，这次调用不会通过编译。这个例子展示了当期望的是MutableList<Any>的时候把一个MutableList<String>当作实参是不安全的，Kotlin编译时阻止拉它。</p><blockquote><p>现在可以回答，把一个字符串列表传给期望Any对象列表的函数是否安全。如果<strong>函数添加或者更换了列表中的元素就是不安全的，因为这样会产生类型不一致的可能性。否则它就是安全的。</strong>可以通过是否可变选择合适的接口来轻易的控制。如果函数接收的是可读列表，可以传递具有更具体的元素类型的列表。如果列表是可变的，不能这样做。</p></blockquote><blockquote><p>这些问题可以推广到任何泛型类，而不仅仅是List。接下来会看到为什么两种接口List和MutableList会因为它们的类型参数产生差异。</p></blockquote><h3 id="9-3-2-类、类型和子类型"><a href="#9-3-2-类、类型和子类型" class="headerlink" title="9.3.2 类、类型和子类型"></a>9.3.2 类、类型和子类型</h3><p>变量的类型规定了该变量的可能值。有时候我们会把类型和类当成相同的概念使用，当它们不一样，现在来看看它们的区别。</p><blockquote><p>例子非泛型类，<strong>类</strong>的名称可以当作<strong>类型</strong>使用。例如，如果你这样些 var x : String，就是声明一个可以保存String类的实例的变量。但是注意，同样的类名称也可以用来声明可空类型：var x:String?。这意味着每个Kotlin类都可以用于构造至少两种类型。</p></blockquote><p>泛型类的情况就变得更加复杂了。要得到一个合法的类型，<strong>需要用一个作为类型实参的具体类型替换（泛型）类的类型形参。</strong>List不是一个类型（它是一个类），但是下面列举出所有的替代品都是合法类型：List<Int>、List<String>、List&lt;List<String>&gt;等。每个泛型类都可能生成潜在无限数量的类型。</p><p><strong>子类型</strong></p><blockquote><p>为了讨论类型之间的关系，需要熟悉子类型这个术语。任何时候如果需要的是类型A的值，你都能使用类型B的值（当作A的值），类型B就称为类型A的子类型。</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210914222218.png" alt="如果期望A的时候可以使用B，B就是A的子类型"></p><p><strong>超类型</strong>是子类型的反义词。如果B是A的子类型，那A就是B的超类型。</p><p><strong>类型是否是另一个子类型的子类型为什么如此重要？</strong></p><pre><code class="kotlin">/*    检查一个类型是否是另一个的子类型    */fun test(i: Int) {    val n: Number = i   //编译通过，因为Int是Number的子类型    fun f(s: String) {        /*...*/    }    f(i)    //不能编译，因为Int不是String的子类型}</code></pre><p><strong>只有值的类型是变量类型的子类型时，才允许变量存储该值。</strong></p><p><strong>简单情况下，子类型和子类本质上意味着一样的事务。</strong>例如，Int类型是Number的子类，因此Int类型是Number类型的子类型。如果一个类实现了一个接口，它的类型就是该接口类型的子类型：String是CharSequence的子类型。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210914234123.png" alt="非空类型A是可空的A?的子类型，反过来却不是"></p><p>这个例子说明，子类型和子类不是同一事务。</p><p><strong>一个非空类型是它的可空类型的子类型，当它们都对应这同一个类。</strong>你始终能在可空类型的变量中存储非空类型的值，当反过来却不行（null不是非空类型变量接收的值）：</p><pre><code class="kotlin">val s:String = &quot;abc&quot;val t:String ? = s    //这次赋值是合法的，因为String是String?的子类型</code></pre><p><strong>泛型类</strong></p><p>当涉及到泛型类时，子类型和子类之间的差异显的格外重要。前面的几个问题，把List<String>类型的变量传给期望List<Any>的函数是否安全，现在可以使用子类型话术语来重新组织：List<String>是List<Any>的子类型吗？你已经了解了为什么把MutableList<String>当成MutableList<Any>的子类型对待是不安全的。显然反过来也是不成立的：MutableList<Any>肯定不是MutableList<String>的子类型。</p><p><strong>一个泛型类–例如，MutableList–如果对任意两种类型A和B，MutableList&lt; A &gt;既不是MutableList&lt; B &gt;的子类型也不是它的超类型，它就被称为在该类型参数上是 <em>不变型</em>。</strong>    </p><p><strong>什么是协变。</strong></p><blockquote><p>对于这样一个类，List，对它来说，子类型化规则不一样。Kotlin中的List接口表示的是只读集合。如果A是B的子类型，那么List&lt; A &gt;就是List&lt; B &gt;的子类型。这样的类或者接口被称为 <strong>协变</strong>。</p></blockquote><h3 id="9-3-3-协变：保留子类型化关系"><a href="#9-3-3-协变：保留子类型化关系" class="headerlink" title="9.3.3 协变：保留子类型化关系"></a>9.3.3 协变：保留子类型化关系</h3><p><strong>协变</strong></p><blockquote><p>一个协变类是泛型类，对这个类来说，下面的描述是成立的：如果A是B的子类，那么Producer&lt; A &gt;就是Producer&lt; B &gt;的子类。<strong>我们说子类型化被保留了。</strong>例如，Producer&lt; Cat &gt;是Producer&lt; Animal &gt;的子类型，因为Cat是Animal的子类型。</p></blockquote><p><strong>在声明类时如何说明某个类型参数是可以协变的！</strong></p><blockquote><p>你需要在该类型参数上加上 out 关键词：</p><pre><code>interface Producer&lt;out T&gt;{    //类被声明在T上的协变    fun producer():T}</code></pre><p>将一个类的类型参数标记为协变的，<strong>在该类型实参没有精确匹配到函数中定于的类型形参时，可以让该类的值作为这个函数的实际参数，也可以作为这个函数的返回值。</strong></p></blockquote><p><strong>不使用协变的例子会出现的问题：</strong></p><blockquote><p>函数 feedAll 用来负责喂养用类Herd代表的一群动物，Herd类的类型参数确定了畜群中动物的类。</p><pre><code class="kotlin">/*    定义一个不变型的类似集合的类    */open class Animal { fun feed() {     /**/ }}class Herd&lt;T : Animal&gt; {   // 类型参数没有声明为协变的。 val size: Int     get() =         operator fun get(i: Int): T {     /*...*/ }}fun feedAll(animals: Herd&lt;Animal&gt;) { for (i in 0 until animals.size) {     animals[i].feed }}</code></pre><p>现在需要添加一群猫照顾。</p><pre><code class="kotlin">/*  使用一个不变型的类似集合的类  */class Cat : Animal() { //Cat是一个Animal fun cleanLitter() {     ... }}fun takeCareOfCats(cats: Herd&lt;Cat&gt;) { for (i in 0 until cats.size) {     cats[i].cleanLitter()   //     //feedAll(cats }}</code></pre><p>这时会出现问题，如果你尝试把Cat猫群类传给feedAll函数，在编译器你就会得到类型不匹配的错误。因为Herd类中的类型参数T没有用任何变形修饰符，猫群不是畜群的子类（子类型化没有被保留）。可以使用显式的类型转化来绕过这个问题，但是这种函数啰嗦，易出错，而且从来不是解决类型不匹配问题的正确方法。</p><p>Herd类中有一类似List的API，并且不允许它的调用者添加和修改畜群中的动物，可以把它变成协变的并相应修改带用代码。</p><pre><code class="kotlin">/*使用一个协变的类似集合的类*/class Herd&lt;out T : Animal&gt; {//}fun takeCaraOfCats(cats: Herd&lt;Cat&gt;) { for (i in 0 until cats.size) {     cats[i].cleanLitter() } feedALl(cats)   //不需要转换}</code></pre></blockquote><p>你不能把任何类都变成协变的：这样不安全。让类在某个类型参数变为协变，限制了该类中对该类参数使用的可能性。要保证类型安全，它只能用在out位置，意味着这个类只能生产（返回）T 的值而不能消费（）</p><blockquote><p>在类成员的声明中类型参数的使用可以分为in位置和out位置。<strong>考虑怎样一个类，它声明一个类型参数T并包含了一个使用T的函数。</strong>如果函数把T当成返回类型，我们说它在out位置，这种情况下，该函数生产类型为T的值。如果T用作函数参数的类型，它就在in位置。这样的函数消费类型为T的值。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20211009171605.png" alt="函数参数的类型叫做in文字，函数返回类型叫作out位置"></p></blockquote><p><strong>约束使用T的位置</strong></p><p>类的类型参数前的out关键字要求所有使用T的方法只能把T放在out位置而不能放在in位置。这个关键字约束了使用T的可能性，这保证了对应子类型关系的安全性。</p><blockquote><p>例子</p><p>以Herd类为例，它只能在一个地方使用类型参数T:get方法的返回值。</p><pre><code class="kotlin">class Herd(out T: Animal) { val size: Int     get() =         operator fun get(i: Int): T {}//把T作为返回类型使用}</code></pre><p>这是一个out位置，可以安全的把类声明成协变的。如果Herd<Animal>类的get方法返回的是Cat，任何调用该方法的代码都可以正常工作，因为Cat是Animal的子类型。</p><p>类型参数T上的关键字out有两层含义：</p><ul><li>子类型化会被保留（Producer<Cat>是Producer<Animal>的子类型）</li><li>T只能用在out位置</li></ul></blockquote><p><strong>类型形参可以作为另一个类的类型实参</strong></p><p>例</p><p>看这个List<Interface>接口。Kotlin中List是只读的，所以它只有一个返回类型为T的元素的方法get，而没有定义任何一个把类型为T的元素存储到列表中的方法。因此它是协变的。</p><pre><code class="kotlin">interface List&lt;Out T&gt;:Collection&lt;T&gt;{    operator fun get(index: Int):T    //只读接口自定义了返回T的方法（所以T在out的位置）}</code></pre><p>类型形参不光可以直接当作参数类型或者返回类型使用，<strong>还可以当作另一个类型的类型实参</strong>。例，List接口包含了一个返回List<T>的subList方法。</p><pre><code class="kotlin">interface List&lt;Out T&gt;:Collection&lt;T&gt;{    fun subList(fromIndex: Int, toIndex: Int): List&lt;T&gt;   //这里的T在out的位置}</code></pre><p>函数subList中的T也用在out位置。</p><p><strong>Mutable不能在类型参数上声明成协变的</strong></p><p>因为即含有接受类型为T的值作为参数的方法，也含有返回这种值的方法（因此，T出现在in和out两种位置上）。</p><pre><code class="kotlin">interface MutableList&lt;T&gt; : List&lt;T&gt;, MutableCollection&lt;T&gt; {  //MutableList不能在T上声明成协变的...    override fun add(element: T): Boolean {//...因为T用在了“in”位置        TODO(&quot;Not yet implemented&quot;)    }}</code></pre><p>编译器强制限制了这次协变。如果这个类被声明成了协变，编译器会报告错误:Type parameter T is declared as ‘out’ but occurs in ‘in’ position（类型参数T声明为“out”但出现在“in”位置）。</p><p><strong>构造方法</strong></p><p>注意，构造方法的参数既不在in位置，也不在out位置。即使类型参数声明成了out，仍然可以在构造方法参数的声明中使用它：</p><pre><code class="kotlin">class Herd&lt;Out T:Animal&gt;(vararg animals:T){    ...}</code></pre><p>如果 把类的实例当成一个类泛化的类型的实例使用，变型会防止该实例被误用：不能调用存在潜在危险的方法。<strong>构造方法在实例创建后不会被调用，因此就不会有危险。</strong></p><p>然而，如果你在构造方法的参数上使用了关键字val和var，同时就会声明一个getter和setter（如果属性是可变的）。<strong>因此对只读属性来说，类型参数用在了out位置， 可变属性在out位置的in位置都是用它：</strong></p><pre><code class="kotlin">class Herd&lt;T:Animal&gt;(var leadAnimal:T,vararg animals:T){...}</code></pre><p>这里 T不能用out标记，因为类包装属性leadAnimal的setter，它在in位置用到了T。</p><p><strong>关于设置修饰符</strong></p><p>这里位置规则只覆盖了类外部可见的（public、protected、和internal）API。私有方法的参数既不在in位置也不在out位置。变形规则只会防止外部使用者对类的误用但不会对类自己的实现起作用：</p><pre><code class="kotlin">class Herd&lt;out T:Animal&gt;(private var leadAnimal:T,vararg animals:T){...}</code></pre><p><strong>现在可以安全地让Herd在T上协变，因为属性leadAnimal变成了私有的。</strong></p><p>如果类型参数在in的位置使用，类和接口会怎样。这是就要有逆变关系成立。</p><h3 id="9-3-4-逆变：反转子类型化的关系"><a href="#9-3-4-逆变：反转子类型化的关系" class="headerlink" title="9.3.4 逆变：反转子类型化的关系"></a>9.3.4 逆变：反转子类型化的关系</h3><p><strong>概念</strong></p><p>逆变的概念可以被看作是协变的镜像：对一个逆变类来说，它的子类型化关系与用作类型实参的类的子类型化关系是相反的。</p><p><strong>逆变例子</strong></p><blockquote><p>我们从Comparator接口的例子开始，这个接口定义了一个方法compare类，用于比较两个给定的对象：</p><pre><code class="kotlin">interface Comparator&lt;in T&gt; { fun compare(e1: T, e2: T): Int {    //在in位置使用T }}</code></pre><p>这个接口方法只是消费类型为T的值。这说明T只在in位置使用，因此它的声明之前用了in关键字。一个为特定类型的值定义的比较器显然可以比较该类型任意子类型的值。例如，如果有一个Comparator<Any>，<strong>可以用它比较任意具体类型的值。</strong></p><pre><code class="kotlin">&gt;&gt;&gt; val anyComparator = Comparator&lt;Any&gt; { e1, e2 -&gt; e1.hashCode() - e2.hashCode()}&gt;&gt;&gt; val strings: List&lt;String&gt;=...&gt;&gt;&gt; strings.sortedWith(anyConparator)   // 可以用任意对象的比较器比较具体对象，比如字符串</code></pre><p>sortedWith函数期望一个Comparator&lt; String &gt;(一个可以比较字符串的比较器)，传给它一个能比较跟一般的类型的比较器是安全的。如果你在特定类型的对象上执行比较，<strong>可以使用能处理该类型或者它的超类型的比较器。这说明Comparator&lt; Any &gt;是Comparator&lt; String &gt;的子类型，其中Any是String的超类型。</strong>不同类型之间的子类型关系和这些类型的比较器之间的子类型化关系截然相反。</p></blockquote><p><strong>描述一个逆变类</strong></p><blockquote><p>在 <strong>类型参数</strong> 上逆变的类是这样的一个泛型类（我们以Consumber&lt; T &gt;为例），对这个类来说，下边的描述是成立的：</p><p><strong>如果B是A的子类型，那么Consumer&lt; A &gt;就是Consumer&lt; B &gt;的子类型。类型参数A和B交换了位置，所以我们说子类型化被反转了。例如，Consumer&lt; Animal &gt;就是Consumer&lt; Cat &gt;的子类型。</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20211011233756.png" alt="对协变类型Producer&lt;T&gt;来说，子类型化保留了，但对逆变类型来说，子类型化反转了"></p><p>展示了类型参数上协变和逆变的类之间子类型化关系的差异。可以看到对Producer类来说，子类型化关系复制了它的类型实参的子类型化关系，而对Consumer类来说，关系反转了。</p><p><strong>in 关键字声明逆变</strong></p><p>in 关键字的意思是，对应类型的值是传递进来给这个类的方法的，并且被这些方法消费。和协变的情况类似，约束类型参数的使用将导致特定的子类型化关系。<strong>在类型参数T上的in关键字意味着子类型化被反转了，而且T只能用在in位置。</strong></p><table><thead><tr><th align="center">协变（方法名称为案例）</th><th>逆变</th><th>不变型</th></tr></thead><tbody><tr><td align="center">Producer&lt; out T&gt;</td><td>Consumer&lt; in T&gt;</td><td>MutableList&lt; T&gt;</td></tr><tr><td align="center">类的子类型化保留了：Producer&lt; Cat&gt;是Producer&lt; Animal&gt;的子类型</td><td>子类型化反转了：Consumer&lt; Animal&gt;是Consumer&lt; Cat&gt;的子类型</td><td>没有子类型化</td></tr><tr><td align="center">T只能在out位置</td><td>T只能在in位置</td><td>T可以在任何位置</td></tr></tbody></table><p><strong>一个类可以在一个类型参数上协变，同时在另一个类型参数上逆变。Function接口的例子。</strong></p><pre><code class="kotlin">interface Function1&lt;in P, out R&gt; {    operator fun invoke(p: P): R}</code></pre><p>Kotlin的表示法(P)-&gt;是表达Function&lt;P,R&gt;的另一种可读性的形式。可以发现用in关键字标记P（参数类型）只用在in位置，而用out关键字标记的R（返回类型）只用在out位置。这意味着对这个函数类型的第一个类型参数来说，子类型化反转了，而对第二个类型参数来说，子类型化保留了。</p><p><strong>例，你有一个高阶函数，该函数尝试对里所有的猫进行迭代，你可以把一个接收任意动物的lambda传给它。</strong></p><pre><code class="kotlin">fun enumerateCats(f: (Cat) -&gt; Number) {    ...}fun Animal.getIndex(): Int = ...&gt;&gt;&gt; enumerateCats(Animal::getIndex) //在Kotlin中这段代码是合法的。Animal是Cat的超类型，而Int是Number的子类型</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20211012002918.png" alt="函数(P)-&gt;R在它的参数类型上逆变而在返回类型上协变"></p><h3 id="9-3-5-使用点变形：在类型出现的地方指定变型"><a href="#9-3-5-使用点变形：在类型出现的地方指定变型" class="headerlink" title="9.3.5 使用点变形：在类型出现的地方指定变型"></a>9.3.5 使用点变形：在类型出现的地方指定变型</h3><p><strong>声明点变型</strong></p><p>在类声明的时候就能够指定变形修饰符是很方便的，因为这些修饰符会应用到所有类被使用的地方。所以被称为<strong>声明点变型</strong></p><p><strong>使用点变型</strong></p><p>如果你熟悉Java的通配符类型（? extends 和 ? super），你会意识到Java用完全不同的方式处理类型。在Java中，每一次使用带类型参数的类型的时候，还可以指定这个类型参数是否可以用它的子类型或者超类型替换。这叫做 <strong>使用点变型</strong></p><p><strong>Kotlin 支持使用，使用点变型</strong></p><blockquote><p>Kotlin支持使用点变型，允许在类型参数出现的具体位置指定变型，即使在类型声明时不能被声明成协变或逆变的。</p></blockquote><p><strong>看看使用点变型是如何工作的</strong></p><blockquote><p>许多MutableList这样的接口，通常情况下既不是协变也不是逆变的，因为它同时生产和消费指定为它们类型参数的类型的值。但是对于这个类型的变量来说，在某个特定函数中只被当成其中一种角色使用的情况很常见：要么是生产者要么是消费者。例如</p><pre><code class="kotlin">/*    带不变型类型参数的 数据拷贝函数    */fun &lt;T&gt; copyData(source: MutableList&lt;T&gt;, destination: MutableList&lt;T&gt;) {for (item in source) {  destination.add(item)}}</code></pre><p>这个函数从一个集合中把元素拷贝到另一个集合中。尽管两个集合都拥有不变型的类型，来源集合只是用于读取，而目标集合只是用于写入。这种情况下，集合元素的类型不需要精确匹配。例如，把一个字符串集合拷贝到可以包含任何集合中一点问题没有。</p><p>让函数支持不同类型的列表，<strong>引入第二泛型参数</strong></p><pre><code class="kotlin">/*    9.15 带不变型类型参数的数据拷贝函数    */fun &lt;T : R, R&gt; copyData(source: MutableList&lt;T&gt;, destination: MutableList&lt;R&gt;) {  //来源的元素类型应该是目标元素类型的子类型for (item in source) {  destination.add(item)}}&gt;&gt;&gt; val ints = mutableListOf(1, 2, 3)&gt;&gt;&gt; val anyItems = mutableListOf&lt;Any&gt;()&gt;&gt;&gt; copyData(ints,anyItems) //可以调用这个函数，因为Int是Any的子类型&gt;&gt;&gt; println(anyItems)[1,2,3]</code></pre><p>你声明了两个泛型参数代表 来源列表和目标列表中的元素类型。为了能够把一个列表中的元素拷贝到另一个列表中，来源元素类型应该是目标列表中的元素的子类型，例如 9.15中的Int是Any的子类型。</p><p>另一种方式支持不同列表。</p><p>Kotlin提供了更优雅的表达方式。当函数的实现调用了那些类型参数只出现在out位置（或只出现在in位置）的方法时，可以充分利用这一点，在函数定义中给特定用途的类型参数用上<strong>变型修饰符</strong></p><pre><code class="kotlin">/*    9.16 带out投影类型参数的数据拷贝函数    */fun &lt;T&gt; copyData(source: MutableList&lt;out T&gt;,destination: MutableList&lt;T&gt;) {for (item in source) {  destination.add(item)}}</code></pre><p>可以为类型声明中类型参数任意的用法指定变型修饰符，用法包括：形参类型、局部变量类型、函数返回类型、等。<strong>这发生的一切都叫做 类型投影：我们说source不是一个常规的MutableList，而是一个投影受限的MutableList。</strong>只能调用返回类型是泛型类型参数的那些方法。编译器禁止调用使用类型参数做实参（类型）的哪些方法（在in位置使用类型参数）：</p><pre><code class="kotlin">&gt;&gt;&gt; val list: MutableList&lt;out Number&gt; = ...&gt;&gt;&gt; list.add(42)Error:Out-projectedType &#39;MutableList&lt;out NUmber&gt;&#39; prohibitsthe use of &#39;fun add(element:E):Boolean&#39;</code></pre><p>（在in位置使用类型参数后调用类型参数方法是不可取的。）</p><p><strong>不要为使用投影类型参数后不能调用某些方法而吃惊。如果需要调用那些方法，你需要的是常规类型而不是投影。</strong>这可能要求你声明第二类型参数，它依赖的是原本要进行投影的类型，例 9.15 中那样。</p><p>因为我们只用了声明在List中的方法，并没有用到MutableList中的方法，而且List类型参数的变型在声明时就指定了。所以实现copyData函数的正确方式应该是使用List<T>作为source实参的类型。<strong>这个例子展示这种概念依然十分重要，尤其是要记住大多数的类并没想List和MutableLIst这样分开两个接口，一个是协变的读取接口，一个是不变型的读取/写入接口。</strong></p><p><strong>在类型参数有out变型时投影没有意义</strong></p><p>如果类型阐述已经有out变型，获取它的out投影没有任何意义。就像List<out T> 这样。它和List<T>是同一个意思，因为List已经声明成了class List<out T>。Kotlin编译器会发出警告，表明这些投影是多余的。</p><p>同理，对类型参数的用法使用in修饰符，来表明这个特定的地方，相应的值担当的是消费者，而且类型参数可以任意使用它的子类型替换。</p><p>用in来重写部分代码（9.16).</p><pre><code class="kotlin">fun &lt;T&gt; copyData(source: MutableList&lt;T&gt;, destination: MutableList&lt;in T&gt;) {//允许目标元素的类型是来源类型的超类型 for (item in source) {     destination.add(item)     }}</code></pre><blockquote><p>注意：Kotlin的使用点变型直接对应Java的限界通配符。Kotlin 中的MutableList<out T> 和Java 中的MutableList&lt;? extends T&gt;是一个意思。in投影是一个意思。in 投影的MutableList<in T>对应到Java的MutableList&lt;? super T&gt;。</p></blockquote></blockquote><p><strong>（优点）使用点变型有助于放宽可接受的类型范围。</strong>讨论另一种极端情况：这种情况下（泛型）类型使用所有可能的类型实参。（泛型要使用所有可能的类型）</p><h3 id="9-3-6-星号投影：-代替类型参数"><a href="#9-3-6-星号投影：-代替类型参数" class="headerlink" title="9.3.6 星号投影：* 代替类型参数"></a>9.3.6 星号投影：* 代替类型参数</h3><p>在提到类型检测和转换的时候，我们提到了一种特殊的 <strong>星号投影</strong> 语法，可以用它来表明你不知道关于泛型实参的任何信息。</p><p>List&lt;*&gt;表示为一个未知类型的元素的列表用这种语法表示。</p><p><strong>星号投影的含义</strong></p><p>首先 ，<strong>需要注意的是MutableList&lt;*&gt;和MutableList&lt;Any?&gt;不一样（这里MutableList<T>在T上是不变型的。）</strong>。你确信MutableList&lt;Any?&gt;这种列表包含的是 <strong>任意类型的元素。</strong>另一方面，MutableList&lt; * &gt;是包含某种 <strong>特定类型的元素的列表</strong>，但是你不知道是那个类型。这种列表被创建成一个 <strong>包含某种特定类型元素的列表</strong>， 比如String（你无法创建一个ArrayList&lt; * &gt;),而且创建它的代码期望只包含特定那种类型的元素。因为不知道是那种类型，你不能向列表中写入任何东西，因为你写入的任何值都可能会违反调用代码的期望。但是从列表中 <strong>读取元素是可行的，</strong> <strong>所有存储在列表中的值都能匹配所有Kotlin类型的超类型Any?</strong></p><pre><code class="kotlin">&gt;&gt;&gt; val list: MutableList&lt;Any?&gt;=mutableListOf(&#39;a&#39;, 1, &#39;qwe&#39;)&gt;&gt;&gt; val chars = mutableListOf(&#39;a&#39;, &#39;b&#39;, c)&gt;&gt;&gt; val unknownElements: MutableLIst&lt;*&gt; = // MutableList&lt;*&gt;和MutableList&lt;Any?&gt;不一样。    if (Random().nextBoolean())        list    else        chars&gt;&gt;&gt; unknownElements.add(42) //编译器禁止调用这个方法Error: Out-projected type &#39;MutableList&lt;*&gt;&#39; prohibits the use of &#39;fun add(element:E): Boolean&#39;&gt;&gt;&gt; println(unknownElements.first())    // 读取元素是安全的：first.(）返回一个类型为Any?的元素。3</code></pre><p>为什么编译器会把 MutableList&lt; * &gt; <strong>当成out投影的类型？（out-projected）</strong>。 在这个例子的上下文中， <strong>MutableList&lt;  *  &gt;投影成了MutableList&lt;Any?&gt;:</strong> 当你没有任何元素类型信息的时候，读取Any?类型的元素仍然是安全的， <strong>但是向列表中写入元素是不安全的。</strong></p><blockquote><p><strong>注意：</strong></p><p>对于Consumber<in T> 这样的逆变类型参数来说，星号投影等价于<in Nothing>。实际上这种星号投影无法调用任何签明中有T的方法。如果类型参数是逆变的，它就只能表现为一个消费者，你不知道它消费的到底是什么。</p></blockquote><p><strong>场景</strong></p><blockquote><p>当类型实参的信息并不重要的时候，可以使用星号投影的语法：不需要使用任何在签名中引用类型参数的方法，或者只是读取数据而不关心它的具体类型。列入，可以实现一个接收List&lt;*&gt;做参数的printFirst函数：</p><pre><code class="kotlin">fun printFirst(list: List&lt;*&gt;) {   // 每一种列表都可能是实参。    if (list.isNotEmpty()) {  // isNotEmpty()没有使用泛型类型参数        println(list.first())   // fist()现在返回的是Any?,但在这里足够了    }}&gt;&gt;&gt; printFirst(listOf(&#39;Svetlana&#39;,&#39;Dmitry&#39;))Svetlana</code></pre><p>使用点变型的情况下，有一个代替方案–引入一个泛型类型参数：</p><pre><code class="kotlin">fun &lt;T&gt; printlnFirst(list: List&lt;T&gt;) { // 每一种列表都是可能的实参    if (list.isNotEmpty()) {        println(list.first())   //first()现在返回的是T的值。    }}</code></pre><p>星号投影的语法很简洁，但只能用在对泛型类型实参的确切值不感兴趣的地方：只是使用生产值的方法，而且不关心那些值的类型。</p></blockquote><p><strong>场景</strong></p><blockquote><p>另一个使用星号投影的日子，以及使用这种方法时会困扰你的陷阱。</p><p>假如你需要验证用户的输入，并声明一个接口FieldValidator。它只包含在in位置的类型参数，所以声明成了逆变的。事实上，当期望的是字符串验证器时使用可验证任意元素的验证器也是没有问题的（这就是声明成逆变带来的效果）。同时还声明了两个验证器来分别处理String和Int。</p><pre><code class="kotlin">/*     9.18 输入验证的接口 */interface FieldValidator(in T) { //接口定义成 在 T 上的逆变。fun validete(input: T): Boolean   // T只在“in&quot;位置使用（这个方法只消费T的值）。}object DefaultStringValidator : FieldValidator&lt;String&gt; {override fun validate(input: String) = input.isNotEmpty()}object DefaultIntValidator : FieldValidator&lt;Int&gt; {override fun validate(input: int) = input &gt;= 0}</code></pre><p>现在假设你想要把所有的验证器都存储到同一个容器中，并根据输入的类型来选出正确的验证器。首先会用到map来存储它们。你存储的是任意类型的验证器，所以你声明了KClass（代表一个Kotlin类，10章会详细介绍KClass）到FiledValidator&lt;*&gt;（可以指向任意类型的验证器）的map：</p><pre><code class="kotlin">&gt;&gt;&gt; validators = mutableMapOf&lt;KClass&lt;*&gt;，FieldValidator&lt;*&gt;&gt;() //key ,value&gt;&gt;&gt; validators[String::class] = DefaultStringValidator&gt;&gt;&gt; validators[Int::class] = DefaultIntValidator</code></pre><p>如果你这样做了，尝试使用验证器的时候就会遇到困难。不能用类型为FieldValidator&lt;*&gt;的验证器来验证字符串。这是不安全的，因为编译器不知道它是那种验证器：</p><pre><code class="kotlin">&gt;&gt;&gt; validators[String::class]!!.validate(&quot;&quot;)    //存储在map中的值的类型是FieldValidator&lt;*&gt;。Error:Out-projected type &#39;FieldValidator&lt;*&gt;&#39; prohibits the use of &#39;fun validate(intput: T):Boolean&#39;</code></pre><p>（写入时会报错）在前面尝试向MutableList&lt;<em>&gt;中写入元素的时候，你已经见过这种错误了。这种情况下，这个错误的意思是把具体类型的值传给未知类型的验证器是否安全的。*</em>一种修正方法是把验证器显式地转换成需要的类型。<strong>这样做是不安全的，也是不推荐的。</strong>但我们还是把他作为让代码快速通过编译的技巧展示在这里，这样可以在后面重构它。**</p><pre><code class="kotlin">/*    9.19 使用显式的转换获取验证器    */&gt;&gt;&gt; val stringValidator = validators[String::class] as FieldValidator&lt;String&gt;   //警告未受检的转换&gt;&gt;&gt; println(stringValidator.validate(&quot;&quot;))false</code></pre><p>编译器发出了未受检转换的警告。注意，尽管如此，这段代码只有在验证时可以失败，而不是在转换时，因为运行时所有的泛型信息都被擦除了。</p><pre><code class="kotlin">/*   9.20 错误的获取验证器   */&gt;&gt;&gt; val stringValidator = validators[Int::class]// 得到一个错误的验证器（可能为不小心0，但代码可以编译。(获取一个Int强制转换为String)        as FieldValidator&lt;String&gt;  // 仅仅一个警告&gt;&gt;&gt; stringValidator.validate(&quot;&quot;)    //直到使用验证器才发现错误。java.lang.ClassCastException:java.lang.String cannot be cast to java.lang.Number at DefaultIntValidator.validate</code></pre><p>这两段代码在两种情景下是相似的，都只会发出警告。这些强制转换导致类型不安全，也容易出错。如果想要把不同类型的验证器存储在同一个地方，我们要研究一下其他的选择。</p></blockquote><p>代码 9.21 中使用解决方法 map validators，<strong>但是把所有对它的访问封装到了两个泛型方法中，它们负责保证只有正确的验证器被注册和返回。</strong>这段代码依然会发出未受捡转换的警告（这之前的一样），但这里的Validators对象控制了所有对map的访问，保证了没有任何人会错误的改变map。</p><pre><code class="kotlin">/*  9.21 封装对验证器集合的访问  */object Validators {    private val validators = = mutableMapOf&lt;KClass&lt;*&gt;, FieldValidator&lt;*&gt;&gt;()  //使用和之前一样的map，但现在无法在外部访问他    fun &lt;T : Any&gt; registerValidator(        kCLass: KClass&lt;T&gt;, fieldValidator: FieldValidator&lt;T&gt;    ) {        validators[kClass] = fieldValidator // 只有正确的键值对被写入map，即但验证器正好对应到类的时候。    }    @Suppress(&quot;UNCHECKED_CAST&quot;) // 禁止关于未受检的转换到FieldValidator&lt;T&gt; 的警告    operator fun &lt;T : Any&gt; get(kClass: KClass&lt;T&gt;): FieldValidator&lt;T&gt; =    validators[kCLass] as? FieldValidator&lt;T&gt; ?: throw IllegalArgumentException(    &quot;No validator for ${kClass.simpleName}&quot;    )}&gt;&gt;&gt; Validators.registerValidator(String::class, DefaultStringValidator)&gt;&gt;&gt; Validators.registerValidator(Int::class,DefaultIntValidator)&gt;&gt;&gt; println(Validators[String::class].validate(&quot;Kotlin&quot;))true&gt;&gt;&gt; println(Validators[Int::class].validate(42))true</code></pre><p>你拥有了一个类似安全的API。所有不安全的逻辑都被隐藏在类的主体中，通过把这些逻辑局部化，保证了它不会被错误的使用。编译器禁止使用错误的验证器，因为Validatos对象始终都会给出正确的验证器实现。</p><pre><code class="kotlin">&gt;&gt;&gt; println(Validators[String::class].validate(42))Error:The integer literal does not conform to the expected type String</code></pre><p>通过封装验证器集合的模式可以轻松的推广到任意自定义泛型类的存储。把不安全的代码局部化到一个分开的位置预防了误用，而且让容器的使用变的安全。这个模式并不是只针对Kotlin，Java中也可以使用同样的方法。</p><h2 id="9-4-小结"><a href="#9-4-小结" class="headerlink" title="9.4 小结"></a>9.4 小结</h2><ul><li>Kotlin的泛型同Java的泛型接近它们使用同样的方式声明泛型函数和泛型类。</li><li>同Java一样，泛型类型的类型实参只在编译器存在。</li><li>不能把带类型实参的类型和is运算符一起使用，因为类型实参在运行时不被擦除。</li><li>内联函数的类型参数可以标记成实化的，允许你在运行时对它们使用is检查，以及获得java.lang.Class实例</li><li>变型是一种说明两种拥有相同基础类型和不同类型参数的泛型类型之间子类型化关系的方式，<strong>它说明了如果其中一个泛型类型的类型参数是另一个的类型参数的子类型，这个泛型类型就是另外一个泛型类型的子类型或者超类型。</strong></li><li>声明一个类在某个类型上是协变的，该参数只能用在out位置。</li><li>逆变情况相反:可以声明一个类在某个类型参数上是逆变的，如果该参数只是用在in位置。</li><li>Kotlin中只读接口List声明成了逆变，这意味着List&lt; String &gt; 是 List&lt; Any &gt;的子类型</li><li>函数接口声明成了在第一个类型参数上逆变而在第二个接口上协变，使(Animal)-&gt;Int称为(Cat)-&gt;Number的子类型。</li><li>在Kotlin中即可以为整个泛型类指定变型（声明点变型），也可以为泛型类型特定的使用指定变型（使用点变型）。</li><li>当确切的类型实参是未知的或者不重要时，可以使用星号投影语法。</li></ul><h1 id="10-注解和反射"><a href="#10-注解和反射" class="headerlink" title="10 注解和反射"></a>10 注解和反射</h1><p>要调用一个函数，你需要知道定义在哪个类中，还有它的名称和参数的类型。 <strong>注解和反射</strong>给你超越这个规则的能力，并让你编写出使用事先未知的任意类的代码。可以使用注解赋予这些类库特定的语义，而反射允许你在运行时分析这些类的结构。</p><p>应用注解非常直接了当。但编写你的注解尤其是编写处理它们的代码，就没有这么简单了。使用注解的语法鱼Java完全相同，而声明自己注解类的语法却略有不同。  反射API的大体结构与Java相仿，但细节存在差异。</p><p><strong>作为注解和反射用法的演示，我们将会带你浏览一个真实项目的实现：一个叫做JKid的库，用来序列化和反序列化JSON。这个库在运行时用反射访问任意的Kotlin对象，同时还根据JSON文件中提供的数据创建对象。注解则可以让你定制具体的类和属性是如何被这个库序列化和反序列化的。</strong></p><p>地址：<a href="https://github.com/TheCara/jkid" target="_blank" rel="noopener">https://github.com/TheCara/jkid</a></p><h2 id="10-1-声明并应用注解"><a href="#10-1-声明并应用注解" class="headerlink" title="10.1 声明并应用注解"></a>10.1 声明并应用注解</h2><p>Kotlin 中的核心概念是一样的。一个注解允许你把额外的元数据关联到一个声明上。然后元数据就可以被相关的源代码工具访问，同个编译好的类文件或是在运行时，取决于这个注解是如何配置的。</p><h3 id="10-1-1-应用注解"><a href="#10-1-1-应用注解" class="headerlink" title="10.1.1 应用注解"></a>10.1.1 应用注解</h3><p>​        在Kotlin中使用注解的方法和Java中一样。要应用一个注解，以@字符作为（注解）名字的前戳，并放在要注解的声明最前面。可以注解不同的代码元素，比如函数和类。</p><p>​        例如，使用框架JUnit（<a href="http://junit.org/junit4)，可以用@Test标记一个测试方法：" target="_blank" rel="noopener">http://junit.org/junit4)，可以用@Test标记一个测试方法：</a></p><pre><code class="kotlin">import org.junit.*class MyTest {    @Test    fun testTrue() {    //@Test注解指引Junit框架把这个方法当测试调用        Assert.assertTrue(true)    }}</code></pre><p>另一个更有趣的例子：@Deprecated注解。它在Kotlin总的含义与java一样（@Deprecated 注解含义：意思为此方法已过时，因为有了新的API代替它。）但是Kotlin用replaceWith参数增强了它，让你可以提供 一个替代者的（匹配）模式，以支持平滑的过渡到API的新版本。</p><p>如何给一个注解提供实参（一条 不推荐使用 的信息和一个 替代者 的模式：</p><pre><code class="kotlin">@Deprecated(&quot;Use removeAt(index) instead.&quot;,RepalceWith(&quot;removeAt(Index)&quot;))fun remove(index:Int){ ... }</code></pre><p>实参在括号中传递，就和常规函数的调用一样。用了这个声明之后，如果有人使用了remove函数，IntelliJ IDEA 不仅会提示应该使用哪个函数来使用它（这个例子中removeAt），还会提供一个自动的快速修正。</p><p>注解只能拥有如下类型的参数：基本数据类型、字符串、枚举、类引用、其他的注解类，以及前面这些类型的数组。指定注解的实参与Java有微小差别：</p><ul><li>要把一个类指定为注解实参，在类名后加上 ::class :@MyAnnotation(MyClass::class) 。</li><li>要把另一个注解指定为一个实参，去掉注解名称前的@。例如，前面例子中的ReplaceWith是一个注解，但是你把它指定为Deprecated注解的实参时没有用@。</li><li>要把一个数组指定为一个实参，使用arrayOf函数：@RequestMapping（path=arrayOf(“/foo”,”/bar”))。如果注解类是在Java中声明的，命名为value的形参按需自动地被转换成可变长度的形参，所以不用arrayOf函数就可以提供多个实参。</li></ul><p><strong>注解实参</strong>需要在编译期就是已知的，所以你不能引用任意的属性作为实参。要把属性当作注解实参使用，你需要用const修饰符标记它，来告知编译器这个属性是 <strong>编译期常量</strong>。</p><p>下面一个JUnit@Test注解的例子，使用timeout参数测试超时时长，单位为毫秒：</p><pre><code class="kotlin">const val TEST_TIMEOUT = 100L@Test(timeout = TEST_TIMEOUT) fun testMethod(){    ...    }</code></pre><p>在使用const标注的属性可以声明在一个文件的顶层或者一个object之中，<strong>而却必须初始化为基本数据类型或者String类型的值。</strong>如果你尝试使用普通属性作为注解实参，将会得到一个错误“Only ‘const val’ can be used in constant expressions.”（只有‘const val’才能用在常量表达式中）。</p><h3 id="10-1-2-注解目标"><a href="#10-1-2-注解目标" class="headerlink" title="10.1.2 注解目标"></a>10.1.2 注解目标</h3><p> 多数情况下，Kotlin源代码中的单个声明会对应多个Java声明，而且它们每个都能携带注解。例如，一个Kotlin 属性就对应了一个Java字段，getter，以及一个潜在的setter和它的参数。而一个在主构造方法中声明的属性还多拥有一个对应的元素：<strong>构造方法的参数</strong>。因此，说明这些元素中那些需要注解十分必要。</p><p>​    <strong>使用点目标声明</strong>被用来说明要注解的元素。<strong>使用点目标被放在@符号和注解名称之间，并用冒号和注解名分开。下列单词get导致注解@Rule被应用到了属性的getter上。</strong></p><pre><code class="kotlin">@get:Rule// get（使用点目标） Rule（注解目标）</code></pre><p>下面看一个使用这个注解的例子。在JUnit中可以指定一个每个测试方法被执行之前都会执行的规则。例，标准的TemporaryFolder规则用来创建文件和文件夹，并在测试结束后删除它们。</p><p><strong>使用 ”使用点目标声明“ 以及注意事项！</strong></p><p>要指定一个规则，<em>在Java中需要声明一个用@Rule的注解的public字段或者方法</em>。如果在你的Kotlin测试类中只是用@Rule注解了属性folder（包含字段folder？）你会得到一个JUnit一场：“The(???)’folder’ must be public.”（(???)’folder’必须是公有的。）这是因为@Rule被应用到了字段上，而字段是默认是私有的。要把它应用到（公有的）getter上，要显式的写出来，@get:Rule 如下：</p><pre><code class="kotlin">class HasTempFolder {    @get:Rule   // 注解的是getter，而不是属性    val folder = TemporaryFolder()    @Test    fun testUsingTempFolder() {        val createFile = folder.newFile(&quot;myfile.txt&quot;)        val createFolder = folder.newFolder(&quot;subfolder&quot;)        // ...    }}</code></pre><p>如果你使用Java中声明的注解来注解一个属性，它会被默认的应用到相应的字段上。Kotlin 也可以让你声明被直接对应到属性上的注解。</p><p>Kotlin支持的使用点目标的完整列表如下：</p><ul><li>property——Java的注解不能应用这种使用点目标。</li><li>field——为属性生成字段。</li><li>get——属性的getter。</li><li>set——属性的setter。</li><li>receiver——扩展函数或者扩展属性的接收者参数。</li><li>param——构造方法的参数。</li><li>setparam——属性的setter的参数。</li><li>delegate——为委托属性存储委托实例的字段。</li><li>file——包含在文件中声明的顶层函数和属性的类。</li></ul><p>任何应用到file目标的注解都必须放在文件的顶层，放在package指令之前。@JvmName是常见的应用到文件的注解之一，它改变了对应类的名称。</p><p>和Java不一样的是，Kotlin允许你对任意的表达式应用注解，而不仅仅是类和函数的声明以及类型。最常见的例子就是@Suppress注解，可以用它遏制被注解的表达式的上下文中的特定的编译器警告。下面就是一个注解的局部变量声明的例子，抑制了未受捡转换的警告：</p><pre><code class="kotlin">fun test(list: List&lt;*&gt;) {    @Suppress(&quot;UNCHECKED_CAST&quot;)    val string = list as List&lt;String&gt;    // ...}</code></pre><blockquote><p><strong>用注解控制JavaAPI</strong></p><p>Kotlin 提供了各种注解来控制Kotlin编写的声明如何编译成字节码并暴露给Java调用者。其中一些注解代替了Java语言中对应的关键字：比如，注解@Volatile和@Strictfp直接充当了Java的关键字volatile和strictfp的替身。其他的注解则被用来改变Kotlin声明对Java调用者的可见性：</p><ul><li>@JvmName将改变由Kotlin生成的Java方法或字段名称。</li><li>@JvmStatic能被用在对象声明或者伴生对象的方法上，把它们暴露成Java的静态方法。</li><li>@JvmOverloads，指导Kotlin编译器为带默认参数值的函数生成多个重载（函数）。</li><li>@JvmField可以应用于一个属性，把这个属性暴露成一个没有访问器的公有Java字段。</li></ul></blockquote><h3 id="10-1-3-使用注解定制JSON序列化"><a href="#10-1-3-使用注解定制JSON序列化" class="headerlink" title="10.1.3 使用注解定制JSON序列化"></a>10.1.3 使用注解定制JSON序列化</h3><p>注解的典型用法之一就是定制化对象的序列化。<strong>序列化</strong> 是一个过程，把对象转换成可以存储或者在网络上可以传输的二进制或者文本的表达式。它的逆向工程可以 <strong>反序列化</strong> ，把这种表达法转换回对象。而最常见的一种用来序列化的格式计算JSON。 有很多广泛使用的库可以把Java对象序列化成JSON，包括Jackson和GSON。这些对Kotlin完全兼容。</p><p>将会讨论一个满足此用途的名为JKid的纯Kotlin库。它足够小巧，可以轻松的读完它的全部源代码。</p><blockquote><p><strong>JKid 库源代码和练习</strong></p><p>JKid 地址：<a href="https://github.com/yole/jkid。要学习库的实现和例子，在IDE中把文件" target="_blank" rel="noopener">https://github.com/yole/jkid。要学习库的实现和例子，在IDE中把文件</a> ch10/jkid/build.gradle 作为Gradle项目打开。在项目的 src/test/kotlin/examples 目录下可以找到这些例子。它并不像GSON或者Jackson那样完善灵活，但它的性能足够使用。</p></blockquote><p>先从简单的例子开始，测试这个库：序列化和反序列化一个Person类的实例。<em>把实例传递给serialize函数，然后它就会返回一个包含该实例JSON表示法的字符串：</em></p><pre><code class="kotlin">data class Person(val name:String,val age:Int)&gt;&gt;&gt; val person = Person(&quot;Alice&quot;,29)&gt;&gt;&gt; println(serialize(person)){&quot;age&quot;:29,&quot;name&quot;:&quot;Alice&quot;}</code></pre><p>一个对象的JSON表达法由键值对组成：具体实例的属性名称和它们的值之间的键值对，比如：“age”:29 。</p><p><strong>要从JSON表达法中取回一个对象，</strong>要调用deserialize函数：</p><pre><code class="kotlin">&gt;&gt;&gt; val json=&quot;&quot;&quot;{&quot;name&quot;:&quot;Alice&quot;,&quot;age&quot;:29}&quot;&quot;&quot;&gt;&gt;&gt; println(deserialize&lt;Person&gt;(json))Person(name=Alice,age = 29)</code></pre><p><strong>当你从JSON数据中创建实例的时候，必须显式的指定一个类作为类型参数，因为JSON没有存储对象的类型，</strong>这种情况下，你要传递Person类。</p><p>下图，展示了一个对象和它的JSON表示法之间的关系。注意序列化之后的类能包含的不仅是图中展示的这些基本数据类型或者字符串类型的值，还可以是集合，以及其他值对象类的实例。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2022-02-20_19-56-13.jpg" alt="Person实例的序列化和反序列化"></p><p>你可以使用注解来定制对象序列化和反序列化的方式。当把一个对象序列化成JOSN的时候，默认情况下这个库尝试序列化的所有属性，并使用属性名称作为键。注解允许你改变默认的行为，两个注解，@JsonExclude和@JsonName，稍后查看它们的实现：</p><ul><li>@JsonExclude注解用来标记一个属性，这个属性应该排除在序列化和反序列化之外。</li><li>@JsonName注解让你说明代表这个属性的（JSON）<strong>键值对中的键应该是一个给定的字符串，而不是属性的名称。</strong></li></ul><p>参考一个例子：</p><pre><code class="kotlin">data class Person {    @JsonName(&quot;alias&quot;)    val firstName: String,    @JsonExclude    val age: Int? = null}</code></pre><p>你注解了属性firstName，来改变JSON中用来表示它的键。<strong>而属性age也被注解了，在序列化和反序列化时会排除它。注意你必须指定age的默认值。否则，在反序列化时你无法创建一个Person的新实例。</strong> 如下展示了Person内实例的表示法发生了怎样的变化。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220228145204.png" alt="应用注解之后Person实例的序列化和反序列化"></p><blockquote><p>键名是@JsonName注解的字符串“alias”。</p></blockquote><p>已经见过了JKid中出现的大多数功能：serialize()、deserialize()、@JsonName和@JsonExclude。讨论如何实现它们吧。</p><h3 id="10-1-4-声明注解"><a href="#10-1-4-声明注解" class="headerlink" title="10.1.4 声明注解"></a>10.1.4 声明注解</h3><p>这次你会以<strong>JKid库中的注解为例学习怎样声明他们</strong>。注解@JsonExclude有着最简单的形式，因为它没有任何参数：</p><pre><code class="kotlin">annotation class JsonExclude</code></pre><p>语法看起来和普通类的声明很像，只是在class关键词之前加上了annotation修饰符。<strong>因为注解类只是用来定义关联到声明和表达式的元数据的结构，它们不能包含任何代码。</strong>因此，编译器禁止为一个注解类指定主体。</p><p><strong>对拥有参数的注解来说，在类的主构造方法中声明这些参数：</strong></p><pre><code class="kotlin">annotation class JsonName(val name:String)</code></pre><p>你用的是常规的主构造方法的声明语法。对一个注解类的所有参数来说，val关键字是强制的。</p><pre><code class="kotlin">/*    Java    */public @interface JsonName{    String value();}</code></pre><p>注意，Java注解拥有一个叫做value的方法，而Kotlin注解拥有一个name属性。Java中value方法很特殊：当你应用一个注解时，你需要提供value以外所有指定特性的显式名称。而另一方面，在Kotlin中应用注解就是常规的构造方法调用。可以使用命名实参语法让实参的名称变成显式的，或者可以省略掉这些实参的名称：@JsonName(name = “first_name”) 和 @JsonName(“first_name”)含义一样。因为name是JsonName构造方法的第一个形参（它的名称可以省略）。（<strong>Kotlin中如何使用Java中声明的注解？</strong>）然而，如果你需要把Java中声明的注解应用到Kotlin元素上，必须对除啦value以外的所有实参使用命名实参语法，而value也会被kotlin特殊对待。</p><p>如何控制注解的使用，以及如何把注解应用到其他注解上。</p><h3 id="10-1-5-元注解：控制如何处理一个注解"><a href="#10-1-5-元注解：控制如何处理一个注解" class="headerlink" title="10.1.5 元注解：控制如何处理一个注解"></a>10.1.5 元注解：控制如何处理一个注解</h3><p>和Java一样，一个Kotlin注解类自己也可以被注解。可以应用到注解类上的注解被称为<strong>元注解</strong>。标准库中定义了一些元注解，它们会控制编译器如何处理注解。其他一些框架也会用到元注解——<em>例如，许多依赖注入库使用了元注解来标记其他注解，表示这些注解用来识别拥有同样类型的不用的可注入对象。</em></p><p>标准库定义的<strong>元注解</strong>中最常见的就是@Target。<strong>JKid</strong>中@JsonExclude和@JsonName的声明中使用它为这些注解指定有效的目标。下面展示它们是如何应用到这些注解上的。</p><pre><code class="kotlin">@Traget(AnnotationTarget.PROPERTY)annotation class JsonExclude</code></pre><p>@Target <strong>元注解说明了注解可以被应用到元素类型</strong>。<strong>如果不使用它，所有的声明都可以应用这个注解</strong>。这并不是JKid想要的，因为它只处理属性的注解。</p><p>AnnotationTarget枚举的值列出了可以应用注解的全部可能目标。例如：类、文件、函数、属性、属性访问器、所有的表达式，等等。如果需要，你还可以声明多个目标：@Target(AnnotationTarget.CLASS,AnnotationTarget.METHOD)。</p><p>要声明你自己的元注解，使用ANNOTATION_CLASS作为目标就好了</p><pre><code class="kotlin">@Target(AnotationTarget.ANNOTATION_CLASS)annotation class BindingAnnotation@BindingAnnotationannotation class MyBinding</code></pre><p><em>在Java代码中无法使用目标PROPERTY的注解：要让这样的注解在Java中使用，可以给它添加第二个目标AnnotationTarget.FIELD。这样注解既可以应用到Kotlin中的属性上，也可以应用到Java中的字段上。</em></p><blockquote><p>@Retention 注解</p><p>你也许在Java中见过另一个重要的元注解：<strong>@Retention。它被用来说明你声明的注解时候会存储到.class文件，以及在运行时是否可以通过反射来访问它。</strong>Java默认会在.class文件中保留注解但不会让它们在运行期间被访问到。大多数注解确实需要在运行时存在，所以Kotlin的默认行为不同：注解拥有RUNTIME保留期。因此JKid中的注解没有显示地指定保留期。</p></blockquote><h3 id="10-1-6-使用类做注解参数"><a href="#10-1-6-使用类做注解参数" class="headerlink" title="10.1.6 使用类做注解参数"></a>10.1.6 使用类做注解参数</h3><p>你已经见过了如何定义保存了作为其实参的静态数据的注解，但有时候你有不同的需求：能够引用类作为声明的元数据。你可以通过声明一个拥有类引用作为形参的注解类来做到这一点。在JKid库中，这出现在@DeserializeInterface注解中，它允许你控制那些接口类型属性的反序列化。<em>不能直接创建一个接口的实例，因此需要指定反序列化时那个类作为实参被创建。</em></p><p>展示这个注解如何使用：</p><pre><code class="kotlin">interface Company{    val name:String}data class CompanyImpl(override val name:String):Companydata class Person(val name:String, @DeserializeInterface(CompanyImpl::class) val company:Company)</code></pre><p>当JKid读到一个Person类实例嵌套的company对象时，它创建并反序列化了一个CompanyImpl实例，把它存储在company属性中。（说明反序列化）<strong>使用CompanyImpl::class 作为@DeserializeInterface注解的实参来说明这一点。</strong>通常，使用类名称后面跟上::class关键字来引用一个类。</p><p>现在我们看看这个<strong>注解是如何声明的</strong>。(声明类作为注解参数)它的单个实参是一个类的引用，就像@DeserializeInterface(CompanyImpl::class):</p><pre><code class="kotlin">annotation class DeserializeInterface(val targetClass:KCLass&lt;out Any&gt;)</code></pre><p>KClass是Java的java.lang.Class类型在Kotlin中的对应类型。<strong>它用来保存Kotlin类的引用</strong>。</p><p>KClass的类型参数说明了这个引用可以指向哪些Kotlin类。例如，CompanyImpl::class 的类型是KClass&lt; CompanyImpl &gt;,它是这个注解形参类型的子类型，例如：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220305154530.png" alt="注解实参类型CompanyImpl::class(KClass&lt;CompanyImpl&gt;) 是注解形参类型(KClass&lt;out Any&gt;) 的子类型"></p><p>如果你只写出KClass&lt; Any &gt; 而没有写出out修饰符，就不能传递CompanyImpl::class 作为实参：唯一允许的实参将是Any::class 。<strong>out关键字说明允许引用哪些继承Any的类，而不仅仅是引用Any自己。</strong></p><h3 id="10-1-6-使用泛型类作为注解参数"><a href="#10-1-6-使用泛型类作为注解参数" class="headerlink" title="10.1.6 使用泛型类作为注解参数"></a>10.1.6 使用泛型类作为注解参数</h3><p>默认情况下，JKid把<strong>非基本数据类型</strong>（基本数据类型以外）的<strong>属性当成嵌套的对象序列化</strong>。但是你可以改变这种行为并为某些值提供你自己的序列化逻辑。</p><p>@CustomSerializer注解接收一个自定义序列化器<strong>类</strong>的引用作为实参。这个序列化器类应该实现ValueSerializer接口</p><pre><code class="kotlin">interface ValueSerializer&lt;T&gt;{    fun toJsonValue(value:T):Any?    fun fromJsonValue(jsonValue:Any?):T}</code></pre><p>假设你需要支持序列化日期，而且已经为此创建了你自己的DateSerializer类，它实现了ValueSerializer&lt; Data &gt; 接口（这个类是JKid源代码中的一个例子：<a href="http://mng.bz/73/a7" target="_blank" rel="noopener">http://mng.bz/73/a7</a> ）展示如何在Person类应用它：</p><pre><code class="kotlin">data class Person(    val name:String,    @CustomSerializer(DataSerializer::class) val birthDate:Date)</code></pre><p>现在我们看看@CustomSerializer注解是如何声明的。ValueSerializer类是泛型的而且定义了一个类型形参，所以在你引用该类型的时候需要提供一个类型实参值。因为你不知道任何关于那些应用了这个注解的属性类型的信息，可以 使用 <strong>星号投影</strong> 作为类型实参：</p><pre><code class="kotlin">annotation class CustomSerializer(    val serializerClass: KClass&lt;out ValueSerializer&lt;*&gt;&gt;    )</code></pre><p>下图，审视了seralizerClass 参数的类型并解释了其中不同的部分。（声明时限制了范围）<strong>你需要保证注解只能引用实现了ValueSerializer接口的类</strong>。（声明时限制了范围）例如，@CustomSerializer(Data::class)的写法是不允许的，因为Data没有实现ValueSerializer接口。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220305173139.png" alt="serializerClass注解参数的类型。指向ValueSerializer实现类的类引用将会有效的注解实参"></p><p>这好像很麻烦，好消息是每一次需要使用类作为注解实参的时候都可以应用同样的模式。如写KClass&lt; out YourClassName &gt;，如果YourClassName有它自己的类型实参，就用 * 代替它们。</p><p>下面讨论如何访问存储在这些注解中的数据。你需要使用反射做到这些。</p><h2 id="10-2-反射：在运行时对Kotlin对象进行自省"><a href="#10-2-反射：在运行时对Kotlin对象进行自省" class="headerlink" title="10.2 反射：在运行时对Kotlin对象进行自省"></a>10.2 反射：在运行时对Kotlin对象进行自省</h2><p>反射，简单来说，（什么是反射？）<strong>一种在运行时动态地访问对象属性和方法的方式，而不需要事先确定这些属性是什么。</strong> <strong>（为什么使用反射或者什么时候使用反射）*</strong>一般来说，当你访问一个对象的方法或者属性时，程序的源代码会引用一个具体的声明，编译器将静态地解析这个引用并确保这个声明是存在的。但有些时候，你需要编写能够使用任意类型的对象的代码，或者只能在运行时才能确定要访问的方法和属性的名称。JSON序列化库就是这种代码绝好的例子：它要能够把任何对象都序列化成JSON，所以它不能引用具体的类和属性。这时就运用到反射了。*</p><p><em>（Java完美支持Kotlin反射）当在Kotlin中使用反射时，你会和两种不同的反射API打交道。第一种是标准的Java反射，定义在包java.lang.reflect中。因为Kotlin类会被编译成普通的Java字节码，Java反射API可以完美地支持它们。实际上，这意味着使用了反射API的Java库完全兼容Kotlin代码。</em></p><p>第二种是Kotlin反射API，定义在包kotlin.reflect中。<strong>它让你能访问那些在Java世界你不存在的概念，诸如属性和可空类型</strong>。但这一次它没有为Java反射API提供一个面面俱到的替身，而且不久你就会看到，有些情况下你仍然会回去使用Java反射。这里有一个重要提示，<strong>Kotlin反射API没有仅限于Kotlin类：你能够使用同样的API访问用任何JVM语言写成的类。</strong></p><blockquote><p>注意：在一些特别在意运行时库的大小的平台上，例如Android，为了降低大小，Kotlin反射API被打包成了单独的jar.文件，即kotlin-reflect.jar。它不会被默认地添加到新项目的依赖中。如果你正在使用Kotlin反射API，你要确保这个库作为依赖被添加（到项目中）。IntelliJ IDEA能够检查到缺失的依赖并协助你添加它。（这个库的 Maven group/artifact 坐标是 org.jetbrains.kotlin:kotlin-reflect。）</p></blockquote><h3 id="10-2-1-Kotlin反射：KClass、KCallable、KFunction和KProperty"><a href="#10-2-1-Kotlin反射：KClass、KCallable、KFunction和KProperty" class="headerlink" title="10.2.1 Kotlin反射：KClass、KCallable、KFunction和KProperty"></a>10.2.1 Kotlin反射：KClass、KCallable、KFunction和KProperty</h3><p><em>Kotlin反射API的主要入口就是KClass，它代表一个类。KClass对应的是java.lang.class，可以用它来列举和访问类中包含的所有声明(列举运行时的所有类和声明)，然后它的超类型中的声明，</em>等等。<strong>MyClass::class 的写法会带给你一个KClass的实例。要在运行时取得一个对象的类，首先使用javaClass属性获得它的Java类，这直接等价于Java中java.lang.Object.getClass()。然后访问该类的.kotlin扩展属性，从Java切换到Kotlin的反射API。</strong></p><pre><code class="kotlin">class Person(val name:String,val age:Int)&gt;&gt;&gt; val person = Person(&quot;Alice&quot;,29)&gt;&gt;&gt; val kClass = person.javaClass.kotlin    //返回一个KClass&lt;Person&gt;的实例&gt;&gt;&gt; println(kClass.simpleName)person&gt;&gt;&gt; kClass.memberProperties.forEach { println(it.name) }agename</code></pre><p>这个简单的例子打印出了类的名称和它的属性的名称，并且使用.memberProperties来收集这个类，<strong>以及它的所有超类中定义的全部会扩展属性（age和name）</strong>。</p><p>如果浏览一下KClass的声明，你就会发现包含大量的方法，用来访问类的内容：</p><pre><code class="kotlin">interface KClass&lt;T:Any&gt;{    val simpleName:String?    val qualifiedName:String?    val members:Collection&lt;KCallable&lt;*&gt;&gt;    val constructors:Collection&lt;KFunction&lt;T&gt;&gt;    val nestedClasses:Collection&lt;KClass&lt;*&gt;&gt;    ...}</code></pre><p>KClass的许多有用的特性，包括前面例子中用到的memberProperties，都声明成了扩展。可以在标准库参考（http::mng/bz/em4i）中看到完整KClass方法类列表。</p><p><em>你可能已经发现了由类的所有成员组成的列表是一个KCallable实例的集合（KClass声明中有提到）</em>。<strong>KCallable是函数和属性的超接口</strong>。它声明了call方法，<strong>允许你调用对应的函数或者对应属性的getter</strong>：</p><pre><code class="kotlin">interface KCallable&lt;out R&gt;{    fun call(vararg age:Any?):R}</code></pre><p>你把（被引用）函数的实参放在varage列表中提供给它。↓展示如何通过反射使用call来调用一个函数：</p><pre><code class="kotlin">fun foo(x:Int) = println(x)&gt;&gt;&gt; val kFunction = ::foo&gt;&gt;&gt; kFunction.call(42)42</code></pre><p>5.1.5节中有见过::foo  语法，现在可以发现这个表达式的值是来自反射API的KFunction类的一个实例。你会使用KCallable.call方法来调用被引用的参数。这个例子中，你需要提供一个单独的实参，42.如果你用错误数量的实参去调用函数，对比kFunction.call()，这将会抛出一个运行时异常：“IllegalArgumentException：Callable expects 1 arguments，but 0 were provided.”（IllegalArgumentException:Callable期望的是一个参数，但只提供了0个）。</p><p>然而，这种情况下(指报错)，<strong>你可以用一个具体的方法来调用这个函数::foo表达式的类型是KFunction1&lt; Int,Unit&gt;，它包含了形参类型和返回类型的信息。1表达这个函数接收一个形参</strong>。你使用invoke方法通过这个接口来调用函数。它（上边foo的方法）接收固定数量的实参（这个例子中是一个），而且这些实参的类型对应着KFunction1接口的类型形参。你可以直接调用kFunction¹以：</p><pre><code class="kotlin">import kotlin.reflect.KFunction2fun sum(x:Int, y:Int) = x + y&gt;&gt;&gt; val kFunction: KFunction2&lt;Int,Int,Int&gt;=::sum&gt;&gt;&gt; println(kFunction.invoke(1,2)+kFunction(3,4))10&gt;&gt;&gt; kFunction(1)ERROR:No value passed for parameter p2</code></pre><p><strong>现在你无法用数量不确定的实参去调用kFunction的invoke方法：这连编译都不能通过</strong>。因此，如果你有这样一个具体类型的KFunction，它的形参类型和返回类型是确定的，那么应该优先使用这个具体类型的invoke方法。call方法是对所有类型都有的的通用手段，但是它不提供类型安全性。</p><blockquote><p><strong>KFunctionN接口是如何定义的，又是在哪里定义的？</strong></p><p>像KFunction1这样的类型代表了不同数量参数的函数。每一个类型都继承了KFunction并加上一个额外的成员invoke，它拥有数量刚好的参数。例如，KFunction2声明了operator fun invoke(p1:P1,p2:P2) : R，其中P1和P2代表着函数的参数类型，而R代表函数的返回类型。</p><p>这些类型称为 <strong>合成的编译器生成类型</strong>， 你不会在包kotlin.reflect中找到它们的声明。这意味着你可以使用任意数量参数的函数接口。合成类型的方式减小了kotlin-reflect.jar的尺寸，同时避免了对函数类型参数数量的人为限制。</p></blockquote><p>你也可以在一个<strong>KProperty</strong>实例上调用call方法，它会调用该属性的getter。<em>但是属性接口为你提供了一个更好的获取属性值的方法：get方法</em>。</p><p>要访问get方法，你需要根据属性声明的方式来使用确定的属性接口。顶层值表述为KProperty0接口的实例，<em>它有一个无参数的get方法</em>：</p><pre><code class="kotlin">var counter = 0&gt;&gt;&gt; val kProperty = ::counter&gt;&gt;&gt; kProperty.setter.call(21)   //通过反射调用setter，把21作为实参传递&gt;&gt;&gt; println(kProperty.get())    //通过调用 “get” 获取属性的值。21</code></pre><p><strong>一个成员属性由KProperty1（描述）的实例表示，它拥有一个单参数的get方法</strong>。<em>要访问该属性的值，就必须提供你需要的值所属的那个对象实例</em>。下面这个例子在memberProperty变量中存储了一个指向属性的引用（Person::age）；<em>然后调用memberProperty.get(person)来获取属性具体person实例的这个属性的值</em>。所以，如果memberProperty指向了Person类的挨个属性，memberProperty.get(person)就是动态获取person.age的值的一种方式：</p><pre><code class="kotlin">class Person(val name: String, val age: Int)&gt;&gt;&gt; val person = Person(&quot;Alice&quot;,29)&gt;&gt;&gt; val memberProperty = Person::age&gt;&gt;&gt; println(memberProperty.get(person))29</code></pre><p>注意，KProperty1是一个泛型类（描述）。变量memberProperty的类型是KProperty&lt;Person,Int&gt;，<strong>其中一个类型参数表示接收者的类型，而第二个类型参数代表了属性的类型</strong>。这样你只能对正确类型的接收者调用它的get方法；而memberProperty.get(“Alice”)这样的调用不会通过编译。</p><p>还有一点值得注意，只能使用反射（反射注意事项）<strong>访问定义在最外层或者类中的属性</strong>，而<strong>不能访问函数的局部变量</strong>。如果你定义了一个局部变量x并试图使用::x来获取它的引用，你会得到一个编译器的错误：“References to variables aren’ t supported yet”（现在还不支持对变量的引用）。</p><p>👇图展示了运行时你可以用来访问源码元素的接口的层级结构。因为所有的声明都能被注解，所以代表运行时声明的接口，比如KClass、KFunction和KParameter，全部继承了KAnnotatedElement。KClass既可以用来表示类也可以表示对象。KProperty可以表示任何属性，而它的子类KMutableProperty表示用var声明的可变属性。可以使用声明在KProperty和KMutableProperty中的特殊接口Getter和Setter，把属性的访问器当成函数使用——例如，如果你需要取回它们的注解。两个访问器的接口都继承了KFunction。简单起见，图中我们省略了像KProperty0这样的具体的属性接口。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220307151846.png" alt="Kotlin反射API中接口层级结构"></p><p>熟悉了Kotlin反射API的基础，下面研究JKid库是如何实现的。</p><h3 id="10-2-2-用反射实现对象序列化"><a href="#10-2-2-用反射实现对象序列化" class="headerlink" title="10.2.2 用反射实现对象序列化"></a>10.2.2 用反射实现对象序列化</h3><p>首先，回忆一下JKid序列化函数的声明：</p><pre><code class="kotlin">fun serialize(obj:Any):String</code></pre><p>这个函数接收一个对象然后返回JSON表示法的字符串。它通过一个StringBuilder实例构建JSON结果。这个函数在序列化对象属性和它们的值同时，这个内容被附加到这个StringBuilder对象之中。<em>我们把实现放在StringBuilder的扩展函数中，好让append的调用更加简洁。这样，你就不用限定符就可以方便地调用append方法：</em></p><pre><code class="kotlin">private fun StringBuilder.serializeObject(x:Any){    append(...)}</code></pre><p><em>把一个函数参数转化成一个扩展函数的接收者是Kotlin代码中的常见模式，我们会在下个章节继续讨论 。 注意serializeObject没有扩展StringBuilder的API。它(扩展)执行的操作在这个特殊的</em> <strong>上下文之外</strong> <em>毫无意义，所以它被标记成private，以保证它不会在其他地方使用</em>。它被声明成扩展以强调这个特殊对象是代码块的主要对象，让这个对象用起来更容易。</p><p><em>结果，serialize函数把所有的工作委托给了serializeObject：</em></p><pre><code class="kotlin">fun serialize(obj:Any):String = buildString{ serializeObject(obj) }</code></pre><p><em>在5.5.2节中，buildString会创建一个StringBuilder，并让你在lambda中填充它的内容。这个例子中，对serializeObject(obj)的调用提供了要填充的内容。</em></p><p><em>现在我们讨论一下序列化函数的行为。默认情况下，它将序列化对象的所有属性：基本数据类型和字符串将会被酌情序列化成JSON数值、布尔值和字符串值：集合将会被序列化成JSON数组；其他类型的属性将会被序列化成嵌套的对象。这些行为是可以通过注解定制的。</em></p><p><strong>看看serializeObject的实现，在这里可以在真实的场景中观察反射API。</strong></p><pre><code class="kotlin">private fun StringBuilder.serializeObject(obj: Any){    val kClass = obj.javaClass.kotlin    //获取对象的kClass    val properties = KClass.memberProperties    //获取类的所有属性    properties.joinToStringBuilder(        this,prefix = &quot;{&quot;,postfix = &quot;}&quot;) {            prop -&gt; serializeString(prop.name)    //获取类的属性名字            append(&quot;:&quot;)            serializePropertyValue(prop.get(obj))    //获取属性值        }}</code></pre><p><em>这个函数的实现应该很清晰：逐一序列化类的每一个属性。生成的JSON看起来会是这样：{prop1:value1,prop2:value2}。joinToStringBuilder函数保证属性与属性之间用逗号隔开。serializeString函数按照JSON格式的要求对特殊的字符进行转义。serializeString函数检查一个值是否是一个基本数据类型的值、字符串、集合或是嵌套对象，然后相应的序列化它的内容</em>。</p><p>在前面的小节中，我们讨论过一个获取KProperty实例值的方式：get方法。在那个例子中，你使用过类型为KProperty1&lt;Person,Int&gt;的成员引用Person::age，它让编译器知道了接收者和属性值的确切类型。然而在这里例子中，确切类型是未知的，因为你列举了一个对象的类中的所有属性。因此，prop变量拥有类型KProperty1&lt;Any,*&gt;,而prop.get(obj)返回一个Any类型的值。你不会得到任何针对接收者的编译器检查，但是因为你传递的对象和获取属性列表的对象是同一个，接收者的类型是不会错的。</p><h3 id="10-2-3-用注解定制序列化"><a href="#10-2-3-用注解定制序列化" class="headerlink" title="10.2.3 用注解定制序列化"></a>10.2.3 用注解定制序列化</h3><p>在本章的前部分，你见过了定制JSON序列化过程的注解定义。实际上我们讨论过@JsonExclude、@JsonName和@CustomSerializer这几个注解。<em>现在是时候看看serializeObject函数是如何处理这些注解的</em>。</p><p>从<u>@JsonExclude开始，这个注解允许你在序列化的时候排除某些属性</u>。让我们研究一下应该如何修改serializeObject函数的实现来支持它。</p><p>（修改serializerObject来支持@JsonExclude） 回忆一下，你使用KClass实例的扩展属性memberProperties，来取得类的所有成员属性。但现在的任务变得更加复杂：<strong>使用@JsonExclude注解的属性需要被过滤掉</strong>（<code>过滤有使用@JsonExclude注解的属性不要它</code>）。我们来看看如何做到这一点。</p><p><strong>KAnotatedElement接口定义了属性annotations，它是一个由应用到源码中元素上的所有注解（具有运行时的保留期）的实例组成的集合</strong>。（<em>继承关系）因为KProperty继承了KAnnotationElement，可以用property.annotations这样的写法来访问一个属性的所有注解</em>（<code>使用property.annotations来获取一个属性的所有注解</code>）。</p><p>但这里的过滤并不会用到所有的注解，它只需要找到那个特定在注解（@JsonExclude）。辅助函数findAnnotation完成了这个工作：</p><pre><code class="kotlin">inline fun &lt;reified T&gt; KAnnotatedElement.findAnnotation():T?    = annotations.filterIsInstance&lt;T&gt;().firstOrNull()</code></pre><p>findAnnotation函数将返回一个注解，其类型就是指定为类型实参的类型，如果这个注解存在。<u>它用到9.2.3节中我们讨论过的模式，让类型形参变成reified，以期把注解类作为类型实参传递</u>。</p><p>现在可以把findAnnotation和标准库函数filter一起使用，过滤掉那些带@JsonExclude注解的属性：</p><pre><code class="kotlin">val properties = kClass.memberProperties    .filter{it.findAnnotation&lt;JsonExclude&gt;() == null}</code></pre><p>下一个注解是@JsonName。我们把它的实现和使用它的例子重新放在这里作为提示：</p><pre><code class="kotlin">annotation class JsonName(val name:String)data class Persion{    @JsonName(&quot;alias&quot;) val firstName:String,    val age:Int}</code></pre><p>这种情况下，<strong>你关心的不仅是注解存不存在，还要关心它的实参：被注解的属性在JSON中应该用的名称</strong>（<code>属性在JSON中的名称</code>）。幸运的是，findAnnotation函数可以帮上忙：</p><pre><code class="kotlin">val jsonNameAnn = prop.findAnnotation&lt;JsonName&gt;()    //取得@JsonName注解的实例，如果它存在的话val propName = jsonNameAnn?.name ?: prop.name     //取得它的“name” 实参或者备用的“prop.name”</code></pre><p><u>如果属性没有用@JsonName注解，jsonNameAnn就是null，而你仍然需要使用prop.name作为属性在JSON中的名称</u>。<strong>如果属性用@JsonName注解了，你就会使用在注解中指定的名称而不是属性自己的名称</strong>。</p><p>（<code>上述代码Person类中的两个属性</code>） <strong>我们来看一下事先声明的Person类的一个实例的序列化过程。在属性firstName序列化期间，jsonNameAnn包含了注解类JsonName对应的实例。所以jsonNameAnn?.name返回了非空的值“alias”，将会用作JSON中的键。但属性age序列化时，没有找到这个注解，所以属性名称age被用作JSON中的键</strong>。</p><p>我们目前为止所有讨论过的修改组合到一起，看看组合后形成的序列化逻辑实现。</p><pre><code class="kotlin">/*    使用属性过滤序列化对象    */private fun StringBuilder.serializeObject(obj:Any){    obj.javaClass.Kotlin.memberProperties    .filder{it.findAnnotation&lt;JsonExclude&gt;()==null}    //判断是否有属性使用JsonExclude注解    .joinToStringBuilder(this,prefix=&quot;{&quot;,postfix = &quot;}&quot;){        serializeProperty(it,obj)    }}</code></pre><p><u>现在用@JsonExclude注解的属性被过滤掉了。我们还把负责属性序列的逻辑抽取到了一个单独的serializeProperty函数。</u></p><pre><code class="kotlin">/*    序列化单个属性    */private fun StringBuilder.serializeProperty(    prop:KProperty1&lt;Any,*&gt;,obj:Any){        val jsonNameAnn = prop.findAnnotation&lt;JsonName&gt;()    val propName = jsonNameAnn?.name ?:prop.name    serializeString(propName)    append(&quot;:&quot;)    serializePropertyValue(prop.get(obj))    }</code></pre><p>属性的名称根据之前讨论的@JsonName注解进行处理。</p><p>下一步，我们来实现剩下的注解@CustomSerializer。<u>它的实现基于getSerializer函数，该函数返回通过@CustomSerializer注解注册的ValueSerializer实例</u>。<u>例如，如果像下面展示的这样声明Person类，并在序列化birthDate属性的时候调用getSerializer()，它会返回一个DataSerializer的实例</u>：（<code>描述</code>）</p><pre><code class="kotlin">data class Person(    val name:String,    @CustomSerializer(DataSerializer::class) val birthDate:Date    )    </code></pre><p>这里提示一下@CustomSerializer注解是如何声明的，帮助你更好的理解getSerializer的实现：</p><pre><code class="kotlin">annotation class CustomSerializer(    val serializerClass: KClass&lt;out ValueSerializer&lt;*&gt;&gt;    )</code></pre><p>下面实现getSerializer函数。</p><pre><code class="kotlin">/*    取回属性值的序列化器    */fun KProperty&lt;*&gt;.getSerializer():ValueSerializer&lt;Any?&gt;?{    val customSerializerAnn = findAnnotation&lt;CustomSerializer&gt;() ?: return null    val serializerClass = customSerializerAnn.serializerClass    val valueSerializer = serializerClass.objectInstance ?: serializerClass.createInstance()    @Suppress(&quot;UNCHECKED_CAST&quot;)    return valueSerializer as ValueSerializer&lt;Any?&gt;}</code></pre><p><strong>它的KProperty的扩展函数，因为属性是这个方法要处理的主要对象（<code>接收者</code>）</strong>。它调用了findAnnotation函数取得一个@CustomSerializer注解的实例，如果实例存在。它的实参serializerClass指定了你需要获取那个类的实例。</p><p>处理作为@CustomSerializer注解的值的类的对象（Kotlin的单例）的方式，是这里最有趣的一部分。它们都用KClass类表示。不同的是，对象拥有非空值objectInstance属性，可以用它来访问为object创建的单例实例。例如，DateSerializer被声明成了object，所以它的objectInstance属性存储了DateSerializer的单例实例。你将用这个实例序列化所用对象，而不会调用createInstace。</p><p>如果KClass表示的是一个普通的类，可以通过调用createInstance来创建一个新的实例。这个函数和java.lang.Class.newInstance类似。</p><p>最终，你可以在serializerProperty的实现中用上getSerializer。下面是这个函数的最终版本。</p><pre><code class="kotlin">/*    序列化属性，支持自定义序列化器    */priavte fun StringBuilder.serializerProperty(    prop: KProperty1&lt;Any,*&gt;, obj:Any){    val name = prop.findAnnotation&lt;JsonName&gt;()?.name ?: prop.name    serializeString(name)    append(&quot;: &quot;)    val value = prop.get(obj)    val jsonValue = prop.getSerializer()?.toJsonValue(value)    //如果自定义序列化器存在就为属性使用它        ?: value    //否则像之前那样使用属性值    serializePropertyValue(jsonValue)        }</code></pre><p><strong>serializeProperty通过调用序列化器的toJsonValue，来吧属性值转换成JSON兼容的格式。如果属性没有自定义序列化器，它就使用属性的值</strong>。</p><p>现在你已经见过了这个库JSON序列化部分的实现，我们的话题将转移到解析和反序列化。反序列化部分需要更多的代码，所以我们不会审查所有代码，但会看到实现的结构，并解释反射是如果用来反序列化对象的。</p><h3 id="10-2-4-JSON解析和对象反序列化"><a href="#10-2-4-JSON解析和对象反序列化" class="headerlink" title="10.2.4 JSON解析和对象反序列化"></a>10.2.4 JSON解析和对象反序列化</h3><p>让我们从故事的第二部分开始：实现反序列化的逻辑。首先，回忆一下API，它和序列化用到的API相似，包含一个单独的函数：</p><pre><code class="kotlin">inline fun &lt;reified T:Any&gt; deserialize(json: String) :T</code></pre><p>使用它的例子（<code>以下源代码在JKid库中</code>）</p><pre><code class="kotlin">data class Author(val name: String)data class Book(val title: String, val author: Author)&gt;&gt;&gt; val json = &quot;&quot;&quot;{&quot;title&quot;: &quot;Catch-22&quot;, &quot;author&quot;: {&quot;name&quot;: &quot;J. Heller&quot;}}&quot;&quot;&quot;&gt;&gt;&gt; println(deserialize&lt;Book&gt;(json))Book(title=Catch-22, author=Author(name=J. Heller))</code></pre><p>你要被反序列化的对象和类型作为实化类型参数传给deserialize函数并拿回一个新的对象实例。</p><p>（<code>对象反序列化要求</code>） <strong>JSON反序列化是比序列化跟困难的任务，因为它涉及解析JSON字符串输入，还有使用反射访问对象的内部细节。JKid中的JSON反序列化器使用相当普通的方式实现，由三个主要阶段组成：<u>词法分析器（通常被称为lexer）、语法分析器或解析器，以及反序列化组件本身</u>。</strong></p><p><strong>词法分析</strong>把一个字符组成的输入字符串切分成一个由<strong>标记组成的列表</strong>。<strong>这里有两类标记</strong>：代表JSON语法中具有特殊意义的字符（逗号、冒号、花括号和方括号）的<strong>字符标记</strong>；对应到字符串、数字、布尔值以及null常量的<strong>值标记</strong>。左花括号（{）、字符串值（“Catch-22”）和整数值（42）是<strong>不同标记</strong>的例子。</p><p><strong>解析器通常负责将无格式的列表转换为结构化的表示法。<em>它在JKid中的任务是理解JSON的更高级别的结构，并将各个标记转换为JSON中支持的语义元素：键值对、对象和数组</em></strong>。</p><p>JsonObject接口跟踪当前正在被反序列化的对象或数组。解析器在发现当前对象的新属性（简单值、复合属性或数组）时调用对应的方法。</p><pre><code class="kotlin">/*  JSON解析器回调接口  */interface JsonObject {    fun setSimpleProperty(propertyName: String, value: Any?)    fun createObject(propertyName: String): JsonObject    fun createArray(propertyName: String): JsonObject}</code></pre><p>这些方法中的参数propertyName接收到了JSON键。<strong>因此，当解析器遇到一个使用对象作为值的author属性时，createObject(“author”)方法会被调用。简单值属性被报告为setSimpleProperty调用，实际的标记值作为value实参传递给这次调用</strong>。JsonObject实现负责创建属性的新对象，并在外部对象中存储对它们的引用。</p><p>下图，<strong>展示了反序列化一个样本字符串时，词法和语法分析每一阶段的输入和输出。再一次，语法分析将输入字符串切分成标记列表，然后句法分析（解析器）处理这个标记列表，并在每个有意义的新元素上调用JsonObject中适当的方法</strong>。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220324182951.png" alt="JSON解析：句法分析器、解析器和反序列器"></p><p>然后，反序列化器为JsonObject提供一种实现，逐步构建相应类型的新实例。它需要找到类属性和JSON键（上图中title、author、和name）之间的对应关系，并构建嵌套对象的值（author）的实例。在这之后，它才可以创建一个最终需要的类的新实例（Book）。</p><p><u>JKid库打算使用数据类，因此，它将从JSON文件加载的所有名称-值的配对作为参数传递给要被反序列化的类的结构方法。它不支持在对象实例创建后设置其属性。这意味着JSON中读取数据时它需要将数据存储在某处，然后才能构建该对象</u>。</p><p>在创建对象之前保存其组件的要求看起来与传统的构建器模式相似，区别在于构建器通常用于创建一种特定类型的对象，并且解决方案需要完全通用。我们在这个实现中使用了一个有趣的词语种子（Seed）。在JSON中，你需要构建不同类型的复合结构：对象、集合和map。ObjectSeed、ObjectListSeed和ValueListSeed类负责构建适当的对象、复合对现象的列表，以及简单值的列表。而map的构造就作为练习留给你了。</p><p>基本的Seed接口继承了JsonObject，并在构建过程完成后提供了一个额外的spawn方法来获取生成的实例。它还声明了用于创建嵌套对象和嵌套列表的createCompositeProperty方法（它们使用相同的底层逻辑通过种子来创建实例）。</p><pre><code class="kotlin">/*   从JSON数据创建对象的接口   */interface Seed : JsonObject {    fun spawn(): Any?    fun createCompositeProperty(            propertyName: String,            isList: Boolean    ): JsonObject    override fun createObject(propertyName: String) = createCompositeProperty(propertyName, false    )    override fun createArray(propertyName: String) = createCompositeProperty(propertyName, true)}</code></pre><p>你可以认为spawn就是返回结果值的build方法的翻版。它返回的是为ObjectSeed构造的对象，以及为ObjectListSeed或ValueListSeed生成的列表。我们不会详细讨论列表是如何反序列化的。我们将注意力集中于创建对象，它更复杂并有助于通用的思路。</p><p>但再次之前，我们<strong>先来研究一下deserialize的主要功能，它完全反序列化一个值的所有工作</strong>。</p><pre><code class="kotlin">/*  顶层反序列化函数  */fun &lt;T : Any&gt; deserialize(json: Reader, targetClass: KClass&lt;T&gt;): T {    val seed = ObjectSeed(targetClass, ClassInfoCache())    (Parser(json, seed))    return seed.spawn}</code></pre><p><strong>整个解析过程是这样的，一开始你会创建一个ObjectSeed来存储反序列化对象的属性，然后调用解析器并输入字符流json传递给它。当达到输入的数据的结尾时，你就可以调用spawn函数来构造最终对象</strong>。</p><p>现在我们聚焦ObjectSeed的实现，它存储了正在构造的对象的状态。<strong><u>ObjectSeed接收了一个目标类的引用和一个classInfoCache对象，该对象包含缓存起来的关于该类属性的信息。这个缓存起来的信息稍后将被用于创建该类的实例</u></strong>。ClassInfoCache和ClassInfo是我们将在下一节讨论的辅助类。</p><pre><code class="kotlin">/*  反序列化一个对象  */class ObjectSeed&lt;out T : Any&gt;(targetClass: KClass&lt;T&gt;, val classInfoCache: ClassInfoCache) : Seed {    private val classInfo: ClassInfo&lt;T&gt; = classInfoCache[targetClass]   //缓存需要创建targetClass实例的信息    private val valueArguments = mutableMapOf&lt;KParameter, Any?&gt;()    private val seedArgements = mutableMapOf&lt;KParameter, Seed&gt;()    private val arguments: Map&lt;KParameter, Any?&gt;  //构建一个从构造方法参数到它们的值的映射        get() = valueArguments + seedArgements.mapValues { it.value.spawn() }    override fun setSimpleProperty(propertyName: String, value: Any?) {        TODO(&quot;Not yet implemented&quot;)        val param = classInfo.getConstructorParameter(propertyName)        valueArguments[param] =                classInfo.deserializeConstructorArgument(param, value)   //如果一个构造方法参数的值是简单值，把它记录下来。    }    override fun createCompositeProperty(propertyName: String, isList: Boolean): Seed {        val param = classInfo.getConstructorParameter(propertyName)        val deserializeAs =                classInfo.getDeserializeClass(propertyName) //如果有的话加载属性DeserializeInterface注解的值        val seed = createSeedForType(                deserializeAs ?: param.type.javaType, isList        )   //根据形参的类型创建一个ObjectSeed或者CollectionSeed         return seed.apply { seedArgements[param] = this }   //并把它记录到seedArgument中    }    override fun spawn(): T =          classInfo.createInstance(auguments) //传递实参map，创建targetClass实例作为结果}</code></pre><p><u>ObjectSeed构建了一个构造方法形参和它们的值之间的映射。这用到了两个可变的map：给简单值用的valueArguments和给复合属性用的seedArguments。当结果开始构建时，新的实参通过setSimpleProperty调用被添加到valueArguments，通过createCompositeProperty调用被添加到seedArguments。新的复合种子被添加时状态是空的，然后被来自输入流的数据填充。最终，spawn方法递归地调用每个种子的spawn方法来构建所有嵌套的种子</u>。</p><p>注意，spawn的方法体中arguments调用是怎样启动递归的复合（种子）实参的构建过程的：auguments自定义的getter调用seedArguments中每一个元素的spawn方法。createSeedType函数分析形参的类型并根据形参是那种集合来创建ObjectSeed、ObjectListSeed或者ValueListSeed。我们把它实现的剩下部分交给你自己去研究。接下来，我们来看看ClassInfo.createInstance函数是如何创建targetClass的实例的。</p><h3 id="10-2-5-反序列化的最后一步：callBy-和使用反射创建对象"><a href="#10-2-5-反序列化的最后一步：callBy-和使用反射创建对象" class="headerlink" title="10.2.5 反序列化的最后一步：callBy()和使用反射创建对象"></a>10.2.5 反序列化的最后一步：callBy()和使用反射创建对象</h3><p>最后一部分你需要理解的就是ClassInfo类，它创建了作为结果的实例，还缓存了关于构造方法参数的信息。ObjectSeed用到了它。但在我们一头扎进实现细节之前，我们先来看看通过反射来创建对象的API。</p><p><u>你已经见过了KCallable.call方法，它调用函数或者构造方法，并接收一个实参组成的列表。这个方法很多情况下都很好用，但它有一个限制：不支持默认参数</u>。这种情况下，如果用户试图用带默认参数的构造方法来反序列化一个对象，绝对不想这个实参还需要在JSON中说明。因此，<u>你需要使用另外一个支持默认参数的方法：KCallable.callBy</u>。</p><pre><code class="kotlin">interface KCallable&lt;out R&gt;{    fun callBy(args:Map&lt;KParameter,Any?&gt;):R}</code></pre><p>这个方法接受一个形参和它们对应值之间的map，这个map将被作为参数传给这个方法。如果map中缺少一个形参，可行的话它的默认值将会被使用。<u>还有一点特别方便的是，你不必按照顺序来写入形参：可以从JSON中读取名称-值的配对，找到每个实参名称队形的形参，把它的值写入map中</u>。</p><p><strong>有一点需要注意的是取得正确的类型。args map中值的类型需要跟构造方法的参数类型想匹配，否则你将得到一个IllegalArgumentException</strong>。这对算数运算来说很特别重要：你需要知道参数接收的是一个Int、一个Long、一个Double，还有一个其他的基本数据类型，<strong>并把来自JSON的算数值转成正确的类型。可以使用KParameter.type属性来做到这一点</strong>。</p><p><u>这里的类型转换是通过ValueSerializer接口完成的，这个接口和定制序列化时用的ValueSerializer接口是同一个。如果属性没有@CustomSerializer注解，你会根据它的类型获取标准的实现</u>。</p><pre><code class="kotlin">/*  根据值类型取得序列化器    */fun serializerForType(type: Type): ValueSerializer&lt;out Any?&gt;? = {    when (type) {        Byte::class.java -&gt; ByteSerializer        Int::class.java -&gt; IntSerializer        Boolean::class.java -&gt; BooleanSerializer        //...        else -&gt; null    }}</code></pre><pre><code class="kotlin">/*  Boolean值的序列化    */object BooleanSerializer : ValueSerializer&lt;Boolean&gt; {    override fun fromJsonValue(jsonValue: Any?): Boolean {        if (jsonValue !is Boolean) throw JKidException(&quot;Boolean expected&quot;)        return jsonValue    }    override fun toJsonValue(value: Boolean) = value}</code></pre><p>callBy方法给了你一种调用一个对象的主构造方法的方式，需要传给它一个形参和对应值之间的map。ValueSerializer机制保证了中的值拥有正确的类型。现在我们看看如何调用这个API。</p><p><strong><u>ClassInfoCache皆在减少反射操作的开销</u></strong>。<strong>回忆一下用来控制序列化和反序列化过程的注解（@JsonName和@CustomSerializer），它们是用在属性上，而不是形参上。当你反序列化一个对象时，你打交道的是构造方法参数而不是属性：要获取注解，你需要先找到对应的属性。在读取每个（JSON）键值对的时候都执行一次这样的搜索将会极其缓慢，所以每个类只会做一次这样的搜索并且把信息缓存起来</strong>。下面是ClassInfoCache的完整实现。</p><pre><code class="kotlin">/*      缓存的反射数据的存储      */class ClassInfoCache {    private val cacheData = mutableMapOf&lt;KClass&lt;*&gt;, ClassInfo&lt;*&gt;&gt;()    @Suppress(&quot;UNCHECKED_CAST&quot;)    operator fun &lt;T : Any&gt; get(cls: KClass&lt;T&gt;): ClassInfo&lt;T&gt; = cacheData.getOrPut(cls) { ClassInfo(cls) } as ClassInfo&lt;T&gt;}</code></pre><p>这里使用了在9.3.6节中我们讨论过的模式： （<code>回去看</code>） <em>在map中存储的时候去掉类型信息，但get方法的实现保证了返回的ClassInfo&lt; T &gt;拥有正确的类型实现。注意getOrOut的用法：如果mapCacheData已经包含了一个cls的值，你就返回这个值。否则，调用传递进来的lambda，它会计算出这个键对应的值并存储在map中，然后返回它</em>。</p><p>ClassInfo类负责按目标类创建新实例并缓存必要信息。为了简化代码，我们省略了一些函数和默认初始化器的代码。还有，你可能注意到生产代码会抛出一个带有丰富信息的异常（这也是你的代码应该采用的良好模式），来替代这里的 !! 。</p><pre><code class="kotlin">/*  构造方法的参数及注解数据的缓存  */class ClassInfo&lt;T : Any&gt;(cls: KClass&lt;T&gt;) {    private val constructor = cls.primaryConstructor!!    private val jsonNameToParamMap = hashMapOf&lt;String, KParameter&gt;()    private val paramToSerializerMap =            hashMapOf&lt;KParameter, ValueSerializer&lt;out Any?&gt;&gt;()    private val jsonNameToSerializerClassMap =            hashMapOf&lt;String, Class&lt;out Any&gt;?&gt;()    init {        constructor.parameters.forEach { (cls, it) }    }    fun getConstructorParameter(propertyName: String): KParameter =            jsonNameToParam[propertyName]!!    fun deserializeConstructorArgument(            param: KParameter, value: Any?    ): Any? {        val serializer = paramToSerializer[param]        if (serializer != null) return serializer.fromJsonValue(value)        validateArgumentType(param, value)        return value    }    fun createInstance(arguments: Map&lt;KParameter, Any?&gt;): T {        ensureAllParametersPresent(arguments)        return constructor.callBy(arguments)    }}</code></pre><p>在初始化时，这段代码找到了每个构造方法参数对应的属性并取回了它们的注解。它把这些数据存储在三个map中：<strong>jsonNameToParamMap说明了JSON文件中的每个键对应的形参，paramToSerializerMap存储了每个形参对应的序列化器，还有jsonNameToDeserializeClassMap存储了指定为@DeserializeInterface注解的实参的累，如果有的话。然后ClassInfo就能根据属性名称提供构造方法的形参，并调用使用形参的代码，这些代码中这个形参将作为形参和实参之间map的键使用</strong>。</p><p>cacheDataForParameter、validateArgumentType和ensureAllParametersPresent是这个类的私有函数。下面是ensureAllParametersPresent的实现，可以自己浏览其他函数的代码。</p><pre><code class="kotlin">/*  验证需要的参数被提供了  */private fun ensureAllParametersPresent(arguments: Map&lt;KParameter, Any?&gt;) {    for (param in constructor.parameters) {        if (arguments[param] == null &amp;&amp; !param.isOptional &amp;&amp; !param.type.isMarkedNullable) {            throw JKidException(&quot;Missing value for parameter ${param.name}&quot;)        }    }}</code></pre><p><strong>这个函数检查你是不是提供了全部需要的参数的值。注意这个反射API是如何帮助你的。如果一个参数有默认值，那么param.isOptional是true，你就可以为他省略一个实参；反之默认值就会被使用。如果一个参数类型是可空的（param.type.isMarkedNullable会告知你这一点)，null将会被作为默认的参数值使用。对所有的形参来说，你都必须提供对应的实参：否则就会抛出异常。反射缓存保证了只会搜索一次那些定制反序列化过程的注解，而不会是JSON数据中出现的每一个属性都执行搜索</strong>。</p><h3 id="10-3-小结"><a href="#10-3-小结" class="headerlink" title="10.3 小结"></a>10.3 小结</h3><ul><li>Kotlin中引用注解的语法和Java几乎一摸一样。</li><li>在kotlin中可以让你应用注解的目标的范围比Java跟广，其中包括了文件和表达式。</li><li>一个注解的参数可以是一个基本数据类型、一个字符串、一个枚举、一个类应用、一个其他注解类的实例，或者前面这些元素组成的数组。</li><li>如果单个Kotlin声明产生了多个字节码元素，像@get:Rule这样指定一个注解的使用点目标，允许你选择注解如果应用。</li><li>注解类的声明是这样的，它是一个拥有主构造方法且没有类主体的类，其构造方法中所有参数都被标记成val属性。</li><li>元注解可以用来指定（使用点）目标、保留期模式和其他注解的特性。</li><li>反射API让你在运行时动态的列举和范围一个对象的方法和属性。它拥有许多接口来表示不同种类的声明，例如类（KClass)、类（KFunction）等。</li><li>要获取一个KClass的实例，如果类是静态已知的，可以使用ClassName::class；否则，使用obj.javaClass.kotlin从对象实例上取得类。</li><li>KFunction接口和KProperty接口都继承了KCallable，它提供了一个通用的call方法。</li><li>KCallable.callBy方法能用来调用带默认参数值的方法。</li><li>KFunction0、KFunction1等这种不同参数数量的函数可以使用invoke方法调用。</li><li>KProperty0和KProperty1是接收者数量不同的属性，支持用get方法取回值。KMutableProperty0和KMutableProperty1继承了这些接口，支持通过set方法来改变属性的值。</li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="字段和属性"><a href="#字段和属性" class="headerlink" title="字段和属性"></a>字段和属性</h2><p><a href="https://blog.csdn.net/chenchunlin526/article/details/71424844" target="_blank" rel="noopener">深入理解Java中的字段与属性的区别</a></p><h3 id="属性和字段的区别"><a href="#属性和字段的区别" class="headerlink" title="属性和字段的区别"></a>属性和字段的区别</h3><p>属性（property），通常可以理解为get 和 set 方法。</p><p>字段（field），通常叫做 <strong>类成员</strong>，或者 <strong>类变量</strong> ，有时也叫 域 ，理解为 数据成员，用来承担数据的。</p><h3 id="属性和字段详解"><a href="#属性和字段详解" class="headerlink" title="属性和字段详解"></a>属性和字段详解</h3><p><strong>字段（field）</strong></p><p>类成员（字段field），通常在类中定义成员变量例如：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200909213136.png" alt=""> </p><p>解释为：<strong>FacebookUser类拥有成员变量nickname，有一个字段 nickname。</strong></p><p>字段一般用于承担数据，所以为了数据的安全性，一般设置为私有的。</p><p>字段和常量描述的类的数据（域），当这些数据的某些部分不运行外界访问时，<strong>根据”对象封装“原则，应该尽量避免将类的字段以公有方式提供给外部</strong>。除啦final修饰的常量。</p><p><strong>属性（property）</strong></p><p><strong>属性只局限于类中方法的声明，并不与类中其它成员相关</strong>，数据JavaBean范畴：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200909220317.png" alt=""></p><p>这是一个属性，一个字段。</p><p>总结：属性是对字段的封装，供外部访问。通常<strong>属性</strong>将对应的<strong>私有字段</strong>通过封装成公共属性，以便于外界访问和修改。</p><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>计算属性通过覆盖字段get或者set运算符来定义的，</p><pre><code>class Book{    val name        get() {}}</code></pre><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>是指可以被求值的代码。</p><p>例如</p><pre><code class="c">int result = add(x + 1,y)</code></pre><blockquote><p>x + 1 作为表达式传递了数值</p></blockquote><pre><code class="c">int result = add（if(x==1),y）</code></pre><blockquote><p>这段语句在 c 中是没有办法作为表达式的。</p></blockquote><h3 id="Kotlin-this表达式"><a href="#Kotlin-this表达式" class="headerlink" title="Kotlin this表达式"></a>Kotlin this表达式</h3><p>为了表示当前的 <strong>接收者</strong> 使用 this{:.keyword} 表达式：</p><ul><li>在类的成员中，this{:.keyword}指的是当前对象</li><li>在扩展函数或者带接受者的函数字面值中，this{:.keyword}表示在点左侧的接收者参数。</li></ul><h2 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h2><p>函数引用 是kotlin引入的一个功能。使用(::)表示对函数的引用。它属于函数类型。</p><p>代码</p><pre><code class="kotlin">val sum:(Int,Int) -&gt; Int = {x,y -&gt; x +y}</code></pre><blockquote><p>sum 是一个函数类型的变量，lambda表达式执行了相加的操作。</p></blockquote><pre><code class="kotlin">fun applyOp(x: Int, y: Int, op: (Int, Int) -&gt; Int): Int = op(x, y)</code></pre><p>applyOp 是一个接受三个参数的函数，第三个参数是lambda类型。可以用下面的返回调用这个函数：</p><pre><code class="kotlin">applyOp(2,3,sum)----------5</code></pre><p>即高阶函数可以作为一个类型赋值给变量，也可以作为另一个函数的参数。</p><h3 id="函数引用：函数可以是一个-lambda"><a href="#函数引用：函数可以是一个-lambda" class="headerlink" title="函数引用：函数可以是一个 lambda"></a>函数引用：函数可以是一个 lambda</h3><p><strong>将上述代码变换成函数时就需要使用到函数引用了。</strong></p><p>上述的lambda表达式，可以用纯函数的形式（也叫具体函数）：</p><pre><code class="kotlin">fun sum(x: Int, y: Int) = x + y</code></pre><p>实现效果是一样的，区别在于不再需要使用变量来保持对函数的引用，但是这样需要对applOp函数要做一些修改</p><pre><code class="kotlin">applyOp(2,3,::sum)----------5</code></pre><p>这些算是 函数引用 的大致概念。同时<strong>函数引用</strong>也是可以赋值给变量的。</p><pre><code class="kotlin">val sumLambda: (Int, Int) -&gt; Int = ::sumapplyOp(2, 3, sumLambda)</code></pre><h3 id="lamnda-表达式-与-匿名内部类的区别"><a href="#lamnda-表达式-与-匿名内部类的区别" class="headerlink" title="lamnda 表达式 与 匿名内部类的区别"></a>lamnda 表达式 与 匿名内部类的区别</h3><blockquote><ul><li>lambda 表达式只能为函数式接口创建实例；匿名内部类可以为任意接口创建实例 – 不管接口包含多少抽象方法，只要匿名内部类是实现所有的抽象方法即可。</li><li>lambda 表达式只能为函数式接口创建实例；匿名内部类可以为抽象类甚至普通话类创建实例；</li><li>lambda 表达式的代码不允许调用接口中定义的默认方法；匿名内部类实现的抽象方法的方法体允许调用接口中定义的默认方法。</li></ul></blockquote><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><h2 id="Reified实化类型参数"><a href="#Reified实化类型参数" class="headerlink" title="Reified实化类型参数"></a>Reified实化类型参数</h2><p>背景：</p><blockquote><p>Java中泛型是在JDK1.5版本后引入的，但集合Collection实在JDK1.2版本时引入的，现在看到的List，是在泛型出现后加入的，那么JDK1.2之前就直接用LIst（java中俗称原生态类型）表示。在为了兼容之前的版本Java采用所谓的伪泛型，伪泛型有一个特征就是<strong>泛型擦除</strong>，表示泛型类型信息在编译时期会被抹除掉，包括你是List还是List在运行时它们都是一样，那都是List类型，泛型类型信息已经被抹除掉了。</p></blockquote><h2 id="Kotlin中的形参和实参"><a href="#Kotlin中的形参和实参" class="headerlink" title="Kotlin中的形参和实参"></a>Kotlin中的形参和实参</h2><p>ps：</p><p><a href="https://juejin.cn/post/6844903694119485447#heading-6" target="_blank" rel="noopener">一个简单方式教你记住Kotlin的形参和实参</a></p><h2 id="什么才是泛型擦除"><a href="#什么才是泛型擦除" class="headerlink" title="什么才是泛型擦除"></a>什么才是泛型擦除</h2><p>ps:</p><p><a href="https://juejin.cn/post/6844904083199918093" target="_blank" rel="noopener">面试官问我：“泛型擦除是什么，会带来什么问题？”</a></p><h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>序列化：对象转化成字节的过程。</p><p>反序列化：字节转化成对象的过程。</p><h2 id="it关键字"><a href="#it关键字" class="headerlink" title="it关键字"></a>it关键字</h2><p>it关键字是由函数自动生成的形参名字，可以直接访问当前函数的形参。</p><pre><code class="kotlin">    val method: (String) -&gt; String = {        &quot;$it 返回了生成的it形参&quot;    }    println(method(&quot;it -- &quot;))it --  返回了生成的it形参</code></pre><h2 id="匿名函数的返回类型推断"><a href="#匿名函数的返回类型推断" class="headerlink" title="匿名函数的返回类型推断"></a>匿名函数的返回类型推断</h2><pre><code class="kotlin">    val methodDouble = { doubleValue: Double -&gt;        doubleValue    }    val methodString = { stringValue: String -&gt;        stringValue    }    println(methodDouble(9.02))    println(methodString(&quot;这是String类型&quot;))9.02这是String类型</code></pre><p>kotlin会自动推断返回类型。</p><h2 id="split-拆分函数"><a href="#split-拆分函数" class="headerlink" title="split 拆分函数"></a>split 拆分函数</h2><p>用来拆分字符串，并按照拆分字符拆分。返回值是个List&lt; String&gt;。</p><pre><code class="kotlin">fun main() {    val testString = &quot;split,and,string&quot;    val splitString = testString.split(&quot;,&quot;)    for (i in splitString)        println(i)}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220331154612.png" alt=""></p><h2 id="replace替换函数"><a href="#replace替换函数" class="headerlink" title="replace替换函数"></a>replace替换函数</h2><p><strong>功能：替换字符。</strong><br><strong>可以接收一个正则表达式来作为匹配字符的条件，它返回String类型。</strong></p><p><strong>这里将条件字符转换成了小写和单词。</strong></p><pre><code class="kotlin">fun main() {    val sourceString = &quot;AADDCCEEFFLLIINN22331&quot;    val replaceString = sourceString.replace(Regex(&quot;[CEF1]&quot;)) {        when (it.value) {            &quot;C&quot; -&gt; &quot;c&quot;            &quot;E&quot; -&gt; &quot;e&quot;            &quot;F&quot; -&gt; &quot;f&quot;            &quot;1&quot; -&gt; &quot;one&quot;            else -&gt; it.value        }    }    println(replaceString)}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220331160940.png" alt=""></p><h2 id="run函数"><a href="#run函数" class="headerlink" title="run函数"></a>run函数</h2><p><strong>场景</strong></p><p>用于let，with函数的场景中。run函数弥补了let函数在函数体中必须使用it参数代替对象，run函数可以同with函数一样省略，直接访问公有属性和方法，同时弥补了with传入对象判空问题，在run函数中又可以像let函数一样判空处理。</p><p>run函数只接受一个lambda函数作为参数，以闭包形式返回，并以最后一行或者指定return的表达式作为返回值。</p><pre><code class="kotlin">object.run{//    函数体    }.run{//    以上条返回值作为参}</code></pre><h2 id="内联函数also"><a href="#内联函数also" class="headerlink" title="内联函数also"></a>内联函数also</h2><p><strong>描述</strong></p><p>let函数用来处理不为空的场景。</p><p>结构上同let一样区别是返回值不一样，let以闭包形式返回，以返回函数体最后一行的值，为空时返回Unit类型为默认值。而also函数返回调用对象本身。</p><pre><code class="kotlin">object.also{//    函数体}fun main() {    val string: String? = null    val stringTest: String? = &quot;test&quot;    println(string?.also { print(&quot;非空&quot;) })    println(stringTest?.also { print(&quot;非空&quot;) })}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/img/20220415181552.png" alt=""></p><h2 id="takeIf-函数"><a href="#takeIf-函数" class="headerlink" title="takeIf 函数"></a>takeIf 函数</h2><p><strong>描述</strong></p><p>对一个对象进行判断，使用判断表达式在表达式为true时返回对象本身，false时返回null。可以对返回的对象进行链式调用。</p><pre><code class="kotlin">fun main() {    val test = &quot;testString&quot;//    false时返回null    println(test.takeIf { it.length &gt; 20 }.apply { println(&quot;判断字符串对象test为false时返回null&quot;) })    println()//    表达式true时返回对象本身    println(test.takeIf { it.length &gt; 0 }.apply { println(&quot;判断字符串对象test为true时返回字符串本身&quot;) })}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220412154629.png" alt=""></p><h2 id="takeUnless-函数"><a href="#takeUnless-函数" class="headerlink" title="takeUnless 函数"></a>takeUnless 函数</h2><p><strong>描述</strong></p><p>对一个对象判断，表达式为true时返回null，不为true为false时返回对象本身。可以对返回对象进行链式调用。</p><pre><code class="kotlin">fun main() {    val test = &quot;testString&quot;//    false时返回对象本身    println(test.takeUnless { it.length &gt; 20 }.apply { println(&quot;使用takeUnless时判断为false时执行&quot;) })    println()//    表达式true时返回null    println(test.takeUnless { it.length &gt; 0 }.apply { println(&quot;使用takeUnless时判断为true时执行&quot;) })}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220412154356.png" alt=""></p><h2 id="List集合的getOrElse函数与getOrNull函数"><a href="#List集合的getOrElse函数与getOrNull函数" class="headerlink" title="List集合的getOrElse函数与getOrNull函数"></a>List集合的getOrElse函数与getOrNull函数</h2><p><strong>描述</strong></p><p>返回给定位置的元素，如果超过超出范围调用getOrNull函数的defaultValue函数参数返回结果。</p><p><strong>源码</strong></p><pre><code class="java">/** * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list. */@kotlin.internal.InlineOnlypublic inline fun &lt;T&gt; List&lt;T&gt;.getOrElse(index: Int, defaultValue: (Int) -&gt; T): T {    return if (index &gt;= 0 &amp;&amp; index &lt;= lastIndex) get(index) else defaultValue(index)}</code></pre><pre><code class="kotlin">fun main() {    val listTest = listOf&lt;String&gt;(&quot;one&quot;, &quot;twp&quot;, &quot;three&quot;)//    打印第一个位置    println(listTest.getOrElse(0, defaultValue = { &quot;超出边界时发送&quot; }))//    超出范围的    println(listTest.getOrElse(4, defaultValue = { &quot;超出边界时发送&quot; }))}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220412183027.png" alt=""></p><p><strong>getOrNull描述</strong></p><p>返回给定位置的元素，超出边界返回“null”</p><p><strong>源码</strong></p><pre><code class="java">/** * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list. *  * @sample samples.collections.Collections.Elements.getOrNull */public fun &lt;T&gt; List&lt;T&gt;.getOrNull(index: Int): T? {    return if (index &gt;= 0 &amp;&amp; index &lt;= lastIndex) get(index) else null}</code></pre><pre><code class="kotlin">fun main() {    val listTest = listOf&lt;String&gt;(&quot;one&quot;, &quot;twp&quot;, &quot;three&quot;)//    打印第一个位置    println(listTest.getOrNull(0))//    超出范围的返回空，并判断打印输出    println(listTest.getOrNull(4))    println(listTest.getOrNull(4) ?: &quot;返回为null超出了边界&quot;)}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220412183554.png" alt=""></p><h2 id="List集合中mutator函数和contains函数、Predicate类"><a href="#List集合中mutator函数和contains函数、Predicate类" class="headerlink" title="List集合中mutator函数和contains函数、Predicate类"></a>List集合中mutator函数和contains函数、Predicate类</h2><p><strong>mutator函数</strong></p><p>能够修改可变列表的函数有统一的名字：mutator函数</p><p><strong>contains函数</strong></p><p>如果字符串中包含[other]字符串作为子字符串，则返回 ‘true’。</p><p><strong>Predicate接口</strong></p><p>函数时接口。此接口用于筛选数据，通过给定的若干项的流作为满足的项。</p><p><strong>removeIf函数</strong></p><p>删除当前项目中满足Predicate接口条件的所有元素。在抛出错误时将异常返回给调用者。删除成功时返回‘true’。</p><pre><code class="kotlin">import java.util.function.Predicatefun main() {    val mutableList = mutableListOf&lt;String&gt;(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)//    mutator函数    mutableList += &quot;添加&quot;    println(mutableList)//    removeIf删除满足条件的元素    mutableList.removeIf(Predicate { it.contains(&quot;one&quot;) })    println(mutableList)}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220412191310.png" alt=""></p><h2 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h2><p>companion伴生对象</p><p><strong>可以做什么？</strong></p><p>可以直接在代码中调用且只加载一次。它与Java中的static静态修饰符类似。</p><pre><code class="kotlin">fun main() {   CompaionClass.testCompanionFun()    println(CompaionClass.testCompanionVal)}class CompaionClass{    companion object{        val testCompanionVal=&quot;伴生对象的变量&quot;        fun testCompanionFun(){            println(&quot;使用伴生对象的静态方法&quot;)        }    }}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220426192030.png" alt=""></p><h2 id="Kotlin-运算符重载"><a href="#Kotlin-运算符重载" class="headerlink" title="Kotlin 运算符重载"></a>Kotlin 运算符重载</h2><p><strong>让运算符为用户定义的类工作</strong></p><p>Kotlin中的operator将调用它相应运算符成员函数。a+b运算符可转换为a.plus(b)</p><p>Kotlin只能重载一组特定的运算符。</p><p><strong>案例用运算符重载拼接两个字符串</strong></p><pre><code class="kotlin">fun main() {    val p1 = TestClass(&quot;wang&quot;)    val p2 = TestClass(name = &quot;li&quot;)    var sum = p1 + p2    println(sum)}data class TestClass(var name: String) {    //    拼接完返回String类型    operator fun plus(p1: TestClass): String {        var string = name + p1.name        return string    }}</code></pre><h2 id="代数数据类型"><a href="#代数数据类型" class="headerlink" title="代数数据类型"></a>代数数据类型</h2><blockquote><p><strong>什么是代数数据类型</strong></p><p>代数：能够代表数字的符号。</p><p>例如x+1=10中的x就代表代数。还可以通过运算符获得新的代数y*9=z。那么将这些代数或者数字转换成类型，以及通过这些类型所产生的类型就叫做代数数据类型。</p></blockquote><p>例子：</p><pre><code class="kotlin">fun main() {    println(&quot;${getArea(Shape.Circle(5.0))}&quot;)    //获得圆形面积    println(&quot;${getArea(Shape.Rectangle(5.0, 5.0))}&quot;) //获得矩形面积    println(&quot;${getArea(Shape.Triangle(5.0, 5.0))}&quot;)  // 获得三角形面积}sealed class Shape {    //由于 sealed 密封类默认是open修饰的所以可以继承父类成为子类    class Circle(val radius: Double) : Shape()    class Rectangle(val width: Double, val height: Double) : Shape()    class Triangle(val base: Double, val height: Double) : Shape()}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220429203505.png" alt=""></p><p>Shape密封类，这里将圆形等图形面积所需要的变量抽象为代数数据类型（ADT）。 因为这些形状都属于几何类型Shape所以可以抽象为代数数据类型。</p><p><strong>引用：</strong></p><p><a href="https://www.web3.xin/code/2606.html" target="_blank" rel="noopener">Kotlin this表达式</a></p><p><a href="https://www.jianshu.com/p/10358883455c" target="_blank" rel="noopener">kotlin中的函数引用详解</a>    </p><p><a href="http://c.biancheng.net/view/6559.html" target="_blank" rel="noopener">Lambda表达式与匿名内部类的联系和区别</a></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-8-3-1.gif" alt="如果有些方法没有详细说明你可以自行搜索查看"></p>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RecyclerView在Kotlin中的使用</title>
      <link href="/2020/07/26/RecyclerView/"/>
      <url>/2020/07/26/RecyclerView/</url>
      
        <content type="html"><![CDATA[<h2 id="创建项目RecyclerExample项目"><a href="#创建项目RecyclerExample项目" class="headerlink" title="创建项目RecyclerExample项目"></a>创建项目RecyclerExample项目</h2><h3 id="需要引入依赖"><a href="#需要引入依赖" class="headerlink" title="需要引入依赖"></a>需要引入依赖</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595735673809.png" alt=""></p><h3 id="需要子项布局"><a href="#需要子项布局" class="headerlink" title="需要子项布局"></a>需要子项布局</h3><p>在 “RecyclerViewExample\app\src\main\res\layout”下创建 “example_item.xml” 👇</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.cardview.widget.CardView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;&gt;    &lt;RelativeLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:padding=&quot;8dp&quot;&gt;        &lt;ImageView            android:id=&quot;@+id/image_view&quot;            android:layout_width=&quot;50dp&quot;            android:layout_height=&quot;50dp&quot;            android:layout_marginEnd=&quot;8dp&quot;            android:src=&quot;@drawable/ic_baseline_android_24&quot; /&gt;        &lt;TextView            android:id=&quot;@+id/text_view_1&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_toEndOf=&quot;@+id/image_view&quot;            android:text=&quot;Line 1&quot;            android:textColor=&quot;@color/cardview_dark_background&quot;            android:textSize=&quot;18sp&quot; /&gt;        &lt;TextView            android:id=&quot;@+id/text_view_2&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_below=&quot;@+id/text_view_1&quot;            android:layout_toEndOf=&quot;@+id/image_view&quot;            android:text=&quot;Line 2&quot; /&gt;    &lt;/RelativeLayout&gt;&lt;/androidx.cardview.widget.CardView&gt;</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595735521036.png" alt=""></p><p>需要自定义的图片 ↓</p><p>选中”drawable”文件夹,选中”New”,选中”Vactor Asset”</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915232142.png" alt=""></p><p>选中”Clip Art” 选中喜欢的图形就可以了。点击 “Next”,再点击 Finish。 创建三个。</p><h3 id="需要-数据类👇"><a href="#需要-数据类👇" class="headerlink" title="需要 数据类👇"></a>需要 数据类👇</h3><p>在 “recyclerviewexample” 包下</p><pre><code>/** *   @DATE : 2020/7/26 *   @Time : 11:42 *   @By : TheCara *   &quot;data&quot; 数据类 */data class Exampleitem(val imageResource: Int, val text1: String, val text2: String)</code></pre><h3 id="需要适配器"><a href="#需要适配器" class="headerlink" title="需要适配器"></a>需要适配器</h3><p>需要适配器”ExampleAdapter”</p><pre><code>/** *   @DATE : 2020/7/27 *   @Time : 15:54 *   @By : TheCara *   需要继承RecyclerView.Adapter类型 *   需要内嵌类继承RecyclerView.ViewHolder类型 */class ExampleAdapter(private val exampleList: List&lt;ExampleItem&gt;) :    RecyclerView.Adapter&lt;ExampleAdapter.ExampleViewHolder&gt;() {    // 关键方法，用于确定列表项    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ExampleViewHolder {        val view = LayoutInflater.from(parent.context).inflate(R.layout.example_item, parent, false)        return ExampleViewHolder(view)    }    override fun getItemCount() = exampleList.size    // 将数据和容器绑定    override fun onBindViewHolder(holder: ExampleViewHolder, position: Int) {        val currenItem = exampleList[position]        holder.imageView.setImageResource(currenItem.imageResource)        holder.textView1.setText(currenItem.text1)        holder.textView2.setText(currenItem.text1)    }    // 获得每个控件的实例,需要ExampleViewHolder的参数(子项布局)作为RecyclerView.ViewHolder()用作实例化    class ExampleViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {        val imageView: ImageView = itemView.image_view        val textView1: TextView = itemView.text_view_1        val textView2: TextView = itemView.text_view_2    }}</code></pre><p>在”MainActivity”修改</p><pre><code>class MainActivity : AppCompatActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        val listExample = generateDummyList(500)        recycler_view.adapter = ExampleAdapter(listExample)        // 设置RecyclerView的布局管理器        recycler_view.layoutManager = LinearLayoutManager(this)        // 确保RecyclerView的尺寸是一个常数        recycler_view.setHasFixedSize(true)    }    // 获得布局中的数据    private fun generateDummyList(size: Int): List&lt;ExampleItem&gt; {        val list = ArrayList&lt;ExampleItem&gt;()        // 使⽤区间&quot;until&quot;        for (i in 0 until size) {            val drawable = when (i % 4) {                0 -&gt; R.drawable.ic_baseline_add_to_home_screen_24                1 -&gt; R.drawable.ic_baseline_airline_seat_flat_angled_24                2 -&gt; R.drawable.ic_baseline_airline_seat_recline_extra_24                else -&gt; R.drawable.ic_baseline_android_24            }            val item = ExampleItem(drawable, &quot;Line $i&quot;, &quot;Line 2&quot;)            list += item        }        return list    }}</code></pre><p>👆”setHasFixedSize()”方法:当我们确定Item的改变不会影响RecyclerView的宽高时,可以<strong>设置这个方法</strong>,并且Adapter的增删方法去刷新RecyclerView,而不是通过notifyDataSetChanged()。(其实可以直接设置为true，当需要改变宽高的时候就用notifyDataSetChanged()去整体刷新一下)</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595841353310.png" alt=""></p><h2 id="添加-增删-功能"><a href="#添加-增删-功能" class="headerlink" title="添加 增删 功能"></a>添加 增删 功能</h2><h2 id="使用RecyclerView在案例中需要什么"><a href="#使用RecyclerView在案例中需要什么" class="headerlink" title="使用RecyclerView在案例中需要什么"></a>使用RecyclerView在案例中需要什么</h2><ul><li>需要引入依赖</li><li>需要适配器</li><li>需要ItemLayout</li><li>需要数据类</li><li>控制器需要初始化</li></ul><h1 id="Doc"><a href="#Doc" class="headerlink" title="Doc"></a>Doc</h1><h2 id="androidx-recyclerview-widget-AsyncListDiffer-类"><a href="#androidx-recyclerview-widget-AsyncListDiffer-类" class="headerlink" title="androidx.recyclerview.widget.AsyncListDiffer 类"></a>androidx.recyclerview.widget.AsyncListDiffer 类</h2><blockquote><p>Helper for computing the difference between two lists via DiffUtil on a background thread.</p><p>在后台线程上通过DiffUtil计算两个列表之间的差异。</p><p>It can be connected to a RecyclerView.</p><p>它可以连接到RecyclerView。</p></blockquote><pre><code class="java">public class AsyncListDiffer&lt;T&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
            <tag> RecyclerView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataBinding的使用</title>
      <link href="/2020/07/24/DataBinding%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/07/24/DataBinding%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="DataBinding-配合-LiveData-和-ViewModel-使用"><a href="#DataBinding-配合-LiveData-和-ViewModel-使用" class="headerlink" title="DataBinding 配合 LiveData 和 ViewModel 使用"></a>DataBinding 配合 LiveData 和 ViewModel 使用</h2><ol><li>需要创建MyViewModel类,继承ViewModel</li><li>需要添加DataBinding的gradle(app)配置信息</li></ol><p>添加配置信息 在gradle(app)中添加 ↓</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-25_10-40-29.png" alt=""></p><h4 id="创建MyViewModel-↓"><a href="#创建MyViewModel-↓" class="headerlink" title="创建MyViewModel ↓"></a>创建MyViewModel ↓</h4><pre><code>/** *   @DATE : 2020/7/24 *   @Time : 21:10 *   @By : TheCara *  负责处理界面数据 *  需要 LiveData 来观察数据刷新UI */class MyViewModel : ViewModel() {    var numberLiveData = MutableLiveData&lt;Int&gt;()    init {        numberLiveData.value = 0    }    // 加值    fun add() {        numberLiveData?.value = numberLiveData?.value?.plus(1)    }}</code></pre><h4 id="修改MainActivity-↓"><a href="#修改MainActivity-↓" class="headerlink" title="修改MainActivity ↓"></a>修改MainActivity ↓</h4><pre><code>/** 需要 ActivityMainBinding 类用来绑定数据* 需要 MyViewModel 来和 ActivityMainBinding 绑定数据* */class MainActivity : AppCompatActivity() {    var myViewModel: MyViewModel? = null    // 设置类型为可空类型    var activityMainBinding: ActivityMainBinding? = null    //ActivityMainBinding 是在DataBingding配置完成之后自动生成的    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        // 初始化DataBindingUtil,用来绑定布局        activityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main)        // 初始化数据类        var myViewModel = ViewModelProviders.of(this).get(MyViewModel::class.java)        activityMainBinding?.myViewModel=myViewModel        activityMainBinding?.lifecycleOwner = this    }}</code></pre><h4 id="布局-使用-“data”-标签-↓"><a href="#布局-使用-“data”-标签-↓" class="headerlink" title="布局 使用 “data” 标签 ↓"></a>布局 使用 “data” 标签 ↓</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595645673021.png" alt=""></p><p>需要 layout 布局保存布局,需要 “data “标签保存绑定来的数据,需要 “variable” 标签设置变量。</p><h4 id="需要使用-“-”-方式访问变量-↓"><a href="#需要使用-“-”-方式访问变量-↓" class="headerlink" title="需要使用 “@{}” 方式访问变量 ↓"></a>需要使用 “@{}” 方式访问变量 ↓</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595645903565.png" alt=""></p><h4 id="需要使用-“-参数-gt-方法-参数-”访问方法-↓"><a href="#需要使用-“-参数-gt-方法-参数-”访问方法-↓" class="headerlink" title="需要使用 “@{(参数)-&gt;方法(参数)}”访问方法 ↓"></a>需要使用 “@{(参数)-&gt;方法(参数)}”访问方法 ↓</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595645888188.png" alt=""></p><p>demo ↓</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595646636793.png" alt=""></p><h2 id="什么是DataBinding"><a href="#什么是DataBinding" class="headerlink" title="什么是DataBinding"></a>什么是DataBinding</h2><p>DataBinding是谷歌在2015年I/O开发者大会上发布的一个数据绑定框架,也就是把数据捆绑到UI上,DataBinding可以让Activity和Fragment减少逻辑,使其方便维护。同时也能提高性能,避免空指针异常,同时DataBinding也支持双向绑定,使UI的改变同时同步到数据上,DataBinding不是MVVM架构的必需品。</p><h2 id="DataBinding有哪些优缺点"><a href="#DataBinding有哪些优缺点" class="headerlink" title="DataBinding有哪些优缺点"></a>DataBinding有哪些优缺点</h2><p><strong>优点</strong></p><ol><li>减少Activity和Fragment的逻辑处理,使Activity和Fragment逻辑更加清晰。</li><li>提高性能,避免内存泄漏以及空指针</li><li>支持双向绑定,当View改变的时候会通知Model,当Model改变时会通知View</li></ol><p><strong>缺点</strong></p><ol><li>bug难定位,出现bug时无法定位到是View中的bug还是Model中的bug,又或是编写的逻辑bug。</li><li>双向绑定不利于View的复用</li></ol><p>引用:<a href="https://juejin.im/post/5edb12346fb9a047da364349#heading-2" target="_blank" rel="noopener">https://juejin.im/post/5edb12346fb9a047da364349#heading-2</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> DataBinding </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LiveData与ViewModel</title>
      <link href="/2020/07/20/LiveData/"/>
      <url>/2020/07/20/LiveData/</url>
      
        <content type="html"><![CDATA[<h4 id="单独使用LiveData"><a href="#单独使用LiveData" class="headerlink" title="单独使用LiveData"></a>单独使用LiveData</h4><ol><li>创建LiveData实例。持有特定的数据类型，例如 int ,String。</li><li>创建一个Observer对象,并且实现onChanged()方法。在onChanged()方法类可以进行UI的刷新等。</li><li>使用LiveData实例的observe(…,…)方法,将Observer对象添加到LiveData中。方法原型为 <strong>observe(LifecycleOwner owner,Observer observer)</strong>,第一个参数是LifecycleOwner对象，为LiveData能够监听生命周期的能力来源。第二个参数为我们的监听对象。</li></ol><p>添加LiveData和ViewModel的依赖 ↓</p><pre><code>// 添加LiveData和ViewModel的依赖implementation &#39;android.arch.lifecycle:extensions:1.1.1&#39;</code></pre><p>界面准备按钮用来开启,使得UI刷新 ↓</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-20_15-48-40.png" alt=""></p><p> MainActivity中的代码 ↓</p><pre><code>class MainActivity : AppCompatActivity() {    val TAG = &quot;MainActivity&quot;    val btnStart = btn_start    val mTvNumber = tv_number    var mNumberLiveData: MutableLiveData&lt;Int&gt;? = null // 声明变量    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        mNumberLiveData = MutableLiveData()        btnStart.setOnClickListener { view: View? -&gt;            thread {                var number = 0                while (number &lt; 5) {                    mNumberLiveData?.postValue(number)                    Log.d(TAG, &quot;setOnClickListener&quot; + number)                    Thread.sleep(3000)                    number++                }            }        }        mNumberLiveData?.observe(this, object : Observer&lt;Int&gt; {            override fun onChanged(t: Int?) {                mTvNumber.setText(&quot;&quot; + t)                Log.d(TAG, &quot;onChanged&quot; + t)            }        })    }}</code></pre><p>界面的TextView会根据数据进行刷新。</p><h4 id="单独使用ViewModel"><a href="#单独使用ViewModel" class="headerlink" title="单独使用ViewModel"></a>单独使用ViewModel</h4><ol><li>创建ViewModel的继承类</li><li>在控制器中实例化继承类</li></ol><p>创建ViewModel继承类 ↓</p><pre><code>class MyViewModel() : ViewModel() {    var number = 0}</code></pre><p>修改控制器 ↓</p><pre><code>class MainActivity : AppCompatActivity() {    val TAG = &quot;MainActivity&quot;    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        // ViewModelProvider.of() 获得MyViewModel持久类用来保存UI数据        // &quot;MyViewModel::class.java&quot; 反射引用类型        var myViewModel = ViewModelProviders.of(this).get(MyViewModel::class.java)        tv_number.setText(myViewModel.number.toString())        btn_start.setOnClickListener {            myViewModel.number++            tv_number.setText(myViewModel.number.toString())        }    }}</code></pre><p>简单的界面样式 ↓</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-21_19-16-39.png" alt=""></p><h4 id="LiveData和ViewModel配合使用"><a href="#LiveData和ViewModel配合使用" class="headerlink" title="LiveData和ViewModel配合使用"></a>LiveData和ViewModel配合使用</h4><ol><li>需要有ViewModel的继承类</li><li>需要在ViewModel的继承类中实例化LiveData类型</li><li>需要在控制器中初始化ViewModel的继承类</li><li>需要调用LiveData的observe的方法</li></ol><pre><code>class MyViewModel : ViewModel() {    var mutableLiveData = MutableLiveData&lt;Int&gt;()    init {        mutableLiveData.value=0    }    fun getLive(): MutableLiveData&lt;Int&gt; {        return mutableLiveData    }    fun addNumber(number: Int) {        mutableLiveData?.value=number+ mutableLiveData.value!!    }}</code></pre><pre><code>class MainActivity : AppCompatActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        // 获得MyViewModel实例        var myViewModel = ViewModelProviders.of(this).get(MyViewModel::class.java)        btn_addone.setOnClickListener {            myViewModel?.addNumber(1)        }        myViewModel?.getLive()?.observe(this, object : Observer&lt;Int&gt; {            override fun onChanged(t: Int?) {                tv_number.setText(t.toString())            }        })    }}</code></pre><h4 id="什么是LiveData"><a href="#什么是LiveData" class="headerlink" title="什么是LiveData"></a>什么是LiveData</h4><p>LiveData是一个可以观察的数据持有类,但是不同于通常的观察者,它具有声明周期的感知能力。通俗些讲,它所持有的数据发生改变时,并且Lifecycle对象还处于活跃状态,LiveData将立即通知观察者数据发生了变化。相比于不同的观察者它多了生命周期和感知能力。</p><h4 id="什么是ViewModel"><a href="#什么是ViewModel" class="headerlink" title="什么是ViewModel"></a>什么是ViewModel</h4><p>简单说ViewModel是一种用来存储和管理UI相关数据的类。但是与其他的Model不同的是,他支持在系统改变时保存数据。</p><p>当屏幕发生改变时,会导致Activity/Fragment重新绘制,会导致我们之前的数据丢失。比如,在EditText中输入了内容,但是当屏幕扭转时,会发现editText中的文本被清空了。</p><p>当对于一下简单的数据,我们可以通过Activity的onSaveInstanceState()方法中储存,然后通过onCreate()中进行恢复,但是这种方式只适合存储少量的数据，并且是能被序列化和反序列的数据。而对那些大量的数据则不适用。</p><p>此外,它也使View的数据持有者和Viewcontroller逻辑更加分离，便于解耦和测试。</p><p>引用:<a href="https://juejin.im/post/5ca9f9156fb9a05e3d0a8aea#heading-6" target="_blank" rel="noopener">https://juejin.im/post/5ca9f9156fb9a05e3d0a8aea#heading-6</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
            <tag> LiveData </tag>
            
            <tag> ViewModel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 讲解</title>
      <link href="/2020/07/19/git%20%E8%AE%B2%E8%A7%A3/"/>
      <url>/2020/07/19/git%20%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="修改提交文件大小"><a href="#修改提交文件大小" class="headerlink" title="修改提交文件大小"></a>修改提交文件大小</h1><p>在要提交的项目根目录下使用。</p><pre><code>$ git config --local http.postBuffer 524288000</code></pre><p>设置为500MB。</p><h1 id="查看本地分支"><a href="#查看本地分支" class="headerlink" title="查看本地分支"></a>查看本地分支</h1><pre><code>git branch</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923155804.png" alt="本地的两个分支"></p><h1 id="查看远程仓库所有分支"><a href="#查看远程仓库所有分支" class="headerlink" title="查看远程仓库所有分支"></a>查看远程仓库所有分支</h1><pre><code>git branch -r</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923155838.png" alt="远程仓库的分支"></p><h1 id="查看本地仓库和远程仓库"><a href="#查看本地仓库和远程仓库" class="headerlink" title="查看本地仓库和远程仓库"></a>查看本地仓库和远程仓库</h1><pre><code>git branch -a</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923160933.png" alt="本地和远程共有仓库"></p><h1 id="创建本地分支"><a href="#创建本地分支" class="headerlink" title="创建本地分支"></a>创建本地分支</h1><pre><code>git branch annotationVersion</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923120947.png" alt="创建了本地分支"></p><h1 id="切换到创建的分支"><a href="#切换到创建的分支" class="headerlink" title="切换到创建的分支"></a>切换到创建的分支</h1><pre><code>git checkout 分支</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923121359.png" alt="切换到创建的 annotationVersion 分支"></p><h1 id="本地分支提交到远程分支"><a href="#本地分支提交到远程分支" class="headerlink" title="本地分支提交到远程分支"></a>本地分支提交到远程分支</h1><p><strong>切换到创建的分支</strong>（annotationVersion）。</p><pre><code>git push origin annotationVersion</code></pre><p>如果<strong>远程仓库</strong>没有这个分支，那么也会创建一个该分支。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923153643.png" alt="由于远程仓库没有本地的分支在push时自动创建了annotationVersion分支"></p><h1 id="本地获得一个远程分支"><a href="#本地获得一个远程分支" class="headerlink" title="本地获得一个远程分支"></a>本地获得一个远程分支</h1><p>使用命令</p><pre><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;例如git pull origin v1.0:v1.0</code></pre><p>pull 了<strong>远程仓库的v1.0分支</strong>本地命名<strong>为v1.0</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923172540.png" alt="pull 完成"></p><h1 id="合并本地两个分支"><a href="#合并本地两个分支" class="headerlink" title="合并本地两个分支"></a>合并本地两个分支</h1><p>如果当前分支（annotationVersion）分支，想与远程分支 master 合并（merge），可以使用如下命令：</p><p>切换到 master 分支：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923161205.png" alt="master分支"></p><p>在 master 分支合并另一个分支（annotationVersion）：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923161241.png" alt="合并完成"></p><p>随后可以将master分支 push 掉（用来提交两个合并了仓库）：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923161838.png" alt="push完成"></p><h1 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h1><p>删除前，要切出被删除的分支（删除A，先切换到B分支再删除）</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20220520171432.png" alt=""></p><pre><code>git branch -d (目标分支)git branch -d A</code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-theme-matery使用手册</title>
      <link href="/2020/07/19/hexo-theme-%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
      <url>/2020/07/19/hexo-theme-%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h4 id="修改头部的渐变颜色"><a href="#修改头部的渐变颜色" class="headerlink" title="修改头部的渐变颜色"></a>修改头部的渐变颜色</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-19_18-44-57.png" alt=""></p><p>修改跟目录下的 themes\hexo-theme-matery\source\css\matery.css 文件。修改”bg-color”即可。</p><h4 id="修改底部的加载进度条"><a href="#修改底部的加载进度条" class="headerlink" title="修改底部的加载进度条"></a>修改底部的加载进度条</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-19_18-47-15.png" alt=""></p><p>修改”progress-bar”即可。</p><h4 id="修改-top-按钮颜色"><a href="#修改-top-按钮颜色" class="headerlink" title="修改 top 按钮颜色"></a>修改 top 按钮颜色</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210302145826.png" alt=""></p><p>修改”.top-scroll .btn-floating”即可</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210302145848.png" alt=""></p><h4 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h4><p>下载插件,修改配置即可。</p><pre><code>npm install hexo-generator-search --save</code></pre><p>在根目录下安装插件。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-20_08-57-52.png" alt=""></p><p>修改配置信息。</p><p>打开根目录下的 “_config.yml”文件,添加配置信息。</p><pre><code>search:  path: search.xml  field: post</code></pre><h4 id="修改友情链接"><a href="#修改友情链接" class="headerlink" title="修改友情链接"></a>修改友情链接</h4><p>在 “Blog\source\data\friends.json” 目录下修改配置文件</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595649945373.png" alt=""></p><h4 id="自动添加文章的名称、时间等信息"><a href="#自动添加文章的名称、时间等信息" class="headerlink" title="自动添加文章的名称、时间等信息"></a>自动添加文章的名称、时间等信息</h4><p>需要创建文件 “scaffolds\post.md”</p><pre><code class="yaml">---title: {{ title }}date: {{ date }}tags: [标签]author: 用户名top: falsecover: falsetoc: truemathjax: truecategories: &quot;分类&quot;---</code></pre><h4 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a>完整实例</h4><p>👇修改文章封面,修改文章轮播图等</p><pre><code class="yaml">---title: {{title}}date: {{data}}author: 作者名字img: /source/images/xxx.jpg &quot;文章特征图,路径在source中&quot;top: true &quot;推荐文章&quot;cover: true &quot;表示该文章是否需要加入到首页轮播封面中&quot;coverImg: /images/1.jpg &quot;轮播图中的封面,访问的是&quot;source&quot;下的&quot;images&quot;&quot;password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: false &quot;是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项&quot;mathjax: false &quot;是否开启数学公式支持,本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行&quot;summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---</code></pre><h4 id="banner-图片的轮播数量"><a href="#banner-图片的轮播数量" class="headerlink" title="banner 图片的轮播数量"></a>banner 图片的轮播数量</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210313183222.png" alt=""></p><p>选择主题下的 <strong>hexo-theme-matery\layout\ _partial\bg-cover-content.ejs</strong> 文件</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210313183501.png" alt=""></p><h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><h2 id="修改各种标题"><a href="#修改各种标题" class="headerlink" title="修改各种标题"></a>修改各种标题</h2><h3 id="修改副标题和短句"><a href="#修改副标题和短句" class="headerlink" title="修改副标题和短句"></a>修改副标题和短句</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031160424.png" alt="副标题"></p><p>修改根目录下的 “<strong>_config.xml</strong>”</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031160741.png" alt="修改副标题"></p><p>根目录下“<strong>themes\hexo-theme-matery\_config.xml</strong>”</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031161025.png" alt=""></p><p>subtitle标签负责副标题的短句。</p><h3 id="修改-“梦想”短句"><a href="#修改-“梦想”短句" class="headerlink" title="修改 “梦想”短句"></a>修改 “梦想”短句</h3><p>根目录下“<strong>themes\hexo-theme-matery\_config.xml</strong>”</p><p>dream标签负责梦想短句。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031161233.png" alt=""></p><h2 id="备份和还原Blog"><a href="#备份和还原Blog" class="headerlink" title="备份和还原Blog"></a>备份和还原Blog</h2><h3 id="备份github创建私有仓库"><a href="#备份github创建私有仓库" class="headerlink" title="备份github创建私有仓库"></a>备份github创建私有仓库</h3><p>私有仓库设置为名字Blog(与文件夹名字相同即可),将文件下载到Blog的根目录下,将”.git”文件和”.gitignore”文件拖拽到Blog目录下。</p><p>‘’.gitignore’文件内添加要忽视的文件夹</p><pre><code>.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/</code></pre><p>正常提交即可</p><p>ps:可能会出现文件夹过大的原因 </p><p><a href="https://thecara.github.io/2020/07/19/git%E8%AE%BE%E7%BD%AE%E6%8F%90%E4%BA%A4%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F/">办法</a></p><h3 id="还原Blog"><a href="#还原Blog" class="headerlink" title="还原Blog"></a>还原Blog</h3><p>建议:使用新的电脑或者使用虚拟机来测试</p><p>安装git,配置git </p><p>使用”git Bash” 输入👇.</p><pre><code>$ git config --global user.name &quot;your name&quot;$ git config --global user.email &quot;your_email@youremail.com&quot;ssh-keygen -t rsa -C &quot;自己的邮箱&quot;</code></pre><p><a href="https://github.com/settings/ssh/new" target="_blank" rel="noopener">设置SHH</a></p><p>完成后会出现shh文件的目录,打开”.pub”类型文件将内容复制到这里。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595819104102.png" alt=""></p><p>完成后克隆我们的”Blog”</p><h3 id="安装nove-js"><a href="#安装nove-js" class="headerlink" title="安装nove.js"></a>安装nove.js</h3><p>在Blog目录下使用”git Bash”</p><p>直接安装 hexo,如果网络过慢建议配置仓库.</p><pre><code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p><a href="https://developer.aliyun.com/mirror/NPM" target="_blank" rel="noopener">更多</a></p><pre><code>npm i hexo-cli -g 或者 npm install hexo --save</code></pre><p>搭建</p><pre><code class="g">hexo ghexo shexo d</code></pre><p>ps:</p><p>如果出现 “ERROR Plugin load failed: hexo-prism-plugin”错误 直接删除”node_modules\hexo-prism-plugin”下的文件夹。</p><p>安装 nove.js 自动安装choco<a href="https://thecara.github.io/2020/07/26/choco%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%89%E8%A3%85/">可能会报错使用</a></p><p>引用:<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md</a></p><h2 id="Hexo-让文章按照最新的提交时间进行排序"><a href="#Hexo-让文章按照最新的提交时间进行排序" class="headerlink" title="Hexo 让文章按照最新的提交时间进行排序"></a>Hexo 让文章按照最新的提交时间进行排序</h2><p>让我们最新提交或者更新的文章在界面的首个位置。</p><p>在主配置文件 <strong>_config.ym</strong>l, 查找 <strong>index_generator</strong> 标签 <strong>order_by</strong> 属性修改为 <strong>-updated</strong> 即可。</p><pre><code class="yaml">index_generator:  path: &#39;&#39;  per_page: 18  order_by: -updated </code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201212171501.png" alt=""></p><p>之后 </p><pre><code>hexo g</code></pre><p>完成。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在使用 目录导航时不建议 “标题” 配合 “无序列表” 使用（hexo-version:4.2）</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-8-19-0.gif" alt=""></p><p>会出现无法跳转到指定目录。</p><p><strong>在使用尖括号（或称角括号）时</strong></p><p>不要使用两对的紧靠的尖括号，会出现识别为假链接的bug</p><p>例如：</p><p><A>test</p><p>实际想要的结果是 &lt; A &gt; test &lt; A &gt;</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2021-10-25-0.gif" alt="上述描述结果"></p>]]></content>
      
      
      <categories>
          
          <category> hexo-theme-matery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> hexo-theme-matery </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
