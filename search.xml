<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络协议</title>
      <link href="/2021/02/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
      <url>/2021/02/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p><strong>引用</strong></p><p><a href="https://www.cnblogs.com/fzz9/p/8964513.html" target="_blank" rel="noopener">一些重要的计算机网络协议（IP、TCP、UDP、HTTP）</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android PendingIntent</title>
      <link href="/2020/12/07/Android-PendingIntent/"/>
      <url>/2020/12/07/Android-PendingIntent/</url>
      
        <content type="html"><![CDATA[<h1 id="PendingIntent"><a href="#PendingIntent" class="headerlink" title="PendingIntent"></a>PendingIntent</h1><blockquote><p>描述</p><p>A description of an Intent and target action to perform with it. Instances of this class are created with <code>getActivity</code>, <code>getActivities</code>, <code>getBroadcast</code>, and <code>getService</code>; the returned object can be handed to other applications so that they can perform the action you described on your behalf at a later time.</p><p>它由getActivity，getService，getBroadcast来创建对象。</p><p>用于一种特殊的异步处理机制。可归结为 “异步激发”，这种异步激发常常是要跨进程执行的。比如说 A进程作为发起段，它可以从系统获得一个PendingIntent，然后A进程可以将PendingIntent对象通过binder机制“传递“给B进程，再通过B进程在未来的某个合适时机，”回调“PendingIntent对象的send()动作，完成激发。</p><p>PendingIntent的生命周期不与主进程相关。外部程序只能调用上述三个组件。</p></blockquote><h4 id="getActivity"><a href="#getActivity" class="headerlink" title="getActivity"></a>getActivity</h4><pre><code class="kotlin">static fun getActivity(    context: Context!,     requestCode: Int,     intent: Intent!,     flags: Int): PendingIntent!</code></pre><blockquote><p>Retrieve a PendingIntent that will start a new activity, like calling <code>Context#startActivity(Intent)</code>. Note that the activity will be started outside of the context of an existing activity, so you must use the <code>Intent#FLAG_ACTIVITY_NEW_TASK</code> launch flag in the Intent.</p><p>获得一个用于启动特定Activity的PendingIntent。</p></blockquote><h4 id="三个返回需要用到的参数"><a href="#三个返回需要用到的参数" class="headerlink" title="三个返回需要用到的参数"></a>三个返回需要用到的参数</h4><ul><li>context：上下文对象</li><li>requstCode：请求码，发件人的私人请求代码（当前未使用）</li><li>intent：请求意图。用于要指明要启动的类以及数据的传递</li><li>flags：这是一个关键的标志位</li></ul><h4 id="flags常量"><a href="#flags常量" class="headerlink" title="flags常量"></a>flags常量</h4><p>FLAG_CANCEL_CURRENT</p><pre><code class="kotlin">static val FLAG_CANCEL_CURRENT: Int</code></pre><blockquote><p>Flag indicating that if the described PendingIntent already exists, the current one should be canceled before generating a new one. For use with <code>getActivity</code>, <code>getBroadcast</code>, and <code>getService</code>.</p><p>如果新请求的 PendingIntent 发现已经存在时，取消已存在的，用新的 PendingInent 替换</p></blockquote><p>FLAG_IMMUTABLE</p><pre><code class="kotlin">static val FLAG_IMMUTABLE: Int</code></pre><blockquote><p>Flag indicating that the created PendingIntent should be immutable. This means that the additional intent argument passed to the send methods to fill in unpopulated properties of this intent will be ignored.</p><p>表示这是一个不可变的 PendingIntent。</p></blockquote><p>FLAG_NO_CREATE</p><pre><code>static val FLAG_NO_CREATE: Int</code></pre><blockquote><p>Flag indicating that if the described PendingIntent does not already exist, then simply return null instead of creating it. For use with <code>getActivity</code>, <code>getBroadcast</code>, and <code>getService</code>.</p><p>如果新请求的 PendingIntent 发现已经存在时，忽视新请求的，继续使用已经存在的请求。较少使用。</p></blockquote><p>FLAG_ONE_SHOT</p><pre><code class="kotlin">static val FLAG_ONE_SHOT: Int</code></pre><blockquote><p>Flag indicating that this PendingIntent can be used only once. For use with <code>getActivity</code>, <code>getBroadcast</code>, and <code>getService</code>.</p><p>表示 PendingIntent 只能使用一次，如果已经使用过，那么 getxxx方法时会返回为NULL，也就是说同类通知只能使用一次，后续的通知单独后无法打开。</p></blockquote><p>FLAG_UPDATE_CURRENT</p><pre><code>static val FLAG_UPDATE_CURRENT: Int</code></pre><blockquote><p>Flag indicating that if the described PendingIntent already exists, then keep it but replace its extra data with what is in this new Intent. For use with <code>getActivity</code>, <code>getBroadcast</code>, and <code>getService</code>.</p><p>如果新的请求的PendingIntent 发现已经存在时，如果 Intent 有字段改变了，则更新已存在的 PendingIntent</p></blockquote><h4 id="引用"><a href="#引用" class="headerlink" title="引用:"></a>引用:</h4><p><a href="https://developer.android.com/reference/kotlin/android/app/PendingIntent" target="_blank" rel="noopener">PendingIntent</a></p><p><a href="https://www.jianshu.com/p/a37f0ce2da2e" target="_blank" rel="noopener">PendingIntent的基本理解</a></p><p><a href="https://www.jianshu.com/p/4a8fc0b78094" target="_blank" rel="noopener">Android PendingIntent</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android-PackageManager</title>
      <link href="/2020/12/07/PackageManager/"/>
      <url>/2020/12/07/PackageManager/</url>
      
        <content type="html"><![CDATA[<h1 id="PackageManager"><a href="#PackageManager" class="headerlink" title="PackageManager"></a>PackageManager</h1><blockquote><p>Class for retrieving various kinds of information related to the application packages that are currently installed on the device. You can find this class through <code>Context#getPackageManager</code>.</p><p>PackageManager 负责管理应用程序安装、卸载和升级的API。</p></blockquote><h4 id="getLaunchIntentForPackage"><a href="#getLaunchIntentForPackage" class="headerlink" title="getLaunchIntentForPackage"></a>getLaunchIntentForPackage</h4><pre><code class="kotlin">abstract fun getLaunchIntentForPackage(packageName: String): Intent?</code></pre><blockquote><p>Returns a “good” intent to launch a front-door activity in a package. This is used, for example, to implement an “open” button when browsing through packages. The current implementation looks first for a main activity in the category <code>Intent#CATEGORY_INFO</code>, and next for a main activity in the category <code>Intent#CATEGORY_LAUNCHER</code>. Returns <code>null</code> if neither are found.</p><p>负责获得应用程序Launch的Intent。</p><p>返回一个“包”中的入口Activity的Intent，例如，这个类似于在浏览包的“打开”按钮。这个当前的安装启动第一步在category(CATEGORY_INFO)中寻找main Activity，然后category(CATEGORY_LAUNCHER)寻找main Activity。如果找不到返回 null。</p></blockquote><h5 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h5><p><a href="https://developer.android.com/reference/kotlin/android/content/pm/PackageManager" target="_blank" rel="noopener">PackageManager</a></p><p><a href="https://www.jianshu.com/p/c56376916d5e" target="_blank" rel="noopener">APK安装流程详解2——PackageManager简介</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>媒体浏览器服务 MediaBrowserService</title>
      <link href="/2020/12/02/%E5%AA%92%E4%BD%93%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%8D%E5%8A%A1-MediaBrowserService/"/>
      <url>/2020/12/02/%E5%AA%92%E4%BD%93%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%8D%E5%8A%A1-MediaBrowserService/</url>
      
        <content type="html"><![CDATA[<h1 id="媒体浏览器服务-MediaBrowserService"><a href="#媒体浏览器服务-MediaBrowserService" class="headerlink" title="媒体浏览器服务 MediaBrowserService"></a>媒体浏览器服务 MediaBrowserService</h1><h4 id="关键类型"><a href="#关键类型" class="headerlink" title="关键类型"></a>关键类型</h4><ol><li>MediaBrowserServiceCompat 媒体浏览器服务</li><li>MediaBrowserCompat 媒体浏览器</li><li>MediaControllerCompat 媒体控制器</li><li>MediaSessionCompat 媒体会话</li></ol><h4 id="MediaBrowserServiceCompat"><a href="#MediaBrowserServiceCompat" class="headerlink" title="MediaBrowserServiceCompat"></a>MediaBrowserServiceCompat</h4><blockquote><p>作用</p><p>音乐播放后台服务。</p><p>客户端中获取音乐数据的服务，所有的音乐数据都通过该服务与服务端进行交互获取。</p></blockquote><p>该类是Service类的子类，可以作为一个后台服务来使用，它实现后台服务并不能通过自身直接实现，而是通过MediaSessionCompat媒体会话来实现的。在使用过程中会话会与该服务关联起来，所有的播放操作都要给MediaSessionCompat实现。</p><p>获得数据时，通过 <strong>MediaBrowserServiceCompat</strong> 的两个方法来实现控制</p><pre><code class="kotlin">@Nullable abstract fun onGetRoot(    @NonNull clientPackageName: String,     clientUid: Int,     @Nullable rootHints: Bundle?): MediaBrowserServiceCompat.BrowserRoot?</code></pre><blockquote><p>此方法自在服务连接时调用，如果返回一个 rootId为空的BrowserRoot则表示客户端可以连接服务，也可以连接其媒体资源</p><p>如果返回null则表示客户端不能流量媒体资源</p></blockquote><pre><code class="kotlin">abstract fun onLoadChildren(    @NonNull parentId: String,     @NonNull result: MediaBrowserServiceCompat.Result&lt;MutableList&lt;MediaBrowserCompat.MediaItem!&gt;!&gt;): Unit</code></pre><blockquote><p>此方法中的 parentId 与上面的方法 onGetRoot 中返回的RootId没有关系，客户端连接后，它可以通过重复调用MediaBrowserCompat.subscribe()方法来发起数据请求。而每次调用subscribe()方法都会返回onLoadChildren()回调到该service中，然后返回MediaBrowser.MediaItem()对象列表</p><p>每个MediaItem都有唯一的Id字符串，它其实是一个隐式的token。当客户想打开子菜单或者播放item时，它就将ID传入。</p></blockquote><h1 id="MediaSessionCompat"><a href="#MediaSessionCompat" class="headerlink" title="MediaSessionCompat"></a>MediaSessionCompat</h1><h1 id="ServiceCompat"><a href="#ServiceCompat" class="headerlink" title="ServiceCompat"></a>ServiceCompat</h1><p>Helper用于访问在向后兼容的API级别4之后引入的 <code>Service</code>功能。</p><h4 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h4><p><a href="">关于媒体浏览器服务(MediaBrowserService)</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ExoPlayer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 图片适配</title>
      <link href="/2020/12/01/Android-%E5%9B%BE%E7%89%87%E9%80%82%E9%85%8D/"/>
      <url>/2020/12/01/Android-%E5%9B%BE%E7%89%87%E9%80%82%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>Android图片适配</p><p>android的drawable文件共有：</p><table><thead><tr><th>中文</th><th>文件夹名称</th></tr></thead><tbody><tr><td>低密度</td><td>drawable-ldpi</td></tr><tr><td>中等密度</td><td>drawable-mdpi</td></tr><tr><td>高密度</td><td>drawable-hdpi</td></tr><tr><td>超高密度</td><td>drawable-xhdpi</td></tr><tr><td>超超高密度</td><td>drawable-xxhdpi</td></tr><tr><td>超超超高密度</td><td>drawable-xxxhdpi</td></tr><tr><td>无缩放</td><td>drawable-nohdpi</td></tr><tr><td>默认</td><td>drawable</td></tr></tbody></table><p>Android 系统会按照设备dpi 范围从合适密度往上适配。</p><p>如果在中等分辨率的手机上，Android 就会现在 drawable-mdpi 文件夹下的图片。如果这里没有那么 drawable-hdpi 上查找以此类推最终会从默认的 drawable 文件夹下查找。</p><p>drawable-nodpi 文件夹，在这里存放的图片系统不会对它进行缩放操作，原图片有多大就会展示多大，匹配原则当匹配更高密度的图片时无法找到的话就会匹配这个文件夹的图片。</p><p>优缺点：放大图片会占用更多内存，缩小时内存减少但是影响打包效果。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android控件</title>
      <link href="/2020/11/29/Android%E6%8E%A7%E4%BB%B6/"/>
      <url>/2020/11/29/Android%E6%8E%A7%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="SeekBar-拖动条"><a href="#SeekBar-拖动条" class="headerlink" title="SeekBar(拖动条)"></a>SeekBar(拖动条)</h1><p>它是 ProgressBar的子类，这样ProgressBar的属性它都可以用！同时它还有自己的属性 android:thumb,允许我们自定义滑块。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Jetpack架构组件 Navigation 导航库</title>
      <link href="/2020/11/20/Navigation-%E5%AF%BC%E8%88%AA%E5%BA%93/"/>
      <url>/2020/11/20/Navigation-%E5%AF%BC%E8%88%AA%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="做什么的？"><a href="#做什么的？" class="headerlink" title="做什么的？"></a>做什么的？</h1><p>用于用户导航、进入或者退出应用中不同内容片段的交互。通过 Jetpack导航组件可帮助你实现导航，无论是简单的按钮点击，还是应用栏或抽屉式导航栏等复杂的模式，这个组件都可以应对。（简化了导航的实现）</p><p>将业务和视图分离。</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li>方便管理Fragment页面。</li><li>可视化页面导航，类似于xcode中的StoryBoard，便于看清页面之间的关系</li><li>通过destination和action来完成页面间的导航</li><li>方便页面切换动画</li><li>页面间内饰内饰的参数传递</li><li>通过NavigationUI类，对菜单，底部导航，抽屉菜单导航进行方便统一的管理</li><li>深层连接</li></ul><blockquote><p>本文中的”<strong>页面</strong>“指的是Fragment和Activity,但主要是Fragment，因为Navigation组件的主要目的就是方便我们在一个Activity中对多个Fragment进行管理。</p></blockquote><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><pre><code>dependencies {    implementation &quot;androidx.navigation:navigation-fragment-ktx:2.3.0&quot;    implementation &quot;androidx.navigation:navigation-ui-ktx:2.3.0&quot;}</code></pre><p><a href="https://developer.android.com/jetpack/androidx/releases/navigation?hl=zh-cn" target="_blank" rel="noopener">更多版本</a></p><h5 id="创建-Navigation-Graph"><a href="#创建-Navigation-Graph" class="headerlink" title="创建 Navigation Graph"></a>创建 Navigation Graph</h5><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123204418.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123204512.png" alt="ok 创建完成"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123204726.png" alt="创建nav_graph文件"></p><h5 id="添加-NavHostFragment"><a href="#添加-NavHostFragment" class="headerlink" title="添加 NavHostFragment"></a>添加 <strong>NavHostFragment</strong></h5><p>添加到Activity布局文件中，作为其他Fragment的容器</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;.MainActivity&quot;&gt;    &lt;androidx.appcompat.widget.Toolbar        android:id=&quot;@+id/toolbar&quot;        android:layout_width=&quot;411dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:background=&quot;?attr/colorPrimary&quot;        android:minHeight=&quot;?attr/actionBarSize&quot;        android:theme=&quot;?attr/actionBarTheme&quot;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;        app:layout_constraintStart_toStartOf=&quot;parent&quot;        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;    &lt;fragment        android:id=&quot;@+id/frameLayout&quot;        android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;0dp&quot;        app:defaultNavHost=&quot;true&quot;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;        app:layout_constraintStart_toStartOf=&quot;parent&quot;        app:layout_constraintTop_toBottomOf=&quot;@+id/toolbar&quot;        app:navGraph=&quot;@navigation/nav_graph&quot;&gt;    &lt;/fragment&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</code></pre><pre><code class="xml">android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;</code></pre><blockquote><p>告诉系统这是一个特殊的Fragment</p></blockquote><pre><code class="xml">app:defaultNavHost=&quot;true&quot;</code></pre><blockquote><p>点击返回按钮是，系统会自动将Fragment退出。</p></blockquote><pre><code class="xml"> app:navGraph=&quot;@navigation/nav_graph&quot;</code></pre><blockquote><p>对应的Fargment导航图</p></blockquote><h5 id="设置导航-Navigation"><a href="#设置导航-Navigation" class="headerlink" title="设置导航(Navigation)"></a>设置导航(Navigation)</h5><p>创建MainFragment和SecondeFragment</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123214054.png" alt=""></p><blockquote><p>destination 表示目的地，既你想要去的地方。Navigation 组件的目的就是方便开发者在一个Activity中管理多个Fragment。所以在这里创建一个MainFragment。</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123214146.png" alt="选择 Fragment"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123214359.png" alt=""></p><blockquote><p>表示首个加载的Fragment</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123214733.png" alt="选择 code"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123214811.png" alt=""></p><blockquote><p>app:startDestination = “@id/mainFragment”</p><p>表示首个加载的Fragment</p></blockquote><p>设置MainFragment界面</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;             xmlns:tools=&quot;http://schemas.android.com/tools&quot;             android:layout_width=&quot;match_parent&quot;             android:layout_height=&quot;match_parent&quot;             tools:context=&quot;.MainFragment&quot;&gt;    &lt;TextView        android:id=&quot;@+id/tvTitle&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_centerInParent=&quot;true&quot;        android:textSize=&quot;18sp&quot;        android:text=&quot;MainFragment&quot;/&gt;    &lt;Button        android:id=&quot;@+id/btnToSecondFragment&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_below=&quot;@+id/tvTitle&quot;        android:textAllCaps=&quot;false&quot;        android:text=&quot;to SecondFragment&quot;/&gt;&lt;/RelativeLayout&gt;</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123215621.png" alt=""></p><h5 id="设置跳转顺序"><a href="#设置跳转顺序" class="headerlink" title="设置跳转顺序"></a>设置跳转顺序</h5><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201123215652.png" alt="ps:sscondFragment为secondFragment"></p><blockquote><p>选中mainFragment后点击方块连线到secondFragment</p></blockquote><p>可以看到 <action/>标签中，app:destination 属性表示目的地，这里表示的是secondFragment</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;navigation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/nav_graph&quot;    app:startDestination=&quot;@id/mainFragment&quot;&gt;    &lt;fragment        android:id=&quot;@+id/mainFragment&quot;        android:name=&quot;com.thecara.navigation.MainFragment&quot;        android:label=&quot;fragment_main&quot;        tools:layout=&quot;@layout/fragment_main&quot;&gt;        &lt;action            android:id=&quot;@+id/action_mainFragment_to_sscondFragment&quot;            app:destination=&quot;@id/secondFragment&quot; /&gt;    &lt;/fragment&gt;    &lt;fragment        android:id=&quot;@+id/secondFragment&quot;        android:name=&quot;com.thecara.navigation.SscondFragment&quot;        android:label=&quot;fragment_sscond&quot;        tools:layout=&quot;@layout/fragment_sscond&quot; /&gt;&lt;/navigation&gt;</code></pre><h5 id="设置跳转"><a href="#设置跳转" class="headerlink" title="设置跳转"></a>设置跳转</h5><p>使用这个来跳转</p><pre><code class="kotlin">        view.findViewById&lt;Button&gt;(R.id.btnToSecondFragment).setOnClickListener {            Navigation.findNavController(view).navigate(R.id.action_mainFragment_to_sscondFragment)        }</code></pre><blockquote><p>  Navigation.findNavController(params).navigate(id)</p><p>表示通过指定id跳转的哪里，这里指跳转到 secondeFragment。</p><p>其中还有</p><p>Navigation.findNavController(params).navigateUp()</p><p>负责向上跳转</p></blockquote><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-11-23-0.gif" alt=""></p><h1 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h1><ul><li>Navigation Graph </li></ul><p>这是一种新型的 XML 资源文件，里面包含了应用程序所有的页面及页面之间的关系</p><ul><li>NavHostFragment</li></ul><p>这是一个特殊的布局文件，NavigationGraph中的页面通过该Fragment展示</p><ul><li>NavController</li></ul><p>用于在代码中完成NavigationGraph中的具体页面切换</p><p><strong>所以，当你使用NavController对象，告诉它你想要去NavigationGraph中的那个页面，NavController将会将相关的页面展示在NavHostFragment中。</strong></p><h5 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h5><p><a href="https://developer.android.com/guide/navigation?hl=zh-cn" target="_blank" rel="noopener">导航</a></p><p><a href="https://zhuanlan.zhihu.com/p/69562454" target="_blank" rel="noopener">Navigation(一)基础入门</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Jetpack架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ExoPlayer2 Google依赖库</title>
      <link href="/2020/11/13/ExoPlayer2-Google%E4%BE%9D%E8%B5%96%E5%BA%93/"/>
      <url>/2020/11/13/ExoPlayer2-Google%E4%BE%9D%E8%B5%96%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><strong>1.添加依赖</strong></p><p>在项目的根目录下 打开 build.gradle 中添加Google和JCenter库。</p><blockquote><p>创建android 项目时 AndroidStudio 会自动添加，在这里提一下。</p></blockquote><pre><code class="groovy">repositories {    google()    jcenter()}</code></pre><ol start="2"><li>在 app module <strong>中添加依赖项</strong>。</li></ol><pre><code class="groovy">implementation &#39;com.google.android.exoplayer:exoplayer:2.X.X&#39;</code></pre><p><strong>2.x.x</strong>替换为首选的最新版本(<a href="https://github.com/google/ExoPlayer/blob/release-v2/RELEASENOTES.md" target="_blank" rel="noopener">ExoPlayer</a>)</p><p>作为完整库的代替方案，可以根据实际需要的库模块。例如，以下内容对Core,DASH和UI库模块的依赖关系，这可能时播放DASH内容的应用程序所需要的。</p><pre><code class="groovy">implementation &#39;com.google.android.exoplayer:exoplayer-core:2.X.X&#39;implementation &#39;com.google.android.exoplayer:exoplayer-dash:2.X.X&#39;implementation &#39;com.google.android.exoplayer:exoplayer-ui:2.X.X&#39;</code></pre><p>可用的库模块在下列出。</p><ul><li><strong>exoplayer-core</strong>：核心功能（必须）。</li><li><strong>exoplayer-dash</strong>：支持DASH内容。</li><li><strong>exoplayer-hls</strong>：支持HLS内容。</li><li><strong>exoplayer-smoothstraming</strong>：支持SmoothStreaming内容。</li><li><strong>exoplayer-ui</strong>：与ExoPlayer一起使用的UI组件和资源。</li></ul><p><a href="https://github.com/google/ExoPlayer/tree/release-v2/extensions/" target="_blank" rel="noopener">更多的扩展模块</a>。</p><p><strong>3.Java8</strong></p><p>在 app 目录下添加 一下内容供所有文件支持Java8</p><pre><code class="groovy">compileOptions {  targetCompatibility JavaVersion.VERSION_1_8}</code></pre><h1 id="DOC"><a href="#DOC" class="headerlink" title="DOC"></a>DOC</h1><h4 id="AudioAttributes-Builder-类"><a href="#AudioAttributes-Builder-类" class="headerlink" title="AudioAttributes.Builder() 类"></a><strong>AudioAttributes.Builder() 类</strong></h4><blockquote><p>用于音频回放的属性，用于配置平台下的AudioTrack。</p><p>如果你要设置音频属性，需要创建一个 AudioAttributes实例。</p></blockquote><ul><li><strong>setContentText(int contentType)</strong></li></ul><blockquote><p>设置描述音频信号内容类型的属性。如语言或音乐。</p></blockquote><ul><li><strong>setUsage(int contentType)</strong></li></ul><blockquote><p>设置描述音频信号用途的属性，例如报警或者铃声。</p></blockquote><ul><li><strong>build()方法</strong></li></ul><blockquote><p>构建器创建一个 AudioAttributes 实例。</p></blockquote><h4 id="C-类"><a href="#C-类" class="headerlink" title="C 类"></a>C 类</h4><blockquote><p>定义标准库的常量</p></blockquote><ul><li><strong>C.CONTENT_TYPE_MUSIC</strong></li></ul><blockquote><p>C 类的常量用于</p><p>在你使用内容类型为音乐时使用的内容类型值。</p></blockquote><ul><li><strong>C.USAGE_MEDIA</strong></li></ul><blockquote><p>当使用媒体是使用这个值(如音乐或者电影原声带)</p></blockquote><h4 id="SimpleExoPlayer-类"><a href="#SimpleExoPlayer-类" class="headerlink" title="SimpleExoPlayer 类"></a>SimpleExoPlayer 类</h4><blockquote><p>实现组件的外部播放。</p><p>用SimpleExoPlayer.Build(context:Context)来实现</p></blockquote><ul><li><strong>build()方法</strong></li></ul><blockquote><p>构建器创建一个 SimpleExoPlayer实例。</p></blockquote><ul><li><strong>setAudioAttributes()</strong></li></ul><blockquote><p>设置音轨使用的音频回放属性。如果没有设置，将使用默认的属性。它们一般设置为媒体播放。设置回放音频属性期间可能回在输出中引入一个短间隙，因为音频轨道被重新创建。还生成一个新的音频会话id。如果音轨是由音轨选择器启用的，指定的音频属性将被忽视，但是当它播放时没有音轨那么指定属性将会被使用。</p><p>If the device is running a build before platform API version 21, audio attributes cannot be set directly on the underlying audio track. In this case, the usage will be mapped onto an equivalent stream type using Util.getStreamTypeForAudioUsage(int).</p><p>If audio focus should be handled, the AudioAttributes.usage must be C.USAGE_MEDIA or C.USAGE_GAME. Other usages will throw an IllegalArgumentException.</p><p><strong>Parameters:</strong></p><p><code>audioAttributes</code> - The attributes to use for audio playback. 用于音频回放的属性</p><p><code>handleAudioFocus</code> - True if the player should handle audio focus, false other wise.    用户处理音轨焦点时选择 true。</p></blockquote><ul><li><strong>setHandleAudioBecomingNoisy(boolean handleAudioBecomingNoisy)</strong></li></ul><blockquote><p>设置当前的音频从耳机重新定向到扬声器事，播放器是否应该暂停。</p><p>默认不启用。false</p><p>Sets whether the player should pause automatically when audio is rerouted from a headset to device speakers.</p><p><strong>Parameters:</strong></p><p><code>handleAudioBecomingNoisy</code> - Whether the player should pause automatically when audio is rerouted from a headset to device speakers.</p></blockquote><h4 id="DefaultDataSourceFactory-类"><a href="#DefaultDataSourceFactory-类" class="headerlink" title="DefaultDataSourceFactory  类"></a>DefaultDataSourceFactory  类</h4><blockquote><p>创建工厂，将非文件的数据委托到 DetaultHttpDataSources。</p><p>Factory that produces DefaultDataSource instances that delegate to DefaultHttpDataSources for non-file/asset/content URIs.</p></blockquote><ul><li><strong>DefaultDataSourceFactory(Context context,String userAgent)</strong></li></ul><blockquote><p>创建 DetaultDataSourceFactory 类实例</p><p><strong>Parameters:</strong></p><p><code>context</code> - A context.</p><p><code>userAgent</code> - The User-Agent string that should be used. 使用用户代理</p></blockquote><ul><li><strong>Util.getUserAgent(Context context,String applicationName)</strong></li></ul><blockquote><p>根据给定的应用程序名词和库版本返回用户代理的字符串。</p><p>Returns a user agent string based on the given application name and the library version.</p><ul><li><p><strong>Parameters:</strong></p><p><code>context</code> - A valid context of the calling application. 当前 app 上下文</p><p><code>applicationName</code> - String that will be prefix’ed to the generated user agent.</p></li></ul></blockquote><h4 id="MediaSessionConnector-类"><a href="#MediaSessionConnector-类" class="headerlink" title="MediaSessionConnector 类"></a>MediaSessionConnector 类</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201204220725.png" alt="继承关系"></p><blockquote><p>介绍</p><p>Connects a MediaSessionCompat to a <a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/Player.html" target="_blank" rel="noopener"><code>Player</code></a>.</p><p>负责连接到 MediaSessionCompat 类</p></blockquote><pre><code class="java">public MediaSessionConnector(android.support.v4.media.session.MediaSessionCompat mediaSession)</code></pre><blockquote><p><code>mediaSession</code> - The <a href="https://developer.android.com/reference/android/support.v4.media.session.MediaSessionCompat.html" target="_blank" rel="noopener"><code>MediaSessionCompat</code></a> to connect to.</p><p>用来连接到 MediaSessionCompat</p></blockquote><p><strong>setPlayer</strong></p><pre><code class="java"> public void setPlayer(@Nullable Player player)</code></pre><blockquote><p>Sets the player to be connected to the media session. Must be called on the same thread that is used to access the player.</p><p>将播放器连接到媒体。主要只能在一条线程上。</p></blockquote><h4 id="MediaSessionCompat-类"><a href="#MediaSessionCompat-类" class="headerlink" title="MediaSessionCompat 类"></a>MediaSessionCompat 类</h4><blockquote><p>Allows interaction with media controllers, volume keys, media buttons, and transport controls.</p><p>用来对媒体控制前、音量键、媒体按钮和传输控件进行交互。</p></blockquote><p><strong>构造方法</strong></p><p><strong>MediaSessionCompat</strong></p><pre><code class="kotlin">MediaSessionCompat(@NonNull context: Context, @NonNull tag: String)</code></pre><blockquote><p>Creates a new session. You must call <code>release()</code> when finished with the session.</p><p>创建对象。在完成时要调用release()释放。</p><p>参数1：创建Session的上下文</p><p>参数2：调试时所用的 tag。</p></blockquote><p><strong>MediaSessionCompat</strong></p><pre><code class="kotlin">MediaSessionCompat(@NonNull context: Context, @NonNull tag: String, @Nullable mbrComponent: ComponentName?, @Nullable mbrIntent: PendingIntent?)</code></pre><blockquote><p>Creates a new session with a specified media button receiver (a component name and/or a pending intent). You must call <code>release()</code> when finished with the session.</p><p>指定一个媒体接收器来创建对象。在完成时要调用release()释放。</p><p>参数1：创建Session的上下文</p><p>参数2：调试时所用的 tag。</p><p>参数3：指定媒体接收器的名称</p><p>参数4：处理媒体按钮事件的接收器组件。可选选项。</p></blockquote><p><strong>setSessionToken</strong></p><pre><code class="kotlin">open fun setSessionToken(token: MediaSessionCompat.Token!): Unit</code></pre><blockquote><p>Call to set the media session.</p><p>This should be called as soon as possible during the service’s startup. It may only be called once.</p><p>呼叫设置媒体会话。</p><p>这应该在服务启动期间尽快调用。 它只能被调用一次。</p></blockquote><p><strong>getSessionToken</strong></p><pre><code class="kotlin">@Nullable open fun getSessionToken(): MediaSessionCompat.Token?</code></pre><blockquote><p>Gets the session token, or null if it has not yet been created or if it has been destroyed.</p><p>获取会话标记，如果尚未创建或已销毁它，则为null。</p></blockquote><h4 id="ConcatenatingMediaSource-类"><a href="#ConcatenatingMediaSource-类" class="headerlink" title="ConcatenatingMediaSource 类"></a>ConcatenatingMediaSource 类</h4><blockquote><p><code>ConcatenatingMediaSource</code>允许播放期间动态的添加和删除<code>MediaSource</code></p></blockquote><h4 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h4><p><a href="https://juejin.im/post/6854573203994443789" target="_blank" rel="noopener">深入解读ExoPlayer 之 开发者指南全译-02 开始使用</a></p><p><a href="https://exoplayer.dev/doc/reference/overview-summary.html" target="_blank" rel="noopener">DOC</a></p><p><a href="https://www.apiref.com/android-zh/index.html" target="_blank" rel="noopener">Android API</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ExoPlayer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Glide Android图片加载库</title>
      <link href="/2020/11/12/Glide-Android%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93/"/>
      <url>/2020/11/12/Glide-Android%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="下载-添加依赖"><a href="#下载-添加依赖" class="headerlink" title="下载 添加依赖"></a>下载 添加依赖</h1><p><strong>添加依赖</strong></p><blockquote><p>在 app 目录下打开 build.gradle</p></blockquote><pre><code class="kotlin">   // Glide    implementation &#39;com.github.bumptech.glide:glide:4.11.0&#39;    kapt &#39;com.github.bumptech.glide:compiler:4.11.0&#39;</code></pre><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><pre><code class="kotlin">Glide.with(context)    .load(url)    .into(imageView);</code></pre><blockquote><ul><li>with(context:Context) 需要上下文。</li><li>load(url:String) 字符串性质的网络图片Url。</li><li>into(imageView :ImageView) 你需要显示的图片的控件</li></ul></blockquote><p><strong>取消加载</strong></p><pre><code class="kotlin">Glide.with(context).clear(imageView);</code></pre><blockquote><p>Glide.with()中传入Activity或者Fragment时会跟随它们创建和销毁，所有手动取消是非必要的。</p></blockquote><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><blockquote><ul><li>setDefaultRequestOptions(RequestOptions requestOptions)</li></ul><p>用于配置加载图片时的默认选项，编码模式包含在其中，默认配置是RGB_565</p><p>参数：</p><ol><li>requestOptions:设置 RequestOptions 到加载的应用中。</li></ol></blockquote><h4 id="RequestOptions类"><a href="#RequestOptions类" class="headerlink" title="RequestOptions类"></a>RequestOptions类</h4><blockquote><p>提供选项来给 Glide 自定义加载。</p></blockquote><ul><li><strong>placeholder(Drawable drawable)</strong></li></ul><blockquote><p>设置加载时的默认图片。</p><p>参数：</p><ol><li>drawable，显示图片的占位符</li></ol></blockquote><ul><li><strong>onError(Drawable drawable)</strong></li></ul><blockquote><p>设置图片加载错误时的图片。</p><p>参数：</p><ol><li>drawable，显示图片的占位符</li></ol></blockquote><ul><li><strong>diskCacheStrategy(DiskCacheStrategy diskCacheStrategy)</strong></li></ul><blockquote><p>将 DiskCacheStrategy 类型应用到单独请求中。允许你加载过程中使用或者写入磁盘缓存，选择性的仅支持无修改的原声数据，或者变换过的缩略图，或者兼而有之。</p><p>参数：</p><ol><li>diskCacheStrategy：使用DiskCacheStrategy类的常量作为缓存策略。</li></ol></blockquote><h4 id="DiskCacheStrategy-类"><a href="#DiskCacheStrategy-类" class="headerlink" title="DiskCacheStrategy  类"></a>DiskCacheStrategy  类</h4><blockquote><p>缓存策略（Disk 、Cache 、Strategy）</p><p>允许你加载过程中使用或者写入磁盘缓存，选择性的仅支持无修改的原声数据，或者变换过的缩略图，或者兼而有之。</p><p>默认是<strong>AUTOMATIC</strong>，会尝试对本地和远程图片使用最佳策略。当你加载远程数据时，<strong>AUTOMATIC</strong>策略会存储维被你加载过程修改过的原始数据(例如，变换，裁剪)，因为下载远程数据相比调整磁盘上已经存在的数据要昂贵的多。对于本都数据，<strong>AUTOMATIC</strong> 策略会存储变换过的缩略图，因为即使你再次生成另一个尺寸或者类型的图片，取回原始数据也是很容易的。</p></blockquote><p><strong>类型介绍</strong></p><blockquote><p>DiskCacheStrategy.NONE: 表示不缓存任何内容。</p><p>DiskCacheStrategy.DATA: 只缓存原始图片。</p><p>DiskCacheStrategy.RESOURCE：表示只缓存转换过后的图片。</p><p>DiskCacheStrategy.ALL:表示既缓存原始图片，也缓存转换过后的图片。</p><p>DiskCacheStrategy.AUTOMATIC: 表示让Gilde根据图片资源智能的选择一种缓存策略（默认）。</p></blockquote><p><strong>引用</strong></p><p><a href="https://muyangmin.github.io/glide-docs-cn/doc/getting-started.html" target="_blank" rel="noopener">Glide</a></p><p><a href="https://www.jianshu.com/p/4f457a124d67" target="_blank" rel="noopener">Android图片加载框架——Glide（Glide v4）</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Glide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dagger-Hilt Android的依赖注入框架</title>
      <link href="/2020/11/11/Dagger-Hilt-Android%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6/"/>
      <url>/2020/11/11/Dagger-Hilt-Android%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Hilt-是干什么的？"><a href="#Hilt-是干什么的？" class="headerlink" title="Hilt 是干什么的？"></a>Hilt 是干什么的？</h1><p>它是 Google 为Android开发提供的场景化依赖库，皆在减少项目中进行的手动依赖注入。</p><p>Hilt 为项目中的每个 Android 类提供容器并自动管理它们的生命周期，为应用程序提供了 DI的标准方法。它是从 Dagger 库的基础上进行构建的，因为 Dagger提供的编译时正确性、运行时性能、可伸缩性并且从AndroidStudio支持Dagger中获益。</p><blockquote><p><strong>相比Dagger，Hilt有那些优化？</strong></p><p>Hilt的实现要比Dagger简单的多，使用Dagger实现依赖注入，需要去编写modules、components等等。每次去创建一个新的Android组件，比如 Activity、Fragment时，我们都需要将它们手动添加到modules中。</p></blockquote><h1 id="使用-Hilt-前的准备工作"><a href="#使用-Hilt-前的准备工作" class="headerlink" title="使用 Hilt 前的准备工作"></a>使用 Hilt 前的准备工作</h1><ul><li>添加依赖 在项目的根目录下 build.gradle 文件</li></ul><pre><code>buildscript {    ...    dependencies {        ...        classpath &quot;com.google.dagger:hilt-android-gradle-plugin:2.28.3-alpha&quot;    }}</code></pre><ul><li>在项目的应用级目录下 </li></ul><pre><code>...apply plugin: &#39;kotlin-kapt&#39;apply plugin: &#39;dagger.hilt.android.plugin&#39;android {    ...}dependencies {    implementation &quot;com.google.dagger:hilt-android:2.28-alpha&quot;    kapt &quot;com.google.dagger:hilt-android-compiler:2.28-alpha&quot;}</code></pre><p>Hilt 使用Java8的功能，所以我们在项目中启用它，应用模块下 build.gradle 文件添加代码。</p><pre><code class="groovy">android {  ...    compileOptions {        sourceCompatibility JavaVersion.VERSION_1_8        targetCompatibility JavaVersion.VERSION_1_8    }    // For Kotlin projects    kotlinOptions {        jvmTarget = &quot;1.8&quot;    }}</code></pre><blockquote><p><strong>注意</strong></p><p>在 Kotlin 项目中，需要添加 kotlinOptions，否则ViewModel会编译不通过。</p><p>需要注意使用hilt 和data binding，需要AndroidStudio的版本必须&gt;=4.0。</p></blockquote><p>Application 是 App 的入口，所有使用Hilt的App必须包含一个使用@HiltAndroidApp注解的Application</p><pre><code class="kotlin">@HiltAndroidAppclass HiltApplication : Application() {    /**     * 1. 所有使用 Hilt 的 App 必须包含一个使用 @HiltAndroidApp 注解的 Application     * 2. @HiltAndroidApp 将会触发 Hilt 代码的生成，包括用作应用程序依赖项容器的基类     * 3. 生成的 Hilt 组件依附于 Application 的生命周期，它也是 App 的父组件，提供其他组件访问的依赖     * 4. 在 Application 中设置好 @HiltAndroidApp 之后，就可以使用 Hilt 提供的组件了，     *    Hilt 提供的 @AndroidEntryPoint 注解用于提供 Android 类的依赖（Activity、Fragment、View、Service、BroadcastReceiver）等等     *    Application 使用 @HiltAndroidApp 注解     */}</code></pre><ol><li>@HiltAndroidApp会触发Hilt代码的生成，包括用作应用程序依赖容器的基类</li><li>生成的Hilt组件依附于Application的生命周期，它也是App的父组件，提供其他组件访问的依赖。</li></ol><h1 id="使用-Hilt-进行依赖注入"><a href="#使用-Hilt-进行依赖注入" class="headerlink" title="使用 Hilt 进行依赖注入"></a>使用 Hilt 进行依赖注入</h1><p>注入 HiltSimple 并在 Application 中调用它的doSomething方法。</p><pre><code class="kotlin">class HiltSimple @Inject constructor() {    fun doSomething() {        Log.e(TAG, &quot;----doSomething----&quot;)    }}@HiltAndroidAppclass HiltApplication : Application() {    @Inject    lateinit var mHiltSimple: HiltSimple    override fun onCreate() {        super.onCreate()        mHiltSimple.doSomething()    }}</code></pre><p>Hilt 需要知道如何从相对应的组件中提供必要的依赖实例。使用@Inject注解来告诉Hilt如何提供该类的实例，@Inject 常用于构造函数、非私有字段、方法。</p><h1 id="Hilt-常用注解的含义"><a href="#Hilt-常用注解的含义" class="headerlink" title="Hilt 常用注解的含义"></a>Hilt 常用注解的含义</h1><h4 id="HiltAndroidApp"><a href="#HiltAndroidApp" class="headerlink" title="@HiltAndroidApp"></a>@HiltAndroidApp</h4><blockquote><p>1 所有使用HIlt的App必须包含一个使用@HiltAndroidApp注解的Application。</p><p>2 @HiltAndroidApp注解将会触发Hilt代码的生成，作为应用程序依赖项容器的基类。</p><p>3 生成的Hilt组件依附于Application的生命周期，它也是App的父组件，提供其他组件访问的依赖。</p><p>4 在Application中设置号@HiltAndroidApp之后，就可以使用Hilt提供的组件了，组件包含Applicaiton、Activity、Fragment等。</p></blockquote><h4 id="AndroidEntryPoint"><a href="#AndroidEntryPoint" class="headerlink" title="@AndroidEntryPoint"></a>@AndroidEntryPoint</h4><blockquote><p>Hilt 提供的@AndroidEntryPoint注解用于提供Android类的依赖（Activity、Fragment、View、Service、BroadcastReceiver）</p><p>特殊的Application使用 @HiltAndroidApp注解。</p><ul><li><p>Activity：支持ComponentActivity的子类例如FragmentActivity、AppCompatActivity等。</p></li><li><p>Fragment：支持 androidx.Fragment包下的Fragment。</p></li><li><p>View</p></li><li><p>Service</p></li><li><p>BroadcastReceiver</p></li></ul></blockquote><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>在使用@AndroidEntryPoint在非ComponentActivity子类上注解，例如Activity则会抛出异常。</p><pre><code class="groovy">Activities annotated with @AndroidEntryPoint must be a subclass of androidx.activity.ComponentActivity. (e.g. FragmentActivity, AppCompatActivity, etc.)</code></pre><p>使用@AndroidEntryPoint注解时，必须在它的依赖的Android类添加同样的注解，<strong>例如Fragment中添加@AndroidEntryPoint注解，必须在Fragment依赖的Activity上也添加@AndroidEntryPoint注解，否则会抛出一样。</strong></p><pre><code class="kotlin">java.lang.IllegalStateException: Hilt Fragments must be attached to an @AndroidEntryPoint Activity. Found: class com.hi.dhl.hilt.MainActivity</code></pre><h4 id="Module"><a href="#Module" class="headerlink" title="@Module"></a>@Module</h4><p>常用于创建依赖类的对象（例如第三方库 OkHttp、Retrofit等等），使用@Module注解的类，需要使用@InstallIn注解指定范围module。</p><pre><code class="kotlin">@Module@InstallIn(ApplicationComponent::class)// 这里使用了 ApplicationComponent，因此 NetworkModule 绑定到 Application 的生命周期。object NetworkModule {}</code></pre><h4 id="InstallIn"><a href="#InstallIn" class="headerlink" title="@InstallIn"></a>@InstallIn</h4><p>使用@Module注入的类，使用@InstallIn注解指定module的范围，例如使用@InstallIn(ActivityComponent::class)注解的module会绑定到Activity的生命周期上。</p><p>Hilt 提供了以下组件来绑定依赖与对应的Android类的活动范围。</p><table><thead><tr><th align="center">Hilt 提供组件</th><th align="center">对应的Android类活动范围</th><th align="center">作用域</th></tr></thead><tbody><tr><td align="center">ApplicationComponent</td><td align="center">Application</td><td align="center">@Singleton</td></tr><tr><td align="center">ActivityRetainedComponent</td><td align="center">ViewModel</td><td align="center">@ActivityRetainedScope</td></tr><tr><td align="center">ActivityComponent</td><td align="center">Activity</td><td align="center">@ActivityScoped</td></tr><tr><td align="center">FragmentComponent</td><td align="center">Fragment</td><td align="center">@FragmentScoped</td></tr><tr><td align="center">ViewComponent</td><td align="center">View</td><td align="center">@ViewScoped</td></tr><tr><td align="center">ViewWithFragmentComponent</td><td align="center">View annotated with @WithFragmentBindings</td><td align="center">@ViewScoped</td></tr><tr><td align="center">ServiceComponent</td><td align="center">Service</td><td align="center">@ServiceScoped</td></tr></tbody></table><blockquote><p><strong>注意</strong></p><p>Hilt 没有为 broadcast receivers 提供组件，因为Hilt直接从ApplicationComponent注入broadcast receivers。</p></blockquote><p>Hilt 会根据相应的 Android 类生命周期自动创建和销毁生成的组件类的实例。如下。</p><table><thead><tr><th align="center">Hilt 提供的组件</th><th align="center">创建对应的生命周期</th><th>销毁对应的生命周期</th></tr></thead><tbody><tr><td align="center">ApplicationComponent</td><td align="center">Application#onCreate()</td><td>Application#onDestory()</td></tr><tr><td align="center">ActivityRetainedComponent</td><td align="center">Activity#onCreate()</td><td>Activity#onDestroy()</td></tr><tr><td align="center">ActivityComponent</td><td align="center">Activity#onCreate()</td><td>Activity#OnDestroy()</td></tr><tr><td align="center">FragmentComponent</td><td align="center">Fragment#OnAttach()</td><td>Fragment#onDestroy()</td></tr><tr><td align="center">ViewComponent</td><td align="center">View#super()</td><td>View destroyed</td></tr><tr><td align="center">ViewWithFragmentComponent</td><td align="center">View#super()</td><td>View destroyed</td></tr><tr><td align="center">ServiceComponent</td><td align="center">Service#onCreate()</td><td>Service#onDestroy()</td></tr></tbody></table><h4 id="Provides"><a href="#Provides" class="headerlink" title="@Provides"></a>@Provides</h4><p>常用于被 @Module 注解标记类的内部方法，并提供依赖项对象。</p><pre><code class="kotlin">@Module@InstallIn(ApplicationComponent::class)// 这里使用了 ApplicationComponent，因此 NetworkModule 绑定到 Application 的生命周期。object NetworkModule {    /**     * @Provides 常用于被 @Module 注解标记类的内部的方法，并提供依赖项对象。     * @Singleton 提供单例     */    @Provides    @Singleton    fun provideOkHttpClient(): OkHttpClient {        return OkHttpClient.Builder()            .build()    }}</code></pre><h1 id="Hilt-同-第三方组件一起使用"><a href="#Hilt-同-第三方组件一起使用" class="headerlink" title="Hilt 同 第三方组件一起使用"></a>Hilt 同 第三方组件一起使用</h1><p>如果你要在项目中添加第三方依赖，需要使用@Module注解，使用@Module注解的普通类，在其中创建第三方依赖的对象。</p><pre><code class="kotlin">@Module@InstallIn(ApplicationComponent::class)// 这里使用了 ApplicationComponent，因此 NetworkModule 绑定到 Application 的生命周期。object NetworkModule {    /**     * @Provides 常用于被 @Module 注解标记类的内部的方法，并提供依赖项对象。     * @Singleton 提供单例     */    @Provides    @Singleton    fun provideOkHttpClient(): OkHttpClient {        return OkHttpClient.Builder()            .build()    }    @Provides    @Singleton    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {        return Retrofit.Builder()            .client(okHttpClient)            .baseUrl(&quot;https://api.github.com/&quot;)            .addConverterFactory(GsonConverterFactory.create())            .build()    }    @Provides    @Singleton    fun provideGitHubService(retrofit: Retrofit): GitHubService {        return retrofit.create(GitHubService::class.java)    }}</code></pre><ul><li>@Module 常用于创建依赖类对象（如OkHttp、Retrofit等等）。</li><li>使用 @Module注入的类，需要使用@InstallIn注解指定module的范围，会绑定到Android类对应的生命周期上。</li><li>@Provides 常用于标记类的内部方法，并提供依赖项对象。</li></ul><h1 id="当需要上下文是使用的注解（预定义限定符）"><a href="#当需要上下文是使用的注解（预定义限定符）" class="headerlink" title="当需要上下文是使用的注解（预定义限定符）"></a>当需要上下文是使用的注解（预定义限定符）</h1><p>​    HIlt提供了预定义限定符。例如，当你需要使用应用或者Activity的Context类时，Hilt提供了<strong>@ApplicationContext</strong>和<strong>@ActivityContext</strong>限定符。</p><p>假如,当前这个类需要Activity的上下文。</p><pre><code class="kotlin">class Test @Inject constructor(    @ActivityContext private val context: Context,    private val service: AnalyticsService) { ... }</code></pre><h4 id="引用："><a href="#引用：" class="headerlink" title="引用："></a><strong>引用</strong>：</h4><p><a href="https://juejin.im/post/6844904198803292173?utm_source=gold_browser_extension#heading-13" target="_blank" rel="noopener">Jetpack 新成员 Hilt 实践（一）启程过坑记</a></p><p><a href="https://juejin.im/post/6845166890562617352" target="_blank" rel="noopener">Jetpack 新成员 Hilt 与 Dagger 大不同（三）落地篇</a></p><p><a href="https://developer.android.com/training/dependency-injection/hilt-android?hl=zh-cn" target="_blank" rel="noopener">Hilt 中的预定义限定符</a></p><p><a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/index-all.html" target="_blank" rel="noopener">JavaDoc-Glide</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Dagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何让Firebase使用Kotlin协程</title>
      <link href="/2020/11/08/%E5%A6%82%E4%BD%95%E8%AE%A9Firebase%E4%BD%BF%E7%94%A8Kotlin%E5%8D%8F%E7%A8%8B/"/>
      <url>/2020/11/08/%E5%A6%82%E4%BD%95%E8%AE%A9Firebase%E4%BD%BF%E7%94%A8Kotlin%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>引用：</strong></p><p>​    <a href="https://medium.com/better-programming/how-to-use-kotlin-coroutines-with-firebase-6f8577a3e00f" target="_blank" rel="noopener">How to Use Kotlin Coroutines With Firebase</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Firebase 讲解</title>
      <link href="/2020/10/29/Firebase-%E8%AE%B2%E8%A7%A3/"/>
      <url>/2020/10/29/Firebase-%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="AndroidStudio-添加-Firebase-选项"><a href="#AndroidStudio-添加-Firebase-选项" class="headerlink" title="AndroidStudio 添加 Firebase 选项"></a>AndroidStudio 添加 Firebase 选项</h1><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201029230255.png" alt="使用时可能会没有 firebase 选项"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201029230927.png" alt="settings 添加 plug-in"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201029231529.png" alt="选择添加 Firebase Services"></p><h1 id="创建-Firebase-项目"><a href="#创建-Firebase-项目" class="headerlink" title="创建 Firebase 项目"></a>创建 Firebase 项目</h1><blockquote><p>准备好 google 账号</p></blockquote><p><strong>打开 Firebase</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-11-2-0.gif" alt=""></p><p><strong>进入控制台</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102004348.png" alt=""></p><p><strong>选择项目名称</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102004431.png" alt="create a firebase"></p><p><strong>继续</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102004513.png" alt=""></p><p><strong>选择默认账户或者创建</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102004549.png" alt=""></p><p><strong>稍等片刻</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102004649.png" alt=""></p><p><strong>完成</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102004812.png" alt=""></p><h1 id="删除-Firebase-项目"><a href="#删除-Firebase-项目" class="headerlink" title="删除 Firebase 项目"></a>删除 Firebase 项目</h1><p><strong>点击设置</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102004958.png" alt=""></p><p><strong>选择项目设置</strong></p><p><strong>翻到最底部</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102005205.png" alt=""></p><p><strong>删除项目。</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201102005613.png" alt=""></p><h1 id="在-CloudFireStore中添加-元数据"><a href="#在-CloudFireStore中添加-元数据" class="headerlink" title="在 CloudFireStore中添加 元数据"></a>在 CloudFireStore中添加 元数据</h1><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201104131055.png" alt="选择Cloud Firestore"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201104131130.png" alt="点击 “开始收集”"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201104131210.png" alt="添加 集合名字"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201104131719.png" alt="添加 文档称呼"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201104131546.png" alt="点击添加字段 直接添加字段即可"></p><h1 id="将-Storage中的数据链接添加到元数据中"><a href="#将-Storage中的数据链接添加到元数据中" class="headerlink" title="将 Storage中的数据链接添加到元数据中"></a>将 Storage中的数据链接添加到元数据中</h1><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201104131958.png" alt="点击上传文件"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-11-4-2.gif" alt="选择要添加的元数据连接"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201104152013.png" alt="粘贴即可"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EC</title>
      <link href="/2020/10/29/EC/"/>
      <url>/2020/10/29/EC/</url>
      
        <content type="html"><![CDATA[<h3 id="基本的语法概念：词性-，一个单次的分类"><a href="#基本的语法概念：词性-，一个单次的分类" class="headerlink" title="基本的语法概念：词性 ，一个单次的分类"></a>基本的语法概念：词性 ，一个单次的分类</h3><p><strong>英语单词共分两类:</strong>虚词和实词</p><p>虚词：没有具体含义。</p><p>实词：有实际的意义。</p><h4 id="虚词"><a href="#虚词" class="headerlink" title="虚词"></a>虚词</h4><p>虚词共分两类： </p><blockquote><p>介词： in at on （可翻译为 在）</p><p>连词：end but or （和、但是、或者）</p></blockquote><h4 id="实词"><a href="#实词" class="headerlink" title="实词"></a>实词</h4><p>实词共分四大类：</p><blockquote><p>名词：用来表达一件东西的名称的词。（花、草、树木等都表示名词）</p><p>动词：表示运动的词。（跑、蹲下）</p><p>形容词：用来修饰名词的词。（美丽的女孩。美丽形容词）</p><p>副词：辅助作用的词。表行为或者状态。（修饰名词以外所有的词。<strong>大声</strong>的唱歌）</p></blockquote><h4 id="不定时"><a href="#不定时" class="headerlink" title="不定时"></a>不定时</h4><blockquote><p>to do</p></blockquote><h3 id="基本的语法概念：句子成分"><a href="#基本的语法概念：句子成分" class="headerlink" title="基本的语法概念：句子成分"></a>基本的语法概念：句子成分</h3><p><strong>注意：</strong>句子成分和词性是不一样的。</p><h1 id="英语的五大句型"><a href="#英语的五大句型" class="headerlink" title="英语的五大句型"></a>英语的五大句型</h1><h2 id="系动词-主语-系动词-表语"><a href="#系动词-主语-系动词-表语" class="headerlink" title="系动词 主语+系动词+表语"></a>系动词 主语+系动词+表语</h2><h3 id="什么是主系表？"><a href="#什么是主系表？" class="headerlink" title="什么是主系表？"></a>什么是<strong>主系表</strong>？</h3><ul><li>主：句子的主体。</li><li>系：系动词，特殊的动词（特殊的谓语属于动词的一种），<strong>在句子中做谓语的动词没有实际意义就属于系动词。</strong></li></ul><blockquote><p>汉语中表示 “是” “为”，英语中表示 am，is ，are。</p><p>在句子中起联系的作用就叫做系动词。</p><p>linking verb 联系动词</p></blockquote><ul><li>表：</li></ul><blockquote><p>表语。<strong>补充说明主语的性质叫做表语</strong>。</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201030150702.png" alt=""></p><p><strong>如何判断句子是否是主系表结构</strong></p><blockquote><p>用中文的方式判断句子里的谓语，可否使用“是”，或者“为”来翻译。</p></blockquote><p>列如：</p><blockquote><p>I am a good persion</p><p>am 可以理解为 “是”。这是主系表</p><p>I become a good persion</p><p>become 理解为 “成为”  “为”。也是主系表结构</p></blockquote><h3 id="系动词共分类四类"><a href="#系动词共分类四类" class="headerlink" title="系动词共分类四类"></a>系动词共分类四类</h3><h4 id="1-be-动词-（am、-is、-are、过去-was、were-、将来-will、be）"><a href="#1-be-动词-（am、-is、-are、过去-was、were-、将来-will、be）" class="headerlink" title="1.be 动词 （am、 is、 are、过去 was、were 、将来 will、be）"></a>1.be 动词 （am、 is、 are、过去 was、were 、将来 will、be）</h4><p>am、 is、 are</p><p>过去 was、were </p><p>将来 will、be</p><h5 id="Be动词后跟三大类-表语"><a href="#Be动词后跟三大类-表语" class="headerlink" title="Be动词后跟三大类 表语"></a>Be动词后跟三大类 表语</h5><ul><li><strong>名词</strong></li></ul><blockquote><p><strong>名词做表语</strong>，可以同汉语完全对应，<strong>be 动词翻译成汉语的是</strong>。</p></blockquote><p>Tim is an engineer</p><p>蒂姆是个工程师</p><p>The price is a £ 2000</p><p>价格是 2000 英镑</p><ul><li><strong>形容词</strong></li></ul><blockquote><p>和汉语不同，<strong>be 动词不会被翻译出来</strong>，<strong>直接被省略介词短语也相当于形容词。</strong></p></blockquote><p>The play was very interesting.</p><p>戏很有意思</p><blockquote><p>The play：戏剧、戏</p><p>was very interesting：很有意思</p></blockquote><p>The milk is in the refrigerator.</p><p>牛奶在冰箱里</p><blockquote><p>in the refrigerator：在冰箱里，用来形容 The milk （牛奶）。介词短语可以用来做形容词</p><p>这是<strong>主系表</strong>结构</p></blockquote><ul><li><strong>地点副词</strong>    </li></ul><blockquote><p>只能接<strong>地点动词</strong>。</p></blockquote><p>Your sister is here there days。</p><p>你姐姐这段在这儿。</p><h4 id="2-状态保持动词-（keep、remain、stay）"><a href="#2-状态保持动词-（keep、remain、stay）" class="headerlink" title="2.状态保持动词 （keep、remain、stay）"></a>2.状态保持动词 （keep、remain、stay）</h4><blockquote><p>这三个词后只能加<strong>形容词作表语</strong>，可以和 be 无限切换。</p></blockquote><p>you should <strong>keep</strong> quiet！（you should <strong>be</strong> quiet！）</p><p>你应该保持安静！</p><p>No one can <strong>remain</strong> youthful forever （No one can <strong>be</strong> youthful forever）</p><p>没有人能永葆青春</p><p>The weather <strong>stayed</strong> fine for a week （The weather <strong>was</strong> fine for a week 。was：过去式）</p><p>这个星期天气一直很好。</p><h4 id="3-状态转变类动词（become、get、go、come、grow、turn）"><a href="#3-状态转变类动词（become、get、go、come、grow、turn）" class="headerlink" title="3.状态转变类动词（become、get、go、come、grow、turn）"></a>3.状态转变类动词（become、get、go、come、grow、turn）</h4><ul><li><strong>become</strong>是一个万能词，既可以表示“变成”，这时候后面只能接名词。同时也可以表示“<strong>变得</strong>”，后面接形容词。</li></ul><p>He <strong>become</strong> a weather.</p><p>他成为了一名教师。</p><p>He <strong>become</strong> very nervous.</p><p>他变得很紧张。</p><ul><li><strong>get</strong>表示“变得怎样”,后边这能接形容词。</li></ul><p>He got very angry.</p><p>他变得非常生气</p><ul><li>come 这个词的本意是来，什么东西会来，当然是好的东西，所以一般come含有“变好”的意思。</li></ul><p>Thing will <strong>come</strong> right.</p><p>事情会变好。</p><ul><li><strong>go</strong> 表示走，你希望的东西你离而去？当然是坏的东西离你而去，所以表达“变坏”，可以用go</li></ul><p>The meat always <strong>goes</strong> bad in summer.</p><p>肉在夏天常常会变坏</p><ul><li>如果你要表示“慢慢变”，使用 <strong>grow</strong>，本意表示 grow 是生长的意思，慢慢长大。</li></ul><p>The weather <strong>grew</strong> cold in the night.</p><p>晚上天气慢慢变冷。</p><ul><li>要表达<strong>“快速变”</strong>，应该用turn。因为turn本意为转身，一下子转过去</li></ul><p>His face <strong>turned</strong> pale.</p><p>他脸色变得苍白</p><h4 id="4-感官动词（look、sound、smell、taste、feel）"><a href="#4-感官动词（look、sound、smell、taste、feel）" class="headerlink" title="4.感官动词（look、sound、smell、taste、feel）"></a>4.感官动词（look、sound、smell、taste、feel）</h4><blockquote><p>五个动词，一律翻译为 “…起来”，“看起来，听起来，闻起来，尝起来，感觉起来（感到）”，后面只能接形容词（相当于形容词的分词）作表语。</p></blockquote><p>I <strong>felt</strong> very nervous when I went into this office.</p><p>我走到他的办公室，感到非常紧张。</p><p>He <strong>looked</strong> very angry.</p><p>他看上去非常气愤。</p><p>They were all hungry and the food <strong>smelled</strong> good.（were：be动词过去式，可以不做翻译）</p><p>他们全都饿了，饭菜散发出阵阵香气。</p><p>The sun <strong>looks like</strong> an orange globe.</p><p>太阳看上去像橙色的球体。</p><blockquote><p>👆 感官动词后，绝不能直接加名词做表语，如果要加名词，必须用：<strong>感官动词+介词like+名词</strong>，此时翻译为“像…”。</p></blockquote><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201030230419.png" alt="句子"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201030230512.png" alt="答案"></p><h2 id="不及物动词-主语-谓语"><a href="#不及物动词-主语-谓语" class="headerlink" title="不及物动词 主语+谓语"></a>不及物动词 主语+谓语</h2><h3 id="什么是主-谓结构？"><a href="#什么是主-谓结构？" class="headerlink" title="什么是主+谓结构？"></a>什么是主+谓结构？</h3><blockquote><p>通常主谓后应该加宾语。当主谓加在一起也可以作为一个句子。</p><p>例如：我笑了 </p><p>“我”和动词“笑了”组成了句子，“我”是主语，“笑了”是谓语，“笑了”是不及物动词所以就组成了句子。</p><p>汉语：我跳舞她。</p><p>英语：I dance her.</p><p>主谓结构同汉语相同。在汉语中 我跳舞她 是不合理的同样英语这样表达也是不合理的。</p><p>I dance.</p></blockquote><h3 id="谓语"><a href="#谓语" class="headerlink" title="谓语"></a>谓语</h3><p><em>名词</em></p><ol><li>语法学中指对主语加以陈述的成分，表示主语「怎么样」或「是什么」。一般的句子都包括主语、谓语，汉语中谓语一般在主语后面。如「我是学生」中「是学生」是谓语。</li></ol><h3 id="出现主谓结构的原因！"><a href="#出现主谓结构的原因！" class="headerlink" title="出现主谓结构的原因！"></a>出现主谓结构的原因！</h3><blockquote><p>因为有不及物动词。</p><p>其中<strong>不及物动词组成主谓结构</strong>。</p></blockquote><h3 id="什么是不及物动词？"><a href="#什么是不及物动词？" class="headerlink" title="什么是不及物动词？"></a>什么是不及物动词？</h3><blockquote><p>intransitive verb，简称：vi.</p><p>它本身意义就是完全的，没有作用对象，<strong>不需要加宾语就能构成完整句子</strong>，例如：游泳、出生、笑、做梦。</p></blockquote><h3 id="如何判断不及物动词？"><a href="#如何判断不及物动词？" class="headerlink" title="如何判断不及物动词？"></a>如何判断不及物动词？</h3><blockquote><p>如何判断，<strong>把这个动词前加上“被”</strong>，看它的寓意是否合理。</p><p>正常则为及物动词，不正常则为不及物动词。</p><p>例如：被打、被喜欢、被处罚。如果说：被跳舞、被做梦、被笑，则为不及物动词。</p></blockquote><h4 id="状语"><a href="#状语" class="headerlink" title="状语"></a>状语</h4><blockquote><p>说明这个动作发生的时间、地点、目的、以及状态等。</p><p>表示 时间、地点和方式的句子成分就叫做状语。</p></blockquote><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul><li><strong>这个句式多带有状语，来进一步说明这个动作发生的时间，地点，目的。</strong></li></ul><p>Detectives were waiting at the airport all morning .</p><p>They were talking loudly.</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031170041.png" alt=""></p><ul><li><strong>很多动词，本身既可以作不及物动词，也可以做及物动词，除啦上述方法外，还要在语境中判断</strong></li></ul><h3 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031110943.png" alt="题目"></p><p>The birds         sing         happily.</p><p>The rain     will stop     in the afternoon.</p><p>The children     are playing         in the park</p><p>My teacher         passed away     in the hospital         yesterday.</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031162342.png" alt=""></p><h2 id="及物动词-主语-谓语-宾语"><a href="#及物动词-主语-谓语-宾语" class="headerlink" title="及物动词 主语+谓语+宾语"></a>及物动词 主语+谓语+宾语</h2><h3 id="什么是及物动词？"><a href="#什么是及物动词？" class="headerlink" title="什么是及物动词？"></a>什么是及物动词？</h3><blockquote><p><strong>及物动词</strong>（transitive verb 简称：vt）</p><p>意思为：加入宾语之后的完整动词，分为主动和被动语态。</p><p>短语相当于及物动词时为：<strong>及物动词短语</strong>。</p></blockquote><p>Yesterday ，    a pigeon         carried     the first     message     from Pinhurst to Slibury.</p><p>昨天，一只鸽子把第一封信从平赫特带到锡尔伯里.</p><p>The bird     covered     the distance     in three minutes.</p><p>这只鸟只用了三分钟就飞完了全程。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031163058.png" alt=""></p><p>The bride and the groom cur the wedding cake together.</p><p>新郎和新娘一起切下结婚蛋糕</p><p>I <strong>had</strong> an amusing experience last year.</p><p>去年我有一次有趣的经历。</p><p>This wonderful plane can <strong>carry</strong> seven passengers.</p><p>这架奇妙的飞机可以载七名乘客</p><h3 id="练习题-2"><a href="#练习题-2" class="headerlink" title="练习题"></a>练习题</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031171234.png" alt=""></p><p>The teacher put up some pictures on the wall in the classroom.</p><p>You should respect the old in public places.</p><p>He began his diet a week ago.</p><p>He set up a new world record in September 1935</p><p>Only very few people can realize their dreams.</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031173411.png" alt=""></p><h2 id="不完全及物动词-主语-谓语-宾语-宾语补语"><a href="#不完全及物动词-主语-谓语-宾语-宾语补语" class="headerlink" title="不完全及物动词 主语+谓语+宾语+宾语补语"></a>不完全及物动词 主语+谓语+宾语+宾语补语</h2><h3 id="什么是不完全及物动词？"><a href="#什么是不完全及物动词？" class="headerlink" title="什么是不完全及物动词？"></a>什么是不完全及物动词？</h3><blockquote><p>不完全及物动词 incomplete transitive verb，简称i.vt</p><p>这个动词加了宾语之后，<strong>意思仍然不完整，需要加上补语（complement）才能使句子完整。</strong></p><p>补语是 <strong>补充说明宾语的特征，或者补语的动作</strong></p></blockquote><ul><li><p>“她 使 我 爱上生活。” 这个 “使” 就是不完全及物动词 如果只说 “她使我” 意思是不完整的，要加上补语 “爱上生活”，才是完整的句子。</p></li><li><p>“他的表演让我 失望。”这个“让”，如果说“他的表演让我”，当然也不完全要加上补语“失望”</p></li></ul><h3 id="如何分别完全及物动词和不完全及物动词？"><a href="#如何分别完全及物动词和不完全及物动词？" class="headerlink" title="如何分别完全及物动词和不完全及物动词？"></a>如何分别完全及物动词和不完全及物动词？</h3><p>最常用的不完全及物动词： <strong>使役动词</strong></p><blockquote><p>在要使什么，做什么时使用使役动词</p></blockquote><ul><li>使…做…（make，have，let，get）</li></ul><p>make/have/let+宾语+动词原形（补语）</p><p>get+宾语+动词不定式（补语）</p><blockquote><p>has：have 的第三人称时态</p></blockquote><ul><li>I made him wash the car.</li></ul><p>我叫他洗车。</p><ul><li>I got him to wash the car.</li></ul><p>我叫他洗车。</p><p>综上所述，只要宾语发出动作，或宾语的状态，均可构成此类句型。</p><h3 id="练习题-3"><a href="#练习题-3" class="headerlink" title="练习题"></a>练习题</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031194550.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031194437.png" alt=""></p><h2 id="授予动词-主语-谓语-间接宾语-直接宾语"><a href="#授予动词-主语-谓语-间接宾语-直接宾语" class="headerlink" title="授予动词 主语+谓语+间接宾语+直接宾语"></a>授予动词 主语+谓语+间接宾语+直接宾语</h2><h3 id="什么是授予动词？"><a href="#什么是授予动词？" class="headerlink" title="什么是授予动词？"></a>什么是授予动词？</h3><p>dative verb，简称d.v</p><ul><li><strong>是及物动词的一种</strong>，当需要接两个宾语，<strong>第一个间接宾语表示授予对象</strong>，<strong>第二个宾语为直接宾语</strong>，<strong>表示授予的东西</strong></li><li>要注意的是，<strong>直接宾语和间接宾语，都是谓语动作的作用对象</strong>，这是与第四大句型的区别。在第四大句型中，补语说明宾语的性质，或者是宾语发出的动作。</li><li>那么在找间宾和直宾使直接找<strong>授予对象</strong>再找<strong>授予的东西</strong>。</li></ul><h3 id="常见的授予动词"><a href="#常见的授予动词" class="headerlink" title="常见的授予动词"></a>常见的授予动词</h3><blockquote><p><strong>give (授予动词)、send、tall、teach、pay、show、offer</strong></p></blockquote><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031215252.png" alt=""></p><ul><li>Richard Mattes <strong>gave</strong> the testers six different kinds of things.</li></ul><p>Richard Matter 给你这些测试者六种不同类型的东西。</p><blockquote><p>直接宾语 <strong>授予的东西</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031220027.png" alt=""></p><ul><li>I <strong>send</strong>     <u>him</u> a     <u>book</u> in reward for his help.</li></ul><p>我送给他一本书答谢他的帮助。</p><blockquote><p>间接宾语<strong>授予的对象</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031221559.png" alt=""></p><ul><li>The scientist <strong>told</strong> <u>us</u> many <u>stories</u> about birds.</li></ul><p>博物学家给我们讲述了许多有关鸟儿的故事。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031221956.png" alt=""></p><ul><li>A friendly waiter <strong>taught</strong> <u>me</u> a few <u>words</u> of Italian.Then he <strong>lent</strong> <u>me</u> a <u>book</u></li></ul><p>一个好客的服务员教我几句意大利语，之后还借给我一本书。</p><ul><li>Yesterday I <strong>paid</strong> <u>him</u> a <u>visit</u>.</li></ul><p>昨天我去看望了他。</p><ul><li>Then he <strong>showed</strong> <u>me</u> the <u>contents</u> of the parcel .</li></ul><p>接着他给我看了包里的东西。</p><ul><li>He <strong>offered</strong> <u>me</u> a lot of <u>money</u>.</li></ul><p>他给了我很多钱。</p><h2 id="主谓宾补与主谓间宾直宾区分（不完全及物动词和授予动词区分）"><a href="#主谓宾补与主谓间宾直宾区分（不完全及物动词和授予动词区分）" class="headerlink" title="主谓宾补与主谓间宾直宾区分（不完全及物动词和授予动词区分）"></a>主谓宾补与主谓间宾直宾区分（不完全及物动词和授予动词区分）</h2><blockquote><p>只要是 <strong>谓语的动作</strong>，<strong>作用于两个不同的名词，也就是两个宾语</strong>，就是第五大句型</p><p>而在第四大类句型中，补语是宾语的动作或状态。</p></blockquote><p>例子：</p><ol><li><p>他 让 <strong>我 学习</strong>。‘“学习” 是 “我” 发出的动作 （学习是在“我”这个宾语后做补充的）</p></li><li><p>他 给了 <strong>我一本书</strong>。 “书” 和 “我” 都是谓语“给”的作用对象所以，</p><p>第1句是第四大句式（主谓宾补），第2句式第五大句型（主谓间宾直宾）</p></li></ol><h3 id="练习题-4"><a href="#练习题-4" class="headerlink" title="练习题"></a>练习题</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031223426.png" alt=""></p><ol><li>题的主谓双宾结构</li></ol><p>He gave his girlfriend a bunch of flowers on Valentine’s Day.</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031225959.png" alt=""></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="谓语-1"><a href="#谓语-1" class="headerlink" title="谓语"></a>谓语</h2><p>名词</p><ol><li>语法学中指对主语加以陈述的成分，表示主语「怎么样」或「是什么」。一般的句子都包括主语、谓语，汉语中谓语一般在主语后面。如「我是学生」中「是学生」是谓语。</li></ol><h2 id="宾语"><a href="#宾语" class="headerlink" title="宾语"></a>宾语</h2><p>名词</p><ol><li>语法上指受动词支配、关涉或受介词引导的成分。在现代汉语中，宾语一般在动词或介词后面。如「尊敬师长」中的「师长」，「他写信」中的「信」，「对他很好」中的「他」。</li></ol><h2 id="表语"><a href="#表语" class="headerlink" title="表语"></a>表语</h2><p>​        属于主语补足语，语法名词，是指说明主语的身份、性质、品性、特征和状态的词或从句，表语常由名词、形容词、介词短语、动名词、不定式、副词来充当，<strong>它常位于系动词（be）之后。</strong></p><p><a href="https://www.bilibili.com/video/BV1sJ411M7Gb?p=3" target="_blank" rel="noopener">英语简单句的造词法则和基本语法概念</a></p><h2 id="介词"><a href="#介词" class="headerlink" title="介词"></a>介词</h2><p><em>名词</em></p><ol><li>虚词的一类。用在名词、代词或名词性短语前边，引进动作行为的时间、处所、方式、目的、涉及或比较的对象以及动作的施事者等。如「在」「从」「以」「为了」「把」「比」「被」等。</li></ol><h2 id="副词"><a href="#副词" class="headerlink" title="副词"></a>副词</h2><p><em>名词</em></p><ol><li>修饰或限制动词、形容词，表示范围、程度、情态、语气等的词，一般不能修饰或限制名词。如「都」「很」「竟然」「再三」等。</li></ol><h1 id="七大英语句子成分的概述"><a href="#七大英语句子成分的概述" class="headerlink" title="七大英语句子成分的概述"></a>七大英语句子成分的概述</h1><h2 id="定语"><a href="#定语" class="headerlink" title="定语"></a>定语</h2><p>一个句子用来界定，限定名词的部分。</p><blockquote><p>一个 <strong>高个子的</strong>，<strong>留着长头发的</strong>，<strong>穿着红色衣服的，喜欢学习英语的</strong>学生。</p><p>加黑部分为 定语。</p></blockquote><h4 id="什么语法成分能够作为定语呢？"><a href="#什么语法成分能够作为定语呢？" class="headerlink" title="什么语法成分能够作为定语呢？"></a>什么语法成分能够作为定语呢？</h4><p><strong>形容词以及相当于形容词性质的语法成分。</strong></p><blockquote><p>一般来说，一个句子，如果是“…的”，它就是形容词性质的，比如说穿着红色衣服的，喜欢学习英语的，都属于形容词短语或者形容词从句。</p></blockquote><p><strong>英语百分之九十五的定语遵循“前小后大”的规则</strong></p><blockquote><p>一个单词组成的定语（限定词，形容词，名词以及名词所有格），放在所修饰名词的前面。</p></blockquote><blockquote><p>两个以上单词组成的定语（of属格，形容词短语，介词短语，分词短语，不定时短语等），放在所修饰词后面。</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201105155015.png" alt="各种语法成分作定语的例子。黑体部分为定语修饰的名词"></p><blockquote><p>They were expecting a valuable parcel of diamonds from South Africa</p><p>他们正期待从南非来的一个装有钻石的贵重包裹。</p><p>定语共是个分别为：</p><p>限定词 a，作顶词修饰 parcel ，a parcel 的包裹。</p><p>形容词 valuable，作定语，贵重。of diamonds 作定语限定为钻石。from South Africa 作定语限制为来自南非。</p></blockquote><blockquote><p>Mrs.Rumbold was a large,unsmiling lady in a tight black dress.</p><p>兰博尔德夫人是一位身材高大、表情严肃的女人，穿一件紧身的黑衣服。</p><p>a large，定语作形容词，形容高大的。unsmiling，定语作形容词严肃的。in a tight black dress，定语作介词短语（形容词性质），形容穿紧身黑衣服。</p></blockquote><blockquote><p>First of all ,he wrote out a long list of all the foods.</p><p>首先，他开列了一张长长列了所有的食物的目录。</p><p>a，限定词定语，限定 list 为一个。</p><p>long，形容词定语，限定为长的list。</p><p>of all the foods ，of属格，限定为食物</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201105170800.png" alt="练习题"></p><blockquote><p>我喜欢课桌上那本英语书</p><p>主语：我。谓语：喜欢。宾语：英语书</p><p>the：定语形容那本书。English：定语形容词，形容book为英语书。on the table:定语介词短语，指桌子上的书。</p></blockquote><blockquote><p>他们正在研究一个关于贸易标准的复杂问题。</p><p>主语：他们。谓语：研究。宾语：问题、</p><p>a：定语限定为一个。complicated：定语形容词，复杂的。about trading standard：作定语 介词短语 关于贸易标准的。</p></blockquote><blockquote><p>我将告诉你们昨天老师给我讲的那个非常有趣的关于月亮的中国古代故事。</p><p>主谓宾补 句式</p><p>主语：我。谓语：将告诉。宾语：你们。补语：故事。</p><p>不加定语：I will tall you story.</p><p>a：定语限定为一个。very :定语 非常。interesting：定语有趣。old Chinese：定语作形容词，中国古老。</p><p>about the moon：介词短语作定语，关于月亮。my teacher told me yesterday：介词短语作定语，老师昨天告诉我。</p><p>that：定语从句。</p></blockquote><h2 id="状语-1"><a href="#状语-1" class="headerlink" title="状语"></a>状语</h2><h4 id="什么是状语？"><a href="#什么是状语？" class="headerlink" title="什么是状语？"></a>什么是状语？</h4><blockquote><p>状语：用来描述定制的细节特征的成分，汉语里常见的对应成，就是“…地”。</p><p>唱歌：</p><p>可以说：大声地唱歌，欢乐地唱歌，投入地唱歌，等等。表达时间、地点、方式的状语，也可以不带“地”字。</p><p>比如：在教室里唱歌，在三个星期的晚会上唱歌，用古典的方式唱歌。</p></blockquote><p>状语可以修饰除啦名词以外的任何词。</p><h4 id="什么语法成分能做状语？"><a href="#什么语法成分能做状语？" class="headerlink" title="什么语法成分能做状语？"></a>什么语法成分能做状语？</h4><p><strong>副词以及相当于副词的语法成分</strong></p><p>副词在句子中处于副手的位置，就是辅助地位</p><blockquote><p>where,when,how–时间，地点，方式，成都</p><p>表示时间的，now ，just now，</p><p>表示地点的介词短语，比如 in the house</p></blockquote><h5 id="小状语（单独的副词）"><a href="#小状语（单独的副词）" class="headerlink" title="小状语（单独的副词）"></a>小状语（单独的副词）</h5><blockquote><p>​    放在其所修饰的词语之前：修饰动词时，放在动词之前。修饰其他成分时，放在其他成分之气那。</p><p>如果需要小状语可以放在句子中的任何位置。</p></blockquote><p>we are <strong>now</strong> living in a beautiful new house in the country.</p><blockquote><p>now：副词（小状语） 修饰living 表示现在生活在。</p><p>我们<strong>现在</strong>住在先将的一栋漂亮的新住宅里。</p></blockquote><p>Letters will cost a little more, but they will <strong>certainly</strong> travel faster.</p><blockquote><p>certainly：小状语 ，表示当然。</p><p>这样会稍微花点钱，但是肯定是快得多了。</p></blockquote><h5 id="大状语"><a href="#大状语" class="headerlink" title="大状语"></a>大状语</h5><blockquote><p>指 （两个及以上单词构成的状语，如介词短语，不定式短语，状语从句），放在整个句子的两头。放在开头时，一半要加上逗号。</p></blockquote><p>On Wednesday evening, We went to the Town Hall.</p><blockquote><p>星期三的晚上，我们去了市政厅。</p><p>其中 On Wednesday evening, 可以放在开头和结尾。</p><p>to the Town Hall：不定式短语</p></blockquote><p>I was having dinner at a restaurant when Tony Steele came in.</p><blockquote><p>我正在一家餐馆吃饭，托尼.斯蒂尔走了进来。</p><p>at a restaurant ：状语</p></blockquote><h3 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h3><p>①句中同时出现几个时间或者地点状语时，从小打到。</p><blockquote><p>We landed in American at 8 o’ clock on June 15th，2012.</p><p>我们2012年6月15日八点在美国着陆。</p><p>We live at number 35.South Renmin Road，Chengdu.</p><p>我们住在成都市人民南路35号。</p></blockquote><p>②句子后面出现多种状语时，顺序是方式–地点–时间。</p><blockquote><p>He put his milk bottles carefully on the doorstep every morning.</p><p>他每天早上小心地把牛奶拼放在门口的台阶上。</p></blockquote><h2 id="同位语"><a href="#同位语" class="headerlink" title="同位语"></a>同位语</h2><blockquote><p>同位语：句子中指代同一事务的两个词、短语或从句，称同为关系。</p></blockquote><p>My sister，Helen Wilson，will travel with me.</p><blockquote><p>句中 My sister 和 Helen Wilson指的是同一个人，它们是同为成分，后一成分通常叫前一成分的同为语。</p></blockquote><p>英语里的同位语，不属于单独的七大句子成分，而是和英语里边的名词成分（主语，宾语，表语）成冰并列关系，相当于对该名词进一步的解释说明。名词或任何相当名词的成分，均可作同位语。</p><h5 id="练习题-5"><a href="#练习题-5" class="headerlink" title="练习题"></a>练习题</h5><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201105220614.png" alt=""></p><p>My English teacher ，Mr. Brent Peter, is a Canadian.</p><blockquote><p>My English teacher 同 Mr.Brent Peter 为同位语状态</p></blockquote><p>Yesterday I met Tom,a friend of my brother’s</p><blockquote><p>Tom 与 friend of my brother’s 同位语状态</p></blockquote><p>We Chinese people are brave and hardworking.</p><blockquote><p>We 同 Chinese people 是同位语状态。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> EC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVC、MVP、MVVM</title>
      <link href="/2020/10/28/MVC%E3%80%81MVP%E3%80%81MVVM/"/>
      <url>/2020/10/28/MVC%E3%80%81MVP%E3%80%81MVVM/</url>
      
        <content type="html"><![CDATA[<h1 id="MVC-MVP-MVVM-图示"><a href="#MVC-MVP-MVVM-图示" class="headerlink" title="MVC MVP MVVM 图示"></a>MVC MVP MVVM 图示</h1><h2 id="MVC（Model、View、Controller）"><a href="#MVC（Model、View、Controller）" class="headerlink" title="MVC（Model、View、Controller）"></a>MVC（Model、View、Controller）</h2><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201028113524.png" alt=""></p><blockquote><ul><li>视图（View）：用户界面</li><li>控制器（Controller）：业务逻辑</li><li>模型（Model）：数据保存</li></ul></blockquote><h5 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h5><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201028113611.png" alt=""></p><blockquote><ol><li>View 传送指令到 Controller</li><li>Controller 完成业务逻辑后，要求 Model 改变状态</li><li>Model 将新的数据发送到 View，用户得到反馈</li></ol></blockquote><p><strong>通信都是单向的</strong></p><h2 id="互动模式"><a href="#互动模式" class="headerlink" title="互动模式"></a>互动模式</h2><blockquote><p><strong>互动模式</strong>（models of interaction），指使用<a href="https://zh.wikipedia.org/wiki/電腦" target="_blank" rel="noopener">电脑</a>时<a href="https://zh.wikipedia.org/wiki/人機互動" target="_blank" rel="noopener">人机互动</a>的界面。好的界面应该是能够有效地让互动顺利进行。互动系统是要让使用者可以在已存在的应用范围中完成他们的目的。系统使用的语言是核语言（core language），使用者使用的语言是任务语言（task language）。</p><p>摘自<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E5%8B%95%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">维基百科</a></p></blockquote><p>接受用户指令时，MVC可分为两种模式。<strong>一种是通过View接受指令</strong>，<strong>传递给Controller。</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201028114024.png" alt=""></p><p><strong>另一种是直接通过controller接受指令。</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201028114109.png" alt=""></p><h2 id="MVP（Model、View、Presenter）"><a href="#MVP（Model、View、Presenter）" class="headerlink" title="MVP（Model、View、Presenter）"></a>MVP（Model、View、Presenter）</h2><p>MVP 模式将 Controller 改名为 <strong>Presenter</strong>，<strong>同时改变了通信方向</strong>。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015020109.png" alt=""></p><blockquote><ol><li><p>各部分之间的通信，是双向的。</p></li><li><p>View 与 Model 不发生联系，都通过 Presenter 传递。</p></li><li><p>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</p></li></ol></blockquote><h2 id="MVVM（Model、View、ViewModel）"><a href="#MVVM（Model、View、ViewModel）" class="headerlink" title="MVVM（Model、View、ViewModel）"></a>MVVM（Model、View、ViewModel）</h2><p>MVVM 模式将 <strong>Presenter</strong> 改名为 <strong>ViewModel</strong>。</p><p>唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。</p><p><strong>引用：</strong></p><p><a href="https://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">MVC，MVP 和 MVVM 的图示</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin 协程</title>
      <link href="/2020/10/14/Kotlin-%E5%8D%8F%E7%A8%8B/"/>
      <url>/2020/10/14/Kotlin-%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h1><blockquote><p><strong>用同步的方式写异步的代码</strong></p></blockquote><p>【协程 Coroutines】 源于Simula 和 Modula-2语言，术语来自于 1958 年的 <strong>Melvin Edward Conway</strong> 发明并且拥有构建汇编程序，说明 <strong>协程是一种编程思想</strong>， 并不局限于特定的语言。</p><h5 id="线程和协程的关系"><a href="#线程和协程的关系" class="headerlink" title="线程和协程的关系"></a>线程和协程的关系</h5><p>从 Android 开发者的角度去理解它们的关系：</p><ul><li>Android中我们所有的代码都跑在线程中的，<strong>而线程是跑在进程中的</strong>。</li><li><strong>协程没有直接和操作系统关联</strong>，它也是<strong>跑在线程中的</strong>，可以是单线程，也可以是多线程。</li><li>单线程中的协程总的<strong>执行时间</strong>并不会比不用协程少。</li><li>Android中，如果在主线程中进行网络访问，会抛出 <strong>NetworkOnMainThreadException</strong>，对于在主线程上的协程也不例外，所以在这种使用场景中也是要切换线程的。</li></ul><h4 id="协程的应用场景之一-线程控制"><a href="#协程的应用场景之一-线程控制" class="headerlink" title="协程的应用场景之一 线程控制"></a>协程的应用场景之一 线程控制</h4><blockquote><p>协程可以让我们在写<strong>代码时不用更多的关注多线程同时更方便的写出并发操作</strong>。</p></blockquote><p><strong>场景</strong></p><p>在Java中实现并发操作通常需要开启 Thread：</p><pre><code class="java">new Thread(new Runnable() {    @Override    public void run() {        ...    }}).start();</code></pre><p>Kotlin中</p><pre><code class="kotlin">Thread({    ...}).start()</code></pre><p><strong>Kotlin和Java使用线程同样存在的问题：</strong></p><ul><li>线程什么时候执行结束</li><li>线程间如何相互通信</li><li>多线程的管理</li></ul><p>可以用Java控制线程 Executor线程池来进行<strong>线程管理</strong>：</p><pre><code class="kotlin">val executor = Executors.newCachedThreadPool()executor.execute({    ...})</code></pre><p>用Android的<strong>AsyncTask</strong>来<strong>解决线程之间的通讯</strong></p><pre><code class="kotlin">object : AsyncTask&lt;T0, T1, T2&gt; {     override fun doInBackground(vararg args: T0): String { ... }    override fun onProgressUpdate(vararg args: T1) { ... }    override fun onPostExecute(t3: T3) { ... }}</code></pre><p>使用<strong>AsyncTask</strong>进行<strong>线程之间</strong>的<strong>通讯</strong>带来的<strong>缺点</strong>（<strong>AsyncTask</strong>是<strong>Android</strong>对<strong>线程池</strong>Executor的<strong>封装</strong>）：</p><ul><li>需要处理多个回调，容易陷入【回调地狱】。</li><li>将业务强行拆分到前台、中间更新、后台三个函数。</li></ul><p>使用 RxJava和协程都可以很好的解决上述的问题。</p><h5 id="例子-使用协程进行网络访问将请求到的数据显示到对应的控件上："><a href="#例子-使用协程进行网络访问将请求到的数据显示到对应的控件上：" class="headerlink" title="例子 使用协程进行网络访问将请求到的数据显示到对应的控件上："></a>例子 使用协程进行网络访问将请求到的数据显示到对应的控件上：</h5><pre><code class="kotlin">launch({    val user = api.getUser() // 👈 网络请求（IO 线程）    nameTv.text = user.name  // 👈 更新 UI（主线程）})</code></pre><p>无需关心 <strong>launch</strong> 它<strong>不是</strong>一个<strong>顶层函数</strong>，只需要关系它的业务逻辑：</p><p>launch <strong>函数</strong>加上实现在 {} 中的<strong>具体逻辑构成</strong>了<strong>协程</strong>。</p><p>通常我们进行网络请求，会传一个callback，或者在IO线程里进行阻塞式的同步调用，而在这段代码中，上下两个语句分别工作在两个线程里，并且写法上和普通单线程代码是一样的。</p><p>这里的 api.getUser是一个挂起函数，所以能够保证nameTv.text的正确赋值，这就涉及到了协程中最著名的【非阻塞式挂起】了。</p><h1 id="协程好在哪里"><a href="#协程好在哪里" class="headerlink" title="协程好在哪里"></a>协程好在哪里</h1><h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><h4 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h4><p><strong>闭包</strong>并<strong>不</strong>是<strong>kotlin</strong>中提出的新概念，在Java8中就已经支持。</p><p>以Thread为例，看看什么是闭包：</p><pre><code class="kotlin">// 创建一个 Thread 的完整写法Thread(object : Runnable {    override fun run() {        ...    }})// 满足 SAM，先简化为Thread({    ...})// 使用闭包，再简化为Thread {    ...}</code></pre><p>语法糖：当函数的最后一个参数是lambda表达式时，可以将<strong>lambda</strong>写在<strong>括号外</strong>。这就是它的<strong>闭包原则</strong>。</p><h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><p>需要一个类型为 Runnable 的参数，而 Runnable 是一个接口，且只定义了一个函数 run，这种情况满足了 Kotlin 的SAM，可以转换成一个传递的 lambda表达式（第二段），以为闭包原则直接写成 Thread{…}（第三段）。</p><p>通过<strong>闭包简化 launch 函数</strong></p><pre><code class="kotlin">launch {    ...}</code></pre><h2 id="基本使用协程"><a href="#基本使用协程" class="headerlink" title="基本使用协程"></a>基本使用协程</h2><p>说过<strong>launch函数不是顶层函数</strong> 并不能直接使用，我们通过下列方法来创建协程：</p><pre><code class="kotlin">// 方法一，使用 runBlocking 顶层函数runBlocking {    getImage(imageId)}// 方法二，使用 GlobalScope 单例对象//            👇 可以直接调用 launch 开启协程GlobalScope.launch {    getImage(imageId)}// 方法三，自行通过 CoroutineContext 创建一个 CoroutineScope 对象//                                    👇 需要一个类型为 CoroutineContext 的参数val coroutineScope = CoroutineScope(context)coroutineScope.launch {    getImage(imageId)}</code></pre><p>方法①，多用于单元测试，业务开发不会用到它，因为它是线程阻塞的。</p><p>方法②，在Android中不推荐这种用法，因为它的生命周期会和app一直，且不能够取消。和使用runBlocking不同它不会阻塞线程。</p><p>方法三，<strong>推荐用法</strong>，通过context参数去管理和控制协程的生命周期（这里的context和Android里的不是同一种东西，更像是一种概念，会有Android平台的封装配合使用）</p><p>其中 <strong>GlobaScope</strong>与<strong>CoroutineScope</strong> 的更多内容后面的文章再说。</p><p>协程<strong>最常用</strong>的<strong>功能</strong>是<strong>并发</strong>，而并发最常用的场景是多线程。可以使用<strong>Dispatchers</strong>.<strong>IO</strong>参数把<strong>任务切换到IO线程执行</strong>：</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.IO) {    ...}</code></pre><p>使用 <strong>Dispatchers.Main</strong> 参数切换到主线程：</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.Main) {    ...}</code></pre><p>所以【什么是协程】中说到的异步请求的完整例子是这样的：</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.Main) {   // 在主线程开启协程    val user = api.getUser() // IO 线程执行网络请求    nameTv.text = user.name  // 主线程更新 UI}</code></pre><p>在Java中回调式的写法是这样的：</p><pre><code class="kotlin">api.getUser(new Callback&lt;User&gt;() {    @Override    public void success(User user) {        runOnUiThread(new Runnable() {            @Override            public void run() {                nameTv.setText(user.name);            }        })    }    @Override    public void failure(Exception e) {        ...    }});</code></pre><h2 id="更为麻烦的并发场景"><a href="#更为麻烦的并发场景" class="headerlink" title="更为麻烦的并发场景"></a>更为麻烦的并发场景</h2><p>对于回调式的写法，如果并发场景再复杂一点，嵌套的可能够多。如果使用协程，多层网络请求。</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.Main) {       // 开始协程：主线程    val token = api.getToken()                  // 网络请求：IO 线程    val user = api.getUser(token)               // 网络请求：IO 线程    nameTv.text = user.name                     // 更新 UI：主线程}</code></pre><p>如果进行多个<strong>网络请求</strong>等待完成后<strong>再刷新UI</strong>。</p><pre><code class="kotlin">api.getAvatar(user, callback)api.getCompanyLogo(user, callback)</code></pre><p>如果使用回调式写法，我们可能会选择妥协，则使用先后请求代替同时请求。</p><pre><code class="kotlin">api.getAvatar(user) { avatar -&gt;    api.getCompanyLogo(user) { logo -&gt;        show(merge(avatar, logo))    }}</code></pre><p>使用窗帘方式去实现可能会导致等待时长了一倍，也相差了一倍的性能。</p><h5 id="协程并行请求网络"><a href="#协程并行请求网络" class="headerlink" title="协程并行请求网络"></a>协程并行请求网络</h5><p>使用协程可以直接并行请求上下两行，最后把结果合并即可：</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.Main) {    //            👇  async 函数之后再讲    val avatar = async { api.getAvatar(user) }    // 获取用户头像    val logo = async { api.getCompanyLogo(user) } // 获取用户所在公司的 logo    val merged = suspendingMerge(avatar, logo)    // 合并结果    //                  👆    show(merged) // 更新 UI}</code></pre><p>即便是比较复杂的并行网络请求，也可以使用并行写出结构清晰的代码。<strong>suspendingMerge</strong> 并不是协程API提供的方法，而是自定义挂起的结果合并方法。</p><h5 id="协程的优势"><a href="#协程的优势" class="headerlink" title="协程的优势"></a>协程的优势</h5><p>让复杂的并发代码，变得简单且清晰是协程的优势。</p><h1 id="协程如何在项目中使用"><a href="#协程如何在项目中使用" class="headerlink" title="协程如何在项目中使用"></a>协程如何在项目中使用</h1><h2 id="在项目中配置对Kotlin协程的支持"><a href="#在项目中配置对Kotlin协程的支持" class="headerlink" title="在项目中配置对Kotlin协程的支持"></a>在项目中配置对Kotlin协程的支持</h2><p>使用协程前，需要在 build.gradle 文件中增加 Kotlin 协程的依赖：</p><ul><li>项目目录下</li></ul><pre><code class="kotlin">buildscript {    ...    // 👇    ext.kotlin_coroutines = &#39;1.3.1&#39;    ...}</code></pre><ul><li>Module 目录下：</li></ul><pre><code class="kotlin">dependencies {    ...    //                                       👇 依赖协程核心库    implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:$kotlin_coroutines&quot;    //                                       👇 依赖当前平台所对应的平台库    implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:$kotlin_coroutines&quot;    ...}</code></pre><p>Kotlin 协程以官方扩展库的形式进行支持。其中【核心库】和【平台库】的版本应该保持一致。</p><ul><li><strong>核心库</strong>为协程的公共API部分。为拉在各个平台统一接口。</li><li><strong>平台库</strong>主要为协程在具体平台的具体实现方式。原因：多线程在各个平台的实现方式不同。</li></ul><h2 id="开始使用协程"><a href="#开始使用协程" class="headerlink" title="开始使用协程"></a>开始使用协程</h2><p><strong>协程最简单的使用</strong>。通过<strong>launch</strong>函数实现线程切换的功能：</p><pre><code class="kotlin">//               👇coroutineScope.launch(Dispatchers.IO) {    ...}</code></pre><h5 id="代码中协程的表现。"><a href="#代码中协程的表现。" class="headerlink" title="代码中协程的表现。"></a><strong>代码中协程的表现。</strong></h5><p><strong>launch</strong> 函数：我要创建协程，并在指定的线程中运行它。被创建的【协程】是谁？ 就是你传给 launch的代码，这段代码叫【协程】。</p><p>当你要切换线程或指定线程时。<strong>要在后台执行任务？</strong></p><pre><code class="kotlin">launch(Dispatchers.IO) {    val image = getImage(imageId)}</code></pre><p><strong>切换到前台刷新界面？</strong></p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.IO) {    val image = getImage(imageId)    launch(Dispatchers.Main) {        avatarIv.setImageBitmap(image)    }}</code></pre><p>发生了嵌套的代码。</p><h5 id="避免嵌套的样子使用协程"><a href="#避免嵌套的样子使用协程" class="headerlink" title="避免嵌套的样子使用协程"></a>避免嵌套的样子使用协程</h5><p>单单使用协程并不会比线程做更多的事情。使用更实用的函数：<strong>withContext</strong>。指定切换线程，并且在执行完内部逻辑后，自动线程切回执行。上述代码使用 withContext：</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.Main) {      // 👈 在 UI 线程开始    val image = withContext(Dispatchers.IO) {  // 👈 切换到 IO 线程，并在执行完成后切回 UI 线程        getImage(imageId)                      // 👈 将会运行在 IO 线程    }    avatarIv.setImageBitmap(image)             // 👈 回到 UI 线程更新 UI} </code></pre><h5 id="比较两种写法来体现-withContext的优势"><a href="#比较两种写法来体现-withContext的优势" class="headerlink" title="比较两种写法来体现 withContext的优势"></a>比较两种写法来体现 withContext的优势</h5><p>当要频繁切换线程时。通过下属代码对比：</p><pre><code class="kotlin">// 第一种写法coroutineScope.launch(Dispatchers.IO) {    ...    launch(Dispatchers.Main){        ...        launch(Dispatchers.IO) {            ...            launch(Dispatchers.Main) {                ...            }        }    }}// 通过第二种写法来实现相同的逻辑coroutineScope.launch(Dispatchers.Main) {    ...    withContext(Dispatchers.IO) {        ...    }    ...    withContext(Dispatchers.IO) {        ...    }    ...}</code></pre><p><strong>优势：</strong></p><p>由于它可以“来回切回来”消除了并发代码在协作时的嵌套。消除了嵌套关系，还可以将 <strong>withContext</strong> 放在单独的函数里：</p><pre><code class="kotlin">launch(Dispatchers.Main) {              // 👈 在 UI 线程开始    val image = getImage(imageId)    avatarIv.setImageBitmap(image)     // 👈 执行结束后，自动切换回 UI 线程}//                               👇fun getImage(imageId: Int) = withContext(Dispatchers.IO) {    ...}</code></pre><p>实现了【同步的方式写异步的代码】。</p><pre><code class="kotlin">launch(Dispatchers.Main) {              // 👈 在 UI 线程开始    val image = getImage(imageId)    avatarIv.setImageBitmap(image)     // 👈 执行结束后，自动切换回 UI 线程}//                               👇fun getImage(imageId: Int) = withContext(Dispatchers.IO) {    ...}</code></pre><p><strong>withContext 单独放在函数中要注意那些</strong></p><pre><code class="kotlin">fun getImage(imageId: Int) = withContext(Dispatchers.IO) {    // IDE 报错 Suspend function&#39;withContext&#39; should be called only from a coroutine or another suspend funcion}</code></pre><p><strong>需要在 suspend函数中调用</strong>。（<strong>withContext</strong> 是<strong>一个 suspend</strong> 函数，所以需要在<strong>协程</strong>或者<strong>suspend函数</strong>中调用。）</p><h2 id="什么是-suspend-函数"><a href="#什么是-suspend-函数" class="headerlink" title="什么是 suspend 函数"></a>什么是 suspend 函数</h2><p><strong>suspend</strong> 函数是<strong>kotlin协程</strong>最核心的关键字。中文意思为【暂停】、【可挂起】。</p><p>解释：</p><blockquote><p>代码执行到 <strong>suspend 函数</strong>的时候会【<strong>挂起</strong>】，并且这个<strong>【挂起】</strong>是<strong>非阻塞式</strong>的，不会阻塞当前线程。</p></blockquote><p>修改上述代码让它可以执行：</p><pre><code class="kotlin">//👇suspend fun getImage(imageId: Int) = withContext(Dispatchers.IO) {    ...}</code></pre><p>到底什么是 suspend ，什么是 【非阻塞】，如何【挂起】。下篇。</p><h1 id="【挂起的本质】"><a href="#【挂起的本质】" class="headerlink" title="【挂起的本质】"></a>【挂起的本质】</h1><p>协程中挂起的对象是什么？     <strong>挂起的对象是协程。</strong></p><p>协程是什么？</p><blockquote><p>启动一个协程可以使用 <strong>launch 或者 async 函数</strong>，协程就是<strong>这两个函数中闭包的代码块</strong>。<strong>launch，async 或者其他函数创建的协程，</strong>在执行到某个 suspend函数时，这个协程会被 【<strong>suspend</strong>】挂起。</p></blockquote><p>从哪里挂起？</p><blockquote><p>在当前线程挂起。就是说<strong>当前协程</strong>在执行的线程中脱离。注意 它只是脱离了，当前线程不再去管理这个协程要求做什么。</p></blockquote><p><strong>当线程执行到协程的suspend函数的时候，暂时不再执行协程中的代码了。</strong></p><p>分开来看，互相脱离的线程和协程接下来将发生什么事情。</p><h4 id="线程："><a href="#线程：" class="headerlink" title="线程："></a>线程：</h4><p>协程的代码块中，<strong>线程执行到了suspend函数这里的时候，就暂时不再执行剩余的协程代码，跳出协程的代码块。</strong></p><p>那线程接下来会做什么？</p><p>例如它是后台线程：</p><ul><li>无事可做，被系统回收</li><li>继续执行别的后台任务</li></ul><p>同Java线程池用到线程在工作结束后的完全一样：回收或者再利用。</p><p>如果是个Android的主线程，那么它会以一秒六十次的界面刷新任务。</p><p>常见的场景是，获取图片，显示出来：</p><pre><code class="kotlin">// 主线程中GlobalScope.launch(Dispatchers.Main) {  val image = suspendingGetImage(imageId)  // 获取图片  avatarIv.setImageBitmap(image)           // 显示出来}suspend fun suspendingGetImage(id: String) = withContext(Dispatchers.IO) {  ...}</code></pre><p>在主线程的协程，<strong>它实质上会往你的主线程 post 一个 Runnable，这个 Runnable 就是你的协程代码：</strong></p><pre><code class="kotlin">handler.post {  val image = suspendingGetImage(imageId)  avatarIv.setImageBitmap(image)}</code></pre><p>协程被挂起时，<strong>主线程的 post 的Runnable 提前结束，然后继续执行它界面的刷新任务。</strong></p><h4 id="协程："><a href="#协程：" class="headerlink" title="协程："></a>协程：</h4><p>线程的代码在到达 <strong>suspend</strong>函数时会被掐断，<strong>协程会从这个 suspend 函数开始继续往下执行，不过是在指定的线程</strong>。</p><p>谁指定的？</p><blockquote><p>suspend 函数指定的， 比如我们这个例子中， 函数内部的withContext传入的Dispatchers.IO所指定的IO线程。</p></blockquote><p><strong>Dispatchers 调度器，限制协程在特定的线程执行，或者分派的一个线程池，或者让它不受限制的运行。</strong></p><p>常用的 Dispatchers，共有那些：</p><ul><li><strong>Dispatchers.Main</strong>:Android的主线程</li><li><strong>DIspatchers.IO</strong>:针对磁盘和网络IO进行了优化，适合IO密集型的任务，例如：读写文件，操作数据库以及网络请求</li><li><strong>Dispatchers.Detault</strong>:适合GPU密集型任务，例如计算。</li></ul><p>协程从 <strong>suspend</strong> 函数开始脱离启动它的线程，继续执行在 <strong>Dispatchers</strong> 所指定的IO线程。</p><p>在 suspend 函数执行完成之后，协程为我们：<strong>自动将线程切回来</strong></p><p><strong>切回？什么意思？</strong></p><p>协程原本是在 <strong>主线程中运动的</strong>，在代码执到 <strong>suspend</strong> 函数的时候，发生线程切换，根据 <strong>Dispatchers</strong> 切换到了IO线程；</p><p>【<strong>切回</strong>】是协程会棒我再 post 一个 Runnable，让剩下的代码继续回到主线程去执行。</p><h4 id="本质："><a href="#本质：" class="headerlink" title="本质："></a>本质：</h4><p>协程再执行到标记有suspend标记的函数时，会被suspend也就是挂起，而所谓的挂起，就是切线程；不同在于，<strong>挂起函数在执行完成之后，协程会重新切回它的线程。</strong> 再简单来说：<strong>kotlin 中挂起，就是一个稍后会被自动切回的线程调度操作。</strong></p><blockquote><p>【切回】动作，在kotlin里叫做 resume，</p></blockquote><p>函数挂起后是需要恢复的。</p><p>而恢复这个功能是协程的，如果不在协程里调用，恢复这个功能是没法实现的，所以也就回答了这个问题：为什么挂起函数必须在协程或者另一个挂起函数中调用。</p><h1 id="如何挂起的？"><a href="#如何挂起的？" class="headerlink" title="如何挂起的？"></a>如何挂起的？</h1><p>【<strong>挂起</strong>】是如何做到的。</p><p>定义的任意函数：</p><pre><code class="kotlin">suspend fun suspendingPrint() {  println(&quot;Thread: ${Thread.currentThread().name}&quot;)}I/System.out: Thread: main</code></pre><p>输出结果还是为主线程。</p><p>为何没有切换线程了？因为它并不知道往哪里切，需要我们告诉它。</p><p>对比之前例子中的 suspendingGetImage函数代码：</p><pre><code class="kotlin">//                                               👇suspend fun suspendingGetImage(id: String) = withContext(Dispatchers.IO) {  ...}</code></pre><p>不同之处在于 <strong>withContext</strong> 函数</p><p><strong>withContext</strong>源码可知，<strong>它本身就是一个挂起函数，它接受一个Dispatcher 函数，依赖这个Dispatcher 函数的指示，你的协程被挂起，然后切换到别的线程。</strong></p><p>所以suspend，并不能起到挂起函数的作用。</p><p>而真正挂起协程的，kotlin协程框架帮助我们做的。</p><p>加上 suspend 关键词是不行的，还需要直接或者间接的调用到 kotlin 协程框架自带的 <strong>suspend</strong> 函数才行。</p><h1 id="suspend-的意义？"><a href="#suspend-的意义？" class="headerlink" title="suspend 的意义？"></a>suspend 的意义？</h1><p>这个关键词最重要的作用就是<strong>提醒</strong>。</p><p>提醒你这个函数是一个挂起操作，<strong>提醒它是个耗时函数，请在协程你调用它。</strong></p><pre><code class="kotlin">// 👇 redundant suspend modifiersuspend fun suspendingPrint() {  println(&quot;Thread: ${Thread.currentThread().name}&quot;)}</code></pre><p>如果你创建使用 <strong>suspend</strong> 函数但是它内部并没有包含真正的挂起逻辑时，<strong>编译器会给你提示</strong>：<strong>redundant suspend modigier</strong>，这个 <strong>suspend</strong> 关键词是多余的。</p><p>因为这个函数并没有发生真正的挂起，此时 suspend 关键词只有一个效果：<strong>限制这个函数只能在协程里被调用，在非协程的代码中是无法调用的。</strong></p><p>创建suspend函数，要在它内部直接或者间接的调用 kotlin 自带的suspend 函数，这是你的 suspend才有意义。</p><h1 id="如何自定义-suspend-函数？"><a href="#如何自定义-suspend-函数？" class="headerlink" title="如何自定义 suspend 函数？"></a>如何自定义 suspend 函数？</h1><p>先分为两个问题:</p><ul><li>什么时候需要自定义 suspend 函数？</li><li>具体应该怎么写?</li></ul><h4 id="什么时候需要自定义-suspend-函数？"><a href="#什么时候需要自定义-suspend-函数？" class="headerlink" title="什么时候需要自定义 suspend 函数？"></a><strong>什么时候需要自定义 suspend 函数？</strong></h4><p>某个函数需要耗时操作时，那就可以把它写成 suspend 函数。这是原则。</p><p>耗时操作共分为两类：IO操作和CPU计算工作，比如文件的读写、网络交付、图片的模糊处理，都是耗时的。</p><h4 id="具体操作："><a href="#具体操作：" class="headerlink" title="具体操作："></a>具体操作：</h4><p>给函数加上 <strong>suspend</strong> 关键字，然后 <strong>withContext</strong> 把函数的内容包住就可以了。</p><p>使用 <strong>withContext</strong> 是因为它在挂起函数中功能最简单直接：把线程自动切走或者切回。</p><p>当然并不是只有 <strong>withContext</strong> 这个函数来辅助我们自定义<strong>suspend</strong> 函数，比如挂起函数 <strong>delay</strong>，它的作用是等待指定时间再往下执行代码。</p><p><strong>使用delay执行等待耗时操作</strong></p><pre><code class="kotlin">suspend fun suspendUntilDone() {  while (!done) {    delay(5)  }}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>什么是挂起？</p><blockquote><p>挂起，就是一个稍后会被指定切回来的线程调度操作。</p></blockquote><p>疑惑：</p><p>协程中的非阻塞式是什么</p><p>协程和RxJava在切换线程方面功能是一样的，都能写出避免嵌套回调的复杂并发代码，协程相比有什么优势，或者让开发者使用的理由？</p><h1 id="协程-Job"><a href="#协程-Job" class="headerlink" title="协程 Job"></a>协程 Job</h1><p>Job 是标准库中启动协程后返回的对象，代表着协程本次作业。我们可以判断协程是否接受，是否取消，是否完成并且额可以取消当前协程以及嵌套子协程。</p><p>基本上每启动一个协程就会产生对应的Job。</p><pre><code class="kotlin">coroutineScope.launch(Dispatchers.IO) {    ...}</code></pre><p>launch 返回的就是一个Job，它可以用来管理协程，一个Job中可以关联多个子Job，同时它也提供了通过外部传入parent的实现。</p><p>Job 管理协程，那么它提供了六种状态表示协程的运行状态。</p><ol><li><strong>New</strong>：创建</li><li><strong>Active</strong>：运行</li><li><strong>Completing</strong>：已经完成等待自身的子协程</li><li><strong>Completed</strong>：完成</li><li><strong>Cancelling</strong>：正在进行取消或者失败</li><li><strong>Cancelled</strong>：取消或失败</li></ol><p>这六种状态 <strong>Job</strong>对外暴露了三种状态，它们可以随时通过Job来获取</p><pre><code class="java">public val isActive: Booleanpublic val isCompleted: Booleanpublic val isCancelled: Boolean</code></pre><p>在你需要手动管理协程时，通过下面的方法来判断当前协程是否在运行。</p><pre><code class="kotlin">while (job.isActive) {// 协程运行中            }</code></pre><p>一般协程创建的时候就处在 <strong>Active</strong>状态，但是也有特殊情况。</p><p><strong>引用：</strong></p><p><a href="https://kaixue.io/kotlin-coroutines-1/" target="_blank" rel="noopener">Kotlin 的协程用力瞥一眼 - 学不会协程？很可能因为你看过的教程都是错的</a></p><p><a href="https://kaixue.io/kotlin-coroutines-2/" target="_blank" rel="noopener">Kotlin 协程的挂起好神奇好难懂？今天我把它的皮给扒了</a></p><p><a href="https://blog.csdn.net/qfanmingyiq/article/details/105547092" target="_blank" rel="noopener">Kotlin协程核心库分析-2 Job简述</a></p><p><a href="https://zhuanlan.zhihu.com/p/297543508" target="_blank" rel="noopener">Kotlin协程实现原理:CoroutineScope&amp;Job</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lifecycle 讲解</title>
      <link href="/2020/10/11/Lifecycle/"/>
      <url>/2020/10/11/Lifecycle/</url>
      
        <content type="html"><![CDATA[<h1 id="Lifecycle使用详解"><a href="#Lifecycle使用详解" class="headerlink" title="Lifecycle使用详解"></a>Lifecycle使用详解</h1><h2 id="Lifecycle可以做什么"><a href="#Lifecycle可以做什么" class="headerlink" title="Lifecycle可以做什么"></a>Lifecycle可以做什么</h2><p><strong>Lifecycle 是具有生命周期感知能力的组件，也就是说，在Activity或者Fragment的生命周期发生变动的是否得到通知</strong>。我们往往会在Activity的各种生命周期方法里执行特定的方法。</p><pre><code class="java">public class TestActivity extends AppCompatActivity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_test);    }    @Override    protected void onStart() {        super.onStart();        EventBus.getDefault().register(this);    }    @Override    protected void onDestroy() {        EventBus.getDefault().unregister(this);        super.onDestroy();    }}</code></pre><p>如果我们把很多这种需要跟生命周期相关的逻辑代码直接放在Activity的生命周期方法中，Activity会变的很难以维护的。通过使用Lifecycle，来避免这种情况。</p><h2 id="Lifecycle使用"><a href="#Lifecycle使用" class="headerlink" title="Lifecycle使用"></a>Lifecycle使用</h2><p>导入Lifecycle依赖</p><p>AndroidX:</p><pre><code class="groovy">implementation &quot;androidx.lifecycle:lifecycle-runtime:2.0.0&quot;</code></pre><h3 id="Lifecycler-实现机制"><a href="#Lifecycler-实现机制" class="headerlink" title="Lifecycler 实现机制"></a>Lifecycler 实现机制</h3><ol><li><strong>需要一个构建Lifecycle对象</strong>（通过一个实现了LifecycleOwner接口的对象 getLifecycle() 方法返回），这个对象就是一个被观察者，具有生命感知能力。</li><li><strong>构建一个LifecycleObserver对象，</strong>对指定的Lifecycle对象进行监听（<strong>观察者</strong>）</li><li>通过将Lifecyc对象的addObserver()方法，将Lifecycle对象和LifecycleObserver对象进行绑定。</li></ol><h3 id="继承AppCompatActivity"><a href="#继承AppCompatActivity" class="headerlink" title="继承AppCompatActivity"></a>继承AppCompatActivity</h3><p>创建 MyObserver.java 让它实现LifeyclerObserver 接口（<strong>LifecycleObserver接口是一个空接口，主要给注解处理器使用</strong>):</p><pre><code class="kotlin">/** *   by:Thecara home *   date:2020/10/11 */class MyObserver : LifecycleObserver {    // 使用注解 @OnLifecycleEvent() 该方法需要监听指定的生命周期事件    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)    fun connectListener() {        Log.d(&quot;MyObserver&quot;, &quot;ON_RESUME&quot;)    }    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)    fun disconnectListener() {        Log.d(&quot;MyObserver&quot;, &quot;ON_PAUSE&quot;)    }}</code></pre><p>可以看到，通过在方法上使用 <strong>@onLifecycleEvent</strong> 注解使得方法具有生命感知能力。<strong>括号里的参数，表明需要监听的是什么生命周期事件。</strong>Lifecycle 主要<strong>通过Event和State者两个枚举类来追踪关联组件的生命周期状态</strong>。具体的Event和State之间的转换关系，可以参考如下：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1692ebbac5daa896" alt=""></p><p>让Activity继承自AppCompatActivity，然后再OnCreate()方法中通过 <strong>getLifecycle().addObserver(new MyObserver())</strong> 完成<strong>Lifecycle</strong>和<strong>LifecycleObser</strong>的绑定:</p><pre><code class="kotlin">class MainActivity : AppCompatActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        // 绑定        lifecycle.addObserver(MyObserver())    }}</code></pre><p>通过切换后台观察状态。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-10-11-0.gif" alt="切换"></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-10-11-1.gif" alt="Log"></p><p>library 26.1.0 及之后的库中，<strong>AppCompatActivity的父类SupportActivity已经默认实现了LifecycleOwner接口，直接通过getLifecycle() 方法获得Lifecycle对象。</strong></p><p>之后通过 <strong>addObserver()</strong> 方法将Lifecycle 跟指定 LifecycleObserver 进行绑定。</p><p><strong>引用：</strong></p><p><a href="https://juejin.im/post/6844903784166998023" target="_blank" rel="noopener">Android生命周期组件Lifecycle使用详解</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Lifecycle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是BuildConfig</title>
      <link href="/2020/09/17/BuildConfig/"/>
      <url>/2020/09/17/BuildConfig/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-BuildConfig"><a href="#什么是-BuildConfig" class="headerlink" title="什么是 BuildConfig"></a>什么是 BuildConfig</h1><p><strong>在打包时自动生成的类。</strong>类似于R.class，生成后不能修改。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200917233605.png" alt="在项目中的位置"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Timber</title>
      <link href="/2020/09/17/Timber/"/>
      <url>/2020/09/17/Timber/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Timber"><a href="#使用-Timber" class="headerlink" title="使用 Timber"></a>使用 Timber</h1><ul><li>配置 timber</li></ul><pre><code class="groovy">implementation &#39;com.jakewharton.timber:timber:4.7.1&#39;</code></pre><ul><li><h5 id="准备Log输出的自定义格式"><a href="#准备Log输出的自定义格式" class="headerlink" title="准备Log输出的自定义格式"></a><strong>准备Log输出的自定义格式</strong></h5></li></ul><blockquote><p>可以直接在Application的onCreate()中调用<code>Timber.plant(new DebugTree())</code>实现Debug功能。但是功能有所欠缺，<strong>可以用来上传crash信息</strong>等。</p><p>ps：</p><p>Timber主要通过添加Tree实例来实现，添加Tree实例可以通过方法Timber.plant完成。</p><p>而使用DebugTree实现自动实例化</p></blockquote><ol><li>不会<strong>打印当前线程</strong></li><li>不会<strong>打印当前行号</strong></li></ol><p>自己创建一个继承类来实现这两个功能。</p><pre><code class="kotlin">class ThreadAwareDebugTree : Timber.DebugTree() {    //添加当前线程    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {        if (tag != null) {            val threadName = Thread.currentThread().name            tag != &quot;&lt;&quot; + threadName + &quot;&gt;&quot;        }        super.log(priority, tag, message, t)    }    // 添加行号    override fun createStackElementTag(element: StackTraceElement): String? {        return super.createStackElementTag(element) + &quot;Line(&quot; + element.lineNumber + &quot;)&quot;    }}</code></pre><p><strong>还有一个类在 release 版本时调用打印log信息</strong></p><blockquote><p>release 版本用来以一种跟踪日志的形式上报给 <strong>Bugly</strong>，它只会显示 w，e，wtf。</p></blockquote><pre><code class="kotlin">class ReleaseTree : ThreadAwareDebugTree() {    override fun isLoggable(tag: String?, priority: Int): Boolean {        return if (priority == Log.VERBOSE || priority == Log.DEBUG || priority == Log.INFO) {            false        } else true    }    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {        if (!isLoggable(tag, priority)) {            return        }        super.log(priority, tag, message, t)    }}</code></pre><ul><li>准备 Application</li></ul><pre><code class="kotlin">class TimberDemoApplication : Application() {    override fun onCreate() {        super.onCreate()        if (DEBUG)            Timber.plant(ThreadAwareDebugTree())    }}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200921111610.png" alt="添加Application"></p><ul><li>调用一个log</li></ul><pre><code class="kotlin">println(Timber.v(&quot;hello&quot;))</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200921112051.png" alt="通过自定义的类型输出了行号的信息"></p><h2 id="重写-Log-方法"><a href="#重写-Log-方法" class="headerlink" title="重写 Log 方法"></a>重写 Log 方法</h2><p><strong>参数</strong></p><blockquote><p>priority:Int 优先级</p><p>tag:String 打印时的标签</p><p>message:String 内容</p><p>t:Throwable 抛出的异常</p></blockquote><p>此方法可以用来根据发送来的 <strong>异常等信息</strong> 自定义接下来的动作。这些信息并不会被从log日志打印出来。</p><p><strong>调用</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201009123005.png" alt="调用log方法"></p><pre><code class="kotlin"> Timber.log(1, &quot;测试打印&quot;)</code></pre><h4 id="打印我们发送来的信息"><a href="#打印我们发送来的信息" class="headerlink" title="打印我们发送来的信息"></a>打印我们发送来的信息</h4><pre><code class="kotlin">class MyTimberFree : Timber.Tree() {    override fun log(priority: Int, tag: String?, message: String, t: Throwable?) {        super.log(priority, tag, message, t)        Timber.v(message)    }}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201009123216.png" alt="发送成功，我们可以根据这些信息上传到crash中。"></p><h1 id="为什么使用Timber"><a href="#为什么使用Timber" class="headerlink" title="为什么使用Timber"></a>为什么使用Timber</h1><ol><li><p>项目开发时，为了方便调试，需要输出log，但是发布后，log中包含很多项目信息，如果全部暴露可能会造成安全隐患，当完全删除也不利于后期调试，因此需要一个开关，关闭开关不能输出bug，打开开关则可以输出log。</p></li><li><p>每次需要打印 TAG</p></li><li><p>不会打印当前线程</p></li><li><p>不会打印当前行号</p></li></ol><p><a href="https://xiazdong.github.io/2017/05/17/Timber/" target="_blank" rel="noopener">Timber和Bugly使用入门</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Timber </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用gradle</title>
      <link href="/2020/09/09/%E4%BD%BF%E7%94%A8gradle/"/>
      <url>/2020/09/09/%E4%BD%BF%E7%94%A8gradle/</url>
      
        <content type="html"><![CDATA[<h1 id="创建-Gradle-项目"><a href="#创建-Gradle-项目" class="headerlink" title="创建 Gradle 项目"></a>创建 Gradle 项目</h1><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-9-9-0.gif" alt=""></p><p>👆 联网状态打开 IDEA</p><h1 id="项目结构介绍"><a href="#项目结构介绍" class="headerlink" title="项目结构介绍"></a>项目结构介绍</h1><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910110408.png" alt=""></p><p><strong>src/main/java</strong> 正式代码目录</p><p><strong>src/main/resources</strong> 正式配置文件目录</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910111041.png" alt=""></p><p><strong>src/test/java</strong> 放置单元测试代码目录</p><p><strong>src/test/resources</strong> 放置单元测试配置文件目录</p><p><strong>src/main/webapp</strong> 还有一个可放置的 web 目录（页面信息）</p><h4 id="src-build-gradle-文件"><a href="#src-build-gradle-文件" class="headerlink" title="src/build.gradle 文件"></a>src/build.gradle 文件</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910162235.png" alt=""></p><p><strong>plugins{}</strong></p><blockquote><p>指运行环境</p></blockquote><p><strong>repositories{}</strong></p><blockquote><p>mavenContral() 为中央仓库，在没有指定情况的下会直接从中央仓库下载 jar 包。</p></blockquote><p><strong>dependenciese{}</strong></p><blockquote><p>gradle工程所有的jar包的坐标都在dependencies属性内放置。</p><p>同时每个jar包的坐标都有三个基本元素构成，group，name，version 组成</p></blockquote><p><strong>group</strong>：多分为多段，第一段为 域，第二段公司名称。其中 org 为非盈利组织，con 为商业组织。例如：tomat：为 apache项目 groupid为org.apache。</p><p><strong>name</strong>：项目的全名称。</p><p><strong>version</strong>：版本号。</p><p><strong>testCompile</strong>：测试时所依赖的jar包，在dradle可由 implementation 代替。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910165023.png" alt=""></p><p>创建项目有提到 👆</p><h4 id="项目-build-gradle-文件"><a href="#项目-build-gradle-文件" class="headerlink" title="项目/build.gradle 文件"></a>项目/build.gradle 文件</h4><p><strong>buildscript{} 属性</strong></p><blockquote><p>gradle执行所需要的依赖，分别对应maven库和插件</p></blockquote><h1 id="通过-mevenCentral-引入-jar-包"><a href="#通过-mevenCentral-引入-jar-包" class="headerlink" title="通过 mevenCentral 引入 jar 包"></a>通过 <strong>mevenCentral</strong> 引入 jar 包</h1><p>使用 compile 添加 jar 包</p><blockquote><p>用来解析所需要的依赖在classpath中可用，并且将它们打包。</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-9-10-1.gif" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910180423.png" alt=""></p><p>依赖完成</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910182006.png" alt=""></p><p>在 用户的 user/用户名/.gradle/caches/modules-2/files-2.1 下有我们加载的 jar 包</p><h1 id="demo-引入一个spring包-并测试使用"><a href="#demo-引入一个spring包-并测试使用" class="headerlink" title="demo 引入一个spring包 并测试使用"></a>demo 引入一个spring包 并测试使用</h1><h3 id="在-mavenRepository-中引入jar-包"><a href="#在-mavenRepository-中引入jar-包" class="headerlink" title="在 mavenRepository 中引入jar 包"></a>在 mavenRepository 中引入jar 包</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200911162643.png" alt=""></p><pre><code class="groovy">// https://mvnrepository.com/artifact/org.springframework/spring-contextcompile group: &#39;org.springframework&#39;, name: &#39;spring-context&#39;, version: &#39;5.2.8.RELEASE&#39;</code></pre><h3 id="引入后的依赖包位置查看"><a href="#引入后的依赖包位置查看" class="headerlink" title="引入后的依赖包位置查看"></a>引入后的依赖包位置查看</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200911162549.png" alt=""></p><h3 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h3><p><strong>创建 接口 ”AccountDao“</strong></p><p>位置 ”com.gradlelearn.dao“</p><pre><code class="java">public interface AccountDao {    public List findAll();}</code></pre><p>作为接口，查询方法</p><p><strong>创建 ”AccountDaoImpl“</strong></p><p>位置 ”com.gradlelearn.dao.impl“</p><pre><code class="java">public class AccountDaoImpl implements AccountDao {    @Override    public List findAll() {        System.out.println(&quot;test&quot;);        return null;    }}</code></pre><p>实现查询功能</p><h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><p><strong>创建 ”AccountTest“</strong></p><p>位置 test 文件下 ”com.gradle.test“</p><p><strong>ClassPathXmlApplicationContext</strong> 类型</p><blockquote><p>获得当前 bean 容器</p><p>创建对象 ApplicationContext 类型</p></blockquote><p><strong>applicationContext.getBean</strong> 方法</p><blockquote><p>从容器中获得当前 Dao</p></blockquote><pre><code class="java">public class AccountTest {    @Test    public void acccountTest() {        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);        AccountDao bean = applicationContext.getBean(AccountDao.class);        bean.findAll();    }}</code></pre><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200911164758.png" alt=""></p><h3 id="打包-jar-包"><a href="#打包-jar-包" class="headerlink" title="打包 jar 包"></a>打包 jar 包</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-9-11-0.gif" alt=""></p><p><strong>jar 包的位置</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200911165345.png" alt=""></p><h1 id="创建-web-工程-demo"><a href="#创建-web-工程-demo" class="headerlink" title="创建 web 工程 demo"></a>创建 web 工程 demo</h1><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h5 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h5><p>使用 ext 扩展块可以一次添加多个属性。</p><p>声明多个属性。添加了键值对的属性集合。</p><pre><code class="groovy">ext.versions = [minSdk:21,targetSdk:29]</code></pre><h5 id="apply-plugin"><a href="#apply-plugin" class="headerlink" title="apply plugin"></a>apply plugin</h5><p>此方式用来引入 <strong>Gradle 官方插件库</strong>。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915181918.png" alt=""></p><h5 id="apply-from"><a href="#apply-from" class="headerlink" title="apply from"></a>apply from</h5><p>引用本地资源</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915182720.png" alt=""></p><h2 id="android"><a href="#android" class="headerlink" title="android"></a>android</h2><p>这个闭包主要为了配置项目结构的各种属性。</p><h5 id="compileSdkVersion"><a href="#compileSdkVersion" class="headerlink" title="compileSdkVersion"></a>compileSdkVersion</h5><p>设置编译时用的Android版本</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915183321.png" alt=""></p><h2 id="defaultConfig-闭包"><a href="#defaultConfig-闭包" class="headerlink" title="defaultConfig 闭包"></a>defaultConfig 闭包</h2><p>默认闭包</p><h5 id="applicationId"><a href="#applicationId" class="headerlink" title="applicationId"></a>applicationId</h5><p>项目的包名</p><h5 id="minSdkVersion"><a href="#minSdkVersion" class="headerlink" title="minSdkVersion"></a>minSdkVersion</h5><p>最低兼容版本</p><h5 id="targetSdkVersion"><a href="#targetSdkVersion" class="headerlink" title="targetSdkVersion"></a>targetSdkVersion</h5><p>目标兼容版本</p><h5 id="versionCode"><a href="#versionCode" class="headerlink" title="versionCode"></a>versionCode</h5><p>项目版本号</p><h5 id="versionName"><a href="#versionName" class="headerlink" title="versionName"></a>versionName</h5><p>版本名称</p><h5 id="testInstrumentationRunner"><a href="#testInstrumentationRunner" class="headerlink" title="testInstrumentationRunner"></a>testInstrumentationRunner</h5><p>用来进行 AndroidJUnitRunner 进行单元测试</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915183913.png" alt="detailtConfig闭包"></p><h2 id="buildTypes-闭包"><a href="#buildTypes-闭包" class="headerlink" title="buildTypes 闭包"></a>buildTypes 闭包</h2><p>生成安装文件的主要配置，多数为两个子闭包，    一个debug闭包，<strong>用于指定生成测试版安装文件的配置</strong>，可忽略。一个release闭包，<strong>用于指定生成正式版的配置</strong>。两者配置参数大多一致，区别为<strong>默认属性配置不一样</strong>。</p><h5 id="minifyEnabled"><a href="#minifyEnabled" class="headerlink" title="minifyEnabled"></a>minifyEnabled</h5><p>是否对代码进行混淆</p><h5 id="proguardFiles"><a href="#proguardFiles" class="headerlink" title="proguardFiles"></a>proguardFiles</h5><p>指定混淆的规则文件</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915185118.png" alt=""></p><h2 id="dependencies闭包"><a href="#dependencies闭包" class="headerlink" title="dependencies闭包"></a>dependencies闭包</h2><p>定义了项目的依赖关系，三种依赖方式：<strong>本地依赖，库依赖，和远程依赖</strong>。</p><blockquote><p>自AndroidStudio3.0后 compile 引入库不再使用，而通过api和implementation，api完全等同于先前的 compile</p><p>，通过 api 引入 整个项目是可以使用当前的依赖库的。<strong>implementation 引入的库只有对应的 Module 使用</strong>。</p><p>在使用 compile时导致模块之间的耦合过高，不利于项目的拆解，<strong>通过 implementation做到降低耦合提高安全性</strong>。</p></blockquote><p>Module：指项目中创建的不同Module。</p><h5 id="implementation"><a href="#implementation" class="headerlink" title="implementation"></a>implementation</h5><p>远程依赖</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915190215.png" alt=""></p><h5 id="testImplementation-和-androidTestImplementation"><a href="#testImplementation-和-androidTestImplementation" class="headerlink" title="testImplementation 和 androidTestImplementation"></a>testImplementation 和 androidTestImplementation</h5><p>测试用依赖库</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915190143.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915190127.png" alt=""></p><h1 id="groovy-快速使用"><a href="#groovy-快速使用" class="headerlink" title="groovy 快速使用"></a>groovy 快速使用</h1><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-9-10-0.gif" alt=""></p><p>打开 idea 的 groovy 编辑器</p><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p><strong>groovy hellow word！</strong></p><pre><code class="groovy">println(&quot;hello world!&quot;);</code></pre><p>groovy 更类似于 java 语言。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910113424.png" alt=""></p><p><strong>groovy 可以省略末尾 “;”号</strong></p><pre><code class="groovy">println(&quot;hello world!&quot;)</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910112155.png" alt=""></p><p><strong>groovy 可以 省略括号</strong></p><pre><code class="groovy">println &quot;hello world!&quot;</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910120309.png" alt=""></p><p><strong>定义变量</strong></p><pre><code class="groovy">def x = 15println x</code></pre><p>def 修饰符是 <strong>弱类型</strong> 声明，groovy会自动根据情况来给变量赋予对应的类型。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910150342.png" alt=""></p><p><strong>定义集合</strong></p><pre><code class="groovy">def x = [&#39;x&#39;, &#39;f&#39;, &#39;c&#39;]x &lt;&lt; &#39;y&#39;println x</code></pre><p>定义集合：通过 “[]” 中括号声明</p><p>集合添加数据，”&lt;&lt;” 双小于号即可</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910151126.png" alt=""></p><p><strong>提取元素</strong></p><pre><code class="groovy">x.get(2)</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910151255.png" alt=""></p><p>提取元素下标为 2 的元素</p><h4 id="定义map"><a href="#定义map" class="headerlink" title="定义map"></a><strong>定义map</strong></h4><p><strong>声明map</strong></p><pre><code class="groovy">def m = [&#39;key1&#39;: &#39;value1&#39;]</code></pre><p>在初始化时必须要有初始化的值，用来对弱类型进行修改。</p><p><strong>添加键值对</strong></p><pre><code class="groovy">m.key2 = &quot;value2&quot;</code></pre><p>打印键值对</p><pre><code class="groovy">println m.get(&#39;key2&#39;)println m</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910152935.png" alt=""></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="groovy-中的闭包"><a href="#groovy-中的闭包" class="headerlink" title="groovy 中的闭包"></a>groovy 中的闭包</h3><p><strong>什么是闭包？</strong></p><p>groovy中的一个代码块。用于在<strong>gradle中把闭包当作参数使用</strong>。</p><p><strong>定义闭包和携带参数的闭包</strong></p><pre><code class="groovy">def b = {    println &quot;hello world!&quot;}</code></pre><pre><code class="groovy">def b = {   v-&gt; println &quot;hello world! $v&quot;}</code></pre><p>花括号 “{}” 即为闭包的样式。</p><p>v 表示一个变量，通过 “$v” 引用变量。</p><p><strong>闭包作为方法的参数，为闭包添加参数</strong></p><pre><code class="groovy">def method(Closure closure) {    closure()}</code></pre><pre><code class="groovy">def method(Closure closure) {    closure(&quot;arguments&quot;)}</code></pre><p>Closure：为闭包的类型，位于 “groovy.lang” 包下。</p><p>字符“arguments”作为参数传递给了闭包，<strong>在使用时将对应闭包添加到方法中即可</strong>。</p><p><strong>使用闭包</strong></p><pre><code class="groovy">method (b)</code></pre><p>method 为自己创建的方法。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200910155625.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> gradle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> gradle </tag>
            
            <tag> groovy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJava2 Android 中使用</title>
      <link href="/2020/08/21/Android-RxJava/"/>
      <url>/2020/08/21/Android-RxJava/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是RxJava"><a href="#什么是RxJava" class="headerlink" title="什么是RxJava"></a>什么是RxJava</h1><p>实现异步操作的库</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>RxJava 是基于<strong>事件流的、实现异步操作的库</strong></p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>实现异步操作</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><pre><code class="groovy">    implementation &quot;io.reactivex.rxjava2:rxjava:2.2.6&quot;    implementation &quot;io.reactivex.rxjava2:rxandroid:2.1.0&quot;</code></pre><h4 id="使用一次订阅并打印出来"><a href="#使用一次订阅并打印出来" class="headerlink" title="使用一次订阅并打印出来"></a>使用一次订阅并打印出来</h4><ul><li>需要 Observable.fromArray 方法</li></ul><blockquote><p>fromArray用来创建一个Observable（被观察者）对象，可以将一个数组转化为可被观察的序列并且将它的数据逐个发送。</p><p>返回值：Observable</p></blockquote><ul><li>需要 subscribe 方法</li></ul><blockquote><p>subscribe 只用于连接被观察者和观察者”“()”圆括号内为观察者”</p></blockquote><ul><li>需要 Consumber 类作为参数</li></ul><blockquote><p>当你只关心观察者的onNext方法时可以使用Consumer类</p></blockquote><ul><li>需要 Subscriber.onNext() 方法</li></ul><blockquote><p>被观察者执行Subscriber.onNext()方法时会在 观察者 订阅时复写该方法来进行发送数据</p></blockquote><p>启动它即可</p><pre><code class="kotlin">        Observable.fromArray(&quot;Ted&quot;, &quot;Ryan&quot;, &quot;Billy&quot;)            .subscribe { onNext -&gt; println(&quot;name: $onNext&quot;) </code></pre><p>观察者打印了字符</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200824012835.png" alt=""></p><p><a href="https://www.youtube.com/watch?v=v7drKJyxo10&list=PL8g0JDLEKun5cDCSkiLkZ1t4r0kE4j0sV" target="_blank" rel="noopener">Android Kotlin - RxJava Intro</a></p><h4 id="刷新一次界面控件"><a href="#刷新一次界面控件" class="headerlink" title="刷新一次界面控件"></a>刷新一次界面控件</h4><ul><li>需要 Obserbable.subscribeOn()</li></ul><blockquote><p>指定Observable（被观察者）自身在哪个调度器上执行</p></blockquote><ul><li>需要 Schedule() 线程控制器</li></ul><blockquote><p>作用：指定每一段代码在什么样的线程中执行</p></blockquote><ul><li>需要 filer() 过滤操作符号</li></ul><blockquote><p>作用：输出过滤条件后的结果项。</p></blockquote><ul><li>需要 Obserbable.observeOn() 方法</li></ul><blockquote><p>指定 Subscribe 所运行在的线程。或者事件消费的线程。</p><p>指定一个观察者在哪个调度器上观察这个Observable。</p><p><strong>observeOn()可以多次使用，可以随意变换线程</strong>。</p></blockquote><ul><li>使用 AndroidSchedulers.mainThread() 方法</li></ul><blockquote><p>切换至主线程</p></blockquote><pre><code class="kotlin">        Observable.fromArray(&quot;Ted&quot;, &quot;Ryan&quot;, &quot;Billy&quot;)            .subscribeOn(Schedulers.newThread())            .filter { item -&gt; item == &quot;Ted&quot; }            .observeOn(AndroidSchedulers.mainThread())            .subscribe { onNext -&gt; textView.text = onNext }</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200825112654.png" alt=""></p><h4 id="执行一次网络访问"><a href="#执行一次网络访问" class="headerlink" title="执行一次网络访问"></a>执行一次网络访问</h4><ul><li>使用 Observable.create() 方法</li></ul><blockquote><p>作用：创建一个被观察者。</p><p>可以通过泛型<String>指定发送数据的类型</p><p>参数：复写 ObservableOnSubscribe 类型，当被观察者被订阅时会执行 subscribe() 中的事件。</p></blockquote><ul><li>需要 onError() 方法</li></ul><blockquote><p>被观察者执行Subscriber.onError()方法时会在 观察者 订阅时复写该方法来进行发送数据</p><p>参数： 发送的泛型数据类型</p></blockquote><ul><li>需要 onComplate() 方法</li></ul><blockquote><p>被观察者执行Subscriber.onComplate()方法时会在 观察者 订阅时复写该方法来进行发送数据</p><p>参数： 发送的泛型数据类型</p></blockquote><p>创建 方法 getTextFromNetwork () </p><p>创建 Observable （被观察者）处理完成后发送事件，subscribeOn 让 subscribe 到一个新的线程中执行，observeOn 切换观察者的线程到主线程刷新UI，并不断接受被观察者发送来的事件。<strong>这是一个异步的操作。</strong></p><pre><code class="kotlin">    fun getTextFromNetwork() {        val task = Observable.create&lt;String&gt; { subscriber -&gt;            try {                subscriber.onNext(&quot;网络访问&quot;)            } catch (e: Exception) {                subscriber.onError(e)            }            subscriber.onComplete()        }        task.subscribeOn(Schedulers.newThread())        task.observeOn(AndroidSchedulers.mainThread())            .subscribe { onNext -&gt; textView.text = onNext }    }</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200825210344.png" alt=""></p><p>在调用 MainActivity </p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200825211048.png" alt=""></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="Observer-接口"><a href="#Observer-接口" class="headerlink" title="Observer 接口"></a>Observer 接口</h2><pre><code class="kotlin">        val observer = object: Observable&lt;String&gt;() {            //观察者接收事件前，默认最先调用复写 onSubscribe()            override fun subscribeActual(observer: Observer&lt;in String&gt;?) {                TODO(&quot;Not yet implemented&quot;)            }        }</code></pre><h2 id="Subscriber-接口"><a href="#Subscriber-接口" class="headerlink" title="Subscriber 接口"></a>Subscriber 接口</h2><p>Subscriber 接口对 Observer 接口进行了扩展</p><pre><code class="kotlin">        val subscribe= object : Subscriber&lt;String&gt;{            //被观察者调用 onSubscribe 时发送事件，观察者会调用此方法进行响应接受此事件            override fun onSubscribe(s: Subscription?) {                TODO(&quot;Not yet implemented&quot;)            }            //被观察者调用 onNext 时发送事件，观察者会调用此方法进行响应接受此事件            override fun onNext(t: String?) {                TODO(&quot;Not yet implemented&quot;)            }            //被观察者调用 onError 时发送事件，观察者会调用此方法进行响应接受此事件            override fun onError(t: Throwable?) {                TODO(&quot;Not yet implemented&quot;)            }            //被观察者调用 onComplete 时发送事件，观察者会调用此方法进行响应接受此事件            override fun onComplete() {                TODO(&quot;Not yet implemented&quot;)            }        }</code></pre><h2 id="Single与SingleObserver"><a href="#Single与SingleObserver" class="headerlink" title="Single与SingleObserver"></a>Single与SingleObserver</h2><p><strong>什么情况下使用 Single。</strong></p><p>如果你使用一个单一的连续事件流，既然只有一个onNext()事件，接着就触发onComplete或者onError，这样你使用Single。</p><p><strong>Single共包含那些</strong></p><p>一个正常处理成功的onSuccess，另一个处理失败的onError，当然它之发送一次信息，其中Single类似于Observable。</p><p><strong>被观察者</strong></p><pre><code class="kotlin">        val single: Single&lt;String&gt; = Single.create&lt;String&gt;(object : SingleOnSubscribe&lt;String&gt; {            override fun subscribe(emitter: SingleEmitter&lt;String&gt;) {                emitter.onSuccess(&quot;t&quot;)                emitter.onSuccess(&quot;c&quot;)                // 连续发送两次是不能成功的。            }        })</code></pre><p><strong>观察者</strong></p><pre><code class="kotlin">        single.subscribe(object : SingleObserver&lt;String&gt; {            // 在被观察者调用 onSubscribe 后，观察者回调到这里。            override fun onSubscribe(d: Disposable) {            }            // 在被观察者调用 onSuccess 后，观察者回调到这里。            override fun onSuccess(t: String) {                tv.text = t            }            // 在被观察者调用 onError 后，观察者回调到这里。            override fun onError(e: Throwable) {            }        })</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-10-10-0.gif" alt="并没有按照预期变成“c”"></p><p>所有 single只适合单次事件流。</p><h2 id="RxJava中关于-Disposable"><a href="#RxJava中关于-Disposable" class="headerlink" title="RxJava中关于 Disposable"></a>RxJava中关于 Disposable</h2><p>Disposable 类</p><ul><li><h5 id="dispose"><a href="#dispose" class="headerlink" title="dispose()"></a>dispose()</h5></li></ul><blockquote><p>主动解除订阅</p></blockquote><ul><li><h5 id="isDisposed"><a href="#isDisposed" class="headerlink" title="isDisposed()"></a>isDisposed()</h5></li></ul><blockquote><p>查询是否解除订阅 。（true 代表解除）</p></blockquote><h1 id="什么是同步"><a href="#什么是同步" class="headerlink" title="什么是同步"></a>什么是同步</h1><p>在执行功能前必须一件一件做完才能进行下一步。</p><h1 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h1><p>与同步是相对的，在我们执行完某个功能之后，我们并不需要立刻得到结果，我们可以正确的做其他的操作，这个功能可以在完成后通知或者回调告诉我们；</p><p>例如：后台下载的例子中，在执行下载功能后，我们无需关心它的下载过程，在它下载完毕之后通知我们就可以了。</p><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p><a href="https://www.runoob.com/design-pattern/observer-pattern.html" target="_blank" rel="noopener">观察者模式</a></p><p>当对象间存在一对多的关系时，则使用观察者模式（Observer Patterm）。    例如：当前对象被修改时这会通知依赖它的对象。观察者模式属于行为型模式。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图</strong>:定义对象之间的一种对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并且被自动更新。</p><p><strong>主要解决</strong>:一个对象状态改变给其他对象通知的问题，而且要考虑到易用性和低耦合，保证高度的协作。</p><p><strong>何时使用</strong>:一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象)都将得到通知，进行广播通知。</p><p>如何解决当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。</p><p><strong>如何解决</strong>：使用面向对象技术，可以将这种关系弱化。</p><p><strong>关键代码</strong>：在抽象类中有一个ArrayList存放观察者。</p><p><strong>应用实例</strong>：</p><ol><li>拍卖时，拍卖师观察最高标价，然后通知其他竞价者竞价。</li><li>菩萨通过洒水招来老乌龟，老乌龟就是观察者，观察菩萨的洒水动作</li></ol><p><strong>优点</strong>：</p><ol><li>观察者和被观察者是抽象耦合的。</li><li>建立一套触发机制</li></ol><p><strong>缺点</strong>：</p><ol><li>如果一个被观察者对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li><li>如果观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅知道观察目标发送变化。</li></ol><p><strong>使用场景</strong>：</p><p>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装到独立的对象中使它们可以各自独立的改变和复用。</p><p>一个对象的改变将导致一个或多个对象也发生改变，而不知道有多少对象改变，可以降低对象之间的耦合度。</p><p>一个对象必须通知其他对象，而不知道这个对象时谁。</p><p>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……。可以使用观察者模式创建一种链式触发机制。</p><h3 id="谁是观察者谁是被观察者？"><a href="#谁是观察者谁是被观察者？" class="headerlink" title="谁是观察者谁是被观察者？"></a>谁是观察者谁是被观察者？</h3><p>当你做出了某些动作另一个人根据你的动作做出某些行为，这时你就是被观察者，另一个人是观察者。</p><h1 id="订阅-发布模式"><a href="#订阅-发布模式" class="headerlink" title="订阅-发布模式"></a>订阅-发布模式</h1><p>订阅-发布模式是观察者模式的另一个别称。</p><p>但是随着时间的变化，已经独立于观察者模式，成为另一种的设计模式。</p><p>在现在的发布订阅模式中，成为发布者的消息发送者不会将信息直接发送给订阅者，这意味这发布者和订阅者不知道彼此的存在。在发布者和订阅者之间存在第三个组件，称为调度中心或事件通道，它维持着发布者和订阅者之间的联系，过滤所有发布者传入的信息并相应的分发给它的订阅者。</p><p>例子：</p><p>你在微博关注了A，同时其他很多人也关注了A，那么当A发布动态的时候，微博就会为你推送这条动态。A就是发布者，你是订阅者，微博就是调度中心，你和A之间没有直接的消息往来，全是通过微博来协调的。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-8-3-1.gif" alt="如果有些方法没有详细说明你可以自行搜索查看"></p><p><strong>引用：</strong></p><p><a href="(https://www.cnblogs.com/onepixel/p/10806891.html)">观察者模式与订阅发布模式的区别</a></p><p><a href="https://maxwell-nc.github.io/android/rxjava2-1.html#Single%E5%92%8CSingleObserver" target="_blank" rel="noopener"><strong>RxJava 2.x 使用详解(一) 快速入门</strong></a></p><p><a href="https://www.jianshu.com/p/2a882604bbe8" target="_blank" rel="noopener">Rxjava关于Disposable你应该知道的事</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> RxJava </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>koin依赖注入框架</title>
      <link href="/2020/08/13/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-koin/"/>
      <url>/2020/08/13/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-koin/</url>
      
        <content type="html"><![CDATA[<h2 id="koin的使用"><a href="#koin的使用" class="headerlink" title="koin的使用"></a>koin的使用</h2><h4 id="添加依赖库"><a href="#添加依赖库" class="headerlink" title="添加依赖库"></a>添加依赖库</h4><pre><code>    implementation &#39;org.koin:koin-androidx-viewmodel:2.0.1&#39;    implementation &#39;org.koin:koin-android:2.0.1&#39;</code></pre><h4 id="需要创建依赖对象"><a href="#需要创建依赖对象" class="headerlink" title="需要创建依赖对象"></a>需要创建依赖对象</h4><p>这里创建三个类，Student，SchoolCourse，Friend。</p><ul><li>Student类</li></ul><blockquote><p>依赖于SchoolCourse，Friend类的方法。</p></blockquote><pre><code class="kotlin">class Student(val course: SchoolCourse,val friend: Friend) {    fun beSmart() {        course.study()        friend.hangout()    }}</code></pre><ul><li>SchoolCourse类</li></ul><blockquote><p>提供方法 study 负责打印 “I am studying”</p></blockquote><pre><code>class SchoolCourse {    fun study() {        println(&quot;I am studying&quot;)    }}</code></pre><ul><li>Friend 类</li></ul><blockquote><p>提供方法 hangout 负责打印 “We’re hanging out”</p></blockquote><pre><code>class Friend {    fun hangout() {        println(&quot;We&#39;re hanging out&quot;)    }}</code></pre><h4 id="定义依赖集合"><a href="#定义依赖集合" class="headerlink" title="定义依赖集合"></a>定义依赖集合</h4><p>创建 Modeles 文件 </p><ul><li>需要使用 module 方法</li></ul><blockquote><p>提供所需要的依赖</p></blockquote><ul><li>需要 signle 方法</li></ul><blockquote><p>使当前依赖为一个单例的对象</p></blockquote><ul><li>需要 factory 方法</li></ul><blockquote><p>定义一个工场每次调用创建一个新的实例</p></blockquote><ul><li>需要 get() 方法</li></ul><blockquote><p>get 用于最终实现注入</p></blockquote><pre><code>val appModule: Module = module {    single { SchoolCourse() }    factory { Friend() }    factory { Student(get(), get()) }}</code></pre><h4 id="启动-Koin"><a href="#启动-Koin" class="headerlink" title="启动 Koin"></a>启动 Koin</h4><ul><li><p>需要系统在创建时第一个启动Application实例</p><blockquote><p>修改 application 中的 name 属性 使得应用第一个启动它</p></blockquote></li></ul><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200813224142.png" alt=""></p><ul><li>需要创建 MyApp</li></ul><blockquote><p>第一个启动的Application实例</p></blockquote><ul><li>需要 startKoin</li></ul><blockquote><p>用来启动Koin</p></blockquote><ul><li>需要 modules</li></ul><blockquote><p>注册声明的Module</p></blockquote><ul><li>需要 androidContext</li></ul><blockquote><p>向Koin中注入context</p></blockquote><pre><code>class MyApp : Application() {    override fun onCreate() {        super.onCreate()        startKoin {            androidContext(this@MyApp)            modules(listOf(appModule))        }    }}</code></pre><h4 id="使用-koin-实现注入"><a href="#使用-koin-实现注入" class="headerlink" title="使用 koin 实现注入"></a>使用 koin 实现注入</h4><p>在需要注入的地方使用</p><ul><li>需要使用 get()</li></ul><blockquote><p>非 懒加载，注入实例</p></blockquote><p>通过 注入依赖完成后的实例调用beSmart()方法</p><pre><code>        val student = get&lt;Student&gt;()        student.beSmart()        val student2 = get&lt;Student&gt;()        student2.beSmart()</code></pre><h4 id="完成注入"><a href="#完成注入" class="headerlink" title="完成注入"></a>完成注入</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/image-20200813233756977.png" alt=""></p><h4 id="什么是-koin？"><a href="#什么是-koin？" class="headerlink" title="什么是 koin？"></a>什么是 koin？</h4><p>一个轻量级的依赖注入组件。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p><a href="https://zhuanlan.zhihu.com/p/188485918" target="_blank" rel="noopener">Koin in Android: 更简单的依赖注入</a></p><h4 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h4><p>get()用于实现注入。</p><p>当你所属类型不确定时，可以指定类型。get<Type>()</p><h4 id="声明：绑定一个接口"><a href="#声明：绑定一个接口" class="headerlink" title="声明：绑定一个接口"></a>声明：绑定一个接口</h4><p>一个  single 或者 factory 声明将会使用其给定的 lambda 表达式类型。比如 single{T}，该声明所匹配的类型就是表达式所声明的类型 T 让我们以一个类及其实现的接口为例：</p><pre><code class="java">// Service interfaceinterface Service{    fun doSomething()}// Service Implementationclass ServiceImp() : Service {    fun doSomething() { ... }}</code></pre><p>在koin模块(module)，我们可以使用Kotiln下的 as 操作符。如下所示：</p><pre><code class="java">val myModule = module {    // 只匹配 Service 类型    single { ServiceImp() }    // 只匹配 Service 类型    single { ServiceImp() as Service }}</code></pre><p>你也可以使用推断类型表达式</p><pre><code class="java">val myModule = module {    // 只匹配 Service 类型    single { ServiceImp() }    // 只匹配 Service 类型    single&lt;Service&gt; { ServiceImp() }}</code></pre><p>第二种风格是首选的，在接下来的文档中，也会使用该方法。</p><h4 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h4><ul><li><p><code>bind()</code> - 为给定的对象声明添加要绑定的类型</p><p>Bind 是一个中辍函数，可以用于把一个Service关联到多个类。例如现在有两个接口：Tool，Flammable，Stove实现了这两个接口。显然如果只定义1个Service是不能同时注入Stove和这两个接口的。</p><p>这是就可以发挥Bind的作用了</p><pre><code>val myModule = module{    factory { Stove() } bind Tool::class bind Flammable::class // &lt;- here!    factory { Chef(get()) }}</code></pre><p>这么一来，下面的三个注入都是合法的，并都会得到一个 Stove 实例：</p><pre><code>val chef: Chef = get()val tool:Tool = get()val flammable:Flammable = get()</code></pre></li></ul><h4 id="named"><a href="#named" class="headerlink" title="named"></a>named</h4><p>限定符，用来区别同一个类的不同实例</p><p>使用</p><pre><code class="java"> single(named(&quot;dev&quot;)) { DataRepository() } single(named(&quot;test&quot;)) { DataRepository() }</code></pre><h4 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h4><p>可通过name或者class检索到对应的实例</p><p>使用</p><pre><code class="kotlin">    factory(name = MAIN) {        AndroidSchedulers.mainThread()    }</code></pre><h2 id="依赖注入和控制反转"><a href="#依赖注入和控制反转" class="headerlink" title="依赖注入和控制反转"></a>依赖注入和控制反转</h2><h3 id="依赖注入（Dependency-Injection，简称-DI）"><a href="#依赖注入（Dependency-Injection，简称-DI）" class="headerlink" title="依赖注入（Dependency  Injection，简称 DI）"></a>依赖注入（Dependency  Injection，简称 DI）</h3><p>什么是依赖注入？</p><p>假设 A 是 耳机，B 是播放器。</p><p>当 A 依赖 B 时（也就是耳机想要播放以音乐时），A 要想播放音乐就必须要有B的实例，也就是</p><ol><li>通过A的接口，把B传入；</li><li>通过A的构造，把B传入；</li><li>通过A的属性，把B传入；</li></ol><p>这些过程叫做<strong>依赖注入（DI）</strong></p><h3 id="控制反转（Inversion-of-Control，简称-Ioc）"><a href="#控制反转（Inversion-of-Control，简称-Ioc）" class="headerlink" title="控制反转（Inversion of Control，简称 Ioc）"></a>控制反转（Inversion of Control，简称 Ioc）</h3><p>但是 A 并不能控制 B 何时播放(创建)或者关闭(销毁)，仅使用 B ，那么 B 的控制权交给 A 之外的事务处理，这些叫做 <strong>控制反转（Ioc）</strong></p><h3 id="为什么需要依赖注入"><a href="#为什么需要依赖注入" class="headerlink" title="为什么需要依赖注入"></a>为什么需要依赖注入</h3><p>降低耦合</p><p>什么是耦合</p><p>耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。两个或多个功能模块之间的关联程度。</p><p>什么是解耦</p><p>解除类（模块）之间的直接关系，将直接关系转换成间接关系</p><p><strong>引用：</strong></p><p><a href="https://www.youtube.com/watch?v=eH9UrAwKEcE&t=140s" target="_blank" rel="noopener">Dependency Injection with Koin - Android Kotlin tutorial</a></p><p><a href="https://github.com/AndyJennifer/koin_doc_zh" target="_blank" rel="noopener">koin 中文 DOC</a></p><p><a href="https://juejin.im/post/6844904202586554382" target="_blank" rel="noopener">Koin in Android: 更简单的依赖注入</a></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-8-3-1.gif" alt="如果有些方法没有详细说明你可以自行搜索查看"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> Kotlin </tag>
            
            <tag> koin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BottomSheet、BottomShaeetDialog使用流程</title>
      <link href="/2020/08/06/BottomSheets/"/>
      <url>/2020/08/06/BottomSheets/</url>
      
        <content type="html"><![CDATA[<h1 id="BottomSheet"><a href="#BottomSheet" class="headerlink" title="BottomSheet"></a>BottomSheet</h1><p>Demo 代码 <a href="https://medium.com/@droidbyme/android-bottom-sheet-7e9cfcec6427" target="_blank" rel="noopener">https://medium.com/@droidbyme/android-bottom-sheet-7e9cfcec6427</a><br>使用 BottomSheet、BottomSheetDialog、BottomSheetDialogFragment</p><h4 id="BottomSheet使用流程"><a href="#BottomSheet使用流程" class="headerlink" title="BottomSheet使用流程"></a>BottomSheet使用流程</h4><p>BottomSheet实现按钮在点击之后滑动布局.不联动也是可以的只要不设置它就可以了。</p><p><strong>被联动的布局使用</strong></p><pre><code>app:layout_behavior=&quot;@string/bottom_sheet_behavior&quot;</code></pre><p><strong>联动按钮使用属性</strong></p><pre><code>app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt;</code></pre><p><img src="/img/Snipaste_2020-07-17_21-58-16.png" alt=""></p><p><strong>在初始化时被联动</strong></p><pre><code>          //  设置绑定动作        //  控件和它绑定        var buttomSheetBehavior = BottomSheetBehavior.from(bottom_sheet_layout)</code></pre><p><strong>设置按钮了</strong></p><p>也就是在现在监听按钮的时候才进行这个按钮的联动滑动</p><pre><code>     btnBottomSheet.setOnClickListener {            if (buttomSheetBehavior.getState() != BottomSheetBehavior.STATE_EXPANDED)                buttomSheetBehavior.state = BottomSheetBehavior.STATE_EXPANDED            else                buttomSheetBehavior.state = BottomSheetBehavior.STATE_COLLAPSED        }</code></pre><p>设置在显示时不显示,不显示时显示。</p><p>设置监听器在它被拖动、滑动、切换时产生提示。</p><pre><code>        buttomSheetBehavior.setBottomSheetCallback(object : BottomSheetCallback() {            //这里是拖拽中的回调，根据slideOffset可以做一些动画            override fun onSlide(bottomSheet: View, slideOffset: Float) {            }            //这里是bottomSheet状态的改变            override fun onStateChanged(bottomSheet: View, newState: Int) {                when (newState) {                    BottomSheetBehavior.STATE_EXPANDED -&gt; {                        Toast.makeText(this@MainActivity, &quot;展开&quot;, Toast.LENGTH_LONG).show()                    }                    BottomSheetBehavior.STATE_COLLAPSED -&gt; {                        Toast.makeText(this@MainActivity, &quot;关闭&quot;, Toast.LENGTH_LONG).show()                    }                    BottomSheetBehavior.STATE_DRAGGING -&gt; {                        Toast.makeText(this@MainActivity, &quot;拖拽状态&quot;, Toast.LENGTH_LONG).show()                    }                    BottomSheetBehavior.STATE_HIDDEN -&gt; {                        Toast.makeText(this@MainActivity, &quot;隐藏状态&quot;, Toast.LENGTH_LONG).show()                    }                    BottomSheetBehavior.STATE_SETTLING -&gt; {                        Toast.makeText(                            this@MainActivity,                            &quot; 拖拽松开之后到达终点位置（collapsed or expanded）前的状态&quot;,                            Toast.LENGTH_LONG                        ).show()                    }                }            }        })</code></pre><h4 id="BottomSheetDialog使用流程"><a href="#BottomSheetDialog使用流程" class="headerlink" title="BottomSheetDialog使用流程"></a>BottomSheetDialog使用流程</h4><p>点击按钮之后弹出Dialog提示(布局界面有且准备好的)</p><p><strong>设置按钮的监听器，点击之后直接弹出Dialog窗口。</strong></p><pre><code>  /*        * Java函数式接口        * 弹窗提示        * */        btnBottomSheetDialog.setOnClickListener {            //使用布局加载器layoutInflater            val view = layoutInflater.inflate(R.layout.fragment_bottom_sheet, null)            //实例话BottomSheetDialog():用来实现弹出提示功能            val dialog = BottomSheetDialog(this)            dialog.setContentView(view)            dialog.show()        }</code></pre><h4 id="BottomSheetDialogFragment在当前界面加载Dialog碎片"><a href="#BottomSheetDialogFragment在当前界面加载Dialog碎片" class="headerlink" title="BottomSheetDialogFragment在当前界面加载Dialog碎片"></a>BottomSheetDialogFragment在当前界面加载Dialog碎片</h4><pre><code>        /*        * 在当前界面加载碎片        * */        btnBottomSheetDialogFragment.setOnClickListener {            val bottomSHeetFragment = BottomSheetFragment()            bottomSHeetFragment.show(supportFragmentManager, bottomSHeetFragment.tag)        }</code></pre><p><strong>准备好要加载的碎片,它是要有bottom_sheet_dialog类型的界面</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MediaStore访问图片、视频</title>
      <link href="/2020/08/01/MediaStore%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/08/01/MediaStore%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="使用”MediaStore”访问图片、视频的缩略图"><a href="#使用”MediaStore”访问图片、视频的缩略图" class="headerlink" title="使用”MediaStore”访问图片、视频的缩略图"></a>使用”MediaStore”访问图片、视频的缩略图</h2><h3 id="需要动态申请权限"><a href="#需要动态申请权限" class="headerlink" title="需要动态申请权限"></a>需要动态申请权限</h3><p>需要配置文件中添加要 申请的权限 “AndroidManifest.xml”</p><pre><code class="xml">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</code></pre><h4 id="注册动态权限"><a href="#注册动态权限" class="headerlink" title="注册动态权限"></a>注册动态权限</h4><ul><li><p>需要自定义 “checkReadExternalStoragePermission()”方法</p></li><li><p>需要 “Build.VERSION.SDK_INT”方法获得当前系统的版本号</p></li><li><p>需要 “Build.VERSION_CODES.M”表示安卓6</p></li><li><p>需要 “ContextCompat.checkSelfPermission()”方法, 判断是否获得了权限.</p></li></ul><blockquote><p>参数1:上下文.参数2:要判断的权限. </p><p>返回值:PackageManager.<strong>PERMISSION_GRANTED</strong> <strong>表示授予权限</strong>,PackageManager.<strong>PERMISSION_DENIED</strong>  = -1    <strong>表示权限未开启</strong>；</p></blockquote><ul><li>需要 “shouldShowRequestPermissionRationale()”方法.</li></ul><blockquote><p>判断当前权限是否被拒绝,并且显示窗口,显示”运行”和”拒绝”选项.</p><p>第一次不显示”不再提醒”按钮,第二次窗口添加”不再显示选择框”。</p><p>返回值:拒绝返回 true ,允许返回 false 或者 不再提醒选中后 返回 false</p></blockquote><ul><li>需要 “requestPermission()”方法.</li></ul><blockquote><p>用来申请系统权限. <strong>每次被调用时都会回调”onRequestPermissionsResult()”方法。</strong></p><p>参数1:要申请的权限.</p><p>参数2:要申请权限的 code 以用来在申请方法回调时确定是当前的申请操作.</p></blockquote><p>在需要注册权限的活动上添加</p><pre><code>    private fun checkReadExternalStoragePermission() {        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {            if (ContextCompat.checkSelfPermission(                    this,                    permission.READ_EXTERNAL_STORAGE                ) == PackageManager.PERMISSION_GRANTED            ) {                   } else {                if (shouldShowRequestPermissionRationale(permission.READ_EXTERNAL_STORAGE)) {                    Toast.makeText(this, &quot;App needs to view thumbnails&quot;, Toast.LENGTH_LONG).show()                }                requestPermissions(                    arrayOf(permission.READ_EXTERNAL_STORAGE),                    READ_EXTERNAL_STORAGE_PERMISSION_RESULT                )            }        } else {        }    }</code></pre><pre><code>    private val READ_EXTERNAL_STORAGE_PERMISSION_RESULT: Int = 0</code></pre><ul><li>需要重写 “onRequestPermissionsResult()”方法</li></ul><blockquote><p>申请权限时会调用它(申请权限时的回调)</p><p>参数1:申请权限时的Code,表示申请权限的操作是否相同.</p><p>参数2:这是要申请的权限永远不为空.</p><p>参数3:表示权限授权的结果永远封装在grantResult数组中</p></blockquote><pre><code>override fun onRequestPermissionsResult(        requestCode: Int,        permissions: Array&lt;out String&gt;,        grantResults: IntArray    ) {        super.onRequestPermissionsResult(requestCode, permissions, grantResults)        when (requestCode) {            READ_EXTERNAL_STORAGE_PERMISSION_RESULT -&gt; {                if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {                    Toast.makeText(this, &quot;now have access to view thumbs&quot;, Toast.LENGTH_LONG).show()                }            }        }    }</code></pre><h3 id="需要RecyclerView的适配器"><a href="#需要RecyclerView的适配器" class="headerlink" title="需要RecyclerView的适配器"></a>需要RecyclerView的适配器</h3><p><a href="https://thecara.github.io/2020/07/26/RecyclerView%E5%9C%A8Kotlin%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/#toc-heading-7">使用此案例创建适配器</a></p><p>初始化控件不再复述了,</p><ul><li>需要变量”mMediaStoreCursor”</li></ul><blockquote><p>表示当前的Cursor</p></blockquote><pre><code>class MediaStoreAdapter(private val mActivity: Activity) :    RecyclerView.Adapter&lt;MediaStoreAdapter.ViewHolder&gt;() {    private var mMediaStoreCursor: Cursor? = null        }</code></pre><ul><li><strong>需要自定义”getBitmapFromMediaStore()”方法</strong></li></ul><blockquote><p>获得系统中图片和视频的缩略图.通过Cursor获得照片和Video的缩略图</p><p>参数1:移动到对应Cursor的行.</p></blockquote><ul><li>需要使用”Cursor.getColumnIndex()”方法</li></ul><blockquote><p>获得当前MediaStoreCursor的”参数1”的索引</p><p>参数1:要索引的位置</p><p>返回值: 返回在当前 Cursor 中的位置,没有返回 -1 </p></blockquote><ul><li>需要使用”Cursor.getInt()’方法</li></ul><blockquote><p>获得”Cursor”中索引(列)的数值.</p><p>参数1:你想要获得的列</p><p>返回值:返回指定列的数值</p></blockquote><ul><li>需要 “MediaStore.Images.Thumbnails.getThumbnail”方法</li></ul><blockquote><p>获得缩略图.</p><p>参数1:表示内容提供器. 参数2:当前”Cursor”缩略图的ID. </p><p>参数3:返回时的清晰度.MICRO_KIND,MINI_KIND字面意思为微型和迷你缩略模式,前者分辨率更低.</p><p>返回值:返回一个Bitmap格式</p></blockquote><p>在适配器中添加</p><pre><code>class MediaStoreAdapter(private val mActivity: Activity) :    RecyclerView.Adapter&lt;MediaStoreAdapter.ViewHolder&gt;() {              private fun getBitmapFromMediaStore(position: Int): Bitmap? {        val idIndex: Int = mMediaStoreCursor!!.getColumnIndex(MediaStore.Files.FileColumns._ID)        val mediaTypeIndex: Int =            mMediaStoreCursor!!.getColumnIndex(MediaStore.Files.FileColumns.MEDIA_TYPE)        mMediaStoreCursor!!.moveToPosition(position)        when (mMediaStoreCursor!!.getInt(mediaTypeIndex)) {            // 当前类型为 IMAGE 时            MediaStore.Files.FileColumns.MEDIA_TYPE_IMAGE -&gt; {                return MediaStore.Images.Thumbnails.getThumbnail(                    mActivity.contentResolver,                    mMediaStoreCursor!!.getLong(idIndex),                    MediaStore.Images.Thumbnails.MICRO_KIND, null                )            }            // 当前类型为 VIDEO            MediaStore.Files.FileColumns.MEDIA_TYPE_VIDEO -&gt; {                return MediaStore.Video.Thumbnails.getThumbnail(                    mActivity.contentResolver,                    mMediaStoreCursor!!.getLong(idIndex),                    MediaStore.Video.Thumbnails.MICRO_KIND, null                )            }        }        return null    }}</code></pre><ul><li><strong>需要自定义方法”swapCursor()”</strong></li></ul><blockquote><p>获得上一个Cursor.</p></blockquote><ul><li>需要 “notifyDataSetChanged()” 方法</li></ul><blockquote><p>检测当前UI线程,刷新UI</p></blockquote><pre><code>class MediaStoreAdapter(private val mActivity: Activity) :    RecyclerView.Adapter&lt;MediaStoreAdapter.ViewHolder&gt;() {   private fun swapCursor(cursor: Cursor): Cursor? {        if (mMediaStoreCursor == cursor) {            return null        }        val oldCursor: Cursor? = mMediaStoreCursor        this.mMediaStoreCursor = cursor        if (cursor != null) {            this.notifyDataSetChanged()        }        return oldCursor    }}</code></pre><ul><li><strong>需要 自定义方法”changeCursor()”</strong></li></ul><blockquote><p>检测上一个Cursor,用来关闭上个Cursor.</p></blockquote><pre><code>class MediaStoreAdapter(private val mActivity: Activity) :    RecyclerView.Adapter&lt;MediaStoreAdapter.ViewHolder&gt;() {        fun changeCursor(cursor: Cursor?) {        val oldCursor: Cursor? = swapCursor(cursor!!)        if (oldCursor != null)            oldCursor.close()    }}</code></pre><ul><li>需要重写 “onBindViewHolder()”方法</li></ul><pre><code>    override fun onBindViewHolder(holder: ViewHolder, position: Int) {        val bitmap: Bitmap? = getBitmapFromMediaStore(position)        if (bitmap != null) {            holder.mediastoreImageView.setImageBitmap(bitmap)        }    }</code></pre><ul><li>需要重写”getItemCount()”方法</li></ul><pre><code>    override fun getItemCount(): Int {        return if (mMediaStoreCursor == null) 0 else mMediaStoreCursor!!.count    }</code></pre><ul><li>需要重写”onCreateViewHolder()”方法</li></ul><pre><code>    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {        val view =            LayoutInflater.from(parent.context).inflate(R.layout.media_image_view, parent, false)        return ViewHolder(view)    }</code></pre><h3 id="需要”LoaderManager-LoaderCallbacks”"><a href="#需要”LoaderManager-LoaderCallbacks”" class="headerlink" title="需要”LoaderManager.LoaderCallbacks”"></a>需要”LoaderManager.LoaderCallbacks”</h3><ul><li>需要实现LoaderManager.LoaderCallbacks<cursor>.(在MediaMainActivity)</li></ul><blockquote><p>在需要的Fragment或Activity中实现它。</p></blockquote><pre><code>class MediaMainActivity : AppCompatActivity(), LoaderManager.LoaderCallbacks&lt;Cursor&gt; {}</code></pre><ul><li>需要重写”onCreateLoader”</li></ul><blockquote><p>在调用initLoader()返回时创建一个Loader.</p><p>根据传入的ID,初始化并返回一个新的加载器.</p></blockquote><ul><li>需要返回的列</li></ul><blockquote><p>MediaStore.Files.FileColums.ID 返回Id列</p><p>MediaStore.Files.FIleColums.DATE_ADDED 图片被添加的时间</p><p>MediaStore.Files.FileColums.MEDIA_TYPE 媒体类型</p><p>MediaStore.Files.FileColums.MEDIA_TYPE_IMAGE 图片列(索引)</p><p>MediaStore.Files.FileColums.MEDIA_TYPE_VIDEO 视频列(索引)</p></blockquote><ul><li>需要”CursorLoader()”匿名类</li></ul><blockquote><p>它查询ContentResolver然后返回一个Cursor.</p><p>参数1:上下文. 参数2:要操作的URI.当前表示所有图片的URI.</p><p>参数3:要返回的列. 参数4:一个过滤器,表明哪些行要被返回.当前返回类型为IMAGE 或 VIDEO</p><p>参数5:用作过滤器的参数. </p><p>参数6:设置排序.相当于SQL语句中Order by.这里使用 DATA_ADDED + DESC 表示按照时间进行排序.</p></blockquote><pre><code class="kotlin">    override fun onCreateLoader(p0: Int, p1: Bundle?): androidx.loader.content.Loader&lt;Cursor&gt; {        val projection = arrayOf&lt;String&gt;(            MediaStore.Files.FileColumns._ID,            MediaStore.Files.FileColumns.DATE_ADDED,            MediaStore.Files.FileColumns.MEDIA_TYPE        )        // SQL命令        val selection =            MediaStore.Files.FileColumns.MEDIA_TYPE +                    &quot; = &quot; + MediaStore.Files.FileColumns.MEDIA_TYPE_IMAGE + &quot; or &quot; + MediaStore.Files.FileColumns.MEDIA_TYPE +                    &quot; = &quot; + MediaStore.Files.FileColumns.MEDIA_TYPE_VIDEO        return object : CursorLoader(            this,            MediaStore.Files.getContentUri(&quot;external&quot;),            projection,            selection,            null,            MediaStore.Files.FileColumns.DATE_ADDED + &quot; DESC &quot;        ) {}    }</code></pre><ul><li>需要重写 “onLoadFinished()”方法</li></ul><blockquote><p>更新UI操作.当一个加载器完成了它的装载过程后被调用.</p></blockquote><ul><li>需要调用changeCursor()方法</li></ul><blockquote><p>刷新当前参数1,关闭上一个Cursor</p><p>参数1:当前的Cursor</p></blockquote><pre><code>class MediaMainActivity : AppCompatActivity(), LoaderManager.LoaderCallbacks&lt;Cursor&gt; {    override fun onLoadFinished(loader: androidx.loader.content.Loader&lt;Cursor&gt;, data: Cursor?) {        mMediaStoreAdapter?.changeCursor(data!!)    }}</code></pre><ul><li>需要重写”onLoaderReset()”方法</li></ul><blockquote><p>何时释放内存,当一个加载器完成了它的装载工作之后被调用</p></blockquote><pre><code>class MediaMainActivity : AppCompatActivity(), LoaderManager.LoaderCallbacks&lt;Cursor&gt; {   override fun onLoaderReset(loader: androidx.loader.content.Loader&lt;Cursor&gt;) {        mMediaStoreAdapter?.changeCursor(null)    }}</code></pre><ul><li><p>需要在用于权限和申请权限之后添加</p></li><li><p>需要在”onRequestPermissionsResult()”中调用”getSupportLoaderManager.initLoader()”</p></li></ul><blockquote><p>启动加载器</p><p>参数1:一个唯一的ID来标志加载器.</p><p>参数2:可选参数,用于加载初始化时(本例为null)</p><p>参数3:LoaderManager.LoaderCallbacks的实现.被LoaderManger调用以报告加载事件,在例子中是传递给自己”this”</p></blockquote><pre><code>when (requestCode) {            READ_EXTERNAL_STORAGE_PERMISSION_RESULT -&gt; {                if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {                //添加 supportLoaderManager.initLoader(MEDIASTORE_LODAR_ID, null, this)                }            }        }</code></pre><ul><li>需要在”checkReadExternalStoragePermission()”中调用</li><li>需要在拥有权限后调用,在”checkSelfPermission()”判断拥有权限后调用</li></ul><pre><code>        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {                  if (ContextCompat.checkSelfPermission(                    this,                    permission.READ_EXTERNAL_STORAGE                ) == PackageManager.PERMISSION_GRANTED            ) {              //添加  supportLoaderManager.initLoader(MEDIASTORE_LODAR_ID, null, this)            }         } else {            //添加  supportLoaderManager.initLoader(MEDIASTORE_LODAR_ID, null, this)        }</code></pre><p>ps:显示了在哪里添加其他的代码不用修改.</p><ul><li>需要添加唯一的ID标志加载器.</li></ul><pre><code>class MediaMainActivity : AppCompatActivity(), LoaderManager.LoaderCallbacks&lt;Cursor&gt; {    private val MEDIASTORE_LODAR_ID: Int = 0}</code></pre><ul><li>需要GridLayoutManger,在 “onCreate()” 中添加</li></ul><blockquote><p>设置RecyclerView的布局</p><p>参数1:上下文 . 参数2:多少列</p></blockquote><pre><code>val gridLayoutManager: GridLayoutManager = GridLayoutManager(this, 3)</code></pre><ul><li>需要RecyclerView的setLayoutManager</li></ul><blockquote><p>设置 GridLayoutManager</p></blockquote><pre><code>thumbnailRecyclerView.layoutManager = gridLayoutManager</code></pre><ul><li>需要设置适配器省略..</li></ul><h3 id="使用-“Glide”的方式加载图片"><a href="#使用-“Glide”的方式加载图片" class="headerlink" title="使用 “Glide”的方式加载图片"></a>使用 “Glide”的方式加载图片</h3><ul><li>需要添加依赖</li></ul><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200803180403.png" alt=""></p><ul><li>需要“MediaStore.Files.FileColumns.DATA”（需要在onCreateLoader的projection修改）</li></ul><blockquote><p>表述索引在磁盘中位置</p></blockquote><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200803180843.png" alt=""></p><p>需要创建自定义返回“getUriFromMediaStore()”（在MediaStoreAdapter中添加）</p><blockquote><p>获得缩略图在ContentResolver中的uri</p><p>参数1：media的那个行</p></blockquote><p>需要“Uri.parse()” 方法</p><blockquote><p>将字符串解析成uri对象</p></blockquote><pre><code>    private fun getUriFromMediaStore(position: Int): Uri {        val dataIndex: Int = mMediaStoreCursor!!.getColumnIndex(MediaStore.Files.FileColumns.DATA)        mMediaStoreCursor!!.moveToPosition(position)        val mediaUri: Uri =            Uri.parse(&quot;file://&quot; + mMediaStoreCursor!!.getString(dataIndex).toString())        return mediaUri    }</code></pre><p>需要“Glide” - (在onBindViewHolder()中添加)</p><blockquote><p>with(content:Content) - 需要上下文</p><p>load(uri:String) - 图片的uri</p><p>centerCrop() - 将图片按比例缩放到足以填充ImageView的尺寸，但是图片可能会显示不完整。</p><p>override(width,height) 重新改变图片大小。</p><p>into() - 你需要显示图片的目标。</p></blockquote><pre><code>      Glide.with(mActivity).load(getUriFromMediaStore(position)).centerCrop().override(96, 96)            .into(holder.mediastoreImageView)</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200803184305.png" alt=""></p><h2 id="什么是Loader"><a href="#什么是Loader" class="headerlink" title="什么是Loader"></a>什么是Loader</h2><p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/developer/2014/0325/1602.html" target="_blank" rel="noopener">android 加载器loader详解</a></p><p>Loader简化了activity和Fragment中异步加载数据的步骤.</p><p>特点:适用于每个Activity和Fragment,提供异步加载的实现方式,监听数据源,在数据发生改变时自动返回新的结果。当由于配置改变后被重新创建后,它们自动重新链接上一个加载游标,所以不必重新查数据.</p><p>loader API 说明</p><table><thead><tr><th align="center">Class/Interface</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">LoaderManager</td><td align="center">一个与Activity和Fragment相关联的抽象类,它管理一个或者多个Loader实例,帮助一个应用管理哪些与Activity或Fragment的声明周期相关的长时间操作.常见方式是与CursorLoader一起使用,然后应用也可以自己写一个加载其他数据类型或者数据源的loader。<strong>每个Activity或者Fragment只有一个LoaderManager.但是一个LoaderManager可以拥有多个加载器</strong></td></tr><tr><td align="center">LoaderManager.LoaderCallbacks</td><td align="center">用于一个客户端与LoaderManager交互的会调接口.例如,你使用回调方法onCreateLoader()来创建一个新的加载器.</td></tr><tr><td align="center">Loader</td><td align="center">一个执行异步数据加载的抽象类,它是加载器的基础类.你可以使用经典的CursorLoader,但是你也可以实现你的子类.一旦加载器被激活,它们将监听它的数据源并且在数据改变时发送新的结果.</td></tr><tr><td align="center">AsyncTaskLoader</td><td align="center">提供一个AsyncTask来执行异步加载工作的抽象类</td></tr><tr><td align="center">CursorLoader</td><td align="center">AsyncTaskLoader的子类,它查询ContentResolver然后返回一个Cursor.这个类为查询Cursor以标准的方式实现了加载器协议,它的游标查询是通过AsyncTaskLoader在后台线程中执行,从而不会阻断线程</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-8-3-1.gif" alt="如果有些方法没有详细说明你可以自行搜索查看"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLite Database 使用</title>
      <link href="/2020/07/28/SQLite-Database-%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/07/28/SQLite-Database-%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><h5 id="需要-创建数据库-类-“MyHelper”"><a href="#需要-创建数据库-类-“MyHelper”" class="headerlink" title="需要 创建数据库 类 “MyHelper”"></a>需要 创建数据库 类 “MyHelper”</h5><pre><code class="kotlin">class MyHelper(    private val mContext: Context? = null,    private val dbname: String = &quot;mydb&quot;,    private val version: Int = 1) : SQLiteOpenHelper(mContext, dbname, null, version) {    /*    * 需要变量sql确定表的格式    * 需要 execSQL()执行创建表的动作    * */    override fun onCreate(p0: SQLiteDatabase?) {        // 创建数据库表        val sql: String =            &quot;CREATE TABLE PRODUCTS (_id INTEGER PRIMARY KEY AUTOINCREMENT, NAME TEXT, DESCRIPTION TEXT, PRICE READ)&quot;        // 执行创建表的动作        p0?.execSQL(sql)    }    /*    *    * */    override fun onUpgrade(p0: SQLiteDatabase?, p1: Int, p2: Int) {        TODO(&quot;Not yet implemented&quot;)    }}</code></pre><ul><li>创建数据库需要继承SQLiteOpenHelper()类型,需要四个参数进行初始化</li><li>(四个参数:mContext:上下文,dbname: 数据库名称,version:数据库版本,factory:null)</li><li>需要实现两个方法onCreate()和onUpgrade()方法</li></ul><h5 id="在需要创建数据库时调用"><a href="#在需要创建数据库时调用" class="headerlink" title="在需要创建数据库时调用"></a>在需要创建数据库时调用</h5><pre><code class="kotlin"> var myHelper: MyHelper = MyHelper(mContext = this) val sqlLiteDatabase: SQLiteDatabase = myHelper.readableDatabase</code></pre><p>这时数据库就创建完成了</p><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>创建仓库后插入数据</p><p>需要”ContentValues()”类型</p><p>需要”SQLiteDatabase的insert()”方法</p><p>在”自定义数据库中”中添加方法</p><pre><code>    private fun instertData(        name: String,        description: String,        price: Double,        database: SQLiteDatabase    ) {        // ContentValues() 类型负责存放键值的数据.你只需要记住它是往数据库中存放数据的.        val values: ContentValues = ContentValues()        values.put(&quot;NAME&quot;, name)        values.put(&quot;DESCRIPTION&quot;, description)        values.put(&quot;PRICE&quot;, price)        // 向当前数据库(database)插入数据(values)        database.insert(&quot;PRODUCTS&quot;, null, values)    }</code></pre><p>在<strong>外部要插入数据</strong>设置类型为 “public”即可。</p><p>插入数据在外部调用方法</p><pre><code>        // insert        instertData(&quot;Jam&quot;, &quot;Fruit Jam&quot;, 300.1, p0!!)        instertData(&quot;Yli&quot;, &quot;Te Jam&quot;, 305.13, p0!!)        instertData(&quot;Tom Li&quot;, &quot;Zhou Jam&quot;, 210.7, p0!!)</code></pre><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>需要”MyHelper”自定义<strong>数据库类的实例</strong></p><p>需要”MyHelper.readableDatabase”方法读取数据库方法<strong>返回一个可对数据库读写的对象</strong>.</p><p>需要”sqlLiteDatabase.rawQuery()”方法<strong>获得(数据库表)每行的集合</strong>(Cursor类型).</p><pre><code>  // 实例话自定义的数据类        var myHelper: MyHelper = MyHelper(mContext = this)        // 创建数据库        val sqlLiteDatabase: SQLiteDatabase = myHelper.readableDatabase        val cursor: Cursor =            sqlLiteDatabase.rawQuery(&quot;SELECT NAME, PRICE FROM PRODUCTS&quot;, arrayOf&lt;String&gt;())        if (cursor != null)            cursor.moveToFirst()        val builder: StringBuilder = StringBuilder()        do {            val name: String = cursor.getString(0)            val price: Double = cursor.getDouble(1)            builder.append(&quot;NAME - &quot; + name + &quot;PRICE - &quot; + price)        } while (cursor.moveToNext())        // 这是在界面上刷新了读取的数据        text_view.setText(builder.toString())</code></pre><p><img src="1595946627126.png" alt=""></p><h4 id="按照条件查询指定数据"><a href="#按照条件查询指定数据" class="headerlink" title="按照条件查询指定数据"></a>按照条件查询指定数据</h4><pre><code>   val cursor: Cursor =            sqlLiteDatabase.rawQuery(&quot;SELECT NAME, PRICE FROM PRODUCTS WHERE NAME = ?&quot;, arrayOf&lt;String&gt;(&quot;Tom Li&quot;))</code></pre><p>查询 列 “NAME,PRICE” 来自表 “PRODUCTS” 根据条件 “NAME = ?”</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200731132244.png" alt=""></p><p>查询完成</p><h2 id="什么是Cursor类型"><a href="#什么是Cursor类型" class="headerlink" title="什么是Cursor类型"></a>什么是Cursor类型</h2><p><a href="https://blog.csdn.net/android_zyf/article/details/53420267" target="_blank" rel="noopener">引用:Android中的Cursor到底是什么？如何理解Cursor的方法都在做什么事情？</a></p><blockquote><p>Cursor是每行的集合</p></blockquote><p>表中共有多行数据.</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200729122947.png" alt=""></p><p>假如:获得通过”select”语句”gender”获得符合这列的男性那么得到的是 “张三,赵六”这两行数据.也就是<strong>说 “Cursor”类型存放了两行数据。</strong></p><h4 id="如何获得Cursor类型"><a href="#如何获得Cursor类型" class="headerlink" title="如何获得Cursor类型"></a>如何获得Cursor类型</h4><p>通过数据库对象的方法获得。👇</p><pre><code>SQLiteDataBase db;Cursor cursor = db.query(各种参数);</code></pre><p>这些就是每一行的集合</p><h4 id="索引在Cursor中是什么"><a href="#索引在Cursor中是什么" class="headerlink" title="索引在Cursor中是什么"></a>索引在Cursor中是什么</h4><p>在Cursor中索引指的就是<strong>表中的列</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200731174701.png" alt=""></p><p>返回了”PRICE”列在表中的索引(位置)。</p><h4 id="关于为何要使用-“moveToFirst-”-方法"><a href="#关于为何要使用-“moveToFirst-”-方法" class="headerlink" title="关于为何要使用 “moveToFirst()” 方法"></a>关于为何要使用 “moveToFirst()” 方法</h4><p>利用反证法,<strong>不使用”moveToFirst()”方法,</strong>获得游标后,直接输出当前的”position”值</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200729210143.png" alt=""></p><p><strong>“position”的值会直接输出 “-1”</strong>,也就是说当我们不适用”moveToFirst()”方法时它会在坐标”position”(0)的<strong>上边</strong>。</p><p>所以我们应该使用方法”moveToFirst()”使”position”为”0”。</p><h4 id="源码分析-使用”moveToNext-”方法是如何得知遍历完成的"><a href="#源码分析-使用”moveToNext-”方法是如何得知遍历完成的" class="headerlink" title="源码分析 使用”moveToNext()”方法是如何得知遍历完成的?"></a>源码分析 使用”moveToNext()”方法是如何得知遍历完成的?</h4><p>先说明 <strong>调用”moveToNext()”方法最总会调用”moveToPosition()”方法</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200729212802.png" alt=""></p><p>👆界面在被初始化时,指当前页面的对象。这时源<strong>码中的”mPos=-1”会被在一个空参数构造方法里初始化</strong>。</p><p>仅理解的话: <strong>“moveToFirst()”调用的是”moveToPostion(0)”,”moveToNext()” 调用的是”moveToNext(mPos+1)”,所以说当首次调用的他们两个的结果是一样的。</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200729215028.png" alt=""></p><p>ps:个人理解:在使用”cursor.moveToFirst()”先进行判断可以更有效的避免空指针异常j</p><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>需要修改<strong>数据库返回的类型为可写入类型</strong></p><pre><code class="kotlin">        // 创建数据库        val sqlLiteDatabase: SQLiteDatabase = myHelper.writableDatabase</code></pre><p>需要 “ContentValues()” 类型存放更新的值</p><pre><code>        //更新数据        val values: ContentValues = ContentValues()        values.put(&quot;PRICE&quot;, 280)        // 参数1:表示更新的表.参数2:表示更新的数据.参数3:表示条件(表示通过那个条件更新值) 参数4:条件的值        sqlLiteDatabase.update(&quot;PRODUCTS&quot;, values, &quot;_id = ?&quot;, arrayOf&lt;String&gt;(&quot;1&quot;))</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200731130854.png" alt=""></p><p>“280”价格更新了</p><h4 id="多条件更新"><a href="#多条件更新" class="headerlink" title="多条件更新"></a>多条件更新</h4><p>更新表 “<strong>PRODUCTS</strong>“ 的值 “<strong>values</strong>“,根据 “<strong>NAME</strong>“为”<strong>Tom Li</strong>“ 和”<strong>DESCRIPTION</strong>“ 为 “<strong>Zhou Jam</strong>“ 的行中的数据.</p><pre><code>sqlLiteDatabase.update(&quot;PRODUCTS&quot;, values, &quot;NAME = ? AND DESCRIPTION = ?&quot;, arrayOf&lt;String&gt;(&quot;Tom Li&quot;,&quot;Zhou Jam&quot;))</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200731132831.png" alt=""></p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>在获得数据库的<strong>可写入类型后。</strong> 调用 “delete()”方法。</p><pre><code>        // 根据条件删除一行数据        // 参数1:要删除的表名字,参数2:选择删除的条件(根据这个条件删除),参数3:条件的值        sqlLiteDatabase.delete(&quot;PRODUCTS&quot;, &quot;_id=?&quot;, arrayOf&lt;String&gt;(&quot;1&quot;))</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200731131332.png" alt=""></p><p>删除成功了.</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> SQLite </tag>
            
            <tag> Cursor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库索引</title>
      <link href="/2020/07/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
      <url>/2020/07/28/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是数据库索引"><a href="#什么是数据库索引" class="headerlink" title="什么是数据库索引"></a>什么是数据库索引</h2><p>MySql官网的介绍,索引是帮助<code>MySQL</code>高效获得数据的结构。类似于书本的目录,从而提高查询速度。</p><p><a href="https://segmentfault.com/a/1190000022341554" target="_blank" rel="noopener">初探MySQL索引</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chocolatey的配置与应用的安装</title>
      <link href="/2020/07/26/choco%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2020/07/26/choco%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-Chocolatey安装7zip"><a href="#使用-Chocolatey安装7zip" class="headerlink" title="使用 Chocolatey安装7zip"></a>使用 Chocolatey安装7zip</h2><p>全程使用科学上网</p><pre><code>choco install 7zip</code></pre><h2 id="如何安装Chocolatey"><a href="#如何安装Chocolatey" class="headerlink" title="如何安装Chocolatey"></a>如何安装Chocolatey</h2><p><a href="https://chocolatey.org/install.ps1" target="_blank" rel="noopener">在桌面下载</a></p><p>使用管理员打开cmd访问到下载的目录中</p><p>输入👇.安装的同时要使用科学上网</p><pre><code>@powershell -NoProfile -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&#39;install.ps1&#39;))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin&quot;</code></pre><p>查看是否安装成功：</p><p>choco</p><p><img src="1595823753408.png" alt=""></p><h2 id="什么是Chocolatey"><a href="#什么是Chocolatey" class="headerlink" title="什么是Chocolatey"></a>什么是Chocolatey</h2><p>Chocolatey是一个Windows下的软件包管理器，你可以像在类Unix系统中使用Yum和APT一样使用它，在Windows中实现自动化轻松管理Windows软件的所有方面。</p><p> <a href="https://zh.wikipedia.org/zh-cn/Chocolatey" target="_blank" rel="noopener">维基百科</a></p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2>]]></content>
      
      
      <categories>
          
          <category> Chocolatey </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chocolatey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kotlin in Action-Kotlin实战</title>
      <link href="/2020/07/26/kotlin-in-Action-Kotlin%E5%AE%9E%E6%88%98/"/>
      <url>/2020/07/26/kotlin-in-Action-Kotlin%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="2-Kotlin-基础"><a href="#2-Kotlin-基础" class="headerlink" title="2 Kotlin 基础"></a>2 Kotlin 基础</h1><h3 id="2-1-基本要素-函数变量"><a href="#2-1-基本要素-函数变量" class="headerlink" title="2.1 基本要素: 函数变量"></a>2.1 基本要素: 函数变量</h3><h4 id="2-1-3-变量"><a href="#2-1-3-变量" class="headerlink" title="2.1.3 变量"></a>2.1.3 变量</h4><p><strong>可变变量和不可变变量</strong></p><ul><li>val–不可变引用。使用val声明的变量不能在初始化之后再次赋值。它对应的是java中的final变量</li><li>var–可变引用。这种变量的值可以被改变。这种声明对应的是普通(非final)变量</li></ul><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595899792330.png" alt=""></p><p>👆在定义了val变量的代码块期间,<strong>val变量只能进行唯一一次初始化</strong>。但是,如果编译器能确保只有唯一一次初始化语句会被执行,可以根据条件使用不同的值来初始化它。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595899976491.png" alt=""></p><p>自身不可变(只可以执行一次,初始化一次)</p><p>注意,尽管val引用自身是不可变的,但是它指向的对象<strong>`可能</strong>`是可变的。列如</p><pre><code>val languages = arrayListOf(&quot;Java&quot;)lenguages.add(&quot;Kotlin&quot;)</code></pre><h3 id="2-3-表示和处理选择：枚举和“when”"><a href="#2-3-表示和处理选择：枚举和“when”" class="headerlink" title="2.3 表示和处理选择：枚举和“when”"></a>2.3 表示和处理选择：枚举和“when”</h3><h4 id="2-3-1-声明枚举类"><a href="#2-3-1-声明枚举类" class="headerlink" title="2.3.1 声明枚举类"></a>2.3.1 声明枚举类</h4><p><strong>什么是枚举</strong></p><p>为了让编译器能够自动检查某个值在枚举的集合中，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用 <strong>enum</strong> 来定义枚举类。</p><pre><code class="kotlin">enum class Color{    RED,ORANGE,YELLOW,GREEN,BLUE,INDIGO,VIOLET}</code></pre><p>kotlin 中 enum 是一个所谓的软关键词：只有当它出现在class前面时才会有特殊的意义，在其他地方可以把它当作普通的名称使用。</p><h4 id="2-3-5-智能转换：合并类型检查和转换"><a href="#2-3-5-智能转换：合并类型检查和转换" class="headerlink" title="2.3.5 智能转换：合并类型检查和转换"></a>2.3.5 智能转换：合并类型检查和转换</h4><h5 id="kotlin智能转换的案例"><a href="#kotlin智能转换的案例" class="headerlink" title="kotlin智能转换的案例"></a>kotlin智能转换的案例</h5><h6 id="表达式类型层次"><a href="#表达式类型层次" class="headerlink" title="表达式类型层次"></a>表达式类型层次</h6><pre><code class="kotlin">interface Exprclass Num(val value: Int) : Expr    // 简单的值对象类，只有一个属性value，实现了Expr接口class Sum(val left: Expr, val right: Expr) : Expr   // Sum运算的实参可以是任何Expr:Num 或者 Sum</code></pre><h6 id="对表达式求值"><a href="#对表达式求值" class="headerlink" title="对表达式求值"></a>对表达式求值</h6><pre><code class="kotlin">fun eval(e: Expr): Int {    if (e is Num) {//        val n = e.value as Num //显示的转换为Num类型多余的        return e.value    }    if (e is Sum) {        return eval(e.left) + eval(e.right) // 变量 e 被智能的转换了类型    }    throw IllegalArgumentException(&quot;test&quot;)}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200831171911.png" alt=""></p><p>结果</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200831171248.png" alt=""></p><h5 id="“is”-修饰符"><a href="#“is”-修饰符" class="headerlink" title="“is” 修饰符"></a>“is” 修饰符</h5><p>在 kotlin 中，你要使用 is 检查来判断一个变量是否是某个类型。</p><h5 id="什么时候进行智能转换？"><a href="#什么时候进行智能转换？" class="headerlink" title="什么时候进行智能转换？"></a>什么时候进行智能转换？</h5><p>如果你检查过一个变量是某种类型，后面就不再需要转换它了，可以就把它当作你检查过的类型使用。事实上编译器为你执行了类型转换，我们把这种行为称为 <strong>智能转换。</strong></p><h1 id="3-函数的订阅和调用"><a href="#3-函数的订阅和调用" class="headerlink" title="3 函数的订阅和调用"></a>3 函数的订阅和调用</h1><h2 id="3-3-给别人的类添加方法：扩展函数和属性"><a href="#3-3-给别人的类添加方法：扩展函数和属性" class="headerlink" title="3.3 给别人的类添加方法：扩展函数和属性"></a>3.3 给别人的类添加方法：扩展函数和属性</h2><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><blockquote><p>扩展函数非常简单，作为一个类的成员函数，不过它定义在类的外边。</p></blockquote><h1 id="4-类、对象和接口"><a href="#4-类、对象和接口" class="headerlink" title="4 类、对象和接口"></a>4 类、对象和接口</h1><h3 id="4-1-定义类继承结构"><a href="#4-1-定义类继承结构" class="headerlink" title="4.1 定义类继承结构"></a>4.1 定义类继承结构</h3><h4 id="4-1-1-Kotlin-中的接口"><a href="#4-1-1-Kotlin-中的接口" class="headerlink" title="4.1.1 Kotlin 中的接口"></a>4.1.1 Kotlin 中的接口</h4><h5 id="声明接口"><a href="#声明接口" class="headerlink" title="声明接口"></a>声明接口</h5><pre><code class="kotlin">interface Clickable{    fun click()}</code></pre><h5 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h5><pre><code>class Button : Clickble {    override fun click() {        println(&quot;I was clicked&quot;)    }}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200826205307.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200826205356.png" alt=""></p><h5 id="Kotlin实现接口与-Java-有那些不同"><a href="#Kotlin实现接口与-Java-有那些不同" class="headerlink" title="Kotlin实现接口与 Java 有那些不同"></a>Kotlin实现接口与 Java 有那些不同</h5><p>Kotlin 在类后面使用冒号来代替 <strong>Java</strong> 中的 extends 和 implements 关键词。 和 Java 一样，<strong>一个类可以实现任意多个接口</strong>，但<strong>只能继承一个类型</strong>。</p><h5 id="override-修饰符的作用"><a href="#override-修饰符的作用" class="headerlink" title="override 修饰符的作用"></a>override 修饰符的作用</h5><ul><li>相同</li></ul><p>与 Java 中的 @Override 注解类似，<strong>override 修饰符用来标注被重写的父类或者接口的方法和属性</strong>。</p><ul><li>不同</li></ul><p>在 Kotlin 中使用 override 修饰符是强制要求的。<strong>这会避免先写出实现方法再添加抽象方法造成的意外重写：</strong>你的代码将不能编译，除非你显式地将这个方法标注为 Override 或者重命名它。</p><h5 id="如何给接口添加一个默认实现的方法"><a href="#如何给接口添加一个默认实现的方法" class="headerlink" title="如何给接口添加一个默认实现的方法"></a>如何给接口添加一个默认实现的方法</h5><p>接口的方法可以有一个默认实现的方法。</p><pre><code class="kotlin">interface Clickable{    fun click() // 普通的方法声明    fun showOff() = println(&quot;I&#39;m clickable!&quot;) // 带默认实现的方法}</code></pre><h5 id="实现一个带有默认实现的方法的接口要注意什么"><a href="#实现一个带有默认实现的方法的接口要注意什么" class="headerlink" title="实现一个带有默认实现的方法的接口要注意什么"></a>实现一个带有默认实现的方法的接口要注意什么</h5><p>如果你实现了这个接口，你需要为 click 提供一个实现。可以重新定义 showOff() 方法的行为，或者如果你对默认行为感到满意也可以直接省略它。（默认实现的方法也可以被重写）</p><h5 id="定义实现了同样方法的接口"><a href="#定义实现了同样方法的接口" class="headerlink" title="定义实现了同样方法的接口"></a>定义实现了同样方法的接口</h5><pre><code class="kotlin">interface Focusable {    fun setFocus(b: Boolean) = println(&quot;I ${if (b) &quot;got&quot; else &quot;lost&quot;} focus.&quot;)    fun showOff() = println(&quot;I&#39;m focusable!&quot;)}</code></pre><h5 id="在类中实现两个有相同默认实现方法的接口会发生什么"><a href="#在类中实现两个有相同默认实现方法的接口会发生什么" class="headerlink" title="在类中实现两个有相同默认实现方法的接口会发生什么"></a>在类中实现两个有相同默认实现方法的接口会发生什么</h5><p>在这两个接口中都带有默认实现的 showOff() 方法：在没有显示的实现 showOff() ,会得到编译错误信息。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827000446.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827000526.png" alt=""></p><h6 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h6><p>必须显式的实现相同方法。</p><h5 id="调用继承-接口-的默认实现方法"><a href="#调用继承-接口-的默认实现方法" class="headerlink" title="调用继承(接口)的默认实现方法"></a>调用继承(接口)的默认实现方法</h5><pre><code class="kotlin">class Button : Clickable, Focusable {    override fun click() {        TODO(&quot;Not yet implemented&quot;)    }    //如果同样的继承成员不止一个实现，必须提供一个显示的实现。    override fun showOff() {        // 使用尖括号加上父类名字的“super”表明了你想要调用哪一个父类的方法        super&lt;Clickable&gt;.showOff()        super&lt;Focusable&gt;.showOff()    }}</code></pre><p>通过调用继承的两个父类型中的实现来实现 showOff() 。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827005257.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200827005432.png" alt=""></p><h4 id="4-1-2-open、final-和-abstract-修饰符：默认为-final"><a href="#4-1-2-open、final-和-abstract-修饰符：默认为-final" class="headerlink" title="4.1.2 open、final 和 abstract 修饰符：默认为 final"></a>4.1.2 open、final 和 abstract 修饰符：默认为 final</h4><h5 id="kotlin-中如何继承一个类"><a href="#kotlin-中如何继承一个类" class="headerlink" title="kotlin 中如何继承一个类"></a>kotlin 中如何继承一个类</h5><p>如果你想要创建一个类的子类，需要使用 open 修饰符来标示这个类。此外<strong>需要给每个可以被重写的属性或者方法添加 open 属性</strong>。</p><h5 id="声明一个带open-方法的-open-类"><a href="#声明一个带open-方法的-open-类" class="headerlink" title="声明一个带open 方法的 open 类"></a>声明一个带open 方法的 open 类</h5><pre><code class="kotlin">open class RichButton : Clickable {    fun disable() {}    // 这个函数是 final 的： 不能在子类中重写它。    open fun animate() {} // 这个函数是 open 的： 可以在子类中重写它    // 这个函数重写了 open 函数并且它本身同样是 open 的    override fun click() {        TODO(&quot;Not yet implemented&quot;)    }}</code></pre><h5 id="默认-final-的好处"><a href="#默认-final-的好处" class="headerlink" title="默认 final 的好处"></a>默认 final 的好处</h5><p>类默认 final 带来了一个重要的好处就是这使得在大量的场景中的只能转换成为可能。</p><h5 id="智能转换的前提"><a href="#智能转换的前提" class="headerlink" title="智能转换的前提"></a>智能转换的前提</h5><p><strong>智能转换只能在进行类型检查后没有改变过的变量上起的作用。</strong>对于一个类来说，这意味着<strong>智能转换在val类型并且没有自定义访问器的类属性上使用</strong>。 这个前提意味着属性必须是 final 的，否则如果一个子类可以重写属性并且定义一个自定义的访问器将会打破智能转换的关键前提。</p><h5 id="抽象类的默认修饰符"><a href="#抽象类的默认修饰符" class="headerlink" title="抽象类的默认修饰符"></a>抽象类的默认修饰符</h5><p>抽象成员始终是open的，所以不需要显式地使用open修饰符。</p><h5 id="声明一个抽象类"><a href="#声明一个抽象类" class="headerlink" title="声明一个抽象类"></a>声明一个抽象类</h5><pre><code class="kotlin">abstract class Animated {    abstract fun animate()  // 这个函数是抽象的：它没有实现必须被子类重写    // 抽象类中的非抽象函数 并不是默认 open 的，但是可以标注为 open的    open fun stopAnimating() {    }    fun animateTwice() {}}</code></pre><h4 id="4-1-4-内部类和嵌套类：默认嵌套类"><a href="#4-1-4-内部类和嵌套类：默认嵌套类" class="headerlink" title="4.1.4 内部类和嵌套类：默认嵌套类"></a>4.1.4 内部类和嵌套类：默认嵌套类</h4><p>内部类：非静态嵌套类，也被成为内部类。</p><p>嵌套类：静态嵌套类，嵌套类多称为：静态嵌套类。</p><h5 id="Kotlin中嵌套类和Java中的不同"><a href="#Kotlin中嵌套类和Java中的不同" class="headerlink" title="Kotlin中嵌套类和Java中的不同"></a>Kotlin中嵌套类和Java中的不同</h5><p>在Kotlin中的嵌套类不能访问外部类的实例，除非你特别的做出要求。 </p><h5 id="在序列化时使用内部类"><a href="#在序列化时使用内部类" class="headerlink" title="在序列化时使用内部类"></a>在序列化时使用内部类</h5><p>在你定义一个 View 元素，它的状态时可序列化的。<strong>想要序列化一个视图可能并不容易，但是可以把所有需要的数据复制到另一个辅助类中去。</strong></p><pre><code class="kotlin">interface State : Serializableinterface View {    fun getCurrentState(): State    fun restoreState(state: State) {}}</code></pre><p>声明State接口去实现Serializable。View接口声明了可以用来保存视图状态的getCurrentState和restoreState方法。</p><h5 id="用内部类的java代码来实现View"><a href="#用内部类的java代码来实现View" class="headerlink" title="用内部类的java代码来实现View"></a>用内部类的java代码来实现View</h5><pre><code class="java">public class Button implements View{    @Override    public State getCurrentState(){        return new ButtonState();    }    @Override    public voiew restoreState(State state){        /**/    }    public class ButtonState implements State{        /**/    }}</code></pre><p>问题：在运行时你会得到 java.io.NotSerializable.Exception:Button 异常，在你序列化声明的按钮状态时。这个可能看起来会很奇怪：你序列化的变量是ButtonState类型，为什么会有Button异常呢？</p><h5 id="无法序列化的原因"><a href="#无法序列化的原因" class="headerlink" title="无法序列化的原因"></a>无法序列化的原因</h5><p>在java中，当你在另一个类中声明一个类时，它会默认变成内部类。案例中：ButtonState类隐示的存储了它的外部Button类的应用。从而解释了为什么ButtonState不能被序列化。</p><h5 id="修复无法序列化"><a href="#修复无法序列化" class="headerlink" title="修复无法序列化"></a>修复无法序列化</h5><p><strong>需要声明ButtonState类是static的</strong>。将嵌套类声明为static会冲这个类中删除包围它的类的隐式引用。</p><h5 id="在kotlin中使用嵌套类来实现-View"><a href="#在kotlin中使用嵌套类来实现-View" class="headerlink" title="在kotlin中使用嵌套类来实现 View"></a>在kotlin中使用嵌套类来实现 View</h5><pre><code class="kotlin">class Button : View {    override fun getCurrentState(): State {        TODO(&quot;Not yet implemented&quot;)    }    override fun restoreState(state: State) {        TODO(&quot;Not yet implemented&quot;)    }    // 这个类与Java中的静态潜逃类类似    class ButtonState : State {    }}</code></pre><p><strong>kotlin中默认行为是嵌套类。</strong></p><h5 id="如何让默认嵌套类的类型变为内部类！"><a href="#如何让默认嵌套类的类型变为内部类！" class="headerlink" title="如何让默认嵌套类的类型变为内部类！"></a>如何让默认嵌套类的类型变为内部类！</h5><p>要把它（嵌套类）变成为一个内部类来持有一个外部类的引用的话需要使用 <strong>inner</strong> 修饰符。</p><h5 id="kotlin中内部类访问外部类"><a href="#kotlin中内部类访问外部类" class="headerlink" title="kotlin中内部类访问外部类"></a>kotlin中内部类访问外部类</h5><p>在kotlin中引用外部类实例的语法与java不同。需要使用this@Outer从Inner类去访问Outer类。</p><h4 id="4-1-5-密封类：定义受限的类继承结构"><a href="#4-1-5-密封类：定义受限的类继承结构" class="headerlink" title="4.1.5 密封类：定义受限的类继承结构"></a>4.1.5 密封类：定义受限的类继承结构</h4><h5 id="什么是密封类”sealed“"><a href="#什么是密封类”sealed“" class="headerlink" title="什么是密封类”sealed“"></a>什么是密封类”sealed“</h5><p>sealed 类。为父类添加了一个新的 sealed 修饰符，可对创建的子类做出严格的限制。<strong>所有的子类必须嵌套在父类中。</strong></p><h5 id="为什么要使用密封类（定义受限的类继承结构）"><a href="#为什么要使用密封类（定义受限的类继承结构）" class="headerlink" title="为什么要使用密封类（定义受限的类继承结构）"></a>为什么要使用密封类（定义受限的类继承结构）</h5><p><strong>作为接口实现的表达式 👇</strong></p><pre><code class="kotlin">interface Exprclass Num(val value: Int) : Exprclass Sum(val left: Expr, val right: Expr):Exprfun eval(e: Expr): Int =    when (e) {        is Num -&gt; e.value        is Sum -&gt; eval(e.left) + eval(e.right)        else -&gt; // 必须检查 else 分支            throw  IllegalArgumentException(&quot;Unknown expression!&quot;)    }</code></pre><p><strong>当使用 when 结构来执行表达式的时候，Kotlin 编译器会强制检查默认选项</strong>。在这个例子中，<strong>不能返回一个有意义的值，所以直接返回异常状态。</strong></p><p>更重要的是，如果你添加了一个新的子类，编译器并不能发现你修改了。<strong>如果你忘记添加一个新的分支，就会选择默认选项，这又可能导致潜在的 bug。</strong></p><h5 id="如何使用密封类-“sealed”"><a href="#如何使用密封类-“sealed”" class="headerlink" title="如何使用密封类 “sealed”"></a>如何使用密封类 “sealed”</h5><pre><code class="kotlin">sealed class Expr { //将基类标记为封闭的    class Num(val value: Int) : Expr()    class Sum(val left: Expr, val right: Expr) : Expr() // 将所有可能的类作为嵌套类列出}fun eval(expr: Expr): Int =    // “when”表达式覆盖了所有的可能情况，所以不再需要 else 分支    when (expr) {        is Expr.Num -&gt; expr.value        is Expr.Sum -&gt; eval(expr.left) + eval(expr.right)    }</code></pre><p><strong>如果你在 when 表达式中处理了所有的 sealed 类的子类，你就不再需要提供默认分支。</strong>注意，sealed 修饰符隐含的这个类是一个 open 类，你不再需要显式地添加 open 修饰符。</p><h3 id="4-2-声明一个带默认构造方法或属性的类"><a href="#4-2-声明一个带默认构造方法或属性的类" class="headerlink" title="4.2 声明一个带默认构造方法或属性的类"></a>4.2 声明一个带默认构造方法或属性的类</h3><p><strong>kotlin中构造方法和java中有那些不同</strong></p><p>与java中一个类可以声明一个或多个构造方法。kotlin也是类似的，只是做出了一些修改：区分了主构造方法（通常是主要而简洁的初始化类的方法，并且在类体外部声明）和从构造方法。</p><h4 id="4-2-1-初始化类：主构造方法和初始化代码块"><a href="#4-2-1-初始化类：主构造方法和初始化代码块" class="headerlink" title="4.2.1 初始化类：主构造方法和初始化代码块"></a>4.2.1 初始化类：主构造方法和初始化代码块</h4><h5 id="什么是主构造方法。"><a href="#什么是主构造方法。" class="headerlink" title="什么是主构造方法。"></a>什么是主构造方法。</h5><pre><code class="kotlin">class User(val nickname:String)</code></pre><p>这段被括号围起来的代码块就叫<strong>做主构造方法</strong>。它有两个目的：表明构造方法的<strong>参数</strong>，以及定义使用这个<strong>参数</strong>的属性。</p><h5 id="明确的主构造方法声明"><a href="#明确的主构造方法声明" class="headerlink" title="明确的主构造方法声明"></a>明确的主构造方法声明</h5><pre><code class="kotlin">class User constructor(_nickname: String) {   // 带一个参数的主构造方法    val nickname: String    init {  // 初始化代码块        nickname = _nickname    }}</code></pre><p>现在来看看完成同样功能的代码具体是什么样子。</p><blockquote><p>两个关键词 <strong>construtor</strong> 和 <strong>init</strong>。 constructor 关键词用来开始一个<strong>构造方法</strong>或者<strong>从构造方法</strong>的声明。init 关键词用来引入初始化代码块。这种代码块包含了类在创建时执行的代码，并且会和主构造方法一起使用。<strong>因为主构造方法有语法限制，不能包含初始化代码，这就是需要初始化代码块（init）的原因。</strong>同时可以创建多个初始化代码块。</p></blockquote><h5 id="用参数来初始化属性"><a href="#用参数来初始化属性" class="headerlink" title="用参数来初始化属性"></a>用参数来初始化属性</h5><pre><code class="kotlin">class User(_nickname: String) { // 带一个参数的构造方法    val nickname: String = _nickname    // 用参数来初始化属性}</code></pre><blockquote><p>在例子中，不需要把初始化代码放在初始化代码块中，因为它可以与nickname属性声明结合。如果主构造方法没有注解或可见性修饰符，同样可以去除 constructor 关键词。</p></blockquote><h5 id="用最简洁的方法再次初始化类"><a href="#用最简洁的方法再次初始化类" class="headerlink" title="用最简洁的方法再次初始化类"></a>用最简洁的方法再次初始化类</h5><pre><code class="kotlin">class User(val nickname:String)    // “val” 意味相对应的属性会用构造方法的参数来初始化。</code></pre><p>前几个案例用 val 关键词声明了属性。如果属性用相对应的构造方法参数来初始化，<strong>代码可以通过把 val 关键词加载参数前的方法来简化它</strong>。可以用来代替类中的属性定义了。</p><h5 id="为构造方法提供默认值"><a href="#为构造方法提供默认值" class="headerlink" title="为构造方法提供默认值"></a>为构造方法提供默认值</h5><pre><code class="kotlin">class User(val nickname: String, val isSubscribed: Boolean = true) // 为构造方法提供一个默认值    </code></pre><p>可以像函数参数一样为构造方法声明默认值。</p><h5 id="如何让一个类不被其他代码实例化"><a href="#如何让一个类不被其他代码实例化" class="headerlink" title="如何让一个类不被其他代码实例化"></a>如何让一个类不被其他代码实例化</h5><p>如果想要你的类不被其他代码实例化，必须把构造方法标记为 private。</p><pre><code class="kotlin">class Secretive private constructor()   // 这个类有 private 构造方法</code></pre><h4 id="4-2-2-构造方法：用不同的方法来初始化方法"><a href="#4-2-2-构造方法：用不同的方法来初始化方法" class="headerlink" title="4.2.2 构造方法：用不同的方法来初始化方法"></a>4.2.2 构造方法：用不同的方法来初始化方法</h4><h5 id="为什么要使用多种方法初始化父类"><a href="#为什么要使用多种方法初始化父类" class="headerlink" title="为什么要使用多种方法初始化父类"></a><strong>为什么要使用多种方法初始化父类</strong></h5><p>最常见的一种就是当你需要扩展一个框架类来提供多个构造方法，以便于通过不同的方法来初始化类的时候。</p><h5 id="父类使用从构造方法"><a href="#父类使用从构造方法" class="headerlink" title="父类使用从构造方法"></a><strong>父类使用从构造方法</strong></h5><pre><code class="kotlin">open class View {    constructor(ctx: Context) { // 从构造方法        //some code    }    constructor(ctx: Context, attr: AttributeSet) { // 从构造方法        //some code    }}</code></pre><h5 id="扩展父类"><a href="#扩展父类" class="headerlink" title="扩展父类"></a>扩展父类</h5><pre><code class="kotlin">class MyButton : View {    constructor(ctx: Context) : super(ctx) {        // 调用父类构造方法    }    constructor(ctx: Context, attr: AttributeSet) : super(ctx, attr) {    }}</code></pre><h5 id="调用父类的另一个构造方法"><a href="#调用父类的另一个构造方法" class="headerlink" title="调用父类的另一个构造方法"></a>调用父类的另一个构造方法</h5><pre><code class="kotlin">class MyButton : View {    constructor(ctx: Context) : this(ctx, My_SYTLE) {        // 委托给这个类的另一个构造方法    }    constructor(ctx: Context, attr: AttributeSet) : super(ctx, attr) {    }}</code></pre><p>从<strong>构造方法</strong>中调用你自己类的另一个<strong>构造方法</strong>。</p><p>可以修改 MyButton类 <strong>使得一个构造方法委托给同一个类的另一个构造方法</strong>，为参数传入默认值，图下👇。第二个方法继续调用super()。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200906113216.png" alt=""></p><h4 id="4-2-3-实现在接口中声明的属性"><a href="#4-2-3-实现在接口中声明的属性" class="headerlink" title="4.2.3 实现在接口中声明的属性"></a>4.2.3 实现在接口中声明的属性</h4><h5 id="在接口中声明一个属性"><a href="#在接口中声明一个属性" class="headerlink" title="在接口中声明一个属性"></a>在接口中声明一个属性</h5><pre><code class="kotlin">interface User {    val nickname: String}</code></pre><p>接口可以包含抽象属性声明。</p><p>这意味这<strong>实现User接口的类需要</strong>提供一个取得nickname值的方式。</p><h5 id="实现接口中的属性-三种"><a href="#实现接口中的属性-三种" class="headerlink" title="实现接口中的属性 三种"></a>实现接口中的属性 三种</h5><p>第一种</p><pre><code class="kotlin">// 主构造方法属性class PrivateUser(override val nickname: String) : User {}</code></pre><p>对于 PrivateUser 来说，<strong>你是用了间接的语法直接在主构造方法中声明了一个属性</strong>。这个属性实现了来自于User的抽象属性，所以你将其标记为 override。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908100413.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908095819.png" alt=""></p><p>运行结果</p><p>第二种</p><pre><code class="kotlin">class SubscribingUser(val email: String) : User {    override val nickname: String get() = email.substringBefore(&#39;@&#39;)  // 自定义getter}</code></pre><p>对于 SubscribeingUser 来说，nikename属性通过一个自定义 getter 实现。<strong>这个属性没有一个支持字段来存储它的值，它只有一个 getter 在每次调用时从 email 中得到昵称。</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908100342.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908100257.png" alt=""></p><p>运行结果</p><p>第三种</p><pre><code class="kotlin">class FacebookUser(val accoundId: Int) : User {    override val nickname = getFacebookName(accoundId)  // 属性初始化    fun getFacebookName(text: String): String {        return text    }}</code></pre><p>nickname在SubscribingUser和FackbookUser中的不同实现。即使它们看起来很相似，第一个属性有一个自定义getter在每次访问时计算 subscringBefore，然后 FackbookUser中的属性有一个<strong>支持字段来存储在类初始化时计算得到数据</strong>。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908104646.png" alt=""></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200908111027.png" alt=""></p><p>运行结果</p><h4 id="4-2-4-通过-getter或setter访问支持字段"><a href="#4-2-4-通过-getter或setter访问支持字段" class="headerlink" title="4.2.4 通过 getter或setter访问支持字段"></a>4.2.4 通过 getter或setter访问支持字段</h4><p>关于两种属性的例子：存储值的属性和具有自定义访问器在每次访问时的属性。<strong>现在让我们来看看怎么结合这两种来实现一个既可以存储值又可以被值访问和修改时提供额外逻辑的属性。</strong>要支持这种情况，需要能够从属性的访问器中访问它的支持字段。</p><p>假设在任何适合对存储的属性中的数据进行修改时输出日志，你声明了一个可变属性并且在每次 setter 访问时执行额外的代码。</p><pre><code class="kotlin">/*    在 setter 中访问支持字段    */class User(val name:String) {    var address: String = &quot;unspecified&quot;        set(value: String){            println(&quot;&quot;&quot;                Address was changed for $name:&quot;$field&quot; -&gt; &quot;$value&quot;.&quot;&quot;&quot;.trinmIndent())    //读取支持字段的值                field = value    // 更新支持字段的值        }}</code></pre><pre><code class="kotlin">&gt;&gt;&gt; val user = User(&quot;Alice&quot;)&gt;&gt;&gt; user.address = &quot;Elasenheimerstrasse 47, 80687 Muenchen&quot;Address was changed for Alice:&quot;unspecified&quot; -&gt; &quot;Elsenheimerstrasse 47, 80687 Muenchen&quot;</code></pre><blockquote><p>可以像平常一样通过使用 user.address = “new value” 来修改一个属性的值，这其实在底层调用了setter。在这个例子中，setter 被重新定义了，所以额外的输出日志的代码被执行了（简单起见，这里直接将其打印出来）。</p><p>在 setter 的函数体中，使用了特殊的标识符 field来访问支持字段的值。在 getter 中，只能读取值：而在 setter 中，既能读取它也能修改它。</p></blockquote><h3 id="4-3-编译器生成的方法-数据类和委托"><a href="#4-3-编译器生成的方法-数据类和委托" class="headerlink" title="4.3 编译器生成的方法:数据类和委托"></a>4.3 编译器生成的方法:数据类和委托</h3><h4 id="4-3-2-数据类-自动生成通用方法的实现"><a href="#4-3-2-数据类-自动生成通用方法的实现" class="headerlink" title="4.3.2 数据类:自动生成通用方法的实现."></a>4.3.2 数据类:自动生成通用方法的实现.</h4><p>实现一个数据类需要重写方法:toString、equals和hashcode。</p><p><strong>数据类</strong></p><pre><code class="kotlin">data class Client(val name:String,val postalCode:Int)</code></pre><p>这是一个数据类,重写了所有标准的Java方法:</p><ul><li>equals 用来比较实例</li><li>hashCode用来作为例如HashMap这种基于哈希容器的键</li><li>toString用来为类生成按声明顺序排列的所有字段的字符串表达形式</li></ul><h3 id="4-4-“object”-关键字：-将声明一个类与创建一个实例结合起来"><a href="#4-4-“object”-关键字：-将声明一个类与创建一个实例结合起来" class="headerlink" title="4.4 “object” 关键字： 将声明一个类与创建一个实例结合起来"></a>4.4 “object” 关键字： 将声明一个类与创建一个实例结合起来</h3><p>这个关键词定义一个类并同时创建一个实例（换句话说就是一个对象）。</p><ul><li><strong>对象声明</strong>是定义一个单例的一种方式。</li><li><strong>伴生对象</strong>可以持有<strong>工场方法</strong>和其他与这个类的相关，但是在调用时并不依赖类实例方法。<strong>它们的成员可以通过类名来访问</strong>。</li><li><strong>对象表达式用来代替Java的匿名内部类</strong></li></ul><h4 id="4-4-1-对象声明：创建单例易如反掌"><a href="#4-4-1-对象声明：创建单例易如反掌" class="headerlink" title="4.4.1 对象声明：创建单例易如反掌"></a>4.4.1 对象声明：创建单例易如反掌</h4><h5 id="为什么使用对象声明？"><a href="#为什么使用对象声明？" class="headerlink" title="为什么使用对象声明？"></a>为什么使用对象声明？</h5><p>在面向对象系统中一个相当常见的情形就是只需要一个实例的类。例如，可以使用一个对象声明来表示一个组织的工资单。</p><h5 id="在Java中是如何实现单例模式？"><a href="#在Java中是如何实现单例模式？" class="headerlink" title="在Java中是如何实现单例模式？"></a>在Java中是如何实现单例模式？</h5><p>定义一个使用private构造方法并且用静态字段来持有这个类仅有的实例。</p><h5 id="什么是对象声明"><a href="#什么是对象声明" class="headerlink" title="什么是对象声明"></a>什么是对象声明</h5><p>Kotlin通过使用对象声明功能为这一切提供了最高级的语言支持。<strong>对象声明将类声明与该类的单一实例声明结合到了一起。</strong></p><h5 id="对象声明使用"><a href="#对象声明使用" class="headerlink" title="对象声明使用"></a>对象声明使用</h5><pre><code>object Payroll {    val allEmployees = arrayListOf&lt;Person&gt;()    fun calculateSalary() {        for (person in allEmployees){        }    }}</code></pre><p>对象声明通过 object 关键词引入。与类一样，一个对象声明也可以包含属性、方法、初始化语句块等的声明，唯一不允许的是构造方法。对象声明在定义时就创建了构造对象，不需要在代码的其他地方调用构造方法。对象声明同样可以继承类和接口。</p><h1 id="5-Lambda-编程"><a href="#5-Lambda-编程" class="headerlink" title="5 Lambda 编程"></a>5 Lambda 编程</h1><h2 id="5-1-Lambda表达式和成员引用"><a href="#5-1-Lambda表达式和成员引用" class="headerlink" title="5.1 Lambda表达式和成员引用"></a>5.1 Lambda表达式和成员引用</h2><h3 id="5-1-1-Lambda-简介：作为函数参数的代码块"><a href="#5-1-1-Lambda-简介：作为函数参数的代码块" class="headerlink" title="5.1.1 Lambda 简介：作为函数参数的代码块"></a>5.1.1 Lambda 简介：作为函数参数的代码块</h3><p>在代码中存储和传递一小段行为是常有的任务。例如，“当一个事件发生的时候运行这个事件处理器”又或是“把这个操作应用到这个数据结构的所有元素上”。在老版本的Java中可以使用匿名函数。</p><blockquote><p>使用函数式编程 提供了另外一种解决问题的方法：</p><p>把函数当作值来对待。可以直接传递函数，而不需要先声明一个类再传递一个类的实例。使用 lambda 表达式后代码会变的更加简洁。</p></blockquote><p>例子。假设你要定义一个点击按钮的行为，添加一个处理点击的监听器。监听器实现了想对应的接口 OnClickListener 和它的一个方法 onClick。</p><pre><code class="java">/*    用匿名内部类实现监听器    */button.setOnClickListener(new OnClickListener(){    @Override    public void onClick(View view){        /*点击之后执行的动作*/    }})</code></pre><p>使用匿名内部类的写法，更加冗余。接下来使用 lambda 写法</p><pre><code class="kotlin">/*    用 lambda 实现监听器    */button.setOnClickListener{    /*    点击后执行操作    */    }</code></pre><h3 id="5-1-2-Lamda-和-集合"><a href="#5-1-2-Lamda-和-集合" class="headerlink" title="5.1.2 Lamda 和 集合"></a>5.1.2 Lamda 和 集合</h3><p>良好的编程风格原则之一是避免代码的重复。我们对集合执行大部分任务都遵循这几个通用的模式，所以要实现这几个模式的代码应该放在一个库里。在没有 lambda 的帮助，很难为集合提供一个好用方便的库。</p><p>看个例子。</p><p>创建一个 Person 类，它包含了这个了的名字和年龄信息。</p><pre><code class="kotlin">data class Person(val name:String, val age :Int)</code></pre><p>假设你现在要在列表中找到年龄最大的那个人。</p><pre><code class="kotlin">/*    手动在集合中搜索    */fun findTheOldest(people:List&lt;Person&gt;){    var maxAge = 0    //存储最大年龄    var theOldest:Person ?= null //存储年龄最大的人    for (person in people){        if(person.age &gt; maxAge){    //如果下一个比现在年龄最大的人还要大，改变最大值            maxAge = person.age            theOldest = person        }    }    println(theOldest)}&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31))&gt;&gt;&gt; findTheOldest(people)Person(name = Bob,age = 31)</code></pre><pre><code class="kotlin">/*    用 lambda 在集合中搜索    */&gt;&gt;&gt; val people = listOf(Person(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31))&gt;&gt;&gt; println(people.maxBy{it.age})    // 比较年龄最大的元素Person(name = Bob, age = 31)</code></pre><p>maxBy函数可以在任何集合上调用，且只需要一个参数：函数指定比较哪个值来找到最大元素。</p><p>花括号中的代码 <strong>{it.age}</strong>就是实现了这个逻辑的lmabda。 它接收一个集合中的元素作为实参(作用 it 引用它)并且返回用来比较的值。在这个例子中，集合元素是Person对象，用来比较的是存储在其age属性中的年龄。</p><pre><code class="kotlin">/*    用成员引用    */people.maxBy(Person:age)</code></pre><h3 id="5-1-3-Lambda-表达式的语法"><a href="#5-1-3-Lambda-表达式的语法" class="headerlink" title="5.1.3 Lambda 表达式的语法"></a>5.1.3 Lambda 表达式的语法</h3><p>概述 lambda</p><blockquote><p>一个 lambda 把一小段行为进行编码，你能把它当作值到处传递。它可以被独立地声明并储存一个变量。</p></blockquote><pre><code class="kotlin">/*    lambda 表达式的语法    */{x:Int,y:Int -&gt; x+y}/*    参数 -&gt; 函数体    */</code></pre><blockquote><p>Kotlin 的lambda 表达式始终用花括号包围。实参并没有用括号括起来。箭头把实参列表和lambda 函数体隔开了。</p></blockquote><p>可以把 lambda表达式存储在一个变量中，把这个变量当作普通函数对待（即通过相应实参调用它）</p><pre><code class="kotlin">&gt;&gt;&gt; val sum = {x:Int,y:int -&gt; x+y}&gt;&gt;&gt; println(sum(1,2))    // 调用保存在变量中的lambda3</code></pre><blockquote><p>Kotlin 中的语法约定，如果 lambda 表达式是函数调用的最后一个实参，它可以放到括号外边。在这个例子中lambda是唯一的实参，所以可以放到括号外边</p><pre><code class="kotlin">people.maxBy(){p:Person -&gt; p.age}</code></pre><p>当 lamdba 是函数的唯一实参时，还可以去除调用代码中的空括号。</p><pre><code class="kotlin">people.maxBy{p:Person -&gt; p.age}</code></pre><p>三种语法形式的含义都是一样的，但最后都是易读的。如果lambda是唯一的实参，你当然愿意在写代码的时候省掉这个括号。而当你有多个实参时，既可以把lambda留在括号内来强调它是一个实参，也可以把它放在括号外面，两种选择都是可行的。如果你想传递两个或多个lamdba，不能把超过一个的lamdba放在外面。这时使用常规语法来传递它们通常是更好的选择。</p></blockquote><p>回顾 joinToString 函数 （对元素添加分隔符）。 Kotlin 标准库中也有定义它，标准库中的这个版本的不同之处在于它可以接收一个附加的函数参数。这个函数可以使用 toString函数以外的方法把一个元素转换成字符串。</p><p><strong>打印出人的名字</strong></p><pre><code class="kotlin">/*    把 lambda 作为命名实参传递    */&gt;&gt;&gt;val people = listOf(Person(&quot;Alice&quot;,31),Person(&quot;Bob&quot;,29))&gt;&gt;&gt;val names = people.joinToString(separator = &quot;&quot;,transform = {p:Person -&gt; p.name})&gt;&gt;&gt;println(names)Alices Bob</code></pre><p><strong>用更简单的方法</strong></p><pre><code class="kotlin">/*    把 lambda 放在括号外传递    */people.joinToString(&quot; &quot;){p:Person -&gt; p.name}</code></pre><p><strong>简化语法，移除参数类型</strong></p><pre><code class="kotlin">/*    省略 lambda 参数类型    */people.maxBy{p:Person -&gt; p.age}    // 显式地写出参数类型people.maxBY{p-&gt;p.age}    // 推导出参数类型</code></pre><p>和局部变量一样，如果 lambda 参数的类型可以被推导出来，你就不需要显式地指定它。以这里的 maxBy 为例子，其参数类型始终和集合的元素类型相同。编译器知道你是对一个Person对象的集合调用maxBy函数，所以它能推断出 lambda参数也会是Person类型。<strong>也存在不能推断出的情况，先遵循：先不声明类型，等编译器报错后再指定它。</strong></p><p><strong>最后的简化是使用默认参数名称 it 代替命名参数</strong></p><pre><code class="kotlin">/*    使用默认参数名称    */people.maxBy(it.age)    //&quot;it&quot;是自动生成的参数名称</code></pre><p>仅在参数名称没有显式地指定时这个默认的名称才会生成。</p><p><strong>可以用变量存储 lambda 表达式</strong></p><pre><code class="kotlin">&gt;&gt;&gt; val getAge = {p:Person -&gt; p.age}&gt;&gt;&gt; people.maxBy(getAge)</code></pre><blockquote><p>lambda 并没有被限制在这样小的规模，它可以包含更多的语句。</p></blockquote><pre><code class="kotlin">&gt;&gt;&gt; val sum = {x:Int,y:Int -&gt;    println(&quot;Computing the sum of $x and $y...&quot;)    x + y}&gt;&gt;&gt; println(sum(1,2))Computing the sum of 1 and 2...3</code></pre><h3 id="5-1-4-在作用域中访问变量"><a href="#5-1-4-在作用域中访问变量" class="headerlink" title="5.1.4 在作用域中访问变量"></a>5.1.4 在作用域中访问变量</h3><blockquote><p>在声明一个匿名内部类的时候，能够在这个匿名类内部引用这个函数的参数和局部变量。</p><p>而在使用 lambda 声明的时候，也可以做同样的事情。如果在函数内部使用 lambda 也可以访问这个函数的参数，还有在 lambda 之前定义的局部变量。</p></blockquote><p><strong>forEach 函数</strong></p><p> 用 forEach 函数展示 上述行为。</p><p>它是最基本集合操作函数之一；它所作的全部事情就是在集合中的每个元素上都调用给定的 lambda。forEach 函数比普通for 函数循环更简洁，除此之外没有其它优势，所以并不急于把所有的循环更改为  lambda。</p><pre><code class="kotlin">/*    在 lambda 中使用函数参数    */fun printMessageWithPrefix(message : Collection&lt;String&gt;,prefix:String){    messages.forEach{    // 接受 lambda 作为实参指定对每个元素操作        println(&quot;$prefix $it&quot;)    // 在 lambda 中访问 “prefix”    }}&gt;&gt;&gt; val errors = listOf(&quot;433 Forbidden&quot;,&quot;404 Not Found&quot;)&gt;&gt;&gt; printMessagesWithPrefix(errors,&quot;Error:&quot;)Error:403 ForbiddenError:404 Not Found</code></pre><blockquote><p>Kotlin 和 Java的一个显著区别就是，在 Kotlin 中不会仅限于访问 final 变量，在 lambda 内部也可以修改变量。</p></blockquote><pre><code class="kotlin">/*    在lambda中改变局部变量    */fun printProblemCounts(responeses:Collection&lt;String&gt;){    var clientErrors = 0    var serverErrors = 0    responeses.forEach{        if(it.startsWith(&quot;4&quot;)){            clientErrors ++        }else if(it.startsWith(&quot;5&quot;)){            serverErrors++        }    }    println(&quot;$clientErrors client error,$serverErrors server errors&quot;)}&gt;&gt;&gt; val responses = listOf(&quot;200 OK&quot;,&quot;418 I&#39;m a teapot&quot;,&quot;500 Internal Server Error&quot;)...&gt;&gt;&gt; printProblemCounts(responses)1 client errors,1 server errors</code></pre><blockquote><p>于 Java 不同，Kotlin 允许在 lambda 内部访问非 final 变量甚至修改它们。从 lambda 内访问外部变量，我们称这个变量被 <strong>lambda捕捉</strong>，如同上述的案例中的 prefix，clientErrors，serverErrors一样。</p></blockquote><p><strong>默认情况下，局部变量的声明期被限制在声明这个变量的函数中。但是如果它被lambda捕捉了，使用这个变量的代码可以被存储并稍后执行。</strong></p><p><strong>如果 lambda 被用作 <em>事件处理器</em> 或者用在其他 <em>异步执行</em> 的情况下，对局部变量的修改只会在 lambda 执行的时候发生。</strong></p><blockquote><p>反面案例</p><pre><code class="kotlin">fun tryToCountButtonClicks(button:Button):Int{    var clicks = 0    button.onClick{clicks++}    return clicks}</code></pre><p>这个函数始终返回0。尽管 onClick 处理器可以修改clicks的值，你并不能观察到值发生了变化，因为onClick处理器是在函数返回之后调用的。<strong>这个函数正确的实现方法需要把点击次数存储在函数外依然可以访问到的地方–例如类的属性，而不是存储在函数的局部变量中。</strong></p></blockquote><h3 id="5-1-5-成员引用"><a href="#5-1-5-成员引用" class="headerlink" title="5.1.5 成员引用"></a>5.1.5 成员引用</h3><p>​    如果把函数转换成一个值，你就可以传递它。</p><pre><code class="kotlin">val getAge = Person::age    //引用 age</code></pre><blockquote><p>这种表达式称为 <strong>成员引用</strong>，它提供了简明语法，来创建一个调用单个方法或者访问单个属性的函数值。 <strong>双冒号把类名称与你要引用的成员（一个方法或者一个属性）名称隔开</strong></p><pre><code class="kotlin">Person::age //类::成员</code></pre></blockquote><p>等价于 </p><pre><code class="kotlin">val getAge = {person:Person -&gt;person.age}</code></pre><blockquote><p>注意，不管你引用的是函数还是属性，都不要在成员引用的名称后面添加括号。</p></blockquote><blockquote><p>成员引用和调用该函数的lambda具有一样的类型，所以可以互换使用：</p><pre><code class="kotlin">people.maxBy(Person::age)</code></pre><p>还可以引用顶层函数</p><pre><code class="kotlin">fun salute() = println(&quot;Salute!&quot;)&gt;&gt;&gt; run(::salute)    // 引用顶层函数Salute!</code></pre><p>这种情况下，你省略了类名称，直接以::开头。成员引用::salute被当作实参传递给库函数run，它会调用想对应的函数。</p><p>如果 lambda 要委托给一个接收多个参数的函数，提供成员引用代替它将会非常方便</p><pre><code class="kotlin">val action = {person:Person,message:String -&gt;    sendEmail(person,massage)    //这个lambda委托sendEmail函数    }val nextAction = :: sendEmail    //用成员引用代替</code></pre><pre><code class="kotlin">/*    用构造方法引用存储或者延期执行创建类实例的动作。 构造方法引用的形式在双冒号后指定类的名称：    */data class Person(val name:String,val age:Int)&gt;&gt;&gt; val createPerson = :：Person    //创建Person实例的动作被保存成了值&gt;&gt;&gt; val p = createPerson(&quot;Alice&quot;,29)&gt;&gt;&gt; println(p)Person(name = Alice,age = 29)</code></pre><p><strong>可以用同样的方法引用扩展函数</strong></p><pre><code class="kotlin">fun Person.isAdult() = age &gt;= 21val predicate = Person::isAdult</code></pre><p>尽管 isAdult 不同类的成员，还是可以通过引用访问它，这个访问的成员没有两样：person.isAdult()。</p></blockquote><p><strong>绑定引用</strong></p><blockquote><p>在 kotlin 1.0 中 ，当接受一个类的方法或者属性引用时，你始终需要提供一个该类的实例来调用这个引用。Kotlin1.1计划支持绑定成员引用，它允许你使用成员引用语法捕捉特定实例对象的方法引用。</p><pre><code class="kotlin">&gt;&gt;&gt; val p = Person(&quot;Dmitry&quot;,34)&gt;&gt;&gt; val personAgeFunction = Person::age&gt;&gt;&gt; println(personsAgeFunction(p))34 &gt;&gt;&gt; val dmitrysAgeFunction = p::age&gt;&gt;&gt; println(dmitryAgeFunction())34</code></pre><p>注意，personsAgeFunction是一个当参数函数（返回给定了的年龄），而dmitryAgeFunction是一个零参数的函数（返回已经指定好的人的年龄）。</p><p>在 Kotlin1.1之前，你需要显式地写出 lambda{p.age},而不是使用绑定成员引用p::age。</p></blockquote><h2 id="5-5-带接收者的lambda：“with”与“apply”"><a href="#5-5-带接收者的lambda：“with”与“apply”" class="headerlink" title="5.5 带接收者的lambda：“with”与“apply”"></a>5.5 带接收者的lambda：“with”与“apply”</h2><h5 id="什么是带接收者的-lambda？"><a href="#什么是带接收者的-lambda？" class="headerlink" title="什么是带接收者的 lambda？"></a>什么是带接收者的 lambda？</h5><blockquote><p>Kotlin 中独特的 lambda 功能：在lambda函数体内可以调用一个不同的对象方法，而且无需借助任何额外的限定符。</p></blockquote><p><strong>接收者：</strong>调用者</p><h3 id="5-5-1-“with”-函数"><a href="#5-5-1-“with”-函数" class="headerlink" title="5.5.1 “with” 函数"></a>5.5.1 “with” 函数</h3><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><blockquote><p>对同一个对象执行很多次操作，不需要反复把对象名称写出来。</p></blockquote><h5 id="构建字母表"><a href="#构建字母表" class="headerlink" title="构建字母表"></a>构建字母表</h5><pre><code class="kotlin">fun alphabet(): String {    val result = StringBuilder()    for (letter in &#39;A&#39;..&#39;Z&#39;) {        result.append(letter)    }    result.append(&quot;\n Now I know the alphbet!&quot;)    return result.toString()}</code></pre><pre><code class="kotlin">fun main() {    println(alphabet())}</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201022214803.png" alt=""></p><h5 id="使用场景（为什么要用”with“）"><a href="#使用场景（为什么要用”with“）" class="headerlink" title="使用场景（为什么要用”with“）"></a><strong>使用场景</strong>（为什么要用”with“）</h5><p>案例中多次调用到 “<strong>result</strong>“实例。使用”<strong>with</strong>“减少对实例的调用。</p><h5 id="如何使用-”with“？"><a href="#如何使用-”with“？" class="headerlink" title="如何使用 ”with“？"></a>如何使用 ”with“？</h5><pre><code class="kotlin">fun alphabet(): String {    val result = StringBuilder()    return with(result) {// 指定接收者的值        for (letter in &#39;A&#39;..&#39;Z&#39;) {            this.append(letter) // 显式的使用‘this’来调用接收者值的方法（result.appned()方法）        }        append(&quot;\n Now I know the alphabet!&quot;)   // 隐藏 ‘this’ 同样可以使用        this.toString()    }}</code></pre><pre><code class="kotlin">fun main() {    println(alphabet())}</code></pre><h5 id="”with“的结构"><a href="#”with“的结构" class="headerlink" title="”with“的结构"></a>”with“的结构</h5><blockquote><p>with 结构看上去像是一种特殊的语法结构，但它实际上是一个接收两个参数的函数：这个例子中两个参数分别是 stringBuilder 和 lambda 。</p></blockquote><p>with 函数把第一个参数转换为第二个参数传递给 lambda 的接收者。</p><h5 id="在普通函数中与扩展函数中带接收者的-lambda-有那些不同"><a href="#在普通函数中与扩展函数中带接收者的-lambda-有那些不同" class="headerlink" title="在普通函数中与扩展函数中带接收者的 lambda 有那些不同"></a>在普通函数中与扩展函数中带接收者的 lambda 有那些不同</h5><blockquote><p>在扩展函数体内部，this 指向了这个函数扩展的那个类型实例，而且也可以被省略掉，让你直接访问接收者的成员。</p></blockquote><h3 id="5-5-2-“apply”-函数"><a href="#5-5-2-“apply”-函数" class="headerlink" title="5.5.2 “apply” 函数"></a>5.5.2 “apply” 函数</h3><h5 id="apply-和-with-的不同"><a href="#apply-和-with-的不同" class="headerlink" title="apply 和 with 的不同"></a>apply 和 with 的不同</h5><blockquote><p>apply 函数同with 函数功能相同，区别在于 apply 始终会返回作为实参传递给它的对象。（返回本身作为实例）</p></blockquote><pre><code class="kotlin">fun alphabet() = StringBuilder().apply {    for (letter in &#39;A&#39;..&#39;Z&#39;) {        append(letter)    }    append(&quot;\n Now I know the alphbet!&quot;)}.toString()</code></pre><p>apply 被声明成一个扩展函数。它的<strong>接收者</strong>变成了作为实参的 lambda 的接收者。执行 apply 的结果是StringBuilder,所以接下来里可以调用 toString 把它转换成 String。</p><p><strong>使用apply初始化一个TextView</strong></p><pre><code class="kotlin">fun createViewWithCustomAttributes(context : Context) = {    TextView(context).apply{        text = &quot;Sample Text&quot;        textSize = 20.0        setPadding(10,0,0,0)    }}</code></pre><p><strong>apply函数允许里使用紧凑的表达式函数体风格</strong>。新的<strong>TextView</strong>实例<strong>创建</strong>之后立即被传给了<strong>apply</strong>。</p><p><strong>那个是接收者?</strong></p><p>TextView实例变成了 (lambda 的) 接收者，你可以调用它的属性和方法。</p><p>with 函数和 apply 函数是最基本和最通用的使用带接收者的 lambda 的例子。更多的函数也可以使用这种模式。例如，使用<strong>标准库函数buildString进一步简化alphbet函数</strong>，它会负责<strong>创建StringBuilder</strong>并<strong>调用toString</strong>。<strong>building实际是带接收者的lambda</strong>，<strong>接收者</strong>就是<strong>StringBuilder</strong>。</p><p><strong>使用buildString创建字母表</strong></p><h2 id="5-6-小结"><a href="#5-6-小结" class="headerlink" title="5.6 小结"></a>5.6 小结</h2><h1 id="6-Kotlin的类型系统"><a href="#6-Kotlin的类型系统" class="headerlink" title="6  Kotlin的类型系统"></a>6  Kotlin的类型系统</h1><h2 id="6-1-可空性"><a href="#6-1-可空性" class="headerlink" title="6.1 可空性"></a>6.1 可空性</h2><h3 id="6-17-“let”-函数"><a href="#6-17-“let”-函数" class="headerlink" title="6.17 “let” 函数"></a>6.17 “let” 函数</h3><p>用来处理可空表达式。和安全调用运算符一起使用，允许你对表达式求值，检查求值结果是否null，并把结果保存为一个变量。</p><pre><code class="kotlin">fun sendEmailTo(email : String){    println(&quot;Sending emaill to $emaill&quot;)}&gt;&gt;&gt; var email:String ? = &quot;yole@example.com&quot;&gt;&gt;&gt; email?.let{sendEmailTo(it)}&gt;&gt;&gt; emaill = null&gt;&gt;&gt; emaill?.let{    sendEmailTo(it)        }</code></pre><blockquote><p>所以说只有这段表达式不为空时才会执行代码块里的代码</p></blockquote><h3 id="6-18-延迟初始化的属性"><a href="#6-18-延迟初始化的属性" class="headerlink" title="6.18 延迟初始化的属性"></a>6.18 延迟初始化的属性</h3><h4 id="使用-延迟初始化属性的原因"><a href="#使用-延迟初始化属性的原因" class="headerlink" title="使用 延迟初始化属性的原因"></a>使用 延迟初始化属性的原因</h4><blockquote><p>Kotlin 通常要求你在构造方法中初始化所有属性，如果某个属性是可空类型，你就必须提供一个非空的初始化值。否则，你就必须使用可空类型。如果你这样做，该属性的每一次访问都需要null检查或者！！运算符</p></blockquote><p><strong>使用非空断言访问可控属性</strong></p><pre><code class="kotlin">class MyService{    fun performAction():String = &quot;foo&quot;}class MyText{    private var myService : MyService ?= null    // 声明了一个可空类型初始化为 null    @Before fun setUp(){    // 在 setUp方法中提供真正的初始化器        myService = MyService()    }    @Test fun testAction(){        Assert.assertEquals(&quot;foo&quot;,myService!!.performAction())    // 必须注意可空性：要么用&quot;!!&quot;，要么用&quot;?.&quot;    }}</code></pre><p><strong>使用延迟初始化</strong></p><pre><code class="kotlin">class MyService{    fun performAction():String = &quot;foo&quot;}class MyText{    private lateinit var myService : MyService    // 声明了一个不需要初始化器的非空类型属性    @Before fun setUp(){    // 在 setUp 方法中初始化 myService        myService = MyService()    }    @Test fun testAction(){        Assert.assertEquals(&quot;foo&quot;,myService.performAction())    // 不需要 null 检查直接访问属性    }}</code></pre><p>注意</p><blockquote><p>初始化的属性必须为var，因为需要在构造方法外修改它的值，使用val属性被编译时必须在构造方法中初始化final片段。</p><p>尽管 myService 属性是非空的，你不需要在构造方法中初始化它。在属性没有被初始化之前调用会得到异常 “lateinit property myService has not been initialized”。</p><p>lateinit 属性常见的一种用法是在依赖注入。在某种情况下，lateinit 属性的值是被依赖注入框架从外部设置的。为了保证和各种依赖注入框架的兼容性</p><p>，Kotlin 会自动生成一个和 lateinit 属性具有相同可见性的字段。如果属性的可见性是public，生成的字段意思public</p></blockquote><h1 id="8-高阶函数：Lambda作为形参和返回值"><a href="#8-高阶函数：Lambda作为形参和返回值" class="headerlink" title="8 高阶函数：Lambda作为形参和返回值"></a>8 高阶函数：Lambda作为形参和返回值</h1><p><strong>内联函数作用</strong></p><p>能够消除lambda带来的性能开销，还能够使lambda内的控制流更加灵活。</p><h2 id="8-1-声明高阶函数"><a href="#8-1-声明高阶函数" class="headerlink" title="8.1 声明高阶函数"></a>8.1 声明高阶函数</h2><p>定义</p><blockquote><p>高阶函数就是以另一个函数作为参数或者返回值的函数。在kotlin中，函数可以用lambda或者函数引用来表示。因此，<strong>任何以lambda或者函数引用作为参数的函数，或者返回值为lambda或函数引用的函数</strong>，或者两者都有满足的函数都是高阶函数。</p></blockquote><p>标准库中的filter函数将一个判断式函数作为参数，因此它是一个高阶函数：</p><pre><code class="kotlin">list.filter{x&gt;0}</code></pre><h3 id="8-1-1-函数类型"><a href="#8-1-1-函数类型" class="headerlink" title="8.1.1 函数类型"></a>8.1.1 函数类型</h3><p>在变量中我们有<strong>Int类型</strong>，<strong>String类型</strong>等那么也有属于函数的<strong>函数类型</strong>。</p><p>声明一个lambda作为实参的函数，你需要知道如何声明对应形参的类型。在那之前，看接下来的例子，把 lambda 表达式保存在局部变量中。在不声明类型的情况下，这些就依赖于Kotlin的类型推导。</p><pre><code class="kotlin">val sum = {x:Int,y:Int -&gt; x+y}val action = {println(42)}</code></pre><p>编译器推导出sum和action两个变量具有<strong>函数类型</strong>。</p><p>显式声明<strong>函数类型的变量</strong></p><pre><code class="kotlin">val sum:(Int ,Int) -&gt; Int = {x,y-&gt;x+y}    // 有两个Int类型参数和Int类型返回值val action:() - &gt; Unit = { println(42) }    //没有参数和返回值</code></pre><p>声明函数类型，需要将函数参数类型放在括号中，紧接着是一个箭头和函数的返回值类型。</p><pre><code class="kotlin">(Int,String) -&gt; Unit// ↑参数类型    ↑返回类型</code></pre><p>在声明函数类型时Unit是不能省略的，其他情况下可以。</p><p>函数类型的返回值标记为可空类型：</p><pre><code class="kotlin">val canReturnNull: (Int,Int) -&gt; Int?={null}</code></pre><p>定义函数类型的可空变量。</p><blockquote><p>为了明确表示是变量本身可空，而不是函数类型的返回类型可空，你需要将整个函数类型的定义包含在括号内并在括号后添加问号。</p><pre><code class="kotlin">val funOrNull:((Int,Int) -&gt; Int) ?= null</code></pre></blockquote><h3 id="8-1-2-调用作为参数的函数"><a href="#8-1-2-调用作为参数的函数" class="headerlink" title="8.1.2 调用作为参数的函数"></a>8.1.2 调用作为参数的函数</h3><p>实现一个高阶函数。</p><p>实现2，3两个数字的任意操作。</p><blockquote><p>函数类型作为参数，形参和实参更像是接口，形参是接口实参则用来具体的实现。</p></blockquote><p>定义一个简单的高阶函数</p><pre><code class="kotlin">//    定义一个函数类型的参数fun twoAndThree(operation: (Int,Int) -&gt; Int){    val result = opration(2,3)    // 调用参数（函数类型）    println(&quot;The result is $result&quot;)}&gt;&gt;&gt; twoAndThree{a,b -&gt; a+b}The result is 5&gt;&gt;&gt; twoAndThree(a,b -&gt; a*b)The result is 6</code></pre><p>实现最常用的标准库函数：filter函数。为了更让事情更简单一些，将实现基于String类型的filter函数，但和作用于泛型的版本原理是显示的。</p><pre><code class="kotlin">/* &quot;String&quot;:接收者类型。    “predicate”：参数类型    “(Char) -&gt; Boolean”：函数类型参数    “Char”:函数类型参数的参数类型    “Boolean”：函数类型的参数返回类型    */fun String.filter(predicate:(Char) -&gt; Boolean):String</code></pre><blockquote><p>filter 函数的声明，以一个判断式作为参数</p></blockquote><p>判断式的类型是一个函数，以字符作为参数并返回boolean类型的值。如果要让传递给判断式的字符出现在最终返回的字符串中，判断式需要返回ture，反之false。</p><pre><code class="kotlin">//    实现一个简单版本的filer函数fun String.filter(predicate: (Char) -&gt; Boolean):String{    val sb = StringBuilder()    for (index in 0 until length){        val element = get(index)        if (predicate(element)) sb.append(element)    // 调用引用的String类型参数给predicate函数进行判断    }    return sb.toString()}&gt;&gt;&gt; println(&quot;ab1c&quot;.filter{it in &#39;a&#39;..&#39;z&#39;})    //传递 lambda 作为 &#39;predicate&#39;参数abc</code></pre><blockquote><p>filter 函数的实现非常简单明了。它检查每个字符时候满足判断式，如果满足就将字符添加到包含结果的StringBuilder中。</p></blockquote><h3 id="8-1-3-在Java中使用函数类"><a href="#8-1-3-在Java中使用函数类" class="headerlink" title="8.1.3 在Java中使用函数类"></a>8.1.3 在Java中使用函数类</h3><p><strong>原理</strong></p><blockquote><p>函数类型被声明为普通的接口：一个函数类型的变量是<strong>FunctionN接口的实现</strong>。</p><p>Kotlin 标准库定义了一系列的接口，这些接口对应于不同的参数数量的函数：<strong>Function0<R>(没有参数的函数)、Function&lt;P1,R&gt;(一个参数的函数)</strong>。</p><p>每个接口定义了一个 invoke 方法，调用这个方法就会执行函数。</p><p>一个函数类型的变量就是实现了对应的Function接口的实现类的实力，实现类的invoke方法包含了lambda函数体。</p></blockquote><p><strong>在 Java 中调用使用了函数类型的 Kotlin 函数。</strong></p><pre><code class="kotlin">/*    kotlin声明    */fun processTheAnswer(f:(Int) -&gt;){    println(f(42))}</code></pre><pre><code class="kotlin">/*    Java    */&gt;&gt;&gt; processTheAnswe(number -&gt; number+1);43</code></pre><p>在旧版 Java 中，可以传递一个实现了函数接口中 invoke 方法的匿名类的实例：</p><pre><code class="java">/*    Java    */&gt;&gt;&gt; processTheAnswer(...        new Function1&lt;Integer,Integer&gt;(){    // 在Java 8 以前使用函数类型...            @Override...            public Integer invoke(Integer number){...                System.out.println(number);...                return number+1;...                }...        });43</code></pre><p>在 Java 中使用函数类型必须显示地传递一个接收者对象作为第一个参数。</p><p>在Java中可以很容易地使用 Kotlin 标准库中以lambda作为参数的扩展函数。</p><pre><code class="java">/*    Java    */&gt;&gt;&gt; List&lt;String&gt; strings = new ArrayList()；&gt;&gt;&gt; strings.add(&quot;42&quot;)&gt;&gt;&gt; CollectionKt.forEach(strings, s -&gt;{    //可以在Java中使用Kotlin标准库中的函数...        System.out.println(a);...        return unit.INSTANCE;    // 必须显示的返回一个Unit类型的值。...})</code></pre><blockquote><p>在 Java 中 ，函数或许lambda可以返回Unit。因为在 Kotlin 中 Unit 类型是有值的，所以需要显示的返回它。</p><p>一个返回 void 的lambda 不能作为返回 Unit 的函数类型的实参，就像之前的例子中的(String) -&gt;Unit.</p></blockquote><h3 id="8-1-4-函数类型的参数默认值和null值"><a href="#8-1-4-函数类型的参数默认值和null值" class="headerlink" title="8.1.4 函数类型的参数默认值和null值"></a>8.1.4 函数类型的参数默认值和null值</h3><p>声明函数类型的参数时可以指定参数的默认值。</p><p><strong>用来理解参数默认值的关键作用</strong></p><pre><code class="kotlin">/*    使用了硬编码toString转换的joinToString函数    */fun &lt;T&gt; Collection&lt;T&gt;.joinToString(        separator: String = &quot;,&quot;,        prefix: String = &quot;&quot;,        postfix: String = &quot;&quot;): String{        val result = StringBuilder(prefix)        for ((index,element) in this.withIndex()){            if(index &gt;0) result.append(separator)            result.append(element)    // 使用默认toString方法将对象转换成字符串        }        result.append(postfix)        return result.toString()}</code></pre><blockquote><p>这里的实现很灵活但是并没有让你控制转换的关键点： 集合中的原始是如何转换成字符串的。</p></blockquote><blockquote><p>这里使用 StringBuilder.append(o:Any?) (result.append(element)),他总是使用toString方法将对象转换成字符串。在大多数情况下这样是可以的，但是不总是这样。</p></blockquote><blockquote><p>现在可以传递一个lambda去指定如何将对象转换成字符串。</p></blockquote><blockquote><p>但是要求所有调用者都传递lambda是比较烦人的，因为大部分调用者使用默认的行为就可以了。为了解决这个问题，可以定义一个函数类型的参数并用一个lambda作为它的默认值。</p></blockquote><pre><code class="kotlin">/*    给函数类型的参数指定默认值    */fun &lt;T&gt; Collection&lt;T&gt;.joinToString(        separator: String = &quot;,&quot;,        prefix: String = &quot;&quot;,        postfix: String = &quot;&quot;,        transform: (T) -&gt; String = {it.toString()}    //声明一个lambda为默认值的函数类型的参数): String {        val result = StringBuilder(prefix)        for ((index,element) in this.withIndex()){            if(index &gt; 0 ) result.append(separator)            result.append(transform(element))    // 调用作为实参的element传递给 “transform”形参的函数        }        result.append(postfix)        return result.toString()}&gt;&gt;&gt; val letters = listOf(&quot;Alpha&quot;,&quot;Beta&quot;)&gt;&gt;&gt;  println(letters.joinToString())    // 使用默认的转换函数Alpha, Beta&gt;&gt;&gt; println(letters.joinToString{it.toLowerCase()})    // 传递一个 lambda 作为参数alpha,beta&gt;&gt;&gt; println(letters.joinToString(separator = &quot;!&quot;,postifx = &quot;!&quot;, transform = {it.ToUpperCase()}))    // 使用命名参数参数语法几个参数，包括lambda。ALPHA,BETA</code></pre><blockquote><p>这个带默认值的函数类型是一个泛型参数T表示集合中的元素类型。 Lambda transform 将接收这个类型的参数。</p></blockquote><blockquote><p>声明函数类型的默认值并不需要特殊的语法，只需要把 lambda 作为值放在 = 号后。上述例子展示了多种方式调用函数类型。</p></blockquote><p><strong>声明函数类型其参数是可空的</strong></p><pre><code class="kotlin">/*    案例1    一般情况*/fun foo(callback: (() -&gt;Unit)?){    if(callback != null){        callback()    }}</code></pre><blockquote><p>这里不能直接调用作为参数传递进行的函数：Kotlin 会因为检查到潜在的空指针异常而导致编译失败。<strong>这里可选的办法是显式地检查null</strong>。</p></blockquote><pre><code class="kotlin">/*    使用函数类型的可空参数    */fun &lt;T&gt; Collection&lt;T&gt;.joinToString(        separator: String = &quot;,&quot;,        prefix: String = &quot;&quot;,        postfix: String = &quot;&quot;,        transform:    ((T) -&gt; String ) ?=null    // 声明一个函数类型的可空参数): String{    val result = StringBuilder(prefix)    for ((index,element) in this.withIndex()){        if (index &gt; 0) result.append(separator)        val str = transform?.invoke(element)    // 使用安全调用语法，调用函数            ?: element.toString()    //使用 Elvis 运算符处理回调没有被指定的情况        result.append(str)    }    result.append(postfix)    return result.toString()}</code></pre><blockquote><p>这是一个更简单的版本，它利用了一个事实 ，函数类型是包含 invoke 方法的接口具体实现。作为一个普通方法，invoke可以通过安全调用语法被调用：callback?.invoke()方法</p></blockquote><h3 id="8-1-5-返回函数的函数"><a href="#8-1-5-返回函数的函数" class="headerlink" title="8.1.5 返回函数的函数"></a>8.1.5 返回函数的函数</h3><pre><code class="kotlin">/*    定义一个返回函数的函数    */enum class Delivery {STANDARD, EXPEDITED}class Order(val itemCount:Int)fun getShippingCostCalculator(delivery:Delivery):(Order)-&gt;Double{    // 声明返回函数的函数    if (delivery == Delivery.EXPEDITEM){    // 返回 lambda        return {order -&gt; 6+2.1 * order.itemCount}    }    return {order -&gt;1.2*order.itemCount}}&gt;&gt;&gt; val calculator = getShippingCostCalculator(Delivery.EXPEDITEM)    // 将返回的函数保存在变量中&gt;&gt;&gt; println(&quot;Shapping costs ${calculator(Order(3))}&quot;)    // 调用返回的函数Shipping costs 12.3</code></pre><blockquote><p><strong>使用场景</strong></p><p>例如，运输费用的计算依赖于选择恰当的逻辑变体并将它作为另一个函数返回。<strong>声明一个 返回另一个函数的函数，需要指定一个函数类型作为返回类型。</strong></p><p>函数 getShippingCostCalculator返回一个函数，这个函数以Order最为参数并返回一个Double类型的值。</p><p><strong>要返回一个函数，需要写一个return表达式，跟上一个lambda、一个成员引用，或者其他的函数类型的表达式，比如一个函数的局部变量。</strong></p></blockquote><p><strong>另一个返回函数的例子</strong></p><blockquote><p>例如，你可以在 UI 上输入一个字符串，然后只显示那些名字以这个字符串开头的联系人；还可以隐藏没有电话号码的联系人。用ContactListFilters这个类来保存这个选项的状态。</p></blockquote><pre><code class="kotlin">class ContactListFilters{    var prefix: String = &quot;&quot;    var onlyWithPhoneNumber: Boolean = false}</code></pre><blockquote><p>当用户输入 D 来查看姓或者名以 D 开头的联系人时，prefix的值会被更新。</p></blockquote><pre><code class="kotlin">/*    在UI代码中定义一个返回函数的函数    */data class Persion(    val firstName:String,    val lastName:String,    val phoneNumber:String?)class ContactListFilters{    val prefix:String = &quot;&quot;    val onlyWithPhoneNumber: Boolean = false    fun getPredicate():(Person) -&gt; Boolean{    //声明一个返回函数的函数        val    startWithPrefix  = {p:Persion -&gt; p.firstName.startsWith(prefix) || p.lastName.startsWith(prefix)        }        if (!onlyWithPhoneNumber){            return startWithPrefix    // 返回一个函数类型的变量        }        return { startsWithPrefix(it)&amp;&amp;it.phoneNumber != null }    //从函数返回一个lambda    }}&gt;&gt;&gt; val contacts = listOf(Persion(&quot;Dmitry&quot;,&quot;Jemeroy&quot;,&quot;123-4567&quot;),...                          Persion(&quot;Svetlane&quot;,&quot;Isakova&quot;,null))&gt;&gt;&gt; val contactListFilters = ContactListFilters()&gt;&gt;&gt; with (contactListFilters){&gt;&gt;&gt;        prefix = &quot;Dm&quot;&gt;&gt;&gt;     onlyWithPhoneNumber = true&gt;&gt;&gt; }&gt;&gt;&gt; println(contacts.filter(...        contactListFilters.getPredicate()))        // 将 getPredicate 返回的函数作为参数传递给 “filter” 函数[Persion (firstName = Dmitry,lastName = Jemetov,phoneNumber = 123-4567)]</code></pre><blockquote><p>为了让展示联系人列表的逻辑代码和输入的过滤条件的UI条件解耦，可以定义一个函数来创建一个判断式，用来过滤联系人列表。判断式检查前戳，如果有需要也检查电话号码时候存在。</p></blockquote><blockquote><p>getPredicate 函数返回一个函数（类型）的值，这个值被传递给filter作为参数。</p></blockquote><h3 id="8-1-6-通过lambda-去除重复代码"><a href="#8-1-6-通过lambda-去除重复代码" class="headerlink" title="8.1.6 通过lambda 去除重复代码"></a>8.1.6 通过lambda 去除重复代码</h3><p>例子</p><blockquote><p>这是一个分析网站访问的例子。SiteVisit类用来保存每次访问的如今、持续时间和用户的操作系统。不同的操作系统使用枚举来表示。</p></blockquote><pre><code class="kotlin">/*    定义站点访问数据    */data calss SiteVisit(    val path: String,    val dutation: Double,    val os: OS    )enum class OS{ WINDOWS,LINUX,MAC,IOS,ANDROID}val log = listOf(    SiteVisit(&quot;/&quot;,34.0,OS.WINDOWS),    SiteVisit(&quot;/&quot;,22.0,OS.MAC),    SiteVisit(&quot;/login&quot;,12.0,OS.WINDOWS),    SiteVisit(&quot;/signup&quot;,8.0,OS.IOS),    SiteVisit(&quot;/&quot;,16.3.OS.ANDROID))</code></pre><blockquote><p>需要显示来自 Windows 的平均访问时间，可以使用 average 函数来完成这个任务。</p></blockquote><pre><code class="kotlin">/*    使用硬编码的过滤器分析站点访问数据    */val averageWindowsDutation = log    .filter {it.os == OS.WINDOWS}    .map(SiteVisit::dutation)    .avaerage()&gt;&gt;&gt;println(averageWindowsDutaion)23.0</code></pre><blockquote><p>显示来自于Windows机器的平均访问时间，用 average 函数来完成任务。</p></blockquote><pre><code class="kotlin">/*    使用普通的方法去除重复代码    */fun List&lt;SiteVisit&gt;.averageDurationFor(os:OS) = filter{it.os == os}.map(SiteVisit::dutation).average()    // 将重复代码抽取到函数中&gt;&gt;&gt; println(log.averageDurationFor(OS.WINDOWS))23.0&gt;&gt;&gt; println(log.averageDurationFor(OS.MAC))22.0</code></pre><blockquote><p>现在你要计算一个来自MAC用户的相同数据，为了避免重复，可以将平台类型抽象成一个参数.</p><p>注意这个函数作为扩展函数增强了可读性。如果它值在局部的上下文中有用，你甚至可以将这个函数声明为局部的扩展函数。</p></blockquote><pre><code class="kotlin">/*    用一个重复的硬编码函数分析站点访问数据    */val averageMobileDutation = log    .filter{it.os == setOf(OS.IOS,OS.ANDROID)}    .map(SiteVisit::duration)    .average()&gt;&gt;&gt; println(averageMobileDuration)12.15</code></pre><blockquote><p>如果你对移动平台的访问的平均时间感兴趣。</p><p>这时已经不能再再用简单的参数表示不同的平台了。可能还需要使用更加复杂的条件查询日志，比如，“来自IOS平台对注册页面的访问平均时间是多少？”</p><p><strong>可以使用函数类型将需要的条件抽象到一个参数中</strong></p></blockquote><pre><code class="kotlin">/*    用高阶函数去除重复代码    */fun List&lt;SiteVisit&gt;.averageDutationFor(predicate:(SiteVisit) -&gt; Boolean) = filter(predicate).map(SiteVisit::duration).average()&gt;&gt;&gt; println(log.averageDurationFor{...        it.os in setOf(OS.ANDROID,OS.IOS)})12.15&gt;&gt;&gt; println(log.averageDurationFor{...        it.os == OS.IOS &amp;&amp; it.path == &quot;/signup&quot;    // 满足系统为IOS，访问地址为 注册界面的条件})8.0</code></pre><blockquote><p>函数类型可以帮助去除重复代码。使用lambda，不仅可以去除重复的数据，也可以去除重复的行为。</p></blockquote><h2 id="8-2-内联函数：消除lambda带来的运行时开销"><a href="#8-2-内联函数：消除lambda带来的运行时开销" class="headerlink" title="8.2 内联函数：消除lambda带来的运行时开销"></a>8.2 内联函数：消除lambda带来的运行时开销</h2><blockquote><p>Kotlin 中传递 lambda 作为函数参数的简明语法与普通的表达式语法很相似。</p><p>lambda 表达式会被正常地编译成匿名类。这表示每调用一次 lambda 表达式，就会额外的创建一个类。并且如果 lambda 捕捉了某个变量，那么每次调用的时候都会创建一个新的对象。这会带来运行时的额外开销，导致使用 lambda 比使用一个直接执行相同代码的函数效率更低。</p><p>有没有可能让编译器生成跟 Java 语句相同高效的代码，但还是能把重复的逻辑抽取到库函数中呢？（作用）</p><p>如果使用 <strong>inline</strong> 修饰符标记一个函数，在函数被使用的时候编译器并不会生成函数调用的代码，而是使用函数实现的真实代码替换每一次的函数调用。</p></blockquote><p><strong>内联函数简介</strong></p><blockquote><p>在<a href="https://baike.baidu.com/item/计算机科学" target="_blank" rel="noopener">计算机科学</a>中，<strong>内联函数</strong>（有时称作<strong>在线函数</strong>或<strong>编译时期展开函数</strong>）是一种<a href="https://baike.baidu.com/item/编程语言" target="_blank" rel="noopener">编程语言</a>结构，用来建议<a href="https://baike.baidu.com/item/编译器" target="_blank" rel="noopener">编译器</a>对一些特殊<a href="https://baike.baidu.com/item/函数" target="_blank" rel="noopener">函数</a>进行内联扩展（有时称作<strong>在线扩展</strong>）；也就是说建议编译器将指定的函数体插入并取代每一处调用该函数的地方（<a href="https://baike.baidu.com/item/上下文" target="_blank" rel="noopener">上下文</a>），从而节省了每次调用函数带来的额外时间开支。但在选择使用内联函数时，必须在程序占用空间和程序执行效率之间进行权衡，因为过多的比较复杂的函数进行内联扩展将带来很大的存储资源开支。另外还需要特别注意的是对<a href="https://baike.baidu.com/item/递归函数" target="_blank" rel="noopener">递归函数</a>的内联扩展可能引起部分编译器的无穷编译。</p></blockquote><h3 id="8-2-1-内联函数如何运作"><a href="#8-2-1-内联函数如何运作" class="headerlink" title="8.2.1 内联函数如何运作"></a>8.2.1 内联函数如何运作</h3><blockquote><p><strong>内联函数！</strong></p><p>当一个函数被声明为 inline 时，它的函数体是内联的–换句话说，函数体会被直接替换到函数被调用的地方，而不是被正常调用。</p></blockquote><pre><code class="kotlin">/*    定义一个内联函数    */inline fun &lt;T&gt; sysnchronized(lock:Lock,action : () -&gt; T):T{    lock.lock()    try{        return action()    }    finally    {        lock.unlock()    }}val l = Lock()synchronized(1){    //...}</code></pre><blockquote><p>函数用于确保一个共享资源不会并发地被多个线程访问。函数锁住一个Lock对象，执行代码块。</p></blockquote><blockquote><p>调用这个函数的语法跟Java中使用 synchronized 语法完全一直。<strong>区别</strong>，Java 的 synchronized 语法可以用于任何对象，这个函数则要求传入一个Lock实例。</p><p>同时，Kotlin 标准库中定义了一个可以接受任何对象作为参数的 synchronized 函数版本。</p><p>这里使用同步操作时显式的对象锁能够提升代码的可读性和维护性。</p></blockquote><blockquote><p><strong>使用 inline 的效果！</strong></p><p>因为已经将 synchronized 函数声明为 inline，所以每次调用它所生成的代码跟 Java 的synchronized 语句都是一样的。</p></blockquote><p><strong>使用 synchronized 的例子。</strong></p><pre><code class="kotlin">fun foo(l:Lock){    println(&quot;Before sync&quot;)    synchronized(1){        println(&quot;Action&quot;)    //内联函数    }    println(&quot;After sync&quot;)}</code></pre><pre><code class="kotlin">/*    编译后的 foo 函数    */fun _foo_(l:Lock){    println(&quot;Before sync&quot;)    //这是调用者 foo 的代码    l.lock()    // 这是被内联的 synchronized 函数代码    try(        println(&quot;Action&quot;)    //被内联的lmabda题代码    )finally{        l.unlock()        //这是调用者 foo 的代码    }    println(&quot;After sync&quot;)    //这是调用者 foo 的代码}</code></pre><blockquote><p>展示的是作用相同的代码，将会被编译成同样的字节码。</p></blockquote><blockquote><p>这里 lambda 表达式 和 synchronized 函数实现了内联。</p><p>由于lambda 生成的字节码成为了函数调用这定义的部分，而不是被包含在一个实现了函数接口的匿名类中</p></blockquote><pre><code class="kotlin">/*    调用内联函数的时候可以传递函数类型的变量作为参数    */class LockOwner(val lock:Lock){    fun runUnderLock(body:() -&gt; Unit){        synchronized(lock,body)    //作为函数类型的变量作为参数，而不是lambda    }}</code></pre><blockquote><p>使用函数类型的变量作为参数，不会被内联。</p></blockquote><blockquote><p>只有synchronized 函数体被内联了，lambda 才会被正确调用。</p></blockquote><pre><code>/*    runUnderLock 的函数字节码    */class LockOwner(val lock:Lock){    fun runUnderLock(body:() -&gt; Unit){    //函数类似于真正的runUnberLock被编译成的字节码        lock.lock()        try{            body() // body 没有被内联，因为在调用到地方换没有 lambda        }finally{            lock.unlock()        }    }}</code></pre><h3 id="8-2-2-内联函数的限制"><a href="#8-2-2-内联函数的限制" class="headerlink" title="8.2.2 内联函数的限制"></a>8.2.2 内联函数的限制</h3><blockquote><p>鉴于内联的运作方式，不是所有使用lambda的函数都可以被内联的。</p></blockquote><blockquote><p>当函数被内联的时候，作为参数的lambda表达式函数体会被直接替换成最终生成的代码中。这会限制函数体中对应的（lambda）参数使用。如果（lambda）参数被调用，这样的代码能被容易的内联。<strong>但是如果（lambda）参数在某个地方被保存起来，一遍后边可以继续使用，lambda表达式的代码将不能被内联，因为必须要有一个包含这些代码的对象存在。</strong></p></blockquote><blockquote><p>一般来说，参数如果被直接调用或者作为参数传递给另外一个inline函数，它是可以被内联的。否则，编译器会禁止参数被内联并给出错误信息“Illeal usage of inline-parameter”</p></blockquote><blockquote><p>例如，许多作用域序列的函数会返回一些类的实例，这些类代表对应的序列操作并接受lambda作为构造参数。 这是 Sequence.map函数的定义：</p></blockquote><pre><code class="kotlin">fun &lt;T,R&gt; Sequence&lt;T&gt;.map(transform:(T) -&gt; R):Sequence&lt;R&gt;{    return TransformingSequence(this,transform)}</code></pre><blockquote><p>map 函数没有直接调用作为 transform参数传递进来的函数。而是将这个函数传递给类的构造方法，构造方法将它保存在一个属性中。</p><p>这时为了支持这一点，作为transform参数传递的lambda需要被编译成标准的非内联的表达式，即实现了一个函数接口的匿名类。</p></blockquote><blockquote><p> 当函数期望两个或多个 lambda 参数，可以选择只内联其中一些参数。这是有道理的，因为一个lambda可能会包含很多代码或者不允许内联的方式使用。接受这样的非内联lambda的参数，可以用 noinline 修饰符来标记它：</p><pre><code class="kotlin">inline fun foo(inlined:() -&gt; Unit,noinlune notInlined:() -&gt; Unit){    //...}</code></pre></blockquote><h3 id="8-2-3-内联集合操作"><a href="#8-2-3-内联集合操作" class="headerlink" title="8.2.3 内联集合操作"></a>8.2.3 内联集合操作</h3><p>Kotlin 标准库中操作集合函数的性能。大部分标准库中的集合函数都带有lambda参数。<strong>不管使用标准库函数，还是直接实现这些操作效率都是一样的。</strong></p><p>我们来比较一下。</p><pre><code class="kotlin">/*    使用lambda过滤一个集合    */data class Person(val name:String,val age:Int)val people = listOf(Persion(&quot;Alice&quot;,29),Person(&quot;Bob&quot;,31))&gt;&gt;&gt; println(people.filter(it.age&lt;30))[Person(name = Alice,age = 29)]</code></pre><pre><code class="kotlin">/*    手动过滤一个集合 不用lambda表达式来实现*/&gt;&gt;&gt; val result = mutableListOf&lt;Person&gt;()&gt;&gt;&gt; for (person in people){&gt;&gt;&gt;         if(person.age &lt; 30) result.add(person)&gt;&gt;&gt;}&gt;&gt;&gt; println(result)[Person(name = &quot;Alice&quot;, age = 29)]</code></pre><blockquote><p>Kotlin 对内联函数的支持让你不必担心性能问题。</p></blockquote><blockquote><p>在Kotlin中，filter 函数被声明为内联函数。这意味着 filter 函数，以及传递给它的lambda的字节码会被一起内联到filter被调用的地方。最终，第一种实现所产生的字节码和第二种实现所产生的字节码大致是一样的。你可以很安全地使用符合语言习惯的集合操作。</p></blockquote><blockquote><p>现象你在连续使用 filter 和 map 两个操作。</p><pre><code class="kotlin">&gt;&gt;&gt; println(people.filter{it.age &gt; 30}...                .map (Persion::name))[Bob]</code></pre><p><strong>这个例子使用了 lambda 表达式和一个成员引用。</strong></p><p>这里 filter 和 map 都被声明为了 inline 函数，所以他们的函数体会被内联，因此不会产生额外的类和对象。上述的代码却创建了一个中间集合来把偶出来列表过滤的结果，由 filter 函数生成的代码会向这个集合种添加元素，而由 map 函数生成的代码会读取这个几个。</p><p><strong>如果有大量的元素需要处理，中间集合的运行开销将成为不可忽视的问题，这时可以在调用链后加上一个asSequence调用，用序列代替集合。</strong></p><p>同时如同上一节看到的一样，用于处理序列的 lambda 不能够被内联，每个中间序列被表示成lambda保存在其字段中的对象，<strong>而末端操作会导致由每个中间序列调用组成的链被执行</strong>。因此，即便序列上的操作是惰性的，你不应该总是试图在集合操作的链后<strong>asSequence</strong>。只有在处理大量数据时有用，小的集合可以用普通集合处理。</p></blockquote><h3 id="8-2-4-决定何时将函数声明成内联"><a href="#8-2-4-决定何时将函数声明成内联" class="headerlink" title="8.2.4 决定何时将函数声明成内联"></a>8.2.4 决定何时将函数声明成内联</h3><p>使用 inline 关键词只能提高 lambda 参数的函数性能，其他情况需要额外的度量和研究。</p><p><strong>将带有 lambda 参数的函数内联能够带来什么好处。</strong></p><blockquote><p>首先， 通过内联避免运行时开销更加明显了。毕竟节约了函数运行时的开销，而且节约了 lambda 创建匿名类，以及创建 lambda 实例对象的开销。其次，JVM 还没有聪明到总是能将函数调用内联。内联可以使用一些不可能被普通 lambda 使用的特征，比如非局部返回。</p></blockquote><p><strong>注意</strong></p><blockquote><p><strong>在使用 inline 关键字的时候，你还是应该注意代码的长度。如果你要内联的函数不大，将它的字节码拷贝到每一个调用点将会极大地增加字节码的长度。在这种情况下，你应该将那些与 lambda 参数无关的代码抽取到一个独立的非内联函数中。在 Kotlin 中内联函数总是很小的。</strong></p></blockquote><h3 id="8-2-5-使用-内联-lambda-管理资源"><a href="#8-2-5-使用-内联-lambda-管理资源" class="headerlink" title="8.2.5  使用 内联 lambda 管理资源"></a>8.2.5  使用 内联 lambda 管理资源</h3><p><strong>Lambda 可以去除重复代码的一个常见模式是资源模式</strong></p><blockquote><p>先获取资源，完成一个操作，释放资源。</p><p>这里资源表示多种不同的东西：一个文件、一个锁、一个数据库事务等。</p><p>实现这个模式的标准做法是使用 try/finally 语句。资源在 try 代码块之前被获取，在 finally 代码块中释放。</p></blockquote><p><strong>synchronization</strong></p><blockquote><p>前部分讲到将 try/finally的逻辑封装在一个函数中，然后将使用资源的代码作为 lambda 传递给这个方法。</p><p>synchronization将一个锁对象作为参数。</p></blockquote><p>代替 <strong>synchronization</strong></p><blockquote><p>Kotlin 标准库定义了一个叫 withLock的函数，它提供了实现同样功能的更符合语言习惯的API：它是 Lock 接口的扩展函数。</p><p>如何使用。</p><pre><code class="kotlin">val l:Lock = ...l.withLock{    // access the resource protected by this lock 在加锁的情况下执行指定的操作。}/*    在Kotlin标准库中的定义    */fun &lt;T&gt; Lock.withLock(action : () -&gt; T):T{    //需要加锁的代码被抽取到一个独立的方法中    lock()    try{        return action()    } finally{        unlock()    }}</code></pre></blockquote><p><strong>文件是另一种可以使用这种模式的常见资源类型。（文件使用 资源模式）</strong></p><blockquote><p>Java 7 为这种模式引入了特殊的语法：try-with-resource 语句。</p><pre><code class="kotlin">/*    下述代码来读取文件的第一行Java方法    *//*    在Java中使用try-with-resource语句    */static String readFirstLineFromFile(String path) throws IOException{    try(BufferedReader br = new BufferedReader(new FileReader(path))){        return br.readLine();    }}</code></pre><p>Kotlin 中并没有等价的语法，因为通过使用一个带有函数类型参数的函数可以无缝地完成相同的事情。这个函数叫use()</p><p><strong>使用 use 函数 重写上述代码</strong></p><pre><code class="kotlin">/*    使用use函数作为资源管理    */fun readFirstLineFromFile (path:String):String{    BufferedReader(FileReader(path)).use{    // 构成 BufferedReader，调用 “use” 函数，传递一个lambda执行文件操作        br -&gt; return br.readLine()    // 从函数中返回文件的一行    }}</code></pre><p>use 函数是一个扩展函数，被用来操作可关闭的资源，它接受一个lambda作为参数。这个返回调用lambda并且确保资源被关闭，无论lambda正常执行饭是抛出了异常。当然使用use函数是内联函数，所以使用它并不会引发任何性能开销。</p></blockquote><h2 id="8-3-高阶函数中的控制流"><a href="#8-3-高阶函数中的控制流" class="headerlink" title="8.3 高阶函数中的控制流"></a>8.3 高阶函数中的控制流</h2><p>把 return 语句放在循环的中间是很简单的事情，但是如果将循环转换成一个类似于 <strong>filter （filter 是内联函数）</strong> 的函数呢？这种情况下 return 会如何工作。</p><h3 id="8-3-1-lambda-中的返回语句：从一个封闭的函数返回"><a href="#8-3-1-lambda-中的返回语句：从一个封闭的函数返回" class="headerlink" title="8.3.1 lambda 中的返回语句：从一个封闭的函数返回"></a>8.3.1 lambda 中的返回语句：从一个封闭的函数返回</h3><p>比较两种不同的 遍历集合的返回： 在下面的代码清单中，如果一个人的名字是 “Alice” ，就应该从函数lookForAlice 返回。</p><pre><code class="kotlin">/*    在一个普通循环中使用return    */data class Person(val neme:String, val age:Int)val people = listOf(Person (&quot;Alice&quot;,29),Person(&quot;Bob&quot;,11))fun lookForAlice(people:List&lt;Person&gt;){    for (person in people){        if (person.name == &quot;Alice&quot;){            println(&quot;Found!&quot;)            return        }    }    println(&quot;Alice is not found&quot;)     //如果“people”中没用Alice，这一行就会被打印出来}&gt;&gt;&gt; lookForAlice(people)Found!</code></pre><blockquote><p>使用 forEach迭代重写这段代码安全吗？</p><pre><code class="kotlin">/*    在传递给 forEach 的lambda 中使用 return    */fun lookForAlice(people:List&lt;Person&gt;){    people.forEach{        if (it.name == &quot;Alice&quot;){            println(&quot;Found!&quot;)            return        }    }    println(&quot;Alice is not found&quot;)    //和上一个代码清单中的效果是一样的}</code></pre><p>这是安全的</p></blockquote><blockquote><p>当你在 lambda 中使用 return 关键字，它会从调用 lambda 的函数中返回，并不是从 lambda 中返回。这个叫做<strong>非局部返回</strong>。<strong>因为它从一个比包含 return 的代码块更大的代码块中返回了。</strong></p></blockquote><blockquote><p>为了理解这条规则背后的逻辑，从Java函数中在for循环或者synchronized 代码块中使用 return 关键字。显然这会从函数中返回，而不是从循环或者代码块中返回。使用以 lambda 作为参数的函数的时候 kotlin 保留了同样的行为。</p></blockquote><blockquote><p>需要注意的是，<strong><em>只有在以 lambda 作为参数的函数是内联函数的时候才能从跟外层的函数返回。</em></strong>在上述代码中，forEach 的函数体和lambda的函数体一起被内联了，所以在编译的时候能很容易做到从包含它的函数中返回。在 非内联函数的lambda 中使用 return 表达式是不允许的。一个非内联函数可以把传给它的lambda保存在变量中，以便在函数返回以后可以继续使用，这个时候lambda先去影响函数的返回已经太晚了。</p></blockquote><h3 id="8-3-2-从-lambda-返回：使用标签返回"><a href="#8-3-2-从-lambda-返回：使用标签返回" class="headerlink" title="8.3.2 从 lambda 返回：使用标签返回"></a>8.3.2 从 lambda 返回：使用标签返回</h3><p><strong>标签返回</strong></p><blockquote><p>可以在lambda表达式总使用<strong>局部返回</strong>。</p><p>lambda 中的局部返回跟 for 循环中的 break 表达式显示。它会终止 lambda 的执行，并接着从调用 lambda 的代码处执行。</p></blockquote><p><strong>区分 局部返回和非局部返回</strong></p><blockquote><p>要区分局部返回和非局部返回，要用到<strong>标签</strong>。</p><p><strong>如何区分。</strong></p><p>想从 lambda 表达式处返回你可以标记它，然后在 return 关键字后面引用这个标签。</p></blockquote><pre><code class="kotlin">/*    用一个标签实现局部返回    */fun lookForAlice(people:List&lt;Person&gt;){    people.forEach lable@{    // ←给lambda表达式加上标签        if (it.name == &quot;Alice&quot;) return@label    //← return@label 引用了这个标签    }    println(&quot;Alice might be somewhere&quot;)    //这里总被打印}&gt;&gt;&gt; lookForAlice(people)Alice might be somewhere!</code></pre><blockquote><p><strong>如何使用标签</strong></p><p>要标记一个lambda表达式，在 lambda 的花括号之前放一个标签名，接着放一个 @ 符号。（标签名可以是任意的）、</p><p>要从一个lambda返回，在return关键词后放一个@符号，接着放标签名。</p><pre><code class="kotlin">// “label@” lambda标签people.forEach label@{    if (it.name == &quot;Alice&quot;) return@label //返回表达式标签}/*    用 “@” 符号标记一个标签从一个lambda返回    */</code></pre></blockquote><blockquote><p><strong>另一种方式，使用 lambda 作为参数的函数的函数名可以作为标签</strong></p><pre><code class="kotlin">/*    用函数名 return 标签    */fun lookForAlice(people:List&lt;Person&gt;) {    people.forEach{        if(it.name == &quot;Alice&quot;)    return@forEach    // ←return@forEach从 lambda 表达式返回    }    println(&quot;Alice might be somewhere&quot;)}</code></pre><p>当里显式的<strong>指定了 lambda 表达式的标签</strong>，再使用函数名作为标签没有任何效果。</p><p>一个 lambda 表达式的标签数量不能多于一个。</p></blockquote><blockquote><p><strong>带标签的 “this” 表达式</strong></p><p>同样的规则也适用于this表达式。在带接收者的lambda中–包含一个隐式上下文对象的lamdba也有通过一个this去访问。</p><p>如果你给带接收者 lambda 指定标签，就可以通过对应的带有标签的this表达式访问它的隐式接收者。</p><pre><code class="kotlin">&gt;&gt;&gt; println(StringBuilder().apply sb@{    // 这个 lambda 隐式接收者可以通过 this@sb 访问...        listOf(1,2,3).apply{    // ”this”指定作用域内最近的隐式接收者...            this@sb.append(this.toString())    // 所以隐式接收者都可以被访问，外层的接收者通过显式的标签访问...        }...    })     [1,2,3]</code></pre><p>局部返回的语法相当冗长，如果一个 lambda 包含多个返回语句会变得更加笨重。所以这里可以使用 <strong>匿名函数。</strong></p></blockquote><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h3 id="字段和属性"><a href="#字段和属性" class="headerlink" title="字段和属性"></a>字段和属性</h3><p><a href="https://blog.csdn.net/chenchunlin526/article/details/71424844" target="_blank" rel="noopener">深入理解Java中的字段与属性的区别</a></p><h4 id="属性和字段的区别"><a href="#属性和字段的区别" class="headerlink" title="属性和字段的区别"></a>属性和字段的区别</h4><p>属性（property），通常可以理解为get 和 set 方法。</p><p>字段（field），通常叫做 <strong>类成员</strong>，或者 <strong>类变量</strong> ，有时也叫 域 ，理解为 数据成员，用来承担数据的。</p><h4 id="属性和字段详解"><a href="#属性和字段详解" class="headerlink" title="属性和字段详解"></a>属性和字段详解</h4><p><strong>字段（field）</strong></p><p>类成员（字段field），通常在类中定义成员变量例如：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200909213136.png" alt=""></p><p>解释为：<strong>FacebookUser类拥有成员变量nickname，有一个字段 nickname。</strong></p><p>字段一般用于承担数据，所以为了数据的安全性，一般设置为私有的。</p><p>字段和常量描述的类的数据（域），当这些数据的某些部分不运行外界访问时，<strong>根据”对象封装“原则，应该尽量避免将类的字段以公有方式提供给外部</strong>。除啦final修饰的常量。</p><p><strong>属性（property）</strong></p><p><strong>属性只局限于类中方法的声明，并不与类中其它成员相关</strong>，数据JavaBean范畴：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200909220317.png" alt=""></p><p>这是一个属性，一个字段。</p><p>总结：属性是对字段的封装，供外部访问。通常<strong>属性</strong>将对应的<strong>私有字段</strong>通过封装成公共属性，以便于外界访问和修改。</p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>是指可以被求值的代码。</p><p>例如</p><pre><code class="c">int result = add(x + 1,y)</code></pre><blockquote><p>x + 1 作为表达式传递了数值</p></blockquote><pre><code class="c">int result = add（if(x==1),y）</code></pre><blockquote><p>这段语句在 c 中是没有办法作为表达式的。</p></blockquote><h3 id="Kotlin-this表达式"><a href="#Kotlin-this表达式" class="headerlink" title="Kotlin this表达式"></a>Kotlin this表达式</h3><p>为了表示当前的 <strong>接收者</strong> 使用 this{:.keyword} 表达式：</p><ul><li>在类的成员中，this{:.keyword}指的是当前对象</li><li>在扩展函数或者带接受者的函数字面值中，this{:.keyword}表示在点左侧的接收者参数。</li></ul><h3 id="函数引用"><a href="#函数引用" class="headerlink" title="函数引用"></a>函数引用</h3><p>函数引用 是kotlin引入的一个功能。使用(::)表示对函数的引用</p><p>代码</p><pre><code class="kotlin">val sum:(Int,Int) -&gt; Int = {x,y -&gt; x +y}</code></pre><blockquote><p>sum 是一个函数类型的变量，lambda表达式执行了相加的操作。</p></blockquote><pre><code class="kotlin">fun applyOp(x: Int, y: Int, op: (Int, Int) -&gt; Int): Int = op(x, y)</code></pre><p>applyOp 是一个接受三个参数的函数，第三个参数是lambda类型。可以用下面的返回调用这个函数：</p><pre><code class="kotlin">applyOp(2,3,sum)</code></pre><p>即高阶函数可以作为一个类型赋值给变量，也可以作为另一个函数的参数。</p><h4 id="函数引用：函数可以是一个-lambda"><a href="#函数引用：函数可以是一个-lambda" class="headerlink" title="函数引用：函数可以是一个 lambda"></a>函数引用：函数可以是一个 lambda</h4><p>上述的lambda表达式，可以用纯函数的形式：</p><pre><code class="kotlin">fun sum(x: Int, y: Int) = x + y</code></pre><p>实现效果是一样的，区别在于不再需要使用变量来保持对函数的引用，但是这样需要对applOp函数要做一些修改，原来的</p><p><strong>applOp(2,3,sum)</strong>写法会报类型不匹配的语法错误。需要修改为使用<strong>函数引用</strong>代码如下：</p><pre><code class="kotlin">applOp(2,3,::sum)</code></pre><p>这些算是 函数引用 的大致概念。同时<strong>函数引用</strong>也是可以赋值给变量的。</p><pre><code class="kotlin">val sumLambda: (Int, Int) -&gt; Int = ::sumapplyOp(2, 3, sumLambda)</code></pre><p><strong>引用：</strong></p><p><a href="https://www.web3.xin/code/2606.html" target="_blank" rel="noopener">Kotlin this表达式</a></p><p><a href="https://www.jianshu.com/p/10358883455c" target="_blank" rel="noopener">kotlin中的函数引用详解</a>    </p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-8-3-1.gif" alt="如果有些方法没有详细说明你可以自行搜索查看"></p>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RecyclerView在Kotlin中的使用</title>
      <link href="/2020/07/26/RecyclerView%E5%9C%A8Kotlin%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/07/26/RecyclerView%E5%9C%A8Kotlin%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="创建项目RecyclerExample项目"><a href="#创建项目RecyclerExample项目" class="headerlink" title="创建项目RecyclerExample项目"></a>创建项目RecyclerExample项目</h2><h3 id="需要引入依赖"><a href="#需要引入依赖" class="headerlink" title="需要引入依赖"></a>需要引入依赖</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595735673809.png" alt=""></p><h3 id="需要子项布局"><a href="#需要子项布局" class="headerlink" title="需要子项布局"></a>需要子项布局</h3><p>在 “RecyclerViewExample\app\src\main\res\layout”下创建 “example_item.xml” 👇</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.cardview.widget.CardView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;&gt;    &lt;RelativeLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;match_parent&quot;        android:padding=&quot;8dp&quot;&gt;        &lt;ImageView            android:id=&quot;@+id/image_view&quot;            android:layout_width=&quot;50dp&quot;            android:layout_height=&quot;50dp&quot;            android:layout_marginEnd=&quot;8dp&quot;            android:src=&quot;@drawable/ic_baseline_android_24&quot; /&gt;        &lt;TextView            android:id=&quot;@+id/text_view_1&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_toEndOf=&quot;@+id/image_view&quot;            android:text=&quot;Line 1&quot;            android:textColor=&quot;@color/cardview_dark_background&quot;            android:textSize=&quot;18sp&quot; /&gt;        &lt;TextView            android:id=&quot;@+id/text_view_2&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_below=&quot;@+id/text_view_1&quot;            android:layout_toEndOf=&quot;@+id/image_view&quot;            android:text=&quot;Line 2&quot; /&gt;    &lt;/RelativeLayout&gt;&lt;/androidx.cardview.widget.CardView&gt;</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595735521036.png" alt=""></p><p>需要自定义的图片 ↓</p><p>选中”drawable”文件夹,选中”New”,选中”Vactor Asset”</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200915232142.png" alt=""></p><p>选中”Clip Art” 选中喜欢的图形就可以了。点击 “Next”,再点击 Finish。 创建三个。</p><h3 id="需要-数据类👇"><a href="#需要-数据类👇" class="headerlink" title="需要 数据类👇"></a>需要 数据类👇</h3><p>在 “recyclerviewexample” 包下</p><pre><code>/** *   @DATE : 2020/7/26 *   @Time : 11:42 *   @By : TheCara *   &quot;data&quot; 数据类 */data class Exampleitem(val imageResource: Int, val text1: String, val text2: String)</code></pre><h3 id="需要适配器"><a href="#需要适配器" class="headerlink" title="需要适配器"></a>需要适配器</h3><p>需要适配器”ExampleAdapter”</p><pre><code>/** *   @DATE : 2020/7/27 *   @Time : 15:54 *   @By : TheCara *   需要继承RecyclerView.Adapter类型 *   需要内嵌类继承RecyclerView.ViewHolder类型 */class ExampleAdapter(private val exampleList: List&lt;ExampleItem&gt;) :    RecyclerView.Adapter&lt;ExampleAdapter.ExampleViewHolder&gt;() {    // 关键方法，用于确定列表项    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ExampleViewHolder {        val view = LayoutInflater.from(parent.context).inflate(R.layout.example_item, parent, false)        return ExampleViewHolder(view)    }    override fun getItemCount() = exampleList.size    // 将数据和容器绑定    override fun onBindViewHolder(holder: ExampleViewHolder, position: Int) {        val currenItem = exampleList[position]        holder.imageView.setImageResource(currenItem.imageResource)        holder.textView1.setText(currenItem.text1)        holder.textView2.setText(currenItem.text1)    }    // 获得每个控件的实例,需要ExampleViewHolder的参数(子项布局)作为RecyclerView.ViewHolder()用作实例化    class ExampleViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {        val imageView: ImageView = itemView.image_view        val textView1: TextView = itemView.text_view_1        val textView2: TextView = itemView.text_view_2    }}</code></pre><p>在”MainActivity”修改</p><pre><code>class MainActivity : AppCompatActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        val listExample = generateDummyList(500)        recycler_view.adapter = ExampleAdapter(listExample)        // 设置RecyclerView的布局管理器        recycler_view.layoutManager = LinearLayoutManager(this)        // 确保RecyclerView的尺寸是一个常数        recycler_view.setHasFixedSize(true)    }    // 获得布局中的数据    private fun generateDummyList(size: Int): List&lt;ExampleItem&gt; {        val list = ArrayList&lt;ExampleItem&gt;()        // 使⽤区间&quot;until&quot;        for (i in 0 until size) {            val drawable = when (i % 4) {                0 -&gt; R.drawable.ic_baseline_add_to_home_screen_24                1 -&gt; R.drawable.ic_baseline_airline_seat_flat_angled_24                2 -&gt; R.drawable.ic_baseline_airline_seat_recline_extra_24                else -&gt; R.drawable.ic_baseline_android_24            }            val item = ExampleItem(drawable, &quot;Line $i&quot;, &quot;Line 2&quot;)            list += item        }        return list    }}</code></pre><p>👆”setHasFixedSize()”方法:当我们确定Item的改变不会影响RecyclerView的宽高时,可以<strong>设置这个方法</strong>,并且Adapter的增删方法去刷新RecyclerView,而不是通过notifyDataSetChanged()。(其实可以直接设置为true，当需要改变宽高的时候就用notifyDataSetChanged()去整体刷新一下)</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595841353310.png" alt=""></p><h2 id="添加-增删-功能"><a href="#添加-增删-功能" class="headerlink" title="添加 增删 功能"></a>添加 增删 功能</h2><h2 id="使用RecyclerView在案例中需要什么"><a href="#使用RecyclerView在案例中需要什么" class="headerlink" title="使用RecyclerView在案例中需要什么"></a>使用RecyclerView在案例中需要什么</h2><ul><li>需要引入依赖</li><li>需要适配器</li><li>需要ItemLayout</li><li>需要数据类</li><li>控制器需要初始化</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
            <tag> RecyclerView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataBinding的使用</title>
      <link href="/2020/07/24/DataBinding%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/07/24/DataBinding%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="DataBinding-配合-LiveData-和-ViewModel-使用"><a href="#DataBinding-配合-LiveData-和-ViewModel-使用" class="headerlink" title="DataBinding 配合 LiveData 和 ViewModel 使用"></a>DataBinding 配合 LiveData 和 ViewModel 使用</h2><ol><li>需要创建MyViewModel类,继承ViewModel</li><li>需要添加DataBinding的gradle(app)配置信息</li></ol><p>添加配置信息 在gradle(app)中添加 ↓</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-25_10-40-29.png" alt=""></p><h4 id="创建MyViewModel-↓"><a href="#创建MyViewModel-↓" class="headerlink" title="创建MyViewModel ↓"></a>创建MyViewModel ↓</h4><pre><code>/** *   @DATE : 2020/7/24 *   @Time : 21:10 *   @By : TheCara *  负责处理界面数据 *  需要 LiveData 来观察数据刷新UI */class MyViewModel : ViewModel() {    var numberLiveData = MutableLiveData&lt;Int&gt;()    init {        numberLiveData.value = 0    }    // 加值    fun add() {        numberLiveData?.value = numberLiveData?.value?.plus(1)    }}</code></pre><h4 id="修改MainActivity-↓"><a href="#修改MainActivity-↓" class="headerlink" title="修改MainActivity ↓"></a>修改MainActivity ↓</h4><pre><code>/** 需要 ActivityMainBinding 类用来绑定数据* 需要 MyViewModel 来和 ActivityMainBinding 绑定数据* */class MainActivity : AppCompatActivity() {    var myViewModel: MyViewModel? = null    // 设置类型为可空类型    var activityMainBinding: ActivityMainBinding? = null    //ActivityMainBinding 是在DataBingding配置完成之后自动生成的    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        // 初始化DataBindingUtil,用来绑定布局        activityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main)        // 初始化数据类        var myViewModel = ViewModelProviders.of(this).get(MyViewModel::class.java)        activityMainBinding?.myViewModel=myViewModel        activityMainBinding?.lifecycleOwner = this    }}</code></pre><h4 id="布局-使用-“data”-标签-↓"><a href="#布局-使用-“data”-标签-↓" class="headerlink" title="布局 使用 “data” 标签 ↓"></a>布局 使用 “data” 标签 ↓</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595645673021.png" alt=""></p><p>需要 layout 布局保存布局,需要 “data “标签保存绑定来的数据,需要 “variable” 标签设置变量。</p><h4 id="需要使用-“-”-方式访问变量-↓"><a href="#需要使用-“-”-方式访问变量-↓" class="headerlink" title="需要使用 “@{}” 方式访问变量 ↓"></a>需要使用 “@{}” 方式访问变量 ↓</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595645903565.png" alt=""></p><h4 id="需要使用-“-参数-gt-方法-参数-”访问方法-↓"><a href="#需要使用-“-参数-gt-方法-参数-”访问方法-↓" class="headerlink" title="需要使用 “@{(参数)-&gt;方法(参数)}”访问方法 ↓"></a>需要使用 “@{(参数)-&gt;方法(参数)}”访问方法 ↓</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595645888188.png" alt=""></p><p>demo ↓</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595646636793.png" alt=""></p><h2 id="什么是DataBinding"><a href="#什么是DataBinding" class="headerlink" title="什么是DataBinding"></a>什么是DataBinding</h2><p>DataBinding是谷歌在2015年I/O开发者大会上发布的一个数据绑定框架,也就是把数据捆绑到UI上,DataBinding可以让Activity和Fragment减少逻辑,使其方便维护。同时也能提高性能,避免空指针异常,同时DataBinding也支持双向绑定,使UI的改变同时同步到数据上,DataBinding不是MVVM架构的必需品。</p><h2 id="DataBinding有哪些优缺点"><a href="#DataBinding有哪些优缺点" class="headerlink" title="DataBinding有哪些优缺点"></a>DataBinding有哪些优缺点</h2><p><strong>优点</strong></p><ol><li>减少Activity和Fragment的逻辑处理,使Activity和Fragment逻辑更加清晰。</li><li>提高性能,避免内存泄漏以及空指针</li><li>支持双向绑定,当View改变的时候会通知Model,当Model改变时会通知View</li></ol><p><strong>缺点</strong></p><ol><li>bug难定位,出现bug时无法定位到是View中的bug还是Model中的bug,又或是编写的逻辑bug。</li><li>双向绑定不利于View的复用</li></ol><p>引用:<a href="https://juejin.im/post/5edb12346fb9a047da364349#heading-2" target="_blank" rel="noopener">https://juejin.im/post/5edb12346fb9a047da364349#heading-2</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> DataBinding </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LiveData与ViewModel</title>
      <link href="/2020/07/20/LiveData/"/>
      <url>/2020/07/20/LiveData/</url>
      
        <content type="html"><![CDATA[<h4 id="单独使用LiveData"><a href="#单独使用LiveData" class="headerlink" title="单独使用LiveData"></a>单独使用LiveData</h4><ol><li>创建LiveData实例。持有特定的数据类型，例如 int ,String。</li><li>创建一个Observer对象,并且实现onChanged()方法。在onChanged()方法类可以进行UI的刷新等。</li><li>使用LiveData实例的observe(…,…)方法,将Observer对象添加到LiveData中。方法原型为 <strong>observe(LifecycleOwner owner,Observer observer)</strong>,第一个参数是LifecycleOwner对象，为LiveData能够监听生命周期的能力来源。第二个参数为我们的监听对象。</li></ol><p>添加LiveData和ViewModel的依赖 ↓</p><pre><code>// 添加LiveData和ViewModel的依赖implementation &#39;android.arch.lifecycle:extensions:1.1.1&#39;</code></pre><p>界面准备按钮用来开启,使得UI刷新 ↓</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-20_15-48-40.png" alt=""></p><p> MainActivity中的代码 ↓</p><pre><code>class MainActivity : AppCompatActivity() {    val TAG = &quot;MainActivity&quot;    val btnStart = btn_start    val mTvNumber = tv_number    var mNumberLiveData: MutableLiveData&lt;Int&gt;? = null // 声明变量    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        mNumberLiveData = MutableLiveData()        btnStart.setOnClickListener { view: View? -&gt;            thread {                var number = 0                while (number &lt; 5) {                    mNumberLiveData?.postValue(number)                    Log.d(TAG, &quot;setOnClickListener&quot; + number)                    Thread.sleep(3000)                    number++                }            }        }        mNumberLiveData?.observe(this, object : Observer&lt;Int&gt; {            override fun onChanged(t: Int?) {                mTvNumber.setText(&quot;&quot; + t)                Log.d(TAG, &quot;onChanged&quot; + t)            }        })    }}</code></pre><p>界面的TextView会根据数据进行刷新。</p><h4 id="单独使用ViewModel"><a href="#单独使用ViewModel" class="headerlink" title="单独使用ViewModel"></a>单独使用ViewModel</h4><ol><li>创建ViewModel的继承类</li><li>在控制器中实例化继承类</li></ol><p>创建ViewModel继承类 ↓</p><pre><code>class MyViewModel() : ViewModel() {    var number = 0}</code></pre><p>修改控制器 ↓</p><pre><code>class MainActivity : AppCompatActivity() {    val TAG = &quot;MainActivity&quot;    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        // ViewModelProvider.of() 获得MyViewModel持久类用来保存UI数据        // &quot;MyViewModel::class.java&quot; 反射引用类型        var myViewModel = ViewModelProviders.of(this).get(MyViewModel::class.java)        tv_number.setText(myViewModel.number.toString())        btn_start.setOnClickListener {            myViewModel.number++            tv_number.setText(myViewModel.number.toString())        }    }}</code></pre><p>简单的界面样式 ↓</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-21_19-16-39.png" alt=""></p><h4 id="LiveData和ViewModel配合使用"><a href="#LiveData和ViewModel配合使用" class="headerlink" title="LiveData和ViewModel配合使用"></a>LiveData和ViewModel配合使用</h4><ol><li>需要有ViewModel的继承类</li><li>需要在ViewModel的继承类中实例化LiveData类型</li><li>需要在控制器中初始化ViewModel的继承类</li><li>需要调用LiveData的observe的方法</li></ol><pre><code>class MyViewModel : ViewModel() {    var mutableLiveData = MutableLiveData&lt;Int&gt;()    init {        mutableLiveData.value=0    }    fun getLive(): MutableLiveData&lt;Int&gt; {        return mutableLiveData    }    fun addNumber(number: Int) {        mutableLiveData?.value=number+ mutableLiveData.value!!    }}</code></pre><pre><code>class MainActivity : AppCompatActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        // 获得MyViewModel实例        var myViewModel = ViewModelProviders.of(this).get(MyViewModel::class.java)        btn_addone.setOnClickListener {            myViewModel?.addNumber(1)        }        myViewModel?.getLive()?.observe(this, object : Observer&lt;Int&gt; {            override fun onChanged(t: Int?) {                tv_number.setText(t.toString())            }        })    }}</code></pre><h4 id="什么是LiveData"><a href="#什么是LiveData" class="headerlink" title="什么是LiveData"></a>什么是LiveData</h4><p>LiveData是一个可以观察的数据持有类,但是不同于通常的观察者,它具有声明周期的感知能力。通俗些讲,它所持有的数据发生改变时,并且Lifecycle对象还处于活跃状态,LiveData将立即通知观察者数据发生了变化。相比于不同的观察者它多了生命周期和感知能力。</p><h4 id="什么是ViewModel"><a href="#什么是ViewModel" class="headerlink" title="什么是ViewModel"></a>什么是ViewModel</h4><p>简单说ViewModel是一种用来存储和管理UI相关数据的类。但是与其他的Model不同的是,他支持在系统改变时保存数据。</p><p>当屏幕发生改变时,会导致Activity/Fragment重新绘制,会导致我们之前的数据丢失。比如,在EditText中输入了内容,但是当屏幕扭转时,会发现editText中的文本被清空了。</p><p>当对于一下简单的数据,我们可以通过Activity的onSaveInstanceState()方法中储存,然后通过onCreate()中进行恢复,但是这种方式只适合存储少量的数据，并且是能被序列化和反序列的数据。而对那些大量的数据则不适用。</p><p>此外,它也使View的数据持有者和Viewcontroller逻辑更加分离，便于解耦和测试。</p><p>引用:<a href="https://juejin.im/post/5ca9f9156fb9a05e3d0a8aea#heading-6" target="_blank" rel="noopener">https://juejin.im/post/5ca9f9156fb9a05e3d0a8aea#heading-6</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
            <tag> LiveData </tag>
            
            <tag> ViewModel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 讲解</title>
      <link href="/2020/07/19/git%20%E8%AE%B2%E8%A7%A3/"/>
      <url>/2020/07/19/git%20%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="修改提交文件大小"><a href="#修改提交文件大小" class="headerlink" title="修改提交文件大小"></a>修改提交文件大小</h1><p>在要提交的项目根目录下使用。</p><pre><code>$ git config --local http.postBuffer 524288000</code></pre><p>设置为500MB。</p><h1 id="查看本地分支"><a href="#查看本地分支" class="headerlink" title="查看本地分支"></a>查看本地分支</h1><pre><code>git branch</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923155804.png" alt="本地的两个分支"></p><h1 id="查看远程仓库所有分支"><a href="#查看远程仓库所有分支" class="headerlink" title="查看远程仓库所有分支"></a>查看远程仓库所有分支</h1><pre><code>git branch -r</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923155838.png" alt="远程仓库的分支"></p><h1 id="查看本地仓库和远程仓库"><a href="#查看本地仓库和远程仓库" class="headerlink" title="查看本地仓库和远程仓库"></a>查看本地仓库和远程仓库</h1><pre><code>git branch -a</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923160933.png" alt="本地和远程共有仓库"></p><h1 id="创建本地分支"><a href="#创建本地分支" class="headerlink" title="创建本地分支"></a>创建本地分支</h1><pre><code>git branch annotationVersion</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923120947.png" alt="创建了本地分支"></p><h1 id="切换到创建的分支"><a href="#切换到创建的分支" class="headerlink" title="切换到创建的分支"></a>切换到创建的分支</h1><pre><code>git checkout 分支</code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923121359.png" alt="切换到创建的 annotationVersion 分支"></p><h1 id="本地分支提交到远程分支"><a href="#本地分支提交到远程分支" class="headerlink" title="本地分支提交到远程分支"></a>本地分支提交到远程分支</h1><p><strong>切换到创建的分支</strong>（annotationVersion）。</p><pre><code>git push origin annotationVersion</code></pre><p>如果<strong>远程仓库</strong>没有这个分支，那么也会创建一个该分支。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923153643.png" alt="由于远程仓库没有本地的分支在push时自动创建了annotationVersion分支"></p><h1 id="本地获得一个远程分支"><a href="#本地获得一个远程分支" class="headerlink" title="本地获得一个远程分支"></a>本地获得一个远程分支</h1><p>使用命令</p><pre><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;例如git pull origin v1.0:v1.0</code></pre><p>pull 了<strong>远程仓库的v1.0分支</strong>本地命名<strong>为v1.0</strong></p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923172540.png" alt="pull 完成"></p><h1 id="合并本地两个分支"><a href="#合并本地两个分支" class="headerlink" title="合并本地两个分支"></a>合并本地两个分支</h1><p>如果当前分支（annotationVersion）分支，想与远程分支 master 合并（merge），可以使用如下命令：</p><p>切换到 master 分支：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923161205.png" alt="master分支"></p><p>在 master 分支合并另一个分支（annotationVersion）：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923161241.png" alt="合并完成"></p><p>随后可以将master分支 push 掉（用来提交两个合并了仓库）：</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20200923161838.png" alt="push完成"></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-theme-matery使用手册</title>
      <link href="/2020/07/19/hexo-theme-%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
      <url>/2020/07/19/hexo-theme-%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h4 id="修改头部的渐变颜色"><a href="#修改头部的渐变颜色" class="headerlink" title="修改头部的渐变颜色"></a>修改头部的渐变颜色</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-19_18-44-57.png" alt=""></p><p>修改跟目录下的 themes\hexo-theme-matery\source\css\matery.css 文件。修改”bg-color”即可。</p><h4 id="修改底部的加载进度条"><a href="#修改底部的加载进度条" class="headerlink" title="修改底部的加载进度条"></a>修改底部的加载进度条</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-19_18-47-15.png" alt=""></p><p>修改”progress-bar”即可。</p><h4 id="修改-top-按钮颜色"><a href="#修改-top-按钮颜色" class="headerlink" title="修改 top 按钮颜色"></a>修改 top 按钮颜色</h4><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210302145826.png" alt=""></p><p>修改”.top-scroll .btn-floating”即可</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20210302145848.png" alt=""></p><h4 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h4><p>下载插件,修改配置即可。</p><pre><code>npm install hexo-generator-search --save</code></pre><p>在根目录下安装插件。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/Snipaste_2020-07-20_08-57-52.png" alt=""></p><p>修改配置信息。</p><p>打开根目录下的 “_config.yml”文件,添加配置信息。</p><pre><code>search:  path: search.xml  field: post</code></pre><h4 id="修改友情链接"><a href="#修改友情链接" class="headerlink" title="修改友情链接"></a>修改友情链接</h4><p>在 “Blog\source\data\friends.json” 目录下修改配置文件</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595649945373.png" alt=""></p><h4 id="自动添加文章的名称、时间等信息"><a href="#自动添加文章的名称、时间等信息" class="headerlink" title="自动添加文章的名称、时间等信息"></a>自动添加文章的名称、时间等信息</h4><p>需要创建文件 “scaffolds\post.md”</p><pre><code class="yaml">---title: {{ title }}date: {{ date }}tags: [标签]author: 用户名top: falsecover: falsetoc: truemathjax: truecategories: &quot;分类&quot;---</code></pre><h4 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a>完整实例</h4><p>👇修改文章封面,修改文章轮播图等</p><pre><code class="yaml">---title: {{title}}date: {{data}}author: 作者名字img: /source/images/xxx.jpg &quot;文章特征图,路径在source中&quot;top: true &quot;推荐文章&quot;cover: true &quot;表示该文章是否需要加入到首页轮播封面中&quot;coverImg: /images/1.jpg &quot;轮播图中的封面,访问的是&quot;source&quot;下的&quot;images&quot;&quot;password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: false &quot;是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项&quot;mathjax: false &quot;是否开启数学公式支持,本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行&quot;summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---</code></pre><h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><h2 id="修改各种标题"><a href="#修改各种标题" class="headerlink" title="修改各种标题"></a>修改各种标题</h2><h3 id="修改副标题和短句"><a href="#修改副标题和短句" class="headerlink" title="修改副标题和短句"></a>修改副标题和短句</h3><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031160424.png" alt="副标题"></p><p>修改根目录下的 “<strong>_config.xml</strong>”</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031160741.png" alt="修改副标题"></p><p>根目录下“<strong>themes\hexo-theme-matery\_config.xml</strong>”</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031161025.png" alt=""></p><p>subtitle标签负责副标题的短句。</p><h3 id="修改-“梦想”短句"><a href="#修改-“梦想”短句" class="headerlink" title="修改 “梦想”短句"></a>修改 “梦想”短句</h3><p>根目录下“<strong>themes\hexo-theme-matery\_config.xml</strong>”</p><p>dream标签负责梦想短句。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201031161233.png" alt=""></p><h2 id="备份和还原Blog"><a href="#备份和还原Blog" class="headerlink" title="备份和还原Blog"></a>备份和还原Blog</h2><h3 id="备份github创建私有仓库"><a href="#备份github创建私有仓库" class="headerlink" title="备份github创建私有仓库"></a>备份github创建私有仓库</h3><p>私有仓库设置为名字Blog(与文件夹名字相同即可),将文件下载到Blog的根目录下,将”.git”文件和”.gitignore”文件拖拽到Blog目录下。</p><p>‘’.gitignore’文件内添加要忽视的文件夹</p><pre><code>.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/</code></pre><p>正常提交即可</p><p>ps:可能会出现文件夹过大的原因 </p><p><a href="https://thecara.github.io/2020/07/19/git%E8%AE%BE%E7%BD%AE%E6%8F%90%E4%BA%A4%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F/">办法</a></p><h3 id="还原Blog"><a href="#还原Blog" class="headerlink" title="还原Blog"></a>还原Blog</h3><p>建议:使用新的电脑或者使用虚拟机来测试</p><p>安装git,配置git </p><p>使用”git Bash” 输入👇.</p><pre><code>$ git config --global user.name &quot;your name&quot;$ git config --global user.email &quot;your_email@youremail.com&quot;ssh-keygen -t rsa -C &quot;自己的邮箱&quot;</code></pre><p><a href="https://github.com/settings/ssh/new" target="_blank" rel="noopener">设置SHH</a></p><p>完成后会出现shh文件的目录,打开”.pub”类型文件将内容复制到这里。</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/1595819104102.png" alt=""></p><p>完成后克隆我们的”Blog”</p><h3 id="安装nove-js"><a href="#安装nove-js" class="headerlink" title="安装nove.js"></a>安装nove.js</h3><p>在Blog目录下使用”git Bash”</p><p>直接安装 hexo,如果网络过慢建议配置仓库.</p><pre><code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p><a href="https://developer.aliyun.com/mirror/NPM" target="_blank" rel="noopener">更多</a></p><pre><code>npm i hexo-cli -g 或者 npm install hexo --save</code></pre><p>搭建</p><pre><code class="g">hexo ghexo shexo d</code></pre><p>ps:</p><p>如果出现 “ERROR Plugin load failed: hexo-prism-plugin”错误 直接删除”node_modules\hexo-prism-plugin”下的文件夹。</p><p>安装 nove.js 自动安装choco<a href="https://thecara.github.io/2020/07/26/choco%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%89%E8%A3%85/">可能会报错使用</a></p><p>引用:<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md</a></p><h2 id="Hexo-让文章按照最新的提交时间进行排序"><a href="#Hexo-让文章按照最新的提交时间进行排序" class="headerlink" title="Hexo 让文章按照最新的提交时间进行排序"></a>Hexo 让文章按照最新的提交时间进行排序</h2><p>让我们最新提交或者更新的文章在界面的首个位置。</p><p>在主配置文件 <strong>_config.ym</strong>l, 查找 <strong>index_generator</strong> 标签 <strong>order_by</strong> 属性修改为 <strong>-updated</strong> 即可。</p><pre><code class="yaml">index_generator:  path: &#39;&#39;  per_page: 18  order_by: -updated </code></pre><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/20201212171501.png" alt=""></p><p>之后 </p><pre><code>hexo g</code></pre><p>完成。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>在使用 目录导航时不建议 “标题” 配合 “无序列表” 使用</p><p><img src="https://raw.githubusercontent.com/TheCara/RepoPicture/master/image/2020-8-19-0.gif" alt=""></p><p>会出现无法跳转到指定目录。</p>]]></content>
      
      
      <categories>
          
          <category> hexo-theme-matery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> hexo-theme-matery </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
